# 1.4. Annotated Controllers

<!-- tabs:start -->

#### ** English **

[Web MVC](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-controller)
#### ** Chinese **

[Web MVC](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-controller)

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Spring WebFlux provides an annotation-based programming model, where `@Controller` and `@RestController` components use annotations to express request mappings, request input, handle exceptions, and more. Annotated controllers have flexible method signatures and do not have to extend base classes nor implement specific interfaces.
#### ** Chinese **

Spring WebFlux提供了一个基于注释的编程模型，其中`@Controller`和`@RestController`组件使用注释来表达请求映射、请求输入、处理异常等等。注释的控制器具有灵活的方法签名，不需要扩展基类，也不需要实现特定的接口。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following listing shows a basic example:
#### ** Chinese **

下面列举了一个基本的例子。

<!-- tabs:end -->


```java
@RestController
public class HelloController {

    @GetMapping("/hello")
    public String handle() {
        return "Hello WebFlux";
    }
}
```

<!-- tabs:start -->

#### ** English **

In the preceding example, the method returns a `String` to be written to the response body.
#### ** Chinese **

在前面的例子中，该方法返回一个`String`，将被写入响应体。

<!-- tabs:end -->


### **1.4.1.** **`@Controller`** 

<!-- tabs:start -->

#### ** English **

[Web MVC](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-controller)
#### ** Chinese **

[Web MVC](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-controller)

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can define controller beans by using a standard Spring bean definition. The `@Controller` stereotype allows for auto-detection and is aligned with Spring general support for detecting `@Component` classes in the classpath and auto-registering bean definitions for them. It also acts as a stereotype for the annotated class, indicating its role as a web component.
#### ** Chinese **

你可以通过使用标准的Spring Bean定义来定义控制器Bean。`@Controller` stereotype允许自动检测，并与Spring对检测classpath中的`@Component`类的一般支持一致，并为它们自动注册Bean定义。它还可以作为注释类的定型，表明其作为web组件的作用。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

To enable auto-detection of such `@Controller` beans, you can add component scanning to your Java configuration, as the following example shows:
#### ** Chinese **

要启用这种`@Controller` Bean的自动检测，可以在Java配置中添加组件扫描，如下例所示。

<!-- tabs:end -->


```java
@Configuration
@ComponentScan("org.example.web") (1)
public class WebConfig {

    // ...
}

//(1) Scan the org.example.web package.
```

<!-- tabs:start -->

#### ** English **

`@RestController` is a [composed annotation](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-meta-annotations) that is itself meta-annotated with `@Controller` and `@ResponseBody`, indicating a controller whose every method inherits the type-level `@ResponseBody` annotation and, therefore, writes directly to the response body versus view resolution and rendering with an HTML template.
#### ** Chinese **

`@RestController`是一个[组成注解](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-meta-annotations)，它本身就带有`@Controller`和`@ResponseBody`的元注解，表示控制器的每一个方法都继承了类型级的`@ResponseBody`注解，因此，与视图解析和HTML模板渲染相比，直接写到响应体。

<!-- tabs:end -->


### **1.4.2. Request Mapping** 

<!-- tabs:start -->

#### ** English **

[Web MVC](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-requestmapping)
#### ** Chinese **

[Web MVC](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-requestmapping)

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The `@RequestMapping` annotation is used to map requests to controllers methods. It has various attributes to match by URL, HTTP method, request parameters, headers, and media types. You can use it at the class level to express shared mappings or at the method level to narrow down to a specific endpoint mapping.
#### ** Chinese **

`@RequestMapping`注释用于将请求映射到控制器方法。它有各种属性，可以根据URL、HTTP方法、请求参数、头文件和媒体类型进行匹配。你可以在类级使用它来表达共享映射，或者在方法级使用它来缩小到特定的端点映射。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

There are also HTTP method specific shortcut variants of `@RequestMapping`:
#### ** Chinese **

`@RequestMapping`也有HTTP方法的特定快捷方式变体。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

- `@GetMapping`

- `@PostMapping`

- `@PutMapping`

- `@DeleteMapping`

- `@PatchMapping`

#### ** Chinese **

- `@GetMapping`

- `@PostMapping`

- `@PutMapping`

- `@DeleteMapping`

- `@PatchMatchMapping`


<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

The preceding annotations are [Custom Annotations](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-requestmapping-composed) that are provided because, arguably, most controller methods should be mapped to a specific HTTP method versus using `@RequestMapping`, which, by default, matches to all HTTP methods. At the same time, a `@RequestMapping` is still needed at the class level to express shared mappings.
#### ** Chinese **

前面的注释是[Custom Annotations](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-requestmapping-composed)，提供这些注释是因为，可以说，与使用`@RequestMapping`相比，大多数控制器方法应该被映射到一个特定的HTTP方法，而默认情况下，它匹配到所有的HTTP方法。同时，在类级仍然需要一个`@RequestMapping`来表达共享映射。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following example uses type and method level mappings:
#### ** Chinese **

前面的注释是[Custom Annotations](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-requestmapping-composed)，提供这些注释是因为，可以说，与使用`@RequestMapping`相比，大多数控制器方法应该被映射到一个特定的HTTP方法，而默认情况下，它匹配到所有的HTTP方法。同时，在类级仍然需要一个`@RequestMapping`来表达共享映射。

<!-- tabs:end -->


```java
@RestController
@RequestMapping("/persons")
class PersonController {

    @GetMapping("/{id}")
    public Person getPerson(@PathVariable Long id) {
        // ...
    }

    @PostMapping
    @ResponseStatus(HttpStatus.CREATED)
    public void add(@RequestBody Person person) {
        // ...
    }
}
```

### **URI Patterns** 

<!-- tabs:start -->

#### ** English **

[Web MVC](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-requestmapping-uri-templates)
#### ** Chinese **

[Web MVC](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-requestmapping-uri-templates)

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can map requests by using glob patterns and wildcards:
#### ** Chinese **

你可以通过使用 glob 模式和通配符来映射请求。

<!-- tabs:end -->


Pattern | Description | Example 
-|-|-
? | Matches one character | "/pages/t?st.html"matches "/pages/test.html" and "/pages/t3st.html" 
* | Matches zero or more characters within a path segment | "/resources/*.png" matches "/resources/file.png""/projects/*/versions" matches "/projects/spring/versions" but does not match "/projects/spring/boot/versions" 
** | Matches zero or more path segments until the end of the path | "/resources/**" matches "/resources/file.png" and "/resources/images/file.png""/resources/**/file.png" is invalid as ** is only allowed at the end of the path. 
{name} | Matches a path segment and captures it as a variable named "name" | "/projects/{project}/versions" matches "/projects/spring/versions" and captures project=spring 
{name:[a-z]+} | Matches the regexp "[a-z]+" as a path variable named "name" | "/projects/{project:[a-z]+}/versions" matches "/projects/spring/versions" but not "/projects/spring1/versions" 
{*path} | Matches zero or more path segments until the end of the path and captures it as a variable named "path" | "/resources/{*file}" matches "/resources/images/file.png" and captures file=resources/file.png 


<!-- tabs:start -->

#### ** English **

Captured URI variables can be accessed with `@PathVariable`, as the following example shows:
#### ** Chinese **

可以用`@PathVariable`访问捕获的URI变量，如下例所示。

<!-- tabs:end -->


```java
@GetMapping("/owners/{ownerId}/pets/{petId}")
public Pet findPet(@PathVariable Long ownerId, @PathVariable Long petId) {
    // ...
}
```

<!-- tabs:start -->

#### ** English **

You can declare URI variables at the class and method levels, as the following example shows:
#### ** Chinese **

你可以在类和方法级声明URI变量，如下例所示。

<!-- tabs:end -->


```java
@Controller
@RequestMapping("/owners/{ownerId}") (1)
public class OwnerController {

    @GetMapping("/pets/{petId}") (2)
    public Pet findPet(@PathVariable Long ownerId, @PathVariable Long petId) {
        // ...
    }
}

//(1) Class-level URI mapping.
(2) Method-level URI mapping.
```

<!-- tabs:start -->

#### ** English **

URI variables are automatically converted to the appropriate type or a `TypeMismatchException` is raised. Simple types (`int`, `long`, `Date`, and so on) are supported by default and you can register support for any other data type. See [Type Conversion](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-typeconversion) and [`DataBinder`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-initbinder).
#### ** Chinese **

URI变量会自动转换为相应的类型，否则会产生一个`TypeMismatchException`。默认支持简单类型（`int`、`long`、`Date`等），你可以注册支持任何其他数据类型。请参见[类型转换](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-typeconversion)和[`DataBinder`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-initbinder)。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

URI variables can be named explicitly (for example, `@PathVariable("customId")`), but you can leave that detail out if the names are the same and you compile your code with debugging information or with the `-parameters` compiler flag on Java 8.
#### ** Chinese **

URI变量可以显式命名（例如，`@PathVariable("customId")`），但如果名字相同，并且你在编译代码时使用调试信息或在Java 8上使用`-parameters`编译器标志，你可以不写这个细节。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The syntax `{*varName}` declares a URI variable that matches zero or more remaining path segments. For example `/resources/{*path}` matches all files `/resources/` and the `"path"` variable captures the complete relative path.
#### ** Chinese **

语法 `{*varName}`声明了一个URI变量，它可以匹配0个或多个剩余的路径段。例如，`/resources/{*path}`匹配所有文件`/resources/`，而`"path"`变量捕获了完整的相对路径。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The syntax `{varName:regex}` declares a URI variable with a regular expression that has the syntax: `{varName:regex}`. For example, given a URL of `/spring-web-3.0.5 .jar`, the following method extracts the name, version, and file extension:
#### ** Chinese **

语法 `{varName:regex}`声明一个带有正则表达式的URI变量，其语法为 `{varName:regex}`。例如，给定一个 URL 为 `/spring-web-3.0.5 .jar`，下面的方法可以提取名称、版本和文件扩展名。

<!-- tabs:end -->


```java
@GetMapping("/{name:[a-z-]+}-{version:\\d\\.\\d\\.\\d}{ext:\\.[a-z]+}")
public void handle(@PathVariable String version, @PathVariable String ext) {
    // ...
}
```

<!-- tabs:start -->

#### ** English **

URI path patterns can also have embedded `${…​}` placeholders that are resolved on startup through `PropertyPlaceHolderConfigurer` against local, system, environment, and other property sources. You ca use this to, for example, parameterize a base URL based on some external configuration.
#### ** Chinese **
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Spring WebFlux uses `PathPattern` and the `PathPatternParser` for URI path matching support. Both classes are located in `spring-web` and are expressly designed for use with HTTP URL paths in web applications where a large number of URI path patterns are matched at runtime.
#### ** Chinese **

Spring WebFlux使用`PathPattern`和`PathPatternParser`来支持URI路径匹配。这两个类都位于 `spring-web`中，专门为在运行时需要匹配大量URI路径模式的Web应用程序中的HTTP URL路径而设计。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Spring WebFlux does not support suffix pattern matching — unlike Spring MVC, where a mapping such as `/person` also matches to `/person.*`. For URL-based content negotiation, if needed, we recommend using a query parameter, which is simpler, more explicit, and less vulnerable to URL path based exploits.
#### ** Chinese **

Spring WebFlux不支持后缀模式匹配---不像Spring MVC那样，像`/person`这样的映射也会匹配到`/person.*`。对于基于URL的内容协商，如果需要的话，我们建议使用查询参数，这样做更简单，更明确，也更不容易受到基于URL路径的攻击。

<!-- tabs:end -->


### **Pattern Comparison** 

<!-- tabs:start -->

#### ** English **

[Web MVC](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-requestmapping-pattern-comparison)
#### ** Chinese **

[Web MVC](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-requestmapping-pattern-comparison)

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

When multiple patterns match a URL, they must be compared to find the best match. This is done with `PathPattern.SPECIFICITY_COMPARATOR`, which looks for patterns that are more specific.
#### ** Chinese **

当多个模式匹配一个URL时，必须对它们进行比较，以找到最佳的匹配。这可以通过`PathPattern.SPECIFICITY_COMPARATOR`来完成，它可以寻找更具体的模式。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

For every pattern, a score is computed, based on the number of URI variables and wildcards, where a URI variable scores lower than a wildcard. A pattern with a lower total score wins. If two patterns have the same score, the longer is chosen.
#### ** Chinese **

对于每个模式，根据URI变量和通配符的数量计算出一个得分，其中URI变量的得分低于通配符。总分较低的模式获胜。如果两个模式的得分相同，则选择较长的模式。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Catch-all patterns (for example, `**`, `{*varName}`) are excluded from the scoring and are always sorted last instead. If two patterns are both catch-all, the longer is chosen.
#### ** Chinese **

补全模式（例如，`****`、`{*varName}`）被排除在评分之外，总是最后排序。如果两个模式都是通吃型，则选择较长的模式。

<!-- tabs:end -->


### **Consumable Media Types** 

<!-- tabs:start -->

#### ** English **

[Web MVC](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-requestmapping-consumes)
#### ** Chinese **

[Web MVC](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-requestmapping-consumes)

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can narrow the request mapping based on the `Content-Type` of the request, as the following example shows:
#### ** Chinese **

您可以根据请求的`Content-Type`来缩小请求映射范围，如下图所示。

<!-- tabs:end -->


```java
@PostMapping(path = "/pets", consumes = "application/json")
public void addPet(@RequestBody Pet pet) {
    // ...
}
```

<!-- tabs:start -->

#### ** English **

The consumes attribute also supports negation expressions — for example, `!text/plain` means any content type other than `text/plain`.
#### ** Chinese **

consumes属性还支持否定表达式--例如，`!text/plain`表示除`text/plain`以外的任何内容类型。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can declare a shared `consumes` attribute at the class level. Unlike most other request mapping attributes, however, when used at the class level, a method-level `consumes` attribute overrides rather than extends the class-level declaration.
#### ** Chinese **

你可以在类级声明一个共享的`consumes`属性。但是，与大多数其他请求映射属性不同，当在类级使用时，方法级的`consumes`属性会覆盖而不是扩展类级声明。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

`MediaType` provides constants for commonly used media types — for example, `APPLICATION_JSON_VALUE` and `APPLICATION_XML_VALUE`.
#### ** Chinese **

`MediaType`为常用的媒体类型提供了常量 - 例如，`APPLICATION_JSON_VALUE`和`APPLICATION_XML_VALUE`。

<!-- tabs:end -->


### **Producible Media Types** 

<!-- tabs:start -->

#### ** English **

[Web MVC](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-requestmapping-produces)
#### ** Chinese **

[Web MVC](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-requestmapping-produces)

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can narrow the request mapping based on the `Accept` request header and the list of content types that a controller method produces, as the following example shows:
#### ** Chinese **

您可以根据`Accept`请求头和控制器方法产生的内容类型列表来缩小请求映射范围，如下例所示。

<!-- tabs:end -->


```java
@GetMapping(path = "/pets/{petId}", produces = "application/json")
@ResponseBody
public Pet getPet(@PathVariable String petId) {
    // ...
}
```

<!-- tabs:start -->

#### ** English **

The media type can specify a character set. Negated expressions are supported — for example, `!text/plain` means any content type other than `text/plain`.
#### ** Chinese **

媒体类型可以指定一个字符集。支持否定表达式 - 例如，`!text/plain`表示除`text/plain`以外的任何内容类型。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can declare a shared `produces` attribute at the class level. Unlike most other request mapping attributes, however, when used at the class level, a method-level `produces` attribute overrides rather than extend the class level declaration.
#### ** Chinese **

你可以在类级声明一个共享的`produces`属性。但是，与大多数其他请求映射属性不同，当在类级使用时，方法级的`produces`属性会覆盖而不是扩展类级声明。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

`MediaType` provides constants for commonly used media types — e.g. `APPLICATION_JSON_VALUE`, `APPLICATION_XML_VALUE`.
#### ** Chinese **

`MediaType`提供了常用媒体类型的常量 - 例如：`APPLICATION_JSON_VALUE`、`APPLICATION_XML_VALUE`。

<!-- tabs:end -->


### **Parameters and Headers** 

<!-- tabs:start -->

#### ** English **

[Web MVC](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-requestmapping-params-and-headers)
#### ** Chinese **

[Web MVC](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-requestmapping-params-and-headers)

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can narrow request mappings based on query parameter conditions. You can test for the presence of a query parameter (`myParam`), for its absence (`!myParam`), or for a specific value (`myParam=myValue`). The following examples tests for a parameter with a value:
#### ** Chinese **

你可以根据查询参数条件来缩小请求映射范围。您可以测试一个查询参数是否存在(`myParam`)，是否存在(`!!myParam`)，或者测试一个特定的值(`myParam=myValue`)。下面的例子测试了一个带值的参数。

<!-- tabs:end -->


```java
@GetMapping(path = "/pets/{petId}", params = "myParam=myValue") (1)
public void findPet(@PathVariable String petId) {
    // ...
}

//(1) Check that myParam equals myValue.
```

<!-- tabs:start -->

#### ** English **

You can also use the same with request header conditions, as the follwing example shows:
#### ** Chinese **

你也可以使用同样的请求头条件，就像下面的例子所示。

<!-- tabs:end -->


```java
@GetMapping(path = "/pets", headers = "myHeader=myValue") (1)
public void findPet(@PathVariable String petId) {
    // ...
}

//(1) Check that myHeader equals myValue.
```

### **HTTP HEAD, OPTIONS** 

<!-- tabs:start -->

#### ** English **

[Web MVC](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-requestmapping-head-options)
#### ** Chinese **

[Web MVC](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-requestmapping-head-options)

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

`@GetMapping` and `@RequestMapping(method=HttpMethod.GET)` support HTTP HEAD transparently for request mapping purposes. Controller methods need not change. A response wrapper, applied in the `HttpHandler` server adapter, ensures a `Content-Length` header is set to the number of bytes written without actually writing to the response.
#### ** Chinese **

`@GetMapping`和`@RequestMapping(method=HttpMethod.GET)`支持HTTP HEAD透明地进行请求映射。控制器方法不需要改变。在`HttpHandler`服务器适配器中应用的响应封装器，可以确保`Content-Length`头被设置为写到响应的字节数，而不实际写入响应。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

By default, HTTP OPTIONS is handled by setting the `Allow` response header to the list of HTTP methods listed in all `@RequestMapping` methods with matching URL patterns.
#### ** Chinese **

默认情况下，通过将`Allow`响应头设置为所有`@RequestMapping`方法中列出的具有匹配的URL模式的HTTP方法列表来处理HTTP OPTIONS。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

For a `@RequestMapping` without HTTP method declarations, the `Allow` header is set to `GET,HEAD,POST,PUT,PATCH,DELETE,OPTIONS`. Controller methods should always declare the supported HTTP methods (for example, by using the HTTP method specific variants — `@GetMapping`, `@PostMapping`, and others).
#### ** Chinese **

对于没有HTTP方法声明的`@RequestMapping`，`Allow`头被设置为`GET,HEAD,POST,PUT,PATCH,DELETE,OPTION`。控制器方法应该总是声明支持的HTTP方法（例如，通过使用HTTP方法的特定变体--`@GetMapping`、`@PostMapping`等）。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can explicitly map a `@RequestMapping` method to HTTP HEAD and HTTP OPTIONS, but that is not necessary in the common case.
#### ** Chinese **

你可以显式地将`@RequestMapping`方法映射到HTTP HEAD和HTTP OPTIONS，但在常见的情况下，这不是必须的。

<!-- tabs:end -->


### **Custom Annotations** 

<!-- tabs:start -->

#### ** English **

[Web MVC](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-requestmapping-composed)
#### ** Chinese **

[Web MVC](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-requestmapping-composed)

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Spring WebFlux supports the use of [composed annotations](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-meta-annotations) for request mapping. Those are annotations that are themselves meta-annotated with `@RequestMapping` and composed to redeclare a subset (or all) of the `@RequestMapping` attributes with a narrower, more specific purpose.
#### ** Chinese **

Spring WebFlux 支持使用 [composition annotations](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-meta-annotations) 来进行请求映射。这些注释本身就是用 `@RequestMapping`进行元注释的注释，这些注释的组成是为了重新定义`@RequestMapping`属性的一个子集（或全部），其目的更窄、更具体。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

`@GetMapping`, `@PostMapping`, `@PutMapping`, `@DeleteMapping`, and `@PatchMapping` are examples of composed annotations. They are provided, because, arguably, most controller methods should be mapped to a specific HTTP method versus using `@RequestMapping`, which, by default, matches to all HTTP methods. If you need an example of composed annotations, look at how those are declared.
#### ** Chinese **

`@GetMapping`、`@PostMapping`、`@PutMapping`、`@DeleteMapping`和`@PatchMapping`是组成注释的例子。提供这些注释是因为，可以说，大多数控制器方法应该被映射到特定的HTTP方法，而不是使用`@RequestMapping`，默认情况下，它匹配到所有的HTTP方法。如果你需要一个组成注释的例子，看看这些注释是如何声明的。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Spring WebFlux also supports custom request mapping attributes with custom request matching logic. This is a more advanced option that requires sub-classing `RequestMappingHandlerMapping` and overriding the `getCustomMethodCondition` method, where you can check the custom attribute and return your own `RequestCondition`.
#### ** Chinese **

Spring WebFlux还支持自定义请求映射属性与自定义请求匹配逻辑。这是一个更高级的选项，需要子类化`RequestMappingHandlerMapping`，并重写`getCustomMethodCondition`方法，在这里你可以检查自定义属性并返回自己的`RequestCondition`。

<!-- tabs:end -->


### **Explicit Registrations** 

<!-- tabs:start -->

#### ** English **

[Web MVC](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-requestmapping-registration)
#### ** Chinese **

[Web MVC](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-requestmapping-registration)

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can programmatically register Handler methods, which can be used for dynamic registrations or for advanced cases, such as different instances of the same handler under different URLs. The following example shows how to do so:
#### ** Chinese **

你可以用程序化的方式注册处理程序方法，它可以用于动态注册，也可以用于高级情况，比如同一处理程序的不同实例在不同的URL下的不同实例。下面的例子说明了如何做到这一点。

<!-- tabs:end -->


```java
@Configuration
public class MyConfig {

    @Autowired
    public void setHandlerMapping(RequestMappingHandlerMapping mapping, UserHandler handler) (1)
            throws NoSuchMethodException {

        RequestMappingInfo info = RequestMappingInfo
                .paths("/user/{id}").methods(RequestMethod.GET).build(); (2)

        Method method = UserHandler.class.getMethod("getUser", Long.class); (3)

        mapping.registerMapping(info, handler, method); (4)
    }

}

//(1) Inject target handlers and the handler mapping for controllers.
(2) Prepare the request mapping metadata.
(3) Get the handler method.
(4) Add the registration.
```

### **1.4.3. Handler Methods** 

<!-- tabs:start -->

#### ** English **

[Web MVC](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-methods)
#### ** Chinese **

[Web MVC](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-methods)

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

`@RequestMapping` handler methods have a flexible signature and can choose from a range of supported controller method arguments and return values.
#### ** Chinese **

`@RequestMapping`处理程序方法具有灵活的签名，可以从一系列支持的控制器方法参数和返回值中选择。

<!-- tabs:end -->


### **Method Arguments** 

<!-- tabs:start -->

#### ** English **

[Web MVC](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-arguments)
#### ** Chinese **

[Web MVC](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-arguments)

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following table shows the supported controller method arguments.
#### ** Chinese **

下表显示了支持的控制器方法参数。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Reactive types (Reactor, RxJava, [or other](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-reactive-libraries)) are supported on arguments that require blocking I/O (for example, reading the request body) to be resolved. This is marked in the Description column. Reactive types are not expected on arguments that do not require blocking.
#### ** Chinese **

Reactive类型（Reactor、RxJava、[或其他](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-reactive-libraries)）支持在需要阻止I/O（例如读取请求体）的参数上进行解析。这在描述栏中标出了。在不需要阻塞的参数上不支持反应型类型。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

JDK 1.8’s `java.util.Optional` is supported as a method argument in combination with annotations that have a `required` attribute (for example, `@RequestParam`, `@RequestHeader`, and others) and is equivalent to `required=false`.
#### ** Chinese **

JDK 1.8 的 `java.utilite.Optional`支持作为方法参数与具有 `required` 属性的注释（例如，`@RequestParam`、`@RequestHeader`等）结合在一起，相当于 `required=false`。

<!-- tabs:end -->


Controller method argument | Description 
-|-
ServerWebExchange | Access to the full ServerWebExchange — container for the HTTP request and response, request and session attributes, checkNotModified methods, and others. 
ServerHttpRequest, ServerHttpResponse | Access to the HTTP request or response. 
WebSession | Access to the session. This does not force the start of a new session unless attributes are added. Supports reactive types. 
java.security.Principal | The currently authenticated user — possibly a specific Principal implementation class if known. Supports reactive types. 
org.springframework.http.HttpMethod | The HTTP method of the request. 
java.util.Locale | The current request locale, determined by the most specific LocaleResolver available — in effect, the configured LocaleResolver/LocaleContextResolver. 
java.util.TimeZone + java.time.ZoneId | The time zone associated with the current request, as determined by a LocaleContextResolver. 
@PathVariable | For access to URI template variables. See URI Patterns. 
@MatrixVariable | For access to name-value pairs in URI path segments. See Matrix Variables. 
@RequestParam | For access to Servlet request parameters. Parameter values are converted to the declared method argument type. See @RequestParam.Note that use of @RequestParam is optional — for example, to set its attributes. See “Any other argument” later in this table. 
@RequestHeader | For access to request headers. Header values are converted to the declared method argument type. See @RequestHeader. 
@CookieValue | For access to cookies. Cookie values are converted to the declared method argument type. See @CookieValue. 
@RequestBody | For access to the HTTP request body. Body content is converted to the declared method argument type by using HttpMessageReader instances. Supports reactive types. See @RequestBody. 
HttpEntity<B> | For access to request headers and body. The body is converted with HttpMessageReader instances. Supports reactive types. See HttpEntity. 
@RequestPart | For access to a part in a multipart/form-data request. Supports reactive types. See Multipart Content and Multipart Data. 
java.util.Map, org.springframework.ui.Model, and org.springframework.ui.ModelMap. | For access to the model that is used in HTML controllers and is exposed to templates as part of view rendering. 
@ModelAttribute | For access to an existing attribute in the model (instantiated if not present) with data binding and validation applied. See @ModelAttribute as well as Model and DataBinder.Note that use of @ModelAttribute is optional — for example, to set its attributes. See “Any other argument” later in this table. 
Errors, BindingResult | For access to errors from validation and data binding for a command object, i.e. a @ModelAttribute argument. An Errors, or BindingResult argument must be declared immediately after the validated method argument. 
SessionStatus + class-level @SessionAttributes | For marking form processing complete, which triggers cleanup of session attributes declared through a class-level @SessionAttributes annotation. See @SessionAttributes for more details. 
UriComponentsBuilder | For preparing a URL relative to the current request’s host, port, scheme, and path. See URI Links. 
@SessionAttribute | For access to any session attribute — in contrast to model attributes stored in the session as a result of a class-level @SessionAttributes declaration. See @SessionAttribute for more details. 
@RequestAttribute | For access to request attributes. See @RequestAttribute for more details. 
Any other argument | If a method argument is not matched to any of the above, it is, by default, resolved as a @RequestParam if it is a simple type, as determined by BeanUtils#isSimpleProperty, or as a @ModelAttribute, otherwise. 


### **Return Values** 

<!-- tabs:start -->

#### ** English **

[Web MVC](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-return-types)
#### ** Chinese **

[Web MVC](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-return-types)

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following table shows the supported controller method return values. Note that reactive types from libraries such as Reactor, RxJava, [or other](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-reactive-libraries) are generally supported for all return values.
#### ** Chinese **

下表显示了支持的控制器方法的返回值。请注意，Reactor、RxJava、[或其他](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-reactive-libraries)等库中的反应式类型一般支持所有返回值。

<!-- tabs:end -->


Controller method return value | Description 
-|-
@ResponseBody | The return value is encoded through HttpMessageWriter instances and written to the response. See @ResponseBody. 
HttpEntity<B>, ResponseEntity<B> | The return value specifies the full response, including HTTP headers, and the body is encoded through HttpMessageWriter instances and written to the response. See ResponseEntity. 
HttpHeaders | For returning a response with headers and no body. 
String | A view name to be resolved with ViewResolver instances and used together with the implicit model — determined through command objects and @ModelAttribute methods. The handler method can also programmatically enrich the model by declaring a Model argument (described earlier). 
View | A View instance to use for rendering together with the implicit model — determined through command objects and @ModelAttribute methods. The handler method can also programmatically enrich the model by declaring a Model argument (described earlier). 
java.util.Map, org.springframework.ui.Model | Attributes to be added to the implicit model, with the view name implicitly determined based on the request path. 
@ModelAttribute | An attribute to be added to the model, with the view name implicitly determined based on the request path.Note that @ModelAttribute is optional. See “Any other return value” later in this table. 
Rendering | An API for model and view rendering scenarios. 
void | A method with a void, possibly asynchronous (for example, Mono<Void>), return type (or a null return value) is considered to have fully handled the response if it also has a ServerHttpResponse, a ServerWebExchange argument, or an @ResponseStatus annotation. The same is also true if the controller has made a positive ETag or lastModified timestamp check. // TODO: See Controllers for details.If none of the above is true, a void return type can also indicate “no response body” for REST controllers or default view name selection for HTML controllers. 
Flux<ServerSentEvent>, Observable<ServerSentEvent>, or other reactive type | Emit server-sent events. The ServerSentEvent wrapper can be omitted when only data needs to be written (however, text/event-stream must be requested or declared in the mapping through the produces attribute). 
Any other return value | If a return value is not matched to any of the above, it is, by default, treated as a view name, if it is String or void (default view name selection applies), or as a model attribute to be added to the model, unless it is a simple type, as determined by BeanUtils#isSimpleProperty, in which case it remains unresolved. 


### **Type Conversion** 

<!-- tabs:start -->

#### ** English **

[Web MVC](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-typeconversion)
#### ** Chinese **

[Web MVC](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-typeconversion)

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Some annotated controller method arguments that represent String-based request input (for example, `@RequestParam`, `@RequestHeader`, `@PathVariable`, `@MatrixVariable`, and `@CookieValue`) can require type conversion if the argument is declared as something other than `String`.
#### ** Chinese **

一些表示基于字符串的请求输入的注释控制器方法参数（例如，`@RequestParam`、`@RequestHeader`、`@PathVariable`、`@MatrixVariable`和`@CookieValue`），如果参数被声明为`String`以外的东西，则可能需要进行类型转换。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

For such cases, type conversion is automatically applied based on the configured converters. By default, simple types (such as `int`, `long`, `Date`, and others) are supported. Type conversion can be customized through a `WebDataBinder` (see [`DataBinder`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-initbinder)) or by registering `Formatters` with the `FormattingConversionService` (see [Spring Field Formatting](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#format)).
#### ** Chinese **

对于这种情况，类型转换会根据配置的转换器自动应用。默认情况下，支持简单的类型（如`int`、`long`、`Date`等）。可以通过 `WebDataBinder`进行类型转换（参见 [`DataBinder`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-initbinder)），或者通过注册 `FormattingConversionService`的 `Formatters`来进行类型转换（参见 [Spring Field Formatting](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#format)）。

<!-- tabs:end -->


### **Matrix Variables** 

<!-- tabs:start -->

#### ** English **

[Web MVC](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-matrix-variables)
#### ** Chinese **

[Web MVC](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-matrix-variables)

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

[RFC 3986](https://tools.ietf.org/html/rfc3986#section-3.3) discusses name-value pairs in path segments. In Spring WebFlux, we refer to those as “matrix variables” based on an [“old post”](https://www.w3.org/DesignIssues/MatrixURIs.html) by Tim Berners-Lee, but they can be also be referred to as URI path parameters.
#### ** Chinese **

RFC 3986](https://tools.ietf.org/html/rfc3986#section-3.3)讨论了路径段中的名-值对。在Spring WebFlux中，我们根据Tim Berners-Lee的一篇["旧帖"](https://www.w3.org/DesignIssues/MatrixURIs.html)，将这些变量称为 "矩阵变量"，但它们也可以被称为URI路径参数。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Matrix variables can appear in any path segment, with each variable separated by a semicolon and multiple values separated by commas — for example, `"/cars;color=red,green;year=2012"`. Multiple values can also be specified through repeated variable names — for example, `"color=red;color=green;color=blue"`.
#### ** Chinese **

矩阵变量可以出现在任何路径段中，每个变量之间用分号隔开，多个值之间用逗号隔开--例如，`"/cars;color=red,green;year=2012"`。也可以通过重复的变量名称指定多个值 - 例如，`"color=red;color=green;color=blue"`。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Unlike Spring MVC, in WebFlux, the presence or absence of matrix variables in a URL does not affect request mappings. In other words, you are not required to use a URI variable to mask variable content. That said, if you want to access matrix variables from a controller method, you need to add a URI variable to the path segment where matrix variables are expected. The following example shows how to do so:
#### ** Chinese **

与Spring MVC不同的是，在WebFlux中，URL中是否存在矩阵变量并不影响请求映射。换句话说，你不需要使用URI变量来屏蔽变量内容。也就是说，如果你想从控制器方法中访问矩阵变量，你需要在期望有矩阵变量的路径段中添加一个URI变量。下面的例子显示了如何做到这一点。

<!-- tabs:end -->


```java
// GET /pets/42;q=11;r=22

@GetMapping("/pets/{petId}")
public void findPet(@PathVariable String petId, @MatrixVariable int q) {

    // petId == 42
    // q == 11
}
```

<!-- tabs:start -->

#### ** English **

Given that all path segments can contain matrix variables, you may sometimes need to disambiguate which path variable the matrix variable is expected to be in, as the following example shows:
#### ** Chinese **

考虑到所有的路径段都可以包含矩阵变量，因此有时可能需要区分矩阵变量在哪个路径变量中，如下例所示。

<!-- tabs:end -->


```java
// GET /owners/42;q=11/pets/21;q=22

@GetMapping("/owners/{ownerId}/pets/{petId}")
public void findPet(
        @MatrixVariable(name="q", pathVar="ownerId") int q1,
        @MatrixVariable(name="q", pathVar="petId") int q2) {

    // q1 == 11
    // q2 == 22
}
```

<!-- tabs:start -->

#### ** English **

You can define a matrix variable may be defined as optional and specify a default value as the following example shows:
#### ** Chinese **

你可以定义一个矩阵变量，可以定义为可选的，并指定一个默认值，如下例所示。

<!-- tabs:end -->


```java
// GET /pets/42

@GetMapping("/pets/{petId}")
public void findPet(@MatrixVariable(required=false, defaultValue="1") int q) {

    // q == 1
}
```

<!-- tabs:start -->

#### ** English **

To get all matrix variables, use a `MultiValueMap`, as the following example shows:
#### ** Chinese **

要获得所有的矩阵变量，使用`MultiValueMap`，如下面的例子所示。

<!-- tabs:end -->


```java
// GET /owners/42;q=11;r=12/pets/21;q=22;s=23

@GetMapping("/owners/{ownerId}/pets/{petId}")
public void findPet(
        @MatrixVariable MultiValueMap<String, String> matrixVars,
        @MatrixVariable(pathVar="petId") MultiValueMap<String, String> petMatrixVars) {

    // matrixVars: ["q" : [11,22], "r" : 12, "s" : 23]
    // petMatrixVars: ["q" : 22, "s" : 23]
}
```

### **`@RequestParam`** 

<!-- tabs:start -->

#### ** English **

[Web MVC](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-requestparam)
#### ** Chinese **

[Web MVC](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-requestparam)

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can use the `@RequestParam` annotation to bind query parameters to a method argument in a controller. The following code snippet shows the usage:
#### ** Chinese **

你可以使用`@RequestParam`注释将查询参数绑定到控制器中的方法参数。下面的代码片段显示了使用方法。

<!-- tabs:end -->


```java
@Controller
@RequestMapping("/pets")
public class EditPetForm {

    // ...

    @GetMapping
    public String setupForm(@RequestParam("petId") int petId, Model model) { (1)
        Pet pet = this.clinic.loadPet(petId);
        model.addAttribute("pet", pet);
        return "petForm";
    }

    // ...
}

//(1) Using @RequestParam.
```

<!-- tabs:start -->

#### ** English **

The Servlet API “request parameter” concept conflates query parameters, form data, and multiparts into one. However, in WebFlux, each is accessed individually through `ServerWebExchange`. While `@RequestParam` binds to query parameters only, you can use data binding to apply query parameters, form data, and multiparts to a [command object](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-modelattrib-method-args).
#### ** Chinese **

Servlet API的 "请求参数 "概念将查询参数、表单数据和多部分混为一谈。然而，在WebFlux中，每个参数都是通过`ServerWebExchange`单独访问的。虽然`@RequestParam`只绑定查询参数，但你可以使用数据绑定来应用查询参数、表单数据和多参数到[命令对象](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-modelattrib-method-args)。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Method parameters that use the `@RequestParam` annotation are required by default, but you can specify that a method parameter is optional by setting the required flag of a `@RequestParam` to `false` or by declaring the argument with a `java.util.Optional` wrapper.
#### ** Chinese **

使用 `@RequestParam` 注解的方法参数默认为必填，但您可以通过将 `@RequestParam`的必填标志设置为 `false`，或者通过使用 `java.utilite.Optional` wrapper 声明参数，指定方法参数为可选的。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Type conversion is applied automatically if the target method parameter type is not `String`. See [Type Conversion](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-typeconversion).
#### ** Chinese **

如果目标方法参数类型不是`String`，则自动进行类型转换。参见[类型转换](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-typeconversion)。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

When a `@RequestParam` annotation is declared on a `Map<String, String>` or `MultiValueMap<String, String>` argument, the map is populated with all query parameters.
#### ** Chinese **

当在`Map<String, String>`或`MultiValueMap<String, String>`参数上声明了`@RequestParam`注解时，该映射被填充了所有的查询参数。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Note that use of `@RequestParam` is optional — for example, to set its attributes. By default, any argument that is a simple value type (as determined by [BeanUtils#isSimpleProperty](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-)) and is not resolved by any other argument resolver is treated as if it were annotated with `@RequestParam`.
#### ** Chinese **

注意，`@RequestParam`的使用是可选的--例如，设置它的属性。默认情况下，任何参数如果是简单值类型（由[BeanUtils#isSimpleProperty](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-)决定），并且没有被任何其他参数解析器解析的参数，则会被视为被注释为`@RequestParam`的参数。

<!-- tabs:end -->


### **`@RequestHeader`** 

<!-- tabs:start -->

#### ** English **

[Web MVC](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-requestheader)
#### ** Chinese **

[Web MVC](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-requestheader)

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can use the `@RequestHeader` annotation to bind a request header to a method argument in a controller.
#### ** Chinese **

可以使用 `@RequestHeader` 注释将请求头绑定到控制器中的方法参数。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following example shows a request with headers:
#### ** Chinese **

下面的例子显示了一个带标题的请求。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Host localhost:8080
#### ** Chinese **

Host localhost:8080

<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

Accept text/html,application/xhtml+xml,application/xml;q=0.9
#### ** Chinese **

接受text/html,application/xhtml+xml,application/xml;q=0.9

<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

Accept-Language fr,en-gb;q=0.7,en;q=0.3
#### ** Chinese **

Accept-Language en,en-gb;q=0.7,en;q=0.3

<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

Accept-Encoding gzip,deflate
#### ** Chinese **

Accept-Encoding gzip,deflate

<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

Accept-Charset ISO-8859-1,utf-8;q=0.7,*;q=0.7
#### ** Chinese **

Accept-Charset ISO-8859-1,utf-8;q=0.7,*;q=0.7

<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

Keep-Alive 300
#### ** Chinese **

保持活力300

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following example gets the value of the `Accept-Encoding` and `Keep-Alive` headers:
#### ** Chinese **

下面的例子可以得到`Accept-Encoding`和`Keep-Ancoding`头的值。

<!-- tabs:end -->


```java
@GetMapping("/demo")
public void handle(
        @RequestHeader("Accept-Encoding") String encoding, (1)
        @RequestHeader("Keep-Alive") long keepAlive) { (2)
    //...
}

//(1) Get the value of the Accept-Encoging header.
(2) Get the value of the Keep-Alive header.
```

<!-- tabs:start -->

#### ** English **

Type conversion is applied automatically if the target method parameter type is not `String`. See [Type Conversion](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-typeconversion).
#### ** Chinese **

如果目标方法参数类型不是`String`，则自动进行类型转换。参见[类型转换](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-typeconversion)。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

When a `@RequestHeader` annotation is used on a `Map<String, String>`, `MultiValueMap<String, String>`, or `HttpHeaders` argument, the map is populated with all header values.
#### ** Chinese **

当`@RequestHeader`注释被用于`Map<String, String>`, `MultiValueMap<String, String>`, 或`HttpHeaders`参数时，该映射被填充了所有的头值。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Built-in support is available for converting a comma-separated string into an array or collection of strings or other types known to the type conversion system. For example, a method parameter annotated with `@RequestHeader("Accept")` may be of type `String` but also of `String[]` or `List<String>`.
#### ** Chinese **

内置支持将逗号分隔的字符串转换为数组或字符串集合或类型转换系统已知的其他类型。例如，用 `@RequestHeader("Accept")`注释的方法参数可以是类型为`String`，但也可以是类型为`String[]`或`List<String>`。

<!-- tabs:end -->


### **`@CookieValue`** 

<!-- tabs:start -->

#### ** English **

[Web MVC](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-cookievalue)
#### ** Chinese **

[Web MVC](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-cookievalue)

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can use the `@CookieValue` annotation to bind the value of an HTTP cookie to a method argument in a controller.
#### ** Chinese **

你可以使用`@CookieValue`注释将HTTP cookie的值绑定到控制器中的方法参数。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following example shows a request with a cookie:
#### ** Chinese **

下面的例子显示了一个带有cookie的请求。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

JSESSIONID=415A4AC178C59DACE0B2C9CA727CDD84
#### ** Chinese **

jsessionid=415a4ac178c59dace0b2c9ca727cdd84

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following code sample demonstrates how to get the cookie value:
#### ** Chinese **

下面的代码示例演示了如何获取cookie值。

<!-- tabs:end -->


```java
@GetMapping("/demo")
public void handle(@CookieValue("JSESSIONID") String cookie) { (1)
    //...
}

//(1) Get the cookie value.
```

<!-- tabs:start -->

#### ** English **

Type conversion is applied automatically if the target method parameter type is not `String`. See [Type Conversion](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-typeconversion).
#### ** Chinese **

如果目标方法参数类型不是`String`，则自动进行类型转换。参见[类型转换](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-typeconversion)。

<!-- tabs:end -->


### **`@ModelAttribute`** 

<!-- tabs:start -->

#### ** English **

[Web MVC](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-modelattrib-method-args)
#### ** Chinese **

[Web MVC](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-modelattrib-method-args)

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can use the `@ModelAttribute` annotation on a method argument to access an attribute from the model or have it instantiated if not present. The model attribute is also overlain with the values of query parameters and form fields whose names match to field names. This is referred to as data binding, and it saves you from having to deal with parsing and converting individual query parameters and form fields. The following example binds an instance of `Pet`:
#### ** Chinese **

你可以在方法参数上使用`@ModelAttribute`注释来访问模型中的属性，或者如果不存在的话，可以将其实例化。模型属性也会与查询参数和表单字段的值重叠，这些参数和表单字段的名称与字段名匹配。这被称为数据绑定，它使您无需处理单个查询参数和表单字段的解析和转换。下面的示例绑定了一个`Pet`的实例。

<!-- tabs:end -->


```java
@PostMapping("/owners/{ownerId}/pets/{petId}/edit")
public String processSubmit(@ModelAttribute Pet pet) { } (1)

//(1) Bind an instance of Pet.
```

<!-- tabs:start -->

#### ** English **

The `Pet` instance in the preceding example is resolved as follows:
#### ** Chinese **

上例中的`Pet`实例的解析如下。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

- From the model if already added through [`Model`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-modelattrib-methods).

- From the HTTP session through [`@SessionAttributes`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-sessionattributes).

- From the invocation of a default constructor.

- From the invocation of a “primary constructor” with arguments that match query parameters or form fields. Argument names are determined through JavaBeans `@ConstructorProperties` or through runtime-retained parameter names in the bytecode.

#### ** Chinese **

- 如果已经通过[`Model`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-modelattrib-methods)从模型中添加。

- 通过[`@SessionAttributes`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-sessionattributes)从HTTP会话中获得。

- 来自于默认构造函数的调用。

- 来自 "主构造函数 "的调用，其参数与查询参数或表单字段匹配。参数名通过JavaBeans `@ConstructorProperties`或通过字节码中的运行时引用的参数名来确定。


<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

After the model attribute instance is obtained, data binding is applied. The `WebExchangeDataBinder` class matches names of query parameters and form fields to field names on the target `Object`. Matching fields are populated after type conversion is applied where necessary. For more on data binding (and validation), see [Validation](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#validation). For more on customizing data binding, see [`DataBinder`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-initbinder).
#### ** Chinese **

在获得模型属性实例后，应用数据绑定。`WebExchangeDataBinder`类将查询参数和窗体字段的名称与目标`Object`上的字段名称进行匹配。在必要时应用类型转换后，匹配的字段会被填充。有关数据绑定（和验证）的更多信息，请参阅 [Validation](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#validation)。有关自定义数据绑定的更多信息，请参阅 [`DataBinder`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-initbinder)。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Data binding can result in errors. By default, a `WebExchangeBindException` is raised, but, to check for such errors in the controller method, you can add a `BindingResult` argument immediately next to the `@ModelAttribute`, as the following example shows:
#### ** Chinese **

数据绑定会导致错误。默认情况下，会产生一个`WebExchangeBindException`，但是，为了在控制器方法中检查这类错误，可以在`@ModelAttribute`旁边添加一个`BindingResult`参数，如下例所示。

<!-- tabs:end -->


```java
@PostMapping("/owners/{ownerId}/pets/{petId}/edit")
public String processSubmit(@ModelAttribute("pet") Pet pet, BindingResult result) { (1)
    if (result.hasErrors()) {
        return "petForm";
    }
    // ...
}

//(1) Adding a BindingResult.
```

<!-- tabs:start -->

#### ** English **

You can automatically apply validation after data binding by adding the `javax.validation.Valid` annotation or Spring’s `@Validated` annotation (see also [Bean Validation](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#validation-beanvalidation) and [Spring validation](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#validation)). The following example uses the `@Valid` annotation:
#### ** Chinese **

您可以通过添加 `javax.validation.Valid` 注释或Spring的 `@Validated` 注释，在数据绑定后自动应用验证（参见 [Bean Validation](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#validation-beanvalidation) 和 [Spring validation](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#validation)）。下面的示例使用了`@Valid`注释。

<!-- tabs:end -->


```java
@PostMapping("/owners/{ownerId}/pets/{petId}/edit")
public String processSubmit(@Valid @ModelAttribute("pet") Pet pet, BindingResult result) { (1)
    if (result.hasErrors()) {
        return "petForm";
    }
    // ...
}

//(1) Using @Valid on a model attribute argument.
```

<!-- tabs:start -->

#### ** English **

Spring WebFlux, unlike Spring MVC, supports reactive types in the model — for example, `Mono<Account>` or `io.reactivex.Single<Account>`. You can declare a `@ModelAttribute` argument with or without a reactive type wrapper, and it will be resolved accordingly, to the actual value if necessary. However, note that, to use a `BindingResult` argument, you must declare the `@ModelAttribute` argument before it without a reactive type wrapper, as shown earlier. Alternatively, you can handle any errors through the reactive type, as the following example shows:
#### ** Chinese **

Spring WebFlux与Spring MVC不同，它支持模型中的反应式类型 - 例如，`Mono<Account>`或`io.reactivex.Single<Account>`。你可以声明一个`@ModelAttribute`参数，无论是否有reactive类型封装器，都可以声明一个`@ModelAttribute`参数，如果有必要，它将相应地解析为实际值。但是，请注意，要使用 `BindingResult` 参数，就必须在它之前声明 `@ModelAttribute` 参数，而不需要响应式类型封装，如前文所示。或者，你可以通过反应式类型来处理任何错误，如下例所示。

<!-- tabs:end -->


```java
@PostMapping("/owners/{ownerId}/pets/{petId}/edit")
public Mono<String> processSubmit(@Valid @ModelAttribute("pet") Mono<Pet> petMono) {
    return petMono
        .flatMap(pet -> {
            // ...
        })
        .onErrorResume(ex -> {
            // ...
        });
}
```

<!-- tabs:start -->

#### ** English **

Note that use of `@ModelAttribute` is optional — for example, to set its attributes. By default, any argument that is not a simple value type( as determined by [BeanUtils#isSimpleProperty](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-)) and is not resolved by any other argument resolver is treated as if it were annotated with `@ModelAttribute`.
#### ** Chinese **

注意，使用`@ModelAttribute`是可选的--例如，设置它的属性。默认情况下，任何参数如果不是简单值类型(由[BeanUtils#isSimpleProperty](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-)确定)，并且没有被任何其他参数解析器解析的参数，则会被视为使用`@ModelAttribute`注释。

<!-- tabs:end -->


### **`@SessionAttributes`** 

<!-- tabs:start -->

#### ** English **

[Web MVC](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-sessionattributes)
#### ** Chinese **

[Web MVC](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-sessionattributes)

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

`@SessionAttributes` is used to store model attributes in the `WebSession` between requests. It is a type-level annotation that declares session attributes used by a specific controller. This typically lists the names of model attributes or types of model attributes that should be transparently stored in the session for subsequent requests to access.
#### ** Chinese **

`@SessionAttributes`用于在请求之间存储`WebSession`中的模型属性。它是一个类型级注释，声明了特定控制器使用的会话属性。这通常会列出模型属性的名称或模型属性的类型，这些属性应该透明地存储在会话中，供后续请求访问。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Consider the following example:
#### ** Chinese **

请看下面的例子：

<!-- tabs:end -->


```java
@Controller
@SessionAttributes("pet") (1)
public class EditPetForm {
    // ...
}

//(1) Using the @SessionAttributes annotation.
```

<!-- tabs:start -->

#### ** English **

On the first request, when a model attribute with the name, `pet`, is added to the model, it is automatically promoted to and saved in the `WebSession`. It remains there until another controller method uses a `SessionStatus` method argument to clear the storage, as the following example shows:
#### ** Chinese **

在第一次请求时，当一个名称为`pet`的模型属性被添加到模型中时，它被自动提升到并保存在`WebSession`中。在另一个控制器方法使用`SessionStatus`方法参数清除存储之前，它将保持在那里，如下例所示。

<!-- tabs:end -->


```java
@Controller
@SessionAttributes("pet") (1)
public class EditPetForm {

    // ...

    @PostMapping("/pets/{id}")
    public String handle(Pet pet, BindingResult errors, SessionStatus status) { (2)
        if (errors.hasErrors()) {
            // ...
        }
            status.setComplete();
            // ...
        }
    }
}

//(1) Using the @SessionAttributes annotation.
(2) Using a SessionStatus variable.
```

### **`@SessionAttribute`** 

<!-- tabs:start -->

#### ** English **

[Web MVC](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-sessionattribute)
#### ** Chinese **

[Web MVC](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-sessionattribute)

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

If you need access to pre-existing session attributes that are managed globally (that is, outside the controller — for example, by a filter) and may or may not be present, you can use the `@SessionAttribute` annotation on a method parameter, as the following example shows:
#### ** Chinese **

如果你需要访问全局管理的预先存在的会话属性（即在控制器之外--例如，通过过滤器），并且可能存在或不存在，你可以在方法参数上使用`@SessionAttribute`注释，如下例所示。

<!-- tabs:end -->


```java
@GetMapping("/")
public String handle(@SessionAttribute User user) { (1)
    // ...
}

//(1) Using @SessionAttribute.
```

<!-- tabs:start -->

#### ** English **

For use cases that require adding or removing session attributes, consider injecting `WebSession` into the controller method.
#### ** Chinese **

对于需要添加或删除会话属性的用例，可以考虑将`WebSession`注入控制器方法中。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

For temporary storage of model attributes in the session as part of a controller workflow, consider using `SessionAttributes`, as described in [`@SessionAttributes`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-sessionattributes).
#### ** Chinese **

对于作为控制器工作流的一部分在会话中临时存储模型属性，可以考虑使用`SessionAttributes`，如[`@SessionAttributes`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-sessionattributes)中描述的那样。

<!-- tabs:end -->


### **`@RequestAttribute`** 

<!-- tabs:start -->

#### ** English **

[Web MVC](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-requestattrib)
#### ** Chinese **

[Web MVC](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-requestattrib)

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Similarly to `@SessionAttribute`, you can use the `@RequestAttribute` annotation to access pre-existing request attributes created earlier (for example, by a `WebFilter`), as the following example shows:
#### ** Chinese **

与`@SessionAttribute`类似，您可以使用`@RequestAttribute` 注解来访问先前创建的预先存在的请求属性（例如，通过`WebFilter`），如下例所示。

<!-- tabs:end -->


```java
@GetMapping("/")
public String handle(@RequestAttribute Client client) { (1)
    // ...
}

//(1) Using @RequestAttribute.
```

### **Multipart Content** 

<!-- tabs:start -->

#### ** English **

[Web MVC](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-multipart-forms)
#### ** Chinese **

[Web MVC](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-multipart-forms)

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

As explained in [Multipart Data](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-multipart), `ServerWebExchange` provides access to multipart content. The best way to handle a file upload form (for example, from a browser) in a controller is through data binding to a [command object](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-modelattrib-method-args), as the following example shows:
#### ** Chinese **

正如[多部分数据](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-multipart)中解释的那样，`ServerWebExchange`提供了对多部分内容的访问。在控制器中处理文件上传表单（例如，来自浏览器的）的最佳方式是通过数据绑定到[命令对象](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-modelattrib-method-args)，如下例所示。

<!-- tabs:end -->


```java
class MyForm {

    private String name;

    private MultipartFile file;

    // ...

}

@Controller
public class FileUploadController {

    @PostMapping("/form")
    public String handleFormUpload(MyForm form, BindingResult errors) {
        // ...
    }

}
```

<!-- tabs:start -->

#### ** English **

You can also submit multipart requests from non-browser clients in a RESTful service scenario. The following example uses a file along with JSON:
#### ** Chinese **

你也可以在RESTful服务场景中提交来自非浏览器客户端的多部分请求。下面的例子中使用了一个文件和JSON。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

POST /someUrl
#### ** Chinese **

POST /someUrl

<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

Content-Type: multipart/mixed
#### ** Chinese **

内容类型：多部分/混合

<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

--edt7Tfrdusa7r3lNQc79vXuhIIMlatb7PQg7Vp
#### ** Chinese **

--edt7Tfrdusa7r3lNQc79vXuhIIMlatb7PQg7Vp

<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

Content-Disposition: form-data; name="meta-data"
#### ** Chinese **

Content-Disposition: form-data; name="meta-data"

<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

Content-Type: application/json; charset=UTF-8
#### ** Chinese **

Content-Type: application/json; charset=UTF-8

<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

Content-Transfer-Encoding: 8bit
#### ** Chinese **

内容-传输-编码。8bit

<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

{ "name": "value"
#### ** Chinese **

{ "name": "value"：

<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

}
#### ** Chinese **

}

<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

--edt7Tfrdusa7r3lNQc79vXuhIIMlatb7PQg7Vp
#### ** Chinese **

--edt7Tfrdusa7r3lNQc79vXuhIIMlatb7PQg7Vp

<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

Content-Disposition: form-data; name="file-data"; filename="file.properties"
#### ** Chinese **

Content-Disposition: form-data; name="file-data"; filename="file.properties"

<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

Content-Type: text/xml
#### ** Chinese **

内容类型：text/xml

<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

Content-Transfer-Encoding: 8bit
#### ** Chinese **

内容-传输-编码。8bit

<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

... File Data ...
#### ** Chinese **

... 日期文件.....

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can access individual parts with `@RequestPart`, as the following example shows:
#### ** Chinese **

你可以用`@RequestPart`访问单个部件，如下例所示。

<!-- tabs:end -->


```java
@PostMapping("/")
public String handle(@RequestPart("meta-data") Part metadata, (1)
        @RequestPart("file-data") FilePart file) { (2)
    // ...
}

//(1) Using @RequestPart to get the metadata.
(2) Using @RequestPart to get the file.
```

<!-- tabs:start -->

#### ** English **

To deserialize the raw part content (for example, to JSON — similar to `@RequestBody`), you can declare a concrete target `Object`, instead of `Part`, as the following example shows:
#### ** Chinese **

要反序列化原始部件内容（例如，将原始部件内容反序列化为JSON---类似于`@RequestBody`），可以声明一个具体的目标`Object`，而不是`Part`，如下例所示。

<!-- tabs:end -->


```java
@PostMapping("/")
public String handle(@RequestPart("meta-data") MetaData metadata) { (1)
    // ...
}

//(1) Using @RequestPart to get the metadata.
```

<!-- tabs:start -->

#### ** English **

You can use `@RequestPart` in combination with `javax.validation.Valid` or Spring’s `@Validated` annotation, which causes Standard Bean Validation to be applied. Validation errors lead to a `WebExchangeBindException` that results in a 400 (BAD_REQUEST) response. The exception contains a `BindingResult` with the error details and can also be handled in the controller method by declaring the argument with an async wrapper and then using error related operators:
#### ** Chinese **

您可以将 `@RequestPart`与 `javax.validation.Validation` 或 Spring 的 `@Validated` 注解结合使用，这将导致标准 Bean Validation 被应用。验证错误会导致一个`WebExchangeBindException`，导致400（BAD_REQUEST）响应。异常包含一个包含错误详细信息的`BindingResult`，并且也可以在控制器方法中通过使用异步包装器声明参数，然后使用错误相关的操作符来处理。

<!-- tabs:end -->


```java
@PostMapping("/")
public String handle(@Valid @RequestPart("meta-data") Mono<MetaData> metadata) {
    // use one of the onError* operators...
}
```

<!-- tabs:start -->

#### ** English **

To access all multipart data as a `MultiValueMap`, you can use `@RequestBody`, as the following example shows:
#### ** Chinese **

要以`MultiValueMap`的形式访问所有多部分数据，可以使用`@RequestBody`，如下例所示。

<!-- tabs:end -->


```java
@PostMapping("/")
public String handle(@RequestBody Mono<MultiValueMap<String, Part>> parts) { (1)
    // ...
}

//(1) Using @RequestBody.
```

<!-- tabs:start -->

#### ** English **

To access multipart data sequentially, in streaming fashion, you can use `@RequestBody` with `Flux<Part>` (or `Flow<Part>` in Kotlin) instead, as the following example shows:
#### ** Chinese **

要以流媒体的方式顺序访问多部分数据，可以使用 `@RequestBody`和 `Flux<Part>`（或 Kotlin 中的 `Flow<Part>`）来代替，如下示例所示。

<!-- tabs:end -->


```java
@PostMapping("/")
public String handle(@RequestBody Flux<Part> parts) { (1)
    // ...
}

//(1) Using @RequestBody.
```

### **`@RequestBody`** 

<!-- tabs:start -->

#### ** English **

[Web MVC](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-requestbody)
#### ** Chinese **

[Web MVC](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-requestbody)

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can use the `@RequestBody` annotation to have the request body read and deserialized into an `Object` through an [HttpMessageReader](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-codecs). The following example uses a `@RequestBody` argument:
#### ** Chinese **

你可以使用 `@RequestBody` 注解来让请求体通过 [HttpMessageReader](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-codecs)读取并反序列化为 `Object`。下面的例子使用了一个`@RequestBody`参数。

<!-- tabs:end -->


```java
@PostMapping("/accounts")
public void handle(@RequestBody Account account) {
    // ...
}
```

<!-- tabs:start -->

#### ** English **

Unlike Spring MVC, in WebFlux, the `@RequestBody` method argument supports reactive types and fully non-blocking reading and (client-to-server) streaming.
#### ** Chinese **

与Spring MVC不同，在WebFlux中，`@RequestBody`方法参数支持反应式类型和完全无阻塞的读取和（客户端到服务器）流。

<!-- tabs:end -->


```java
@PostMapping("/accounts")
public void handle(@RequestBody Mono<Account> account) {
    // ...
}
```

<!-- tabs:start -->

#### ** English **

You can use the [HTTP message codecs](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-config-message-codecs) option of the [WebFlux Config](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-config) to configure or customize message readers.
#### ** Chinese **

您可以使用[WebFlux Config](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-config)的[HTTP 消息编解码器](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-config-message-codecs)选项来配置或自定义消息阅读器。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can use `@RequestBody` in combination with `javax.validation.Valid` or Spring’s `@Validated` annotation, which causes Standard Bean Validation to be applied. Validation errors cause a `WebExchangeBindException`, which results in a 400 (BAD_REQUEST) response. The exception contains a `BindingResult` with error details and can be handled in the controller method by declaring the argument with an async wrapper and then using error related operators:
#### ** Chinese **

您可以将 `@RequestBody`与 `javax.validation.Validation` 或 Spring 的 `@Validated` 注解结合使用，这将导致标准 Bean Validation 被应用。验证错误会导致一个`WebExchangeBindException`，从而产生一个400（BAD_REQUEST）响应。异常包含一个`BindingResult`，其中包含错误的详细信息，可以在控制器方法中通过使用Async wrapper声明参数，然后使用错误相关的操作符来处理。

<!-- tabs:end -->


```java
@PostMapping("/accounts")
public void handle(@Valid @RequestBody Mono<Account> account) {
    // use one of the onError* operators...
}
```

### **`HttpEntity`** 

<!-- tabs:start -->

#### ** English **

[Web MVC](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-httpentity)
#### ** Chinese **

[Web MVC](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-httpentity)

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

`HttpEntity` is more or less identical to using [`@RequestBody`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-requestbody) but is based on a container object that exposes request headers and the body. The following example uses an `HttpEntity`:
#### ** Chinese **

`HttpEntity`与使用[`@RequestBody`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-requestbody)大致相同，但它是基于一个容器对象，该容器对象暴露了请求头和主体。下面的例子使用了一个`HttpEntity`。

<!-- tabs:end -->


```java
@PostMapping("/accounts")
public void handle(HttpEntity<Account> entity) {
    // ...
}
```

### **`@ResponseBody`** 

<!-- tabs:start -->

#### ** English **

[Web MVC](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-responsebody)
#### ** Chinese **

[Web MVC](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-responsebody)

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can use the `@ResponseBody` annotation on a method to have the return serialized to the response body through an [HttpMessageWriter](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-codecs). The following example shows how to do so:
#### ** Chinese **

你可以在一个方法上使用`@ResponseBody`注释，通过[HttpMessageWriter](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-codecs)将返回序列化为响应体。下面的例子显示了如何做到这一点。

<!-- tabs:end -->


```java
@GetMapping("/accounts/{id}")
@ResponseBody
public Account handle() {
    // ...
}
```

<!-- tabs:start -->

#### ** English **

`@ResponseBody` is also supported at the class level, in which case it is inherited by all controller methods. This is the effect of `@RestController`, which is nothing more than a meta-annotation marked with `@Controller` and `@ResponseBody`.
#### ** Chinese **

`@ResponseBody`也在类级支持，在这种情况下，它被所有的控制器方法继承。这就是 `@RestController`的效果，它不过是一个标有`@Controller`和`@ResponseBody`的元注释。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

`@ResponseBody` supports reactive types, which means you can return Reactor or RxJava types and have the asynchronous values they produce rendered to the response. For additional details, see [Streaming](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-codecs-streaming) and [JSON rendering](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-codecs-jackson).
#### ** Chinese **

`@ResponseBody`支持反应式类型，这意味着你可以返回Reactor或RxJava类型，并将它们产生的异步值渲染到响应中。更多详情，请参阅 [Streaming](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-codecs-streaming) 和 [JSON渲染](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-codecs-jackson)。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can combine `@ResponseBody` methods with JSON serialization views. See [Jackson JSON](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-jackson) for details.
#### ** Chinese **

你可以将`@ResponseBody`方法与JSON序列化视图结合起来。详情请参阅[Jackson JSON](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-jackson)。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can use the [HTTP message codecs](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-config-message-codecs) option of the [WebFlux Config](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-config) to configure or customize message writing.
#### ** Chinese **

您可以使用[WebFlux Config](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-config)中的[HTTP消息编解码器](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-config-message-codecs)选项来配置或自定义消息编写。

<!-- tabs:end -->


### **`ResponseEntity`** 

<!-- tabs:start -->

#### ** English **

[Web MVC](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-responseentity)
#### ** Chinese **

[Web MVC](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-responseentity)

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

`ResponseEntity` is like [`@ResponseBody`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-responsebody) but with status and headers. For example:
#### ** Chinese **

`ResponseEntity`就像[`@ResponseBody`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-responsebody)一样，但有状态和标题。比如说。

<!-- tabs:end -->


```java
@GetMapping("/something")
public ResponseEntity<String> handle() {
    String body = ... ;
    String etag = ... ;
    return ResponseEntity.ok().eTag(etag).build(body);
}
```

<!-- tabs:start -->

#### ** English **

WebFlux supports using a single value [reactive type](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-reactive-libraries) to produce the `ResponseEntity` asynchronously, and/or single and multi-value reactive types for the body.
#### ** Chinese **

WebFlux支持使用单值[反应式类型](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-reactive-libraries)来异步生成`ResponseEntity`，和/或使用单值和多值反应式类型来生成主体。

<!-- tabs:end -->


### **Jackson JSON** 

<!-- tabs:start -->

#### ** English **

Spring offers support for the Jackson JSON library.
#### ** Chinese **

Spring提供了对JSON JSON库的支持。

<!-- tabs:end -->


### **JSON Views** 

<!-- tabs:start -->

#### ** English **

[Web MVC](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-jackson)
#### ** Chinese **

[Web MVC](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-jackson)

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Spring WebFlux provides built-in support for [Jackson’s Serialization Views](https://www.baeldung.com/jackson-json-view-annotation), which allows rendering only a subset of all fields in an `Object`. To use it with `@ResponseBody` or `ResponseEntity` controller methods, you can use Jackson’s `@JsonView` annotation to activate a serialization view class, as the following example shows:
#### ** Chinese **

Spring WebFlux提供了对[Jackson的Serialization Views](https://www.baeldung.com/jackson-json-view-annotation)的内置支持，它允许只渲染`Object`中所有字段的一个子集。要与`@ResponseBody`或`ResponseEntity`控制器方法一起使用它，可以使用Jackson的`@JsonView`注释来激活序列化视图类，如下例所示。

<!-- tabs:end -->


```java
@RestController
public class UserController {

    @GetMapping("/user")
    @JsonView(User.WithoutPasswordView.class)
    public User getUser() {
        return new User("eric", "7!jd#h23");
    }
}

public class User {

    public interface WithoutPasswordView {};
    public interface WithPasswordView extends WithoutPasswordView {};

    private String username;
    private String password;

    public User() {
    }

    public User(String username, String password) {
        this.username = username;
        this.password = password;
    }

    @JsonView(WithoutPasswordView.class)
    public String getUsername() {
        return this.username;
    }

    @JsonView(WithPasswordView.class)
    public String getPassword() {
        return this.password;
    }
}
```

<!-- tabs:start -->

#### ** English **

`@JsonView` allows an array of view classes but you can only specify only one per controller method. Use a composite interface if you need to activate multiple views.
#### ** Chinese **

`@JsonView`允许一个视图类数组，但每个控制器方法只能指定一个。如果你需要激活多个视图，请使用复合接口。

<!-- tabs:end -->


### **1.4.4.** **`Model`** 

<!-- tabs:start -->

#### ** English **

[Web MVC](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-modelattrib-methods)
#### ** Chinese **

[Web MVC](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-modelattrib-methods)

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can use the `@ModelAttribute` annotation:
#### ** Chinese **

你可以使用`@ModelAttribute`注释。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

- On a [method argument](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-modelattrib-method-args) in `@RequestMapping` methods to create or access an Object from the model and to bind it to the request through a `WebDataBinder`.

- As a method-level annotation in `@Controller` or `@ControllerAdvice` classes, helping to initialize the model prior to any `@RequestMapping` method invocation.

- On a `@RequestMapping` method to mark its return value as a model attribute.

#### ** Chinese **

- 在`@RequestMapping`方法中的[方法参数](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-modelattrib-method-args)上，用于从模型中创建或访问对象，并通过`WebDataBinder`将其绑定到请求中。

- 作为`@Controller`或`@ControllerAdvice`类中的方法级注释，帮助在任何`@RequestMapping`方法调用之前初始化模型。

- 在`@RequestMapping`方法上，将其返回值标记为模型属性。


<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

This section discusses `@ModelAttribute` methods, or the second item from the preceding list. A controller can have any number of `@ModelAttribute` methods. All such methods are invoked before `@RequestMapping` methods in the same controller. A `@ModelAttribute` method can also be shared across controllers through `@ControllerAdvice`. See the section on [Controller Advice](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-controller-advice) for more details.
#### ** Chinese **

本节讨论了`@ModelAttribute`方法，或者说是前面列表中的第二项。一个控制器可以有任意数量的`@ModelAttribute`方法。所有这些方法都在同一控制器中的`@RequestMapping`方法之前调用。一个`@ModelAttribute`方法也可以通过`@ControllerAdvice`跨控制器共享。更多详情，请参见[ControllerAdvice](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-controller-advice)章节。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

`@ModelAttribute` methods have flexible method signatures. They support many of the same arguments as `@RequestMapping` methods (except for `@ModelAttribute` itself and anything related to the request body).
#### ** Chinese **

`@ModelAttribute`方法具有灵活的方法签名。它们支持许多与 `@RequestMapping`方法相同的参数（除了 `@ModelAttribute`本身和任何与请求体相关的东西之外）。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following example uses a `@ModelAttribute` method:
#### ** Chinese **

下面的示例使用了`@ModelAttribute`方法。

<!-- tabs:end -->


```java
@ModelAttribute
public void populateModel(@RequestParam String number, Model model) {
    model.addAttribute(accountRepository.findAccount(number));
    // add more ...
}
```

<!-- tabs:start -->

#### ** English **

The following example adds one attribute only:
#### ** Chinese **

下面的例子只增加了一个属性。

<!-- tabs:end -->


```java
@ModelAttribute
public Account addAccount(@RequestParam String number) {
    return accountRepository.findAccount(number);
}
```

<!-- tabs:start -->

#### ** English **

When a name is not explicitly specified, a default name is chosen based on the type, as explained in the javadoc for [`Conventions`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/core/Conventions.html). You can always assign an explicit name by using the overloaded `addAttribute` method or through the name attribute on `@ModelAttribute` (for a return value).
#### ** Chinese **

当没有显式指定名称时，会根据类型选择一个默认的名称，这在[`Conventions`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/core/Conventions.html)的javadoc中解释过。你总是可以通过使用重载的`addAttribute`方法或通过`@ModelAttribute`上的name属性（用于返回值）来指定一个显式名称。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Spring WebFlux, unlike Spring MVC, explicitly supports reactive types in the model (for example, `Mono<Account>` or `io.reactivex.Single<Account>`). Such asynchronous model attributes can be transparently resolved (and the model updated) to their actual values at the time of `@RequestMapping` invocation, provided a `@ModelAttribute` argument is declared without a wrapper, as the following example shows:
#### ** Chinese **

Spring WebFlux与Spring MVC不同，它在模型中显式支持反应式类型（例如，`Mono<Account>`或`io.reactivex.Single<Account>`）。这样的异步模型属性可以在`@RequestMapping`调用时透明地解析（和模型更新）到它们的实际值，前提是声明了一个`@ModelAttribute`参数，而不需要封装，如下例所示。

<!-- tabs:end -->


```java
@ModelAttribute
public void addAccount(@RequestParam String number) {
    Mono<Account> accountMono = accountRepository.findAccount(number);
    model.addAttribute("account", accountMono);
}

@PostMapping("/accounts")
public String handle(@ModelAttribute Account account, BindingResult errors) {
    // ...
}
```

<!-- tabs:start -->

#### ** English **

In addition, any model attributes that have a reactive type wrapper are resolved to their actual values (and the model updated) just prior to view rendering.
#### ** Chinese **

此外，在视图渲染之前，任何具有反应式类型封装的模型属性都会被解析为其实际值（和模型更新）。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can also use `@ModelAttribute` as a method-level annotation on `@RequestMapping` methods, in which case the return value of the `@RequestMapping` method is interpreted as a model attribute. This is typically not required, as it is the default behavior in HTML controllers, unless the return value is a `String` that would otherwise be interpreted as a view name. `@ModelAttribute` can also help to customize the model attribute name, as the following example shows:
#### ** Chinese **

您也可以在 `@ModelAttribute`方法上使用 `@RequestMapping`方法的方法级注释，在这种情况下，`@RequestMapping`方法的返回值被解释为模型属性。通常不需要这样做，因为这是HTML控制器中的默认行为，除非返回值是一个`String`，否则会被解释为视图名称。 `@ModelAttribute`也可以帮助自定义模型属性名称，如下例所示。

<!-- tabs:end -->


```java
@GetMapping("/accounts/{id}")
@ModelAttribute("myAccount")
public Account handle() {
    // ...
    return account;
}
```

### **1.4.5.** **`DataBinder`** 

<!-- tabs:start -->

#### ** English **

[Web MVC](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-initbinder)
#### ** Chinese **

[Web MVC](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-initbinder)

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

`@Controller` or `@ControllerAdvice` classes can have `@InitBinder` methods, to initialize instances of `WebDataBinder`. Those, in turn, are used to:
#### ** Chinese **

`@Controller`或`@ControllerAdvice`类可以有`@InitBinder`方法，用于初始化`WebDataBinder`的实例。反过来，这些方法又被用来:

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

- Bind request parameters (that is, form data or query) to a model object.

- Convert `String`-based request values (such as request parameters, path variables, headers, cookies, and others) to the target type of controller method arguments.

- Format model object values as `String` values when rendering HTML forms.

#### ** Chinese **

- 将请求参数（即表单数据或查询）绑定到模型对象。

- 将基于`String`的请求值（如请求参数、路径变量、页眉、cookies等）转换为控制器方法参数的目标类型。

- 在渲染HTML表单时，将模型对象值格式化为`String`值。


<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

`@InitBinder` methods can register controller-specific `java.bean.PropertyEditor` or Spring `Converter` and `Formatter` components. In addition, you can use the [WebFlux Java configuration](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-config-conversion) to register `Converter` and `Formatter` types in a globally shared `FormattingConversionService`.
#### ** Chinese **

`@InitBinder`方法可以注册控制器特定的`java.bean.PropertyEditor`或Spring `Converter`和`Formatter`组件。此外，您可以使用[WebFlux Java配置](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-config-conversion)在全局共享的`FormattingConversionService`中注册`Converter`和`Formatter`类型。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

`@InitBinder` methods support many of the same arguments that `@RequestMapping` methods do, except for `@ModelAttribute` (command object) arguments. Typically, they are declared with a `WebDataBinder` argument, for registrations, and a `void` return value. The following example uses the `@InitBinder` annotation:
#### ** Chinese **

`@InitBinder`方法支持许多与`@RequestMapping`方法相同的参数，但`@ModelAttribute`（命令对象）参数除外。通常情况下，它们是用`WebDataBinder`参数声明的，用于注册，并且有一个`void`返回值。下面的示例使用了`@InitBinder`注释。

<!-- tabs:end -->


```java
@Controller
public class FormController {

    @InitBinder (1)
    public void initBinder(WebDataBinder binder) {
        SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
        dateFormat.setLenient(false);
        binder.registerCustomEditor(Date.class, new CustomDateEditor(dateFormat, false));
    }

    // ...
}

//(1) Using the @InitBinder annotation.
```

<!-- tabs:start -->

#### ** English **

Alternatively, when using a `Formatter`-based setup through a shared `FormattingConversionService`, you could re-use the same approach and register controller-specific `Formatter` instances, as the following example shows:
#### ** Chinese **

另外，当通过共享的`FormattingConversionService`使用基于`Formatter`的设置时，您可以重复使用相同的方法，并注册控制器专用的`Formatter`实例，如下例所示。

<!-- tabs:end -->


```java
@Controller
public class FormController {

    @InitBinder
    protected void initBinder(WebDataBinder binder) {
        binder.addCustomFormatter(new DateFormatter("yyyy-MM-dd")); (1)
    }

    // ...
}

//(1) Adding a custom formatter (a DateFormatter, in this case).
```

### **1.4.6. Managing Exceptions** 

<!-- tabs:start -->

#### ** English **

[Web MVC](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-exceptionhandler)
#### ** Chinese **

[Web MVC](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-exceptionhandler)

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

`@Controller` and [@ControllerAdvice](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-controller-advice) classes can have `@ExceptionHandler` methods to handle exceptions from controller methods. The following example includes such a handler method:
#### ** Chinese **

`@Controller`和[@ControllerAdvice](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-controller-advice)类可以有`@ExceptionHandler`方法来处理来自控制器方法的异常。下面的例子包括这样一个处理方法。

<!-- tabs:end -->


```java
@Controller
public class SimpleController {

    // ...

    @ExceptionHandler (1)
    public ResponseEntity<String> handle(IOException ex) {
        // ...
    }
}

//(1) Declaring an @ExceptionHandler.
```

<!-- tabs:start -->

#### ** English **

The exception can match against a top-level exception being propagated (that is, a direct `IOException` being thrown) or against the immediate cause within a top-level wrapper exception (for example, an `IOException` wrapped inside an `IllegalStateException`).
#### ** Chinese **

异常可以与正在传播的顶层异常匹配（即直接抛出的 `IOException`，也可以与顶层包装器异常中的直接原因匹配（例如，在`IllegalStateException`中包装的`IOException`）。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

For matching exception types, preferably declare the target exception as a method argument, as shown in the preceding example. Alternatively, the annotation declaration can narrow the exception types to match. We generally recommend being as specific as possible in the argument signature and to declare your primary root exception mappings on a `@ControllerAdvice` prioritized with a corresponding order. See [the MVC section](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-exceptionhandler) for details.
#### ** Chinese **

对于匹配的异常类型，最好将目标异常声明为方法参数，如上例所示。另外，注解声明也可以缩小要匹配的异常类型。一般来说，我们建议在参数签名中尽可能的具体化，并且在`@ControllerAdvice`上声明你的主根异常映射，并以相应的顺序优先级来声明。详情请参见[MVC部分](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-exceptionhandler)。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

An `@ExceptionHandler` method in WebFlux supports the same method arguments and return values as a `@RequestMapping` method, with the exception of request body- and `@ModelAttribute`-related method arguments.
#### ** Chinese **

WebFlux中的`@ExceptionHandler`方法支持与`@RequestMapping`方法相同的方法参数和返回值，但请求体和`@ModelAttribute`相关的方法参数除外。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Support for `@ExceptionHandler` methods in Spring WebFlux is provided by the `HandlerAdapter` for `@RequestMapping` methods. See [`DispatcherHandler`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-dispatcher-handler) for more detail.
#### ** Chinese **

Spring WebFlux 中的 `@ExceptionHandler`方法的支持由 `HandlerAdapter`提供，用于 `@RequestMapping`方法。更多详情，请参阅 [`DispatcherHandler`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-dispatcher-handler)。

<!-- tabs:end -->


### **REST API exceptions** 

<!-- tabs:start -->

#### ** English **

[Web MVC](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-rest-exceptions)
#### ** Chinese **

[Web MVC](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-rest-exceptions)

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

A common requirement for REST services is to include error details in the body of the response. The Spring Framework does not automatically do so, because the representation of error details in the response body is application-specific. However, a `@RestController` can use `@ExceptionHandler` methods with a `ResponseEntity` return value to set the status and the body of the response. Such methods can also be declared in `@ControllerAdvice` classes to apply them globally.
#### ** Chinese **

REST服务的一个常见需求是在响应主体中包含错误细节。Spring框架不会自动这样做，因为响应体中的错误细节表示是特定于应用程序的。但是，`@RestController`可以使用`@ExceptionHandler`方法，并带有`ResponseEntity`返回值来设置响应的状态和响应体。这样的方法也可以在`@ControllerAdvice`类中声明，以便全局应用。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Note that Spring WebFlux does not have an equivalent for the Spring MVC `ResponseEntityExceptionHandler`, because WebFlux raises only `ResponseStatusException` (or subclasses thereof), and those do not need to be translated to an HTTP status code.
#### ** Chinese **

请注意，Spring WebFlux 没有 Spring MVC `ResponseEntityExceptionHandler`的等价物，因为 WebFlux 只会引发 `ResponseStatusException`（或其子类），而这些不需要翻译成 HTTP 状态代码。

<!-- tabs:end -->


### **1.4.7. Controller Advice** 

<!-- tabs:start -->

#### ** English **

[Web MVC](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-controller-advice)
#### ** Chinese **

[Web MVC](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-controller-advice)

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Typically, the `@ExceptionHandler`, `@InitBinder`, and `@ModelAttribute` methods apply within the `@Controller` class (or class hierarchy) in which they are declared. If you want such methods to apply more globally (across controllers), you can declare them in a class annotated with `@ControllerAdvice` or `@RestControllerAdvice`.
#### ** Chinese **

通常情况下，`@ExceptionHandler`、`@InitBinder`和`@ModelAttribute`方法会在其声明的`@Controller`类（或类层次结构）中应用。如果你想让这些方法在全局范围内（跨控制器）应用，你可以在类中声明这些方法，并以 `@ControllerAdvice`或`@RestControllerAdvice`注释。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

`@ControllerAdvice` is annotated with `@Component`, which means that such classes can be registered as Spring beans through [component scanning](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-java-instantiating-container-scan). `@RestControllerAdvice` is a composed annotation that is annotated with both `@ControllerAdvice` and `@ResponseBody`, which essentially means `@ExceptionHandler` methods are rendered to the response body through message conversion (versus view resolution or template rendering).
#### ** Chinese **

`@ControllerAdvice`被注释为`@Component`，这意味着这样的类可以通过[组件扫描](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-java-instantiating-container-scan)注册为Spring Bean。 `@RestControllerAdvice`是一个组成的注释，它同时被注释为`@ControllerAdvice`和`@ResponseBody`，这本质上意味着`@ExceptionHandler`方法通过消息转换（相对于视图解析或模板渲染）渲染到响应体。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

On startup, the infrastructure classes for `@RequestMapping` and `@ExceptionHandler` methods detect Spring beans annotated with `@ControllerAdvice` and then apply their methods at runtime. Global `@ExceptionHandler` methods (from a `@ControllerAdvice`) are applied *after* local ones (from the `@Controller`). By contrast, global `@ModelAttribute` and `@InitBinder` methods are applied *before* local ones.
#### ** Chinese **

在启动时，`@RequestMapping`和`@ExceptionHandler`方法的基础架构类会检测到用`@ControllerAdvice`注释的Spring Bean，然后在运行时应用它们的方法。全局的 `@ExceptionHandler`方法（来自 `@ControllerAdvice`）是在*后应用本地方法（来自 `@Controller`）。相比之下，全局的 `@ModelAttribute` 和 `@InitBinder`方法是在*前应用于本地方法。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

By default, `@ControllerAdvice` methods apply to every request (that is, all controllers), but you can narrow that down to a subset of controllers by using attributes on the annotation, as the following example shows:
#### ** Chinese **

默认情况下，`@ControllerAdvice`方法适用于每个请求（也就是所有控制器），但你可以通过使用注释上的属性将其缩小到控制器的子集，如下例所示。

<!-- tabs:end -->


```java
// Target all Controllers annotated with @RestController
@ControllerAdvice(annotations = RestController.class)
public class ExampleAdvice1 {}

// Target all Controllers within specific packages
@ControllerAdvice("org.example.controllers")
public class ExampleAdvice2 {}

// Target all Controllers assignable to specific classes
@ControllerAdvice(assignableTypes = {ControllerInterface.class, AbstractController.class})
public class ExampleAdvice3 {}
```

<!-- tabs:start -->

#### ** English **

The selectors in the preceding example are evaluated at runtime and may negatively impact performance if used extensively. See the [`@ControllerAdvice`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/web/bind/annotation/ControllerAdvice.html) javadoc for more details.
#### ** Chinese **

前面例子中的选择器在运行时进行评估，如果大量使用，可能会对性能产生负面影响。有关详细信息，请参阅 [`@ControllerAdvice`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/web/bind/annotation/ControllerAdvice.html) javadoc。

<!-- tabs:end -->



[下一章](Spring-Framework-5.2.6.RELEASE/Web%20on%20Reactive%20Stack/1.5.%20Functional%20Endpoints.md)


[回目录](Spring-Framework-5.2.6.RELEASE/summary.md)

[回首页](/README)
