# 5. RSocket

<!-- tabs:start -->

#### ** English **

This section describes Spring Framework’s support for the RSocket protocol.
#### ** Chinese **

本节介绍Spring框架对RSocket协议的支持。

<!-- tabs:end -->


### **5.1. Overview** 

<!-- tabs:start -->

#### ** English **

RSocket is an application protocol for multiplexed, duplex communication over TCP, WebSocket, and other byte stream transports, using one of the following interaction models:
#### ** Chinese **

RSocket是一种通过TCP、WebSocket和其他字节流传输的多工、双工通信的应用协议，使用以下交互模型之一。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

- `Request-Response` — send one message and receive one back.

- `Request-Stream` — send one message and receive a stream of messages back.

- `Channel` — send streams of messages in both directions.

- `Fire-and-Forget` — send a one-way message.

#### ** Chinese **

- `Request-Request-Response` - 发送一条消息并接收一条回传。

- `Request-Stream` - 发送一条消息，并接收一条回传的消息流。

- `通道` - 向两个方向发送消息流。

- `Fire-and-Forget` - 发送一条单向消息。


<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

Once the initial connection is made, the "client" vs "server" distinction is lost as both sides become symmetrical and each side can initiate one of the above interactions. This is why in the protocol calls the participating sides "requester" and "responder" while the above interactions are called "request streams" or simply "requests".
#### ** Chinese **

一旦建立了初始连接，"客户端 "与 "服务器 "的区别就失去了，因为双方变得对称，每一方都可以发起上述交互中的一个。这就是为什么在协议中把参与的双方称为 "请求者 "和 "响应者"，而上述交互被称为 "请求流 "或简单地称为 "请求"。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

These are the key features and benefits of the RSocket protocol:
#### ** Chinese **

这些是RSocket协议的主要特点和优点。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

- [Reactive Streams](https://www.reactive-streams.org/) semantics across network boundary — for streaming requests such as `Request-Stream` and `Channel`, back pressure signals travel between requester and responder, allowing a requester to slow down a responder at the source, hence reducing reliance on network layer congestion control, and the need for buffering at the network level or at any level.

- Request throttling — this feature is named "Leasing" after the `LEASE` frame that can be sent from each end to limit the total number of requests allowed by other end for a given time. Leases are renewed periodically.

- Session resumption — this is designed for loss of connectivity and requires some state to be maintained. The state management is transparent for applications, and works well in combination with back pressure which can stop a producer when possible and reduce the amount of state required.

- Fragmentation and re-assembly of large messages.

- Keepalive (heartbeats).

#### ** Chinese **

- Reactive Streams](https://www.reactive-streams.org/) 跨网络边界的[Reactive Streams](https://www.reactive-streams.org/)语义--对于流式请求，如`Request-Stream`和`Channel`，背压信号在请求者和响应者之间穿行，允许请求者在源端减缓响应者的速度，从而减少对网络层拥塞控制的依赖，减少了在网络层或任何层级的缓冲需求。

- 请求节流--该功能以`LEASE`帧命名为 "Leasing"，该帧可以从每端发送的`LEASE`来限制其他端在给定时间内允许的请求总数。租约是定期更新的。

- 会话恢复--这是为失去连接而设计的，需要保持一定的状态。状态管理对应用来说是透明的，与背压结合起来效果很好，背压可以在可能的情况下停止一个生产者，减少所需的状态量。

- 大消息的碎片化和重新组装。

- Keepalive（心动）。


<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

RSocket has [implementations](https://github.com/rsocket) in multiple languages. The [Java library](https://github.com/rsocket/rsocket-java) is built on [Project Reactor](https://projectreactor.io/), and [Reactor Netty](https://github.com/reactor/reactor-netty) for the transport. That means signals from Reactive Streams Publishers in your application propagate transparently through RSocket across the network.
#### ** Chinese **

RSocket有多种语言的[实现](https://github.com/rsocket)。Java库](https://github.com/rsocket/rsocket-java)是建立在[Project Reactor](https://projectreactor.io/)的基础上，而[Reactor Netty](https://github.com/reactor/reactor-netty)则是用于传输。这意味着你的应用程序中的Reactive Streams发布器的信号会通过RSocket在网络上透明地传播。

<!-- tabs:end -->


### **5.1.1. The Protocol** 

<!-- tabs:start -->

#### ** English **

One of the benefits of RSocket is that it has well defined behavior on the wire and an easy to read [specification](https://rsocket.io/docs/Protocol) along with some protocol [extensions](https://github.com/rsocket/rsocket/tree/master/Extensions). Therefore it is a good idea to read the spec, independent of language implementations and higher level framework APIs. This section provides a succinct overview to establish some context.
#### ** Chinese **

RSocket的好处之一是它在网络上有很好的定义行为，并且有一个易于阅读的[规范](https://rsocket.io/docs/Protocol)和一些协议[扩展](https://github.com/rsocket/rsocket/tree/master/Extensions)。因此，阅读规范是个好主意，独立于语言实现和更高层次的框架API之外，阅读规范是个好主意。本节提供了一个简洁的概述，以建立一些上下文。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

**Connecting** 
#### ** Chinese **

***连接** 

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Initially a client connects to a server via some low level streaming transport such as TCP or WebSocket and sends a `SETUP` frame to the server to set parameters for the connection.
#### ** Chinese **

最初，客户端通过一些低级的流媒体传输，如TCP或WebSocket等连接到服务器，并向服务器发送一个`SETUP`帧来设置连接参数。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The server may reject the `SETUP` frame, but generally after it is sent (for the client) and received (for the server), both sides can begin to make requests, unless `SETUP` indicates use of leasing semantics to limit the number of requests, in which case both sides must wait for a `LEASE` frame from the other end to permit making requests.
#### ** Chinese **

服务器可能会拒绝`SETUP`帧，但一般情况下，在发送（对客户端来说）和接收（对服务器来说）之后，双方都可以开始提出请求，除非`SETUP`表示使用租赁语义来限制请求的数量，在这种情况下，双方都必须等待来自另一端的`LEASE`帧，以允许提出请求。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

**Making Requests** 
#### ** Chinese **

***提出要求*** 

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Once a connection is established, both sides may initiate a request through one of the frames `REQUEST_RESPONSE`, `REQUEST_STREAM`, `REQUEST_CHANNEL`, or `REQUEST_FNF`. Each of those frames carries one message from the requester to the responder.
#### ** Chinese **

一旦建立了连接，双方可以通过`REQUEST_RESPONSE`、`REQUEST_STREAM`、`REQUEST_CHANNEL`或`REQUEST_FNF`等帧中的一个发起请求。这些帧中的每一个都会携带一个从请求者到响应者的消息。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The responder may then return `PAYLOAD` frames with response messages, and in the case of `REQUEST_CHANNEL` the requester may also send `PAYLOAD` frames with more request messages.
#### ** Chinese **

然后，响应者可以返回`PAYLOAD`帧和响应消息，而在`REQUEST_CHANNEL`的情况下，请求者也可以发送`PAYLOAD`帧和更多的请求消息。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

When a request involves a stream of messages such as `Request-Stream` and `Channel`, the responder must respect demand signals from the requester. Demand is expressed as a number of messages. Initial demand is specified in `REQUEST_STREAM` and `REQUEST_CHANNEL` frames. Subsequent demand is signaled via `REQUEST_N` frames.
#### ** Chinese **

当一个请求涉及一个消息流，如`Request-Stream`和`Channel`，响应者必须尊重来自请求者的需求信号。需求用消息的数量来表示。初始需求在`REQUEST_STREAM`和`REQUEST_CHANNEL`帧中指定。随后的需求通过`REQUEST_N`帧发出信号。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Each side may also send metadata notifications, via the `METADATA_PUSH` frame, that do not pertain to any individual request but rather to the connection as a whole.
#### ** Chinese **

每一方也可以通过`METADATA_PUSH`帧发送元数据通知，这些元数据通知不涉及任何单个请求，而是涉及整个连接。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

**Message Format** 
#### ** Chinese **

***信息格式*** 

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

RSocket messages contain data and metadata. Metadata can be used to send a route, a security token, etc. Data and metadata can be formatted differently. Mime types for each are declared in the `SETUP` frame and apply to all requests on a given connection.
#### ** Chinese **

RSocket消息包含数据和元数据。元数据可以用来发送路由、安全令牌等。数据和元数据可以有不同的格式。每种类型的MIME类型在`SETUP`帧中声明，并适用于给定连接上的所有请求。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

While all messages can have metadata, typically metadata such as a route are per-request and therefore only included in the first message on a request, i.e. with one of the frames `REQUEST_RESPONSE`, `REQUEST_STREAM`, `REQUEST_CHANNEL`, or `REQUEST_FNF`.
#### ** Chinese **

虽然所有报文都可以有元数据，但通常情况下，元数据（如路由）是每个请求的元数据，因此只包含在请求的第一个报文中，即包含有`REQUEST_RESPONSE`、`REQUEST_STREAM`、`REQUEST_CHANNEL`或`REQUEST_FNF`的帧之一。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Protocol extensions define common metadata formats for use in applications:
#### ** Chinese **

协议扩展定义了应用中使用的通用元数据格式。

<!-- tabs:end -->


### **5.1.2. Java Implementation** 

<!-- tabs:start -->

#### ** English **

The [Java implementation](https://github.com/rsocket/rsocket-java) for RSocket is built on [Project Reactor](https://projectreactor.io/). The transports for TCP and WebSocket are built on [Reactor Netty](https://github.com/reactor/reactor-netty). As a Reactive Streams library, Reactor simplifies the job of implementing the protocol. For applications it is a natural fit to use `Flux` and `Mono` with declarative operators and transparent back pressure support.
#### ** Chinese **

RSocket的[Java实现](https://github.com/rsocket/rsocket-java)是在[项目Reactor](https://projectreactor.io/)上建立的。TCP和WebSocket的传输是建立在[Reactor Netty](https://github.com/reactor/reactor-netty)上。作为一个 Reactor 流库，Reactor 简化了实现协议的工作。对于应用来说，使用`Flux`和`Mono`是很自然的，它具有声明式操作符和透明的背压支持。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The API in RSocket Java is intentionally minimal and basic. It focuses on protocol features and leaves the application programming model (e.g. RPC codegen vs other) as a higher level, independent concern.
#### ** Chinese **

RSocket Java中的API是有意地将其简化和基本的。它专注于协议特性，将应用程序设计模型（如RPC codegen vs other）作为一个更高层次的、独立的关注点。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The main contract [io.rsocket.RSocket](https://github.com/rsocket/rsocket-java/blob/master/rsocket-core/src/main/java/io/rsocket/RSocket.java) models the four request interaction types with `Mono` representing a promise for a single message, `Flux` a stream of messages, and `io.rsocket.Payload` the actual message with access to data and metadata as byte buffers. The `RSocket` contract is used symmetrically. For requesting, the application is given an `RSocket` to perform requests with. For responding, the application implements `RSocket` to handle requests.
#### ** Chinese **

主合约[io.rsocket.RSocket](https://github.com/rsocket/rsocket-java/blob/master/rsocket-core/src/main/java/io/rsocket/RSocket.java)模拟了四种请求交互类型，其中`Mono`代表单个消息的承诺，`Flux`代表消息流，而`io.rsocket.Payload`则是实际的消息，以字节缓冲区的形式访问数据和元数据。`RSocket`合约是对称使用的。对于请求，应用程序被赋予一个`RSocket`来执行请求。对于响应，应用程序实现了`RSocket`来处理请求。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

This is not meant to be a thorough introduction. For the most part, Spring applications will not have to use its API directly. However it may be important to see or experiment with RSocket independent of Spring. The RSocket Java repository contains a number of [sample apps](https://github.com/rsocket/rsocket-java/tree/master/rsocket-examples) that demonstrate its API and protocol features.
#### ** Chinese **

这并不是要做一个彻底的介绍。在大多数情况下，Spring应用程序将不需要直接使用它的API。然而，独立于Spring之外的RSocket可能是很重要的。RSocket Java存储库中包含了一些[示例应用](https://github.com/rsocket/rsocket-java/tree/master/rsocket-examples)，展示了它的API和协议功能。

<!-- tabs:end -->


### **5.1.3. Spring Support** 

<!-- tabs:start -->

#### ** English **

The `spring-messaging` module contains the following:
#### ** Chinese **

`spring-messaging`模块包含以下内容。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

- [Composite Metadata](https://github.com/rsocket/rsocket/blob/master/Extensions/CompositeMetadata.md)-- multiple, independently formatted metadata entries.

- [Routing](https://github.com/rsocket/rsocket/blob/master/Extensions/Routing.md) — the route for a request.

- [RSocketRequester](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#rsocket-requester) — fluent API to make requests through an `io.rsocket.RSocket` with data and metadata encoding/decoding.

- [Annotated Responders](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#rsocket-annot-responders) — `@MessageMapping` annotated handler methods for responding.

#### ** Chinese **

- [复合元数据](https://github.com/rsocket/rsocket/blob/master/Extensions/CompositeMetadata.md)----多个独立格式化的元数据条目。

- [Routing](https://github.com/rsocket/rsocket/blob/master/Extensions/Routing.md)----请求的路由。

- [RSocketRequester](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#rsocket-requester) ---通过`io.rsocket.RSocket`的数据和元数据编码/解码的流畅的API来发出请求。

- [Annotated Responders](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#rsocket-annot-responders) - `@MessageMapping`注释了响应的处理程序方法。


<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

The `spring-web` module contains `Encoder` and `Decoder` implementations such as Jackson CBOR/JSON, and Protobuf that RSocket applications will likely need. It also contains the `PathPatternParser` that can be plugged in for efficient route matching.
#### ** Chinese **

`spring-web`模块包含`Encoder`和`Decoder`实现，例如Jackson CBOR/JSON和Protobuf，这些都是RSocket应用可能需要的。它还包含了`PathPatternParser`，可以插入它来实现有效的路由匹配。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Spring Boot 2.2 supports standing up an RSocket server over TCP or WebSocket, including the option to expose RSocket over WebSocket in a WebFlux server. There is also client support and auto-configuration for an `RSocketRequester.Builder` and `RSocketStrategies`. See the [RSocket section](https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-rsocket) in the Spring Boot reference for more details.
#### ** Chinese **

Spring Boot 2.2 支持通过 TCP 或 WebSocket 建立 RSocket 服务器，包括在 WebFlux 服务器中通过 WebSocket 暴露 RSocket 的选项。此外，还有客户端支持和自动配置`RSocketRequester.Builder`和`RSocketStrategies`。有关详细信息，请参阅 Spring Boot 参考文献中的 [RSocket 部分](https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-rsocket)。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Spring Security 5.2 provides RSocket support.
#### ** Chinese **

Spring Security 5.2提供了对RSocket的支持。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Spring Integration 5.2 provides inbound and outbound gateways to interact with RSocket clients and servers. See the Spring Integration Reference Manual for more details.
#### ** Chinese **

Spring Integration 5.2 提供了与 RSocket 客户端和服务器交互的入站和出站网关。有关详细信息，请参阅Spring Integration参考手册。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Spring Cloud Gateway supports RSocket connections.
#### ** Chinese **

Spring云网关支持RSocket连接。

<!-- tabs:end -->


### **5.2. RSocketRequester** 

<!-- tabs:start -->

#### ** English **

`RSocketRequester` provides a fluent API to perform RSocket requests, accepting and returning objects for data and metadata instead of low level data buffers. It can be used symmetrically, to make requests from clients and to make requests from servers.
#### ** Chinese **

`RSocketRequester`提供了一个流畅的API来执行RSocket请求，接受并返回数据和元数据的对象，而不是低级数据缓冲区。它可以对称使用，从客户端发出请求，也可以从服务器发出请求。

<!-- tabs:end -->


### **5.2.1. Client Requester** 

<!-- tabs:start -->

#### ** English **

To obtain an `RSocketRequester` on the client side requires connecting to a server along with preparing and sending the initial RSocket `SETUP` frame. `RSocketRequester` provides a builder for that. Internally uses RSocket Java’s `RSocketFactory`.
#### ** Chinese **

要在客户端获得一个`RSocketRequester`，需要连接到服务器，同时准备并发送初始的RSocket `SETUP`帧。 `RSocketRequester`为此提供了一个构建器。内部使用RSocket Java的`RSocketFactory`。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

This is the most basic way to connect with default settings:
#### ** Chinese **

这是最基本的连接方式，用默认的设置来连接。

<!-- tabs:end -->


```java
Mono<RSocketRequester> requesterMono = RSocketRequester.builder()
    .connectTcp("localhost", 7000);

Mono<RSocketRequester> requesterMono = RSocketRequester.builder()
    .connectWebSocket(URI.create("https://example.org:8080/rsocket"));
```

<!-- tabs:start -->

#### ** English **

The above is deferred. To actually connect and use the requester:
#### ** Chinese **

以上是递延的。要实际连接和使用请求者。

<!-- tabs:end -->


```java
// Connect asynchronously
RSocketRequester.builder().connectTcp("localhost", 7000)
    .subscribe(requester -> {
        // ...
    });

// Or block
RSocketRequester requester = RSocketRequester.builder()
    .connectTcp("localhost", 7000)
    .block(Duration.ofSeconds(5));
```

### **Connection Setup** 

<!-- tabs:start -->

#### ** English **

`RSocketRequester.Builder` provides the following to customize the initial `SETUP` frame:
#### ** Chinese **

`RSocketRequester.Builder`提供了以下内容来定制初始`SETUP`框架。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

- `dataMimeType(MimeType)` — set the mime type for data on the connection.

- `metadataMimeType(MimeType)` — set the mime type for metadata on the connection.

- `setupData(Object)` — data to include in the `SETUP`.

- `setupRoute(String, Object…​)` — route in the metadata to include in the `SETUP`.

- `setupMetadata(Object, MimeType)` — other metadata to include in the `SETUP`.

#### ** Chinese **

- `dataMimeType(MimeType)` - 为连接上的数据设置mime类型。

- `metadataMimeType(MimeType)` - 为连接上的元数据设置mime类型。

- `setupData(Object)` - 要包含在`SETUP`中的数据。

- `setupRoute(String, Object...)` - 元数据中要包含在`SETUP`中的路由。

- `setupMetadata(Object, MimeType)` - 要包含在`SETUP`中的其他元数据。


<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

For data, the default mime type is derived from the first configured `Decoder`. For metadata, the default mime type is [composite metadata](https://github.com/rsocket/rsocket/blob/master/Extensions/CompositeMetadata.md) which allows multiple metadata value and mime type pairs per request. Typically both don’t need to be changed.
#### ** Chinese **

对于数据，默认的哑语类型来自于第一个配置的`解码器`。对于元数据，默认的mime类型是[composite metadata](https://github.com/rsocket/rsocket/blob/master/Extensions/CompositeMetadata.md)，它允许每个请求有多个元数据值和mime类型对。通常情况下，这两种类型都不需要更改。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Data and metadata in the `SETUP` frame is optional. On the server side, [@ConnectMapping](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#rsocket-annot-connectmapping) methods can be used to handle the start of a connection and the content of the `SETUP` frame. Metadata may be used for connection level security.
#### ** Chinese **

`SETUP`帧中的数据和元数据是可选的。在服务器端，[@ConnectMapping](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#rsocket-annot-connectmapping)方法可以用来处理连接的开始和`SETUP`帧的内容。元数据可以用于连接级安全。

<!-- tabs:end -->


### **Strategies** 

<!-- tabs:start -->

#### ** English **

`RSocketRequester.Builder` accepts `RSocketStrategies` to configure the requester. You’ll need to use this to provide encoders and decoders for (de)-serialization of data and metadata values. By default only the basic codecs from `spring-core` for `String`, `byte[]`, and `ByteBuffer` are registered. Adding `spring-web` provides access to more that can be registered as follows:
#### ** Chinese **

`RSocketRequester.Builder`接受`RSocketStrategies`来配置请求器。你需要用它来提供编码器和解码器，用于（去）序列化数据和元数据值。默认情况下，只注册了`spring-core`中的基本编解码器`String`、`byte[]`和`ByteBuffer`。添加 `spring-web`，就可以访问更多可以注册的内容，如下所示。

<!-- tabs:end -->


```java
RSocketStrategies strategies = RSocketStrategies.builder()
    .encoders(encoders -> encoders.add(new Jackson2CborEncoder()))
    .decoders(decoders -> decoders.add(new Jackson2CborDecoder()))
    .build();

Mono<RSocketRequester> requesterMono = RSocketRequester.builder()
    .rsocketStrategies(strategies)
    .connectTcp("localhost", 7000);
```

<!-- tabs:start -->

#### ** English **

`RSocketStrategies` is designed for re-use. In some scenarios, e.g. client and server in the same application, it may be preferable to declare it in Spring configuration.
#### ** Chinese **

`RSocketStrategies`是为重复使用而设计的。在某些情况下，例如在同一个应用程序中的客户端和服务器，最好在Spring配置中声明。

<!-- tabs:end -->


### **Client Responders** 

<!-- tabs:start -->

#### ** English **

`RSocketRequester.Builder` can be used to configure responders to requests from the server.
#### ** Chinese **

`RSocketRequester.Builder`可以用来配置来自服务器的请求的响应者。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can use annotated handlers for client-side responding based on the same infrastructure that’s used on a server, but registered programmatically as follows:
#### ** Chinese **

你可以使用注解的处理程序来进行客户端响应，该处理程序基于在服务器上使用的相同的基础架构，但以编程方式注册如下。

<!-- tabs:end -->


```java
RSocketStrategies strategies = RSocketStrategies.builder()
    .routeMatcher(new PathPatternRouteMatcher())  (1)
    .build();

ClientHandler handler = new ClientHandler(); (2)

Mono<RSocketRequester> requesterMono = RSocketRequester.builder()
    .rsocketFactory(RSocketMessageHandler.clientResponder(strategies, handler)) (3)
    .connectTcp("localhost", 7000);

//(1) Use PathPatternRouteMatcher, if spring-web is present, for efficient
route matching.
(2) Create responder that contains @MessageMaping or @ConnectMapping methods.
(3) Use static factory method in RSocketMessageHandler to register one or more responders.
```

<!-- tabs:start -->

#### ** English **

Note the above is only a shortcut designed for programmatic registration of client responders. For alternative scenarios, where client responders are in Spring configuration, you can still declare `RSocketMessageHandler` as a Spring bean and then apply as follows:
#### ** Chinese **

注意，以上只是为客户机响应器的程序化注册而设计的一种快捷方式。在Spring配置中的客户端应答器的替代方案中，你仍然可以将`RSocketMessageHandler`声明为Spring Bean，然后应用如下。

<!-- tabs:end -->


```java
ApplicationContext context = ... ;
RSocketMessageHandler handler = context.getBean(RSocketMessageHandler.class);

Mono<RSocketRequester> requesterMono = RSocketRequester.builder()
    .rsocketFactory(factory -> factory.acceptor(handler.responder()))
    .connectTcp("localhost", 7000);
```

<!-- tabs:start -->

#### ** English **

For the above you may also need to use `setHandlerPredicate` in `RSocketMessageHandler` to switch to a different strategy for detecting client responders, e.g. based on a custom annotation such as `@RSocketClientResponder` vs the default `@Controller`. This is necessary in scenarios with client and server, or multiple clients in the same application.
#### ** Chinese **

对于上述情况，您可能还需要在`RSocketMessageHandler`中使用`setHandlerPredicate`来切换到不同的策略来检测客户端响应器，例如，基于自定义注释，如`@RSocketClientResponder`和默认的`@Controller`。这在有客户端和服务器或同一应用程序中的多个客户端的情况下是必要的。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

See also [Annotated Responders](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#rsocket-annot-responders), for more on the programming model.
#### ** Chinese **

更多关于程序设计模式的内容，请参见[注解回复](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#rsocket-annot-responders)。

<!-- tabs:end -->


### **Advanced** 

<!-- tabs:start -->

#### ** English **

`RSocketRequesterBuilder` provides a callback to expose the underlying `ClientRSocketFactory` from RSocket Java for further configuration options for keepalive intervals, session resumption, interceptors, and more. You can configure options at that level as follows:
#### ** Chinese **

`RSocketRequesterBuilder`提供了一个回调，用于从RSocket Java中公开底层的`ClientRSocketFactory`，以进一步配置选项，用于保持时间间隔、会话恢复、拦截器等。你可以在这个级别配置选项如下。

<!-- tabs:end -->


```java
Mono<RSocketRequester> requesterMono = RSocketRequester.builder()
    .rsocketFactory(factory -> {
        // ...
    })
    .connectTcp("localhost", 7000);
```

### **5.2.2. Server Requester** 

<!-- tabs:start -->

#### ** English **

To make requests from a server to connected clients is a matter of obtaining the requester for the connected client from the server.
#### ** Chinese **

要从服务器向连接的客户机发出请求，就需要从服务器上获取连接的客户机的请求者。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

In [Annotated Responders](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#rsocket-annot-responders), `@ConnectMapping` and `@MessageMapping` methods support an `RSocketRequester` argument. Use it to access the requester for the connection. Keep in mind that `@ConnectMapping` methods are essentially handlers of the `SETUP` frame which must be handled before requests can begin. Therefore, requests at the very start must be decoupled from handling. For example:
#### ** Chinese **

在[Annotated Responders](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#rsocket-annot-responders)中，`@ConnectMapping`和`@MessageMapping`方法支持一个`RSocketRequester`参数。使用它来访问连接的请求器。请记住，`@ConnectMapping`方法本质上是`SETUP`帧的处理程序，在请求开始之前，必须先处理好这个帧。因此，一开始的请求必须与处理程序解耦。比如说。

<!-- tabs:end -->


```java
@ConnectMapping
Mono<Void> handle(RSocketRequester requester) {
    requester.route("status").data("5")
        .retrieveFlux(StatusReport.class)
        .subscribe(bar -> { (1)
            // ...
        });
    return ... (2)
}

//(1) Start the request asynchronously, independent from handling.
(2) Perform handling and return completion Mono<Void>.
```

### **5.2.3. Requests** 

<!-- tabs:start -->

#### ** English **

Once you have a [client](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#rsocket-requester-client) or [server](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#rsocket-requester-server) requester, you can make requests as follows:
#### ** Chinese **

一旦你有一个[客户端](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#rsocket-requester-client)或[服务器](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#rsocket-requester-server)请求者，你就可以进行如下请求。

<!-- tabs:end -->


```java
ViewBox viewBox = ... ;

Flux<AirportLocation> locations = requester.route("locate.radars.within") (1)
        .data(viewBox) (2)
        .retrieveFlux(AirportLocation.class); (3)

//(1) Specify a route to include in the metadata of the request message.
(2) Provide data for the request message.
(3) Declare the expected response.
```

<!-- tabs:start -->

#### ** English **

The interaction type is determined implicitly from the cardinality of the input and output. The above example is a `Request-Stream` because one value is sent and a stream of values is received. For the most part you don’t need to think about this as long as the choice of input and output matches an RSocket interaction type and the types of input and output expected by the responder. The only example of an invalid combination is many-to-one.
#### ** Chinese **

交互类型是由输入和输出的cardinality决定的。上面的例子是一个`Request-Stream`，因为发送一个值，然后接收一个值流。在大多数情况下，你不需要考虑这个问题，只要输入和输出的选择与RSocket交互类型和响应者期望的输入和输出类型相匹配就可以了。无效组合的唯一例子是多对一。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The `data(Object)` method also accepts any Reactive Streams `Publisher`, including `Flux` and `Mono`, as well as any other producer of value(s) that is registered in the `ReactiveAdapterRegistry`. For a multi-value `Publisher` such as `Flux` which produces the same types of values, consider using one of the overloaded `data` methods to avoid having type checks and `Encoder` lookup on every element:
#### ** Chinese **

`data(Object)`方法也接受任何 Reactive Streams `Publisher`，包括 `Flux`和`Mono`，以及在 `ReactiveAdapterRegistry`中注册的任何其他值的生产者。对于多值 `Publisher`，如 `Flux`产生相同类型的值，可以考虑使用重载的 `data`方法之一，以避免对每个元素进行类型检查和 `Encoder`查找。

<!-- tabs:end -->


```java
data(Object producer, Class<?> elementClass);
data(Object producer, ParameterizedTypeReference<?> elementTypeRef);
```

<!-- tabs:start -->

#### ** English **

The `data(Object)` step is optional. Skip it for requests that don’t send data:
#### ** Chinese **

`data(Object)`步骤是可选的。对于不发送数据的请求，跳过它。

<!-- tabs:end -->


```java
Mono<AirportLocation> location = requester.route("find.radar.EWR"))
    .retrieveMono(AirportLocation.class);
```

<!-- tabs:start -->

#### ** English **

Extra metadata values can be added if using [composite metadata](https://github.com/rsocket/rsocket/blob/master/Extensions/CompositeMetadata.md) (the default) and if the values are supported by a registered `Encoder`. For example:
#### ** Chinese **

如果使用[composite metadata](https://github.com/rsocket/rsocket/blob/master/Extensions/CompositeMetadata.md)，可以添加额外的元数据值。 (默认值)，以及是否有注册的`编码器`支持这些值。例如：

<!-- tabs:end -->


```java
String securityToken = ... ;
ViewBox viewBox = ... ;
MimeType mimeType = MimeType.valueOf("message/x.rsocket.authentication.bearer.v0");

Flux<AirportLocation> locations = requester.route("locate.radars.within")
        .metadata(securityToken, mimeType)
        .data(viewBox)
        .retrieveFlux(AirportLocation.class);
```

<!-- tabs:start -->

#### ** English **

For `Fire-and-Forget` use the `send()` method that returns `Mono<Void>`. Note that the `Mono` indicates only that the message was successfully sent, and not that it was handled.
#### ** Chinese **

对于`Fire-and-Forget`，使用`send()`方法返回`Mono<Void>`。请注意，`Mono`仅表示消息已成功发送，而不是表示消息已被处理。

<!-- tabs:end -->


### **5.3. Annotated Responders** 

<!-- tabs:start -->

#### ** English **

RSocket responders can be implemented as `@MessageMapping` and `@ConnectMapping` methods. `@MessageMapping` methods handle individual requests while `@ConnectMapping` methods handle connection-level events (setup and metadata push). Annotated responders are supported symmetrically, for responding from the server side and for responding from the client side.
#### ** Chinese **

RSocket响应器可以用`@MessageMapping`和`@ConnectMapping`方法来实现。 `@MessageMapping`方法处理单个请求，而`@ConnectMapping`方法处理连接级事件（设置和元数据推送）。注释的响应器是对称支持的，用于从服务器端响应和从客户端响应。

<!-- tabs:end -->


### **5.3.1. Server Responders** 

<!-- tabs:start -->

#### ** English **

To use annotated responders on the server side, add `RSocketMessageHandler` to your Spring configuration to detect `@Controller` beans with `@MessageMapping` and `@ConnectMapping` methods:
#### ** Chinese **

要在服务器端使用注解响应器，请在Spring配置中添加`RSocketMessageHandler`，以便用`@MessageMapping`和`@ConnectMapping`方法检测`@Controller` Bean。

<!-- tabs:end -->


```java
@Configuration
static class ServerConfig {

    @Bean
    public RSocketMessageHandler rsocketMessageHandler() {
        RSocketMessageHandler handler = new RSocketMessageHandler();
        handler.routeMatcher(new PathPatternRouteMatcher());
        return handler;
    }
}
```

<!-- tabs:start -->

#### ** English **

Then start an RSocket server through the Java RSocket API and plug the `RSocketMessageHandler` for the responder as follows:
#### ** Chinese **

然后通过Java RSocket API启动一个RSocket服务器，并为响应器插入`RSocketMessageHandler`，如下所示。

<!-- tabs:end -->


```java
ApplicationContext context = ... ;
RSocketMessageHandler handler = context.getBean(RSocketMessageHandler.class);

CloseableChannel server =
    RSocketFactory.receive()
        .acceptor(handler.responder())
        .transport(TcpServerTransport.create("localhost", 7000))
        .start()
        .block();
```

<!-- tabs:start -->

#### ** English **

`RSocketMessageHandler` supports [composite](https://github.com/rsocket/rsocket/blob/master/Extensions/CompositeMetadata.md) and [routing](https://github.com/rsocket/rsocket/blob/master/Extensions/Routing.md) metadata by default. You can set its [MetadataExtractor](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#rsocket-metadata-extractor) if you need to switch to a different mime type or register additional metadata mime types.
#### ** Chinese **

`RSocketMessageHandler`默认支持[composite](https://github.com/rsocket/rsocket/blob/master/Extensions/CompositeMetadata.md)和[routing](https://github.com/rsocket/rsocket/blob/master/Extensions/Routing.md)元数据。如果你需要切换到不同的mime类型或注册额外的元数据mime类型，你可以设置它的[MetadataExtractor](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#rsocket-metadata-extractor)。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You’ll need to set the `Encoder` and `Decoder` instances required for metadata and data formats to support. You’ll likely need the `spring-web` module for codec implementations.
#### ** Chinese **

您需要设置`编码器`和`解码器`实例，以支持元数据和数据格式。您可能需要`spring-web`模块来实现编解码器。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

By default `SimpleRouteMatcher` is used for matching routes via `AntPathMatcher`. We recommend plugging in the `PathPatternRouteMatcher` from `spring-web` for efficient route matching. RSocket routes can be hierarchical but are not URL paths. Both route matchers are configured to use "." as separator by default and there is no URL decoding as with HTTP URLs.
#### ** Chinese **

默认情况下，`SimpleRouteMatcher`被用于通过`AntPathMatcher`匹配路由。我们建议从`spring-web`中插入`PathPatternRouteMatcher`，以实现高效的路由匹配。RSocket路由可以是分层的，但不是URL路径。这两个路由匹配器都被配置为默认使用". "作为分隔符，并且没有像HTTP URL那样对URL进行解码。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

`RSocketMessageHandler` can be configured via `RSocketStrategies` which may be useful if you need to share configuration between a client and a server in the same process:
#### ** Chinese **

`RSocketMessageHandler`可以通过`RSocketStrategies`进行配置，如果您需要在同一进程中的客户端和服务器之间共享配置，这可能会很有用。

<!-- tabs:end -->


```java
@Configuration
static class ServerConfig {

    @Bean
    public RSocketMessageHandler rsocketMessageHandler() {
        RSocketMessageHandler handler = new RSocketMessageHandler();
        handler.setRSocketStrategies(rsocketStrategies());
        return handler;
    }

    @Bean
    public RSocketStrategies rsocketStrategies() {
        return RSocketStrategies.builder()
            .encoders(encoders -> encoders.add(new Jackson2CborEncoder()))
            .decoders(decoders -> decoders.add(new Jackson2CborDecoder()))
            .routeMatcher(new PathPatternRouteMatcher())
            .build();
    }
}
```

### **5.3.2. Client Responders** 

<!-- tabs:start -->

#### ** English **

Annotated responders on the client side need to be configured in the `RSocketRequester.Builder`. For details, see [Client Responders](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#rsocket-requester-client-responder).
#### ** Chinese **

客户端的注释响应器需要在`RSocketRequester.Builder`中配置。有关详细信息，请参阅[Client Responders](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#rsocket-requester-client-responder)。

<!-- tabs:end -->


### **5.3.3. @MessageMapping** 

<!-- tabs:start -->

#### ** English **

Once [server](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#rsocket-annot-responders-server) or [client](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#rsocket-annot-responders-client) responder configuration is in place, `@MessageMapping` methods can be used as follows:
#### ** Chinese **

一旦[server](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#rsocket-annot-responders-server)或[client](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#rsocket-annot-responders-client)应答器配置到位，`@MessageMapping`方法可以按以下方式使用。

<!-- tabs:end -->


```java
@Controller
public class RadarsController {

    @MessageMapping("locate.radars.within")
    public Flux<AirportLocation> radars(MapRequest request) {
        // ...
    }
}
```

<!-- tabs:start -->

#### ** English **

The above `@MessageMapping` method responds to a Request-Stream interaction having the route "locate.radars.within". It supports a flexible method signature with the option to use the following method arguments:
#### ** Chinese **

上述`@MessageMapping`方法响应一个路由为 "locate.radars.inner "的请求流交互。它支持一个灵活的方法签名，可以选择使用以下方法参数。

<!-- tabs:end -->


Method Argument | Description 
-|-
@Payload | The payload of the request. This can be a concrete value of asynchronous types like Mono or Flux.Note: Use of the annotation is optional. A method argument that is not a simple type and is not any of the other supported arguments, is assumed to be the expected payload. 
RSocketRequester | Requester for making requests to the remote end. 
@DestinationVariable | Value extracted from the route based on variables in the mapping pattern, e.g. @MessageMapping("find.radar.{id}"). 
@Header | Metadata value registered for extraction as described in MetadataExtractor. 
@Headers Map<String, Object> | All metadata values registered for extraction as described in MetadataExtractor. 


<!-- tabs:start -->

#### ** English **

The return value is expected to be one or more Objects to be serialized as response payloads. That can be asynchronous types like `Mono` or `Flux`, a concrete value, or either `void` or a no-value asynchronous type such as `Mono<Void>`.
#### ** Chinese **

返回值应该是一个或多个对象作为响应有效载荷序列化。这可以是异步类型，如 `Mono` 或 `Flux`，也可以是一个具体的值，或者是 `void`或无值异步类型，如 `Mono<Void>`。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The RSocket interaction type that an `@MessageMapping` method supports is determined from the cardinality of the input (i.e. `@Payload` argument) and of the output, where cardinality means the following:
#### ** Chinese **

`@MessageMapping`方法所支持的RSocket交互类型由输入（即`@Payload`参数）和输出的cardinality决定，其中cardinality指的是以下内容。

<!-- tabs:end -->


Cardinality | Description 
-|-
1 | Either an explicit value, or a single-value asynchronous type such as Mono<T>. 
Many | A multi-value asynchronous type such as Flux<T>. 
0 | For input this means the method does not have an @Payload argument.For output this is void or a no-value asynchronous type such as Mono<Void>. 


<!-- tabs:start -->

#### ** English **

The table below shows all input and output cardinality combinations and the corresponding interaction type(s):
#### ** Chinese **

下表显示了所有的输入和输出卡数组合以及相应的交互类型。

<!-- tabs:end -->


Input Cardinality | Output Cardinality | Interaction Types 
-|-|-
0, 1 | 0 | Fire-and-Forget, Request-Response 
0, 1 | 1 | Request-Response 
0, 1 | Many | Request-Stream 
Many | 0, 1, Many | Request-Channel 


### **5.3.4. @ConnectMapping** 

<!-- tabs:start -->

#### ** English **

`@ConnectMapping` handles the `SETUP` frame at the start of an RSocket connection, and any subsequent metadata push notifications through the `METADATA_PUSH` frame, i.e. `metadataPush(Payload)` in `io.rsocket.RSocket`.
#### ** Chinese **

`@ConnectMapping` 处理 RSocket 连接开始时的 `SETUP` 帧，以及通过 `METADATA_PUSH` 帧处理任何后续的元数据推送通知，即 `io.rsocket.RSocket`中的 `metadataPush(Payload)` `io.rsocket.RSocket`中的 `metadataPush(Payload)`。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

`@ConnectMapping` methods support the same arguments as [@MessageMapping](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#rsocket-annot-messagemapping) but based on metadata and data from the `SETUP` and `METADATA_PUSH` frames. `@ConnectMapping` can have a pattern to narrow handling to specific connections that have a route in the metadata, or if no patterns are declared then all connections match.
#### ** Chinese **

`@ConnectMapping`方法支持与[@MessageMapping](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#rsocket-annot-messagemapping)相同的参数，但基于元数据和来自`SETUP`和`METADATA_PUSH`帧的数据。 `@ConnectMapping`可以有一个模式，以便将处理范围缩小到元数据中具有路由的特定连接，或者如果没有声明模式，则所有连接都匹配。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

`@ConnectMapping` methods cannot return data and must be declared with `void` or `Mono<Void>` as the return value. If handling returns an error for a new connection then the connection is rejected. Handling must not be held up to make requests to the `RSocketRequester` for the connection. See [Server Requester](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#rsocket-requester-server) for details.
#### ** Chinese **

`@ConnectMapping`方法不能返回数据，必须用`void`或`Mono<Void>`声明为返回值。如果处理方法返回一个新连接的错误，那么该连接将被拒绝。处理过程中，必须不允许对连接的`RSocketRequester`进行请求。详情请参阅[服务器请求器](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#rsocket-requester-server)。

<!-- tabs:end -->


### **5.4. MetadataExtractor** 

<!-- tabs:start -->

#### ** English **

Responders must interpret metadata. [Composite metadata](https://github.com/rsocket/rsocket/blob/master/Extensions/CompositeMetadata.md) allows independently formatted metadata values (e.g. for routing, security, tracing) each with its own mime type. Applications need a way to configure metadata mime types to support, and a way to access extracted values.
#### ** Chinese **

响应者必须解释元数据。 复合元数据](https://github.com/rsocket/rsocket/blob/master/Extensions/CompositeMetadata.md)允许独立格式化的元数据值(例如路由、安全、追踪)，每个元数据值都有自己的mime类型。应用程序需要一种方法来配置元数据mime类型来支持，并且需要一种方法来访问提取的值。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

`MetadataExtractor` is a contract to take serialized metadata and return decoded name-value pairs that can then be accessed like headers by name, for example via `@Header` in annotated handler methods.
#### ** Chinese **

`MetadataExtractor`是一个合约，用于获取序列化的元数据，并返回经解码的名-值对，然后可以像标题一样通过名称访问，例如通过注释处理程序方法中的`@Header`来访问。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

`DefaultMetadataExtractor` can be given `Decoder` instances to decode metadata. Out of the box it has built-in support for ["message/x.rsocket.routing.v0"](https://github.com/rsocket/rsocket/blob/master/Extensions/Routing.md) which it decodes to `String` and saves under the "route" key. For any other mime type you’ll need to provide a `Decoder` and register the mime type as follows:
#### ** Chinese **

`DefaultMetadataExtractor`可以被赋予`Decoder`实例来解码元数据。开箱即用，它内置了对["message/x.rsocket.rsocket.routing.v0"](https://github.com/rsocket/rsocket/blob/master/Extensions/Routing.md)的支持，它可以将其解码为`String`，并保存在 "路由 "键下。对于任何其他的mime类型，你需要提供一个`解码器`，并按以下方式注册mime类型。

<!-- tabs:end -->


```java
DefaultMetadataExtractor extractor = new DefaultMetadataExtractor(metadataDecoders);
extractor.metadataToExtract(fooMimeType, Foo.class, "foo");
```

<!-- tabs:start -->

#### ** English **

Composite metadata works well to combine independent metadata values. However the requester might not support composite metadata, or may choose not to use it. For this, `DefaultMetadataExtractor` may needs custom logic to map the decoded value to the output map. Here is an example where JSON is used for metadata:
#### ** Chinese **

复合元数据可以很好地组合独立的元数据值。然而，请求者可能不支持复合元数据，或者可能选择不使用复合元数据。为此，`DefaultMetadataExtractor`可能需要自定义逻辑来将解码后的值映射到输出映射中。下面是一个使用JSON作为元数据的例子。

<!-- tabs:end -->


```java
DefaultMetadataExtractor extractor = new DefaultMetadataExtractor(metadataDecoders);
extractor.metadataToExtract(
    MimeType.valueOf("application/vnd.myapp.metadata+json"),
    new ParameterizedTypeReference<Map<String,String>>() {},
    (jsonMap, outputMap) -> {
        outputMap.putAll(jsonMap);
    });
```

<!-- tabs:start -->

#### ** English **

When configuring `MetadataExtractor` through `RSocketStrategies`, you can let `RSocketStrategies.Builder` create the extractor with the configured decoders, and simply use a callback to customize registrations as follows:
#### ** Chinese **

当通过`MetadataExtractor`配置`MetadataExtractor`时，可以让`RSocketStrategies.Builder`用配置好的解码器创建提取器，并简单地使用回调来定制注册，具体如下。

<!-- tabs:end -->


```java
RSocketStrategies strategies = RSocketStrategies.builder()
    .metadataExtractorRegistry(registry -> {
        registry.metadataToExtract(fooMimeType, Foo.class, "foo");
        // ...
    })
    .build();
```


[下一章](Spring-Framework-5.2.6.RELEASE/Web%20on%20Reactive%20Stack/6.%20Reactive%20Libraries.md)


[回目录](Spring-Framework-5.2.6.RELEASE/summary.md)

[回首页](/README)
