# 1.2. Reactive Core

<!-- tabs:start -->

#### ** English **

The `spring-web` module contains the following foundational support for reactive web applications:
#### ** Chinese **

`spring-web`模块包含了对反应式web应用的以下基础支持。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

- For server request processing there are two levels of support.
#### ** Chinese **

- 对于服务器请求处理，有两级支持。

<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

  - [HttpHandler](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-httphandler): Basic contract for HTTP request handling with non-blocking I/O and Reactive Streams back pressure, along with adapters for Reactor Netty, Undertow, Tomcat, Jetty, and any Servlet 3.1+ container.
#### ** Chinese **

  - HttpHandler](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-httphandler)。用于HTTP请求处理的基本合约，具有无阻塞的I/O和Reactive Streams回压，以及Reactor Netty、Undertow、Tomcat、Jetty和任何Servlet 3.1以上容器的适配器。

<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

  - [`WebHandler`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-web-handler-api)[ API](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-web-handler-api): Slightly higher level, general-purpose web API for request handling, on top of which concrete programming models such as annotated controllers and functional endpoints are built.
#### ** Chinese **

  - `WebHandler`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-web-handler-api)[API](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-web-handler-api)。略高一级的通用型 Web API，用于处理请求，在此基础上建立了具体的编程模型，如注释控制器和功能端点。

<!-- tabs:end -->


### **1.2.1.** **`HttpHandler`** 

<!-- tabs:start -->

#### ** English **

[HttpHandler](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/http/server/reactive/HttpHandler.html) is a simple contract with a single method to handle a request and a response. It is intentionally minimal, and its main and only purpose is to be a minimal abstraction over different HTTP server APIs.
#### ** Chinese **

[HttpHandler](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/http/server/reactive/HttpHandler.html)是一个简单的契约，只有一个方法来处理一个请求和一个响应。它是有意的，它的主要也是唯一的目的是在不同的HTTP服务器API上做一个最小的抽象。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following table describes the supported server APIs:
#### ** Chinese **

下表介绍了支持的服务器API。

<!-- tabs:end -->


Server name | Server API used | Reactive Streams support 
-|-|-
Netty | Netty API | Reactor Netty 
Undertow | Undertow API | spring-web: Undertow to Reactive Streams bridge 
Tomcat | Servlet 3.1 non-blocking I/O; Tomcat API to read and write ByteBuffers vs byte[] | spring-web: Servlet 3.1 non-blocking I/O to Reactive Streams bridge 
Jetty | Servlet 3.1 non-blocking I/O; Jetty API to write ByteBuffers vs byte[] | spring-web: Servlet 3.1 non-blocking I/O to Reactive Streams bridge 
Servlet 3.1 container | Servlet 3.1 non-blocking I/O | spring-web: Servlet 3.1 non-blocking I/O to Reactive Streams bridge 


<!-- tabs:start -->

#### ** English **

The following table describes server dependencies (also see [supported versions](https://github.com/spring-projects/spring-framework/wiki/What%27s-New-in-the-Spring-Framework)):
#### ** Chinese **

下表描述了服务器的依赖关系（也请参见[支持的版本](https://github.com/spring-projects/spring-framework/wiki/What%27s-New-in-the-Spring-Framework)）。

<!-- tabs:end -->


Server name | Group id | Artifact name 
-|-|-
Reactor Netty | io.projectreactor.netty | reactor-netty 
Undertow | io.undertow | undertow-core 
Tomcat | org.apache.tomcat.embed | tomcat-embed-core 
Jetty | org.eclipse.jetty | jetty-server, jetty-servlet 


<!-- tabs:start -->

#### ** English **

The code snippets below show using the `HttpHandler` adapters with each server API:
#### ** Chinese **

下面的代码片段显示了使用`HttpHandler`适配器与每个服务器API的使用情况。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

**Reactor Netty** 
#### ** Chinese **

***反应器Netty**** 

<!-- tabs:end -->


```java
HttpHandler handler = ...
ReactorHttpHandlerAdapter adapter = new ReactorHttpHandlerAdapter(handler);
HttpServer.create().host(host).port(port).handle(adapter).bind().block();
```

<!-- tabs:start -->

#### ** English **

**Undertow** 
#### ** Chinese **

***水深火热**** 

<!-- tabs:end -->


```java
HttpHandler handler = ...
UndertowHttpHandlerAdapter adapter = new UndertowHttpHandlerAdapter(handler);
Undertow server = Undertow.builder().addHttpListener(port, host).setHandler(adapter).build();
server.start();
```

<!-- tabs:start -->

#### ** English **

**Tomcat** 
#### ** Chinese **

**Tomcat*** 

<!-- tabs:end -->


```java
HttpHandler handler = ...
Servlet servlet = new TomcatHttpHandlerAdapter(handler);

Tomcat server = new Tomcat();
File base = new File(System.getProperty("java.io.tmpdir"));
Context rootContext = server.addContext("", base.getAbsolutePath());
Tomcat.addServlet(rootContext, "main", servlet);
rootContext.addServletMappingDecoded("/", "main");
server.setHost(host);
server.setPort(port);
server.start();
```

<!-- tabs:start -->

#### ** English **

**Jetty** 
#### ** Chinese **

**Jetty*** 

<!-- tabs:end -->


```java
HttpHandler handler = ...
Servlet servlet = new JettyHttpHandlerAdapter(handler);

Server server = new Server();
ServletContextHandler contextHandler = new ServletContextHandler(server, "");
contextHandler.addServlet(new ServletHolder(servlet), "/");
contextHandler.start();

ServerConnector connector = new ServerConnector(server);
connector.setHost(host);
connector.setPort(port);
server.addConnector(connector);
server.start();
```

<!-- tabs:start -->

#### ** English **

**Servlet 3.1+ Container** 
#### ** Chinese **

***Servlet 3.1+容器***。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

To deploy as a WAR to any Servlet 3.1+ container, you can extend and include [`AbstractReactiveWebInitializer`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/web/server/adapter/AbstractReactiveWebInitializer.html) in the WAR. That class wraps an `HttpHandler` with `ServletHttpHandlerAdapter` and registers that as a `Servlet`.
#### ** Chinese **

要作为WAR部署到任何Servlet 3.1+容器中，你可以在WAR中扩展并包含[`AbstractReactiveWebInitializer`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/web/server/adapter/AbstractReactiveWebInitializer.html)。该类用`ServletHttpHandlerAdapter`包装一个`HttpHandler`，并将其注册为一个`Servlet`。

<!-- tabs:end -->


### **1.2.2.** **`WebHandler`** ** API** 

<!-- tabs:start -->

#### ** English **

The `org.springframework.web.server` package builds on the [`HttpHandler`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-httphandler) contract to provide a general-purpose web API for processing requests through a chain of multiple [`WebExceptionHandler`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/web/server/WebExceptionHandler.html), multiple [`WebFilter`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/web/server/WebFilter.html), and a single [`WebHandler`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/web/server/WebHandler.html) component. The chain can be put together with `WebHttpHandlerBuilder` by simply pointing to a Spring `ApplicationContext` where components are [auto-detected](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-web-handler-api-special-beans), and/or by registering components with the builder.
#### ** Chinese **

`org.springframework.web.server`包建立在[`HttpHandler`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-httphandler)合约的基础上，提供了一个通用的Web API，用于通过多个[`WebExceptionHandler`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/web/server/WebExceptionHandler.html)、多个[`WebFilter`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/web/server/WebFilter.html)和一个[`WebHandler`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/web/server/WebHandler.html)组件的链来处理请求。这个链可以用`WebHttpHandlerBuilder`简单地指向一个Spring `ApplicationContext`，其中组件是[自动检测的](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-web-handler-api-special-beans)，和/或通过注册组件到构建器中来组装。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

While `HttpHandler` has a simple goal to abstract the use of different HTTP servers, the `WebHandler` API aims to provide a broader set of features commonly used in web applications such as:
#### ** Chinese **

虽然`HttpHandler`有一个简单的目标，即抽象出不同的HTTP服务器的使用，但`WebHandler` API的目的是提供一个更广泛的功能集，在Web应用中常用的功能集，如：`HttpHandler`。

<!-- tabs:end -->


### **Special bean types** 

<!-- tabs:start -->

#### ** English **

The table below lists the components that `WebHttpHandlerBuilder` can auto-detect in a Spring ApplicationContext, or that can be registered directly with it:
#### ** Chinese **

下表列出了`WebHttpHandlerBuilder`可以在Spring ApplicationContext中自动检测到的组件，或者可以直接注册到它的组件。

<!-- tabs:end -->


Bean name | Bean type | Count | Description 
-|-|-|-
<any> | WebExceptionHandler | 0..N | Provide handling for exceptions from the chain of WebFilter instances and the target WebHandler. For more details, see Exceptions. 
<any> | WebFilter | 0..N | Apply interception style logic to before and after the rest of the filter chain and the target WebHandler. For more details, see Filters. 
webHandler | WebHandler | 1 | The handler for the request. 
webSessionManager | WebSessionManager | 0..1 | The manager for WebSession instances exposed through a method on ServerWebExchange. DefaultWebSessionManager by default. 
serverCodecConfigurer | ServerCodecConfigurer | 0..1 | For access to HttpMessageReader instances for parsing form data and multipart data that is then exposed through methods on ServerWebExchange. ServerCodecConfigurer.create() by default. 
localeContextResolver | LocaleContextResolver | 0..1 | The resolver for LocaleContext exposed through a method on ServerWebExchange. AcceptHeaderLocaleContextResolver by default. 
forwardedHeaderTransformer | ForwardedHeaderTransformer | 0..1 | For processing forwarded type headers, either by extracting and removing them or by removing them only. Not used by default. 


### **Form Data** 

<!-- tabs:start -->

#### ** English **

`ServerWebExchange` exposes the following method for accessing form data:
#### ** Chinese **

`ServerWebExchange`暴露了以下方法来访问表单数据。

<!-- tabs:end -->


```java
Mono<MultiValueMap<String, String>> getFormData();
```

<!-- tabs:start -->

#### ** English **

The `DefaultServerWebExchange` uses the configured `HttpMessageReader` to parse form data (`application/x-www-form-urlencoded`) into a `MultiValueMap`. By default, `FormHttpMessageReader` is configured for use by the `ServerCodecConfigurer` bean (see the [Web Handler API](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-web-handler-api)).
#### ** Chinese **

`DefaultServerWebExchange`使用配置的`HttpMessageReader`将表单数据（`application/x-www-form-urlencoded`）解析成`MultiValueMap`。默认情况下，`FormHttpMessageReader`被配置为由`ServerCodecConfigurer` bean使用（参见[Web Handler API](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-web-handler-api)）。

<!-- tabs:end -->


### **Multipart Data** 

<!-- tabs:start -->

#### ** English **

[Web MVC](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-multipart)
#### ** Chinese **

[Web MVC](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-multipart)

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

`ServerWebExchange` exposes the following method for accessing multipart data:
#### ** Chinese **

`ServerWebExchange`暴露了以下方法，用于访问多部分数据。

<!-- tabs:end -->


```java
Mono<MultiValueMap<String, Part>> getMultipartData();
```

<!-- tabs:start -->

#### ** English **

The `DefaultServerWebExchange` uses the configured `HttpMessageReader<MultiValueMap<String, Part>>` to parse `multipart/form-data` content into a `MultiValueMap`. At present, [Synchronoss NIO Multipart](https://github.com/synchronoss/nio-multipart) is the only third-party library supported and the only library we know for non-blocking parsing of multipart requests. It is enabled through the `ServerCodecConfigurer` bean (see the [Web Handler API](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-web-handler-api)).
#### ** Chinese **

`DefaultServerWebExchange`使用配置好的`HttpMessageReader<MultiValueMap<String, Part>`来解析`multipart/form-data`内容，将其解析成`MultiValueMap`。目前，[Synchronoss NIO Multipart](https://github.com/synchronoss/nio-multipart)是唯一支持的第三方库，也是我们所知道的唯一一个对多部分请求进行无阻塞解析的库。它是通过`ServerCodecConfigurer` bean启用的（参见[Web Handler API](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-web-handler-api)）。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

To parse multipart data in streaming fashion, you can use the `Flux<Part>` returned from an `HttpMessageReader<Part>` instead. For example, in an annotated controller, use of `@RequestPart` implies `Map`-like access to individual parts by name and, hence, requires parsing multipart data in full. By contrast, you can use `@RequestBody` to decode the content to `Flux<Part>` without collecting to a `MultiValueMap`.
#### ** Chinese **

要以流媒体的方式解析多部分数据，可以使用从 `HttpMessageReader<Part>`返回的 `Flux<Part>`来代替。例如，在注释控制器中，使用 `@RequestPart`意味着通过名称访问单个部件的`Map`，因此，需要完整地解析多部件数据。相反，你可以使用 `@RequestBody`将内容解码为 `Flux<Part>`，而不需要收集到 `MultiValueMap`。

<!-- tabs:end -->


### **Forwarded Headers** 

<!-- tabs:start -->

#### ** English **

[Web MVC](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#filters-forwarded-headers)
#### ** Chinese **

[Web MVC](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#filters-forwarded-headers)

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

As a request goes through proxies (such as load balancers), the host, port, and scheme may change. That makes it a challenge, from a client perspective, to create links that point to the correct host, port, and scheme.
#### ** Chinese **

当请求通过代理（如负载均衡器）时，主机、端口和方案可能会发生变化。这使得从客户端的角度来看，创建指向正确的主机、端口和方案的链接是一个挑战。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

[RFC 7239](https://tools.ietf.org/html/rfc7239) defines the `Forwarded` HTTP header that proxies can use to provide information about the original request. There are other non-standard headers, too, including `X-Forwarded-Host`, `X-Forwarded-Port`, `X-Forwarded-Proto`, `X-Forwarded-Ssl`, and `X-Forwarded-Prefix`.
#### ** Chinese **

[RFC 7239](https://tools.ietf.org/html/rfc7239)定义了`Forwarded`HTTP头，代理机构可以用它来提供关于原始请求的信息。还有其他非标准头，包括`X-Forwarded-Host`、`X-Forwarded-Port`、`X-Forwarded-Proto`、`X-Forwarded-Ssl`和`X-Forwarded-Prefix`。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

`ForwardedHeaderTransformer` is a component that modifies the host, port, and scheme of the request, based on forwarded headers, and then removes those headers. If you declare it as a bean with the name `forwardedHeaderTransformer`, it will be [detected](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-web-handler-api-special-beans) and used.
#### ** Chinese **

`ForwardedHeaderTransformer`是一个组件，它根据转发的头文件，修改请求的主机、端口和方案，然后删除这些头文件。如果你把它声明为一个名为 `forwardedHeaderTransformer`的bean，它将被[检测到](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-web-handler-api-special-beans)并使用。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

There are security considerations for forwarded headers, since an application cannot know if the headers were added by a proxy, as intended, or by a malicious client. This is why a proxy at the boundary of trust should be configured to remove untrusted forwarded traffic coming from the outside. You can also configure the `ForwardedHeaderTransformer` with `removeOnly=true`, in which case it removes but does not use the headers.
#### ** Chinese **

对于转发的报头有安全方面的考虑，因为应用程序无法知道这些报头是由代理添加的，还是由恶意客户端添加的。这就是为什么应该配置信任边界的代理来删除来自外部的不信任转发流量的原因。您也可以将`ForwardedHeaderTransformer`配置为`removeOnly=true`，在这种情况下，它将删除但不使用报头。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

In 5.1 `ForwardedHeaderFilter` was deprecated and superceded by `ForwardedHeaderTransformer` so forwarded headers can be processed earlier, before the exchange is created. If the filter is configured anyway, it is taken out of the list of filters, and `ForwardedHeaderTransformer` is used instead.
#### ** Chinese **

在 5.1 中，`ForwardedHeaderFilter`被废止，并被 `ForwardedHeaderTransformer`所取代，因此在创建交换之前，可以更早地处理转发的头文件。如果无论如何配置了过滤器，它将被从过滤器列表中移除，而 `ForwardedHeaderTransformer` 将被使用。

<!-- tabs:end -->


### **1.2.3. Filters** 

<!-- tabs:start -->

#### ** English **

[Web MVC](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#filters)
#### ** Chinese **

[Web MVC](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#filters)

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

In the [`WebHandler`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-web-handler-api)[ API](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-web-handler-api), you can use a `WebFilter` to apply interception-style logic before and after the rest of the processing chain of filters and the target `WebHandler`. When using the [WebFlux Config](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-config), registering a `WebFilter` is as simple as declaring it as a Spring bean and (optionally) expressing precedence by using `@Order` on the bean declaration or by implementing `Ordered`.
#### ** Chinese **

在[`WebHandler`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-web-handler-api)[API](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-web-handler-api)中，您可以使用`WebFilter`在过滤器处理链的其他处理链和目标`WebHandler`之前和之后应用拦截式逻辑。在使用 [WebFlux Config](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-config)时，注册一个 `WebFilter`就像将其声明为一个Spring Bean一样简单，并通过在Bean声明中使用`@Order`或实现`Ordered`来表达优先级一样（可选）。

<!-- tabs:end -->


### **CORS** 

<!-- tabs:start -->

#### ** English **

[Web MVC](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#filters-cors)
#### ** Chinese **

[Web MVC](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#filters-cors)

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Spring WebFlux provides fine-grained support for CORS configuration through annotations on controllers. However, when you use it with Spring Security, we advise relying on the built-in `CorsFilter`, which must be ordered ahead of Spring Security’s chain of filters.
#### ** Chinese **

Spring WebFlux 通过控制器上的注释为 CORS 配置提供了精细化的支持。然而，当您将其与Spring Security一起使用时，我们建议您依赖内置的`CorsFilter`，它必须在Spring Security的过滤器链之前订购。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

See the section on [CORS](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-cors) and the [webflux-cors.html](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/webflux-cors.html#webflux-cors-webfilter) for more details.
#### ** Chinese **

详情请参见[CORS](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-cors)和[webflux-cors.html](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/webflux-cors.html#webflux-cors-webfilter)。

<!-- tabs:end -->


### **1.2.4. Exceptions** 

<!-- tabs:start -->

#### ** English **

[Web MVC](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-customer-servlet-container-error-page)
#### ** Chinese **

[Web MVC](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-customer-servlet-container-error-page)

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

In the [`WebHandler`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-web-handler-api)[ API](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-web-handler-api), you can use a `WebExceptionHandler` to handle exceptions from the chain of `WebFilter` instances and the target `WebHandler`. When using the [WebFlux Config](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-config), registering a `WebExceptionHandler` is as simple as declaring it as a Spring bean and (optionally) expressing precedence by using `@Order` on the bean declaration or by implementing `Ordered`.
#### ** Chinese **

在[`WebHandler`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-web-handler-api)[API](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-web-handler-api)中，你可以使用`WebExceptionHandler`来处理来自`WebFilter`实例链和目标`WebHandler`的异常。当使用[WebFlux Config](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-config)时，注册一个`WebExceptionHandler`就像将其声明为一个Spring Bean一样简单，并通过在Bean声明中使用`@Order`或实现`Ordered`来表达优先级一样。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following table describes the available `WebExceptionHandler` implementations:
#### ** Chinese **

下表描述了可用的`WebExceptionHandler`实现。

<!-- tabs:end -->


Exception Handler | Description 
-|-
ResponseStatusExceptionHandler | Provides handling for exceptions of type ResponseStatusException by setting the response to the HTTP status code of the exception. 
WebFluxResponseStatusExceptionHandler | Extension of ResponseStatusExceptionHandler that can also determine the HTTP status code of a @ResponseStatus annotation on any exception.This handler is declared in the WebFlux Config. 


### **1.2.5. Codecs** 

<!-- tabs:start -->

#### ** English **

[Web MVC](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#rest-message-conversion)
#### ** Chinese **

[Web MVC](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#rest-message-conversion)

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The `spring-web` and `spring-core` modules provide support for serializing and deserializing byte content to and from higher level objects through non-blocking I/O with Reactive Streams back pressure. The following describes this support:
#### ** Chinese **

`spring-web`和`spring-core`模块提供了对通过无阻塞I/O与Reactive Streams回压的非阻塞I/O与更高层次的对象进行串联和解串联的支持。下面介绍这种支持。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

- For the client side, there is a basic `ClientHttpConnector` contract to perform HTTP requests with non-blocking I/O and Reactive Streams back pressure, along with adapters for [Reactor Netty](https://github.com/reactor/reactor-netty) and for the reactive [Jetty HttpClient](https://github.com/jetty-project/jetty-reactive-httpclient). The higher level [WebClient](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-client) used in applications builds on this basic contract.

- For client and server, [codecs](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-codecs) for serialization and deserialization of HTTP request and response content.

- User session with attributes.

- Request attributes.

- Resolved `Locale` or `Principal` for the request.

- Access to parsed and cached form data.

- Abstractions for multipart data.

- and more..

- [`Encoder`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/core/codec/Encoder.html) and [`Decoder`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/core/codec/Decoder.html) are low level contracts to encode and decode content independent of HTTP.

- [`HttpMessageReader`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/http/codec/HttpMessageReader.html) and [`HttpMessageWriter`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/http/codec/HttpMessageWriter.html) are contracts to encode and decode HTTP message content.

- An `Encoder` can be wrapped with `EncoderHttpMessageWriter` to adapt it for use in a web application, while a `Decoder` can be wrapped with `DecoderHttpMessageReader`.

- [`DataBuffer`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/core/io/buffer/DataBuffer.html) abstracts different byte buffer representations (e.g. Netty `ByteBuf`, `java.nio.ByteBuffer`, etc.) and is what all codecs work on. See [Data Buffers and Codecs](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#databuffers) in the "Spring Core" section for more on this topic.

#### ** Chinese **

- 对于客户端，有一个基本的`ClientHttpConnector`合约，用于执行非阻塞的I/O和Reactive Streams回压的HTTP请求，同时还有[Reactor Netty](https://github.com/reactor/reactor-netty)和用于被动的[Jetty HttpClient](https://github.com/jetty-project/jetty-reactive-httpclient)的适配器。应用中使用的更高级别的[WebClient](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-client)是建立在这个基本契约的基础上。

- 对于客户端和服务器来说，[codecs](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-codecs)用于HTTP请求和响应内容的序列化和反序列化。

- 带属性的用户会话。

- 请求属性。

- 为请求解决`Locale`或`Principal`。

- 访问已解析和缓存的表单数据。

- 多部分数据的抽象。

- 以及更多.....

- [`编码器`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/core/codec/Encoder.html)和[`解码器`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/core/codec/Decoder.html)是独立于HTTP的内容编码和解码的低级合约。

- [`HttpMessageReader`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/http/codec/HttpMessageReader.html)和[`HttpMessageWriter`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/http/codec/HttpMessageWriter.html)是编码和解码HTTP消息内容的契约。

- `Encoder`可以用`EncoderHttpMessageWriter`来封装，以适应在web应用程序中使用，而`Decoder`可以用`DecoderHttpMessageReader`来封装。

- [`DataBuffer`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/core/io/buffer/DataBuffer.html)抽象出不同的字节缓冲区表示（例如Netty `ByteBuf`、`java.nio.ByteBuffer`等），是所有编解码器的工作对象。有关这个主题的更多信息，请参见 "Spring Core "部分中的[数据缓冲区和编解码器](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#databuffers)。


<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

The `spring-core` module provides `byte[]`, `ByteBuffer`, `DataBuffer`, `Resource`, and `String` encoder and decoder implementations. The `spring-web` module provides Jackson JSON, Jackson Smile, JAXB2, Protocol Buffers and other encoders and decoders along with web-only HTTP message reader and writer implementations for form data, multipart content, server-sent events, and others.
#### ** Chinese **

`spring-core`模块提供了`byte[]]`、`ByteBuffer`、`DataBuffer`、`Resource`和`String`编码器和解码器实现。`spring-web`模块提供了Jackson JSON、Jackson Smile、JAXB2、Protocol Buffers和其他编码器和解码器，以及用于表单数据、多部分内容、服务器发送的事件和其他的web专用HTTP消息读写器实现。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

`ClientCodecConfigurer` and `ServerCodecConfigurer` are typically used to configure and customize the codecs to use in an application. See the section on configuring [HTTP message codecs](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-config-message-codecs).
#### ** Chinese **

`ClientCodecConfigurer`和`ServerCodecConfigurer`通常用于配置和定制应用程序中使用的编解码器。参见配置[HTTP消息编解码器](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-config-message-codecs)。

<!-- tabs:end -->


### **Jackson JSON** 

<!-- tabs:start -->

#### ** English **

JSON and binary JSON ([Smile](https://github.com/FasterXML/smile-format-specification)) are both supported when the Jackson library is present.
#### ** Chinese **

JSON和二进制的JSON([Smile](https://github.com/FasterXML/smile-format-specification))都支持，当JSON库存在的时候。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The `Jackson2Decoder` works as follows:
#### ** Chinese **

`Jackson2Decoder`工作原理如下。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

- Jackson’s asynchronous, non-blocking parser is used to aggregate a stream of byte chunks into `TokenBuffer`'s each representing a JSON object.

- Each `TokenBuffer` is passed to Jackson’s `ObjectMapper` to create a higher level object.

- When decoding to a single-value publisher (e.g. `Mono`), there is one `TokenBuffer`.

- When decoding to a multi-value publisher (e.g. `Flux`), each `TokenBuffer` is passed to the `ObjectMapper` as soon as enough bytes are received for a fully formed object. The input content can be a JSON array, or [line-delimited JSON](https://en.wikipedia.org/wiki/JSON_streaming) if the content-type is `application/stream+json`.

#### ** Chinese **

- Jackson的异步、非阻塞解析器用于将字节流聚合成`TokenBuffer`，每个字节流代表一个JSON对象。

- 每个`TokenBuffer`都被传递给Jackson的`ObjectMapper`以创建一个更高级别的对象。

- 当解码到单值发布器（例如`Mono`）时，有一个`TokenBuffer`。

- 当向多值发布器解码时（例如`Flux`），每个`TokenBuffer`在接收到足够的字节后，就会被传递给`ObjectMapper`。输入内容可以是一个JSON数组，如果内容类型是`application/stream+json`，那么输入内容可以是一个JSON数组，也可以是[行限制的JSON](https://en.wikipedia.org/wiki/JSON_streaming)。


<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

The `Jackson2Encoder` works as follows:
#### ** Chinese **

`Jackson2Encoder`工作原理如下。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

- For a single value publisher (e.g. `Mono`), simply serialize it through the `ObjectMapper`.

- For a multi-value publisher with `application/json`, by default collect the values with `Flux#collectToList()` and then serialize the resulting collection.

- For a multi-value publisher with a streaming media type such as `application/stream+json` or `application/stream+x-jackson-smile`, encode, write, and flush each value individually using a [line-delimited JSON](https://en.wikipedia.org/wiki/JSON_streaming) format.

- For SSE the `Jackson2Encoder` is invoked per event and the output is flushed to ensure delivery without delay.

#### ** Chinese **

- 对于单值发布器（例如`Mono`），只需通过`ObjectMapper`将其序列化即可。

- 对于带有`application/json`的多值发布器，默认情况下，使用`Flux#collectToList()`收集值，然后将生成的集合序列化。

- 对于具有流媒体类型的多值发布器，如`application/stream+json`或`application/stream+x-json-smile`，使用[行限JSON](https://en.wikipedia.org/wiki/JSON_streaming)格式对每个值进行编码、写入和刷新。

- 对于SSE来说，`Jackson2Encoder`会在每个事件中被调用，并且输出会被刷新，以确保无延迟地交付。


<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

By default both `Jackson2Encoder` and `Jackson2Decoder` do not support elements of type `String`. Instead the default assumption is that a string or a sequence of strings represent serialized JSON content, to be rendered by the `CharSequenceEncoder`. If what you need is to render a JSON array from `Flux<String>`, use `Flux#collectToList()` and encode a `Mono<List<String>>`.
#### ** Chinese **

默认情况下，`Jackson2Encoder`和`Jackson2Decoder`都不支持类型为`String`的元素。相反，默认的假设是一个字符串或字符串序列代表序列化的JSON内容，由`CharSequenceEncoder`渲染。如果你需要的是从`Flux<String>`中渲染一个JSON数组，请使用`Flux#collectToList()`，并编码一个`Mono<List<String>`。

<!-- tabs:end -->


### **Form Data** 

<!-- tabs:start -->

#### ** English **

`FormHttpMessageReader` and `FormHttpMessageWriter` support decoding and encoding `application/x-www-form-urlencoded` content.
#### ** Chinese **

`FormHttpMessageReader`和`FormHttpMessageWriter`支持解码和编码`application/x-www-form-urlencoded`内容。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

On the server side where form content often needs to be accessed from multiple places, `ServerWebExchange` provides a dedicated `getFormData()` method that parses the content through `FormHttpMessageReader` and then caches the result for repeated access. See [Form Data](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-form-data) in the [`WebHandler`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-web-handler-api)[ API](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-web-handler-api) section.
#### ** Chinese **

在服务器端，如果表单内容经常需要从多个地方访问，`ServerWebExchange`提供了一个专门的`getFormData()`方法，该方法通过`FormHttpMessageReader`解析内容，然后缓存结果以备重复访问。参见[`WebHandler`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-web-handler-api)[API](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-web-handler-api)部分中的[Form Data](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-form-data)。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Once `getFormData()` is used, the original raw content can no longer be read from the request body. For this reason, applications are expected to go through `ServerWebExchange` consistently for access to the cached form data versus reading from the raw request body.
#### ** Chinese **

一旦使用了 `getFormData()`，就不能再从请求体中读取原始内容。因此，应用程序需要通过`ServerWebExchange`来访问缓存的表单数据，而不是从原始请求体中读取。

<!-- tabs:end -->


### **Multipart** 

<!-- tabs:start -->

#### ** English **

`MultipartHttpMessageReader` and `MultipartHttpMessageWriter` support decoding and encoding "multipart/form-data" content. In turn `MultipartHttpMessageReader` delegates to another `HttpMessageReader` for the actual parsing to a `Flux<Part>` and then simply collects the parts into a `MultiValueMap`. At present [Synchronoss NIO Multipart](https://github.com/synchronoss/nio-multipart) is used for the actual parsing.
#### ** Chinese **

`MultipartHttpMessageReader`和`MultipartHttpMessageWriter`支持解码和编码 "多部分/表单数据 "内容。反过来，`MultipartHttpMessageReader`委托给另一个`HttpMessageReader`进行实际的解析，然后简单地将这些部分收集到一个`MultiValueMap`中。目前，[Synchronoss NIO Multipart](https://github.com/synchronoss/nio-multipart)用于实际解析。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

On the server side where multipart form content may need to be accessed from multiple places, `ServerWebExchange` provides a dedicated `getMultipartData()` method that parses the content through `MultipartHttpMessageReader` and then caches the result for repeated access. See [Multipart Data](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-multipart) in the [`WebHandler`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-web-handler-api)[ API](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-web-handler-api) section.
#### ** Chinese **

在服务器端，如果多部分表单内容可能需要从多个地方访问，`ServerWebExchange`提供了一个专门的`getMultipartData()`方法，该方法通过`MultipartHttpMessageReader`解析内容，然后缓存结果，以便重复访问。参见[`WebHandler`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-web-handler-api)[API](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-web-handler-api)部分中的[Multipart Data](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-multipart)。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Once `getMultipartData()` is used, the original raw content can no longer be read from the request body. For this reason applications have to consistently use `getMultipartData()` for repeated, map-like access to parts, or otherwise rely on the `SynchronossPartHttpMessageReader` for a one-time access to `Flux<Part>`.
#### ** Chinese **

一旦`getMultipartData()`被使用，就不能再从请求体中读取原始内容。为此，应用程序必须始终如一地使用 `getMultipartData()`来重复使用类似于map的方式访问部件，否则就必须依赖`SynchronossPartHttpMessageReader`来一次性访问`Flux<Part>`。

<!-- tabs:end -->


### **Limits** 

<!-- tabs:start -->

#### ** English **

`Decoder` and `HttpMessageReader` implementations that buffer some or all of the input stream can be configured with a limit on the maximum number of bytes to buffer in memory. In some cases buffering occurs because input is aggregated and represented as a single object — for example, a controller method with `@RequestBody byte[]`, `x-www-form-urlencoded` data, and so on. Buffering can also occur with streaming, when splitting the input stream — for example, delimited text, a stream of JSON objects, and so on. For those streaming cases, the limit applies to the number of bytes associated with one object in the stream.
#### ** Chinese **

`解码器`和`HttpMessageReader`的实现，可以对缓冲部分或全部输入流的部分或全部输入流进行配置，并对内存中缓冲的最大字节数进行限制。在某些情况下，缓冲的发生是因为输入被聚合并表示为一个单一的对象--例如，一个控制器方法与`@RequestBody byte[]`、`x-www-form-urlencoded`数据等。在分割输入流时也会出现缓冲，例如，分割输入流--例如，分隔的文本、JSON对象流等等。对于这些流的情况，限制适用于流中与一个对象关联的字节数。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

To configure buffer sizes, you can check if a given `Decoder` or `HttpMessageReader` exposes a `maxInMemorySize` property and if so the Javadoc will have details about default values. On the server side, `ServerCodecConfigurer` provides a single place from where to set all codecs, see [HTTP message codecs](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-config-message-codecs). On the client side, the limit for all codecs can be changed in [WebClient.Builder](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-client-builder-maxinmemorysize).
#### ** Chinese **

要配置缓冲区大小，你可以检查给定的`解码器`或`HttpMessageReader`是否暴露了一个`maxInMemorySize`属性，如果是的话，Javadoc会有关于默认值的详细信息。在服务器端，`ServerCodecConfigurer`提供了一个可以设置所有编解码器的地方，请参阅[HTTP消息编解码器](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-config-message-codecs)。在客户端，所有编解码器的限制可以在[WebClient.Builder](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-client-builder-maxinmemorysize)中更改。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

For [Multipart parsing](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-codecs-multipart) the `maxInMemorySize` property limits the size of non-file parts. For file parts, it determines the threshold at which the part is written to disk. For file parts written to disk, there is an additional `maxDiskUsagePerPart` property to limit the amount of disk space per part. There is also a `maxParts` property to limit the overall number of parts in a multipart request. To configure all three in WebFlux, you’ll need to supply a pre-configured instance of `MultipartHttpMessageReader` to `ServerCodecConfigurer`.
#### ** Chinese **

对于[Multipart parsing](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-codecs-multipart)，`maxInMemorySize` 属性限制了非文件部分的大小。对于文件部分，它决定了该部分写入磁盘的阈值。对于写入磁盘的文件部件，还有一个额外的`maxDiskUsagePerPart`属性，用于限制每个部件的磁盘空间量。还有一个 `maxParts` 属性，用于限制多部件请求中的总部件数。要在WebFlux中配置这三个属性，你需要向`ServerCodecConfigurer`提供一个预配置的`MultipartHttpMessageReader`实例。

<!-- tabs:end -->


### **Streaming** 

<!-- tabs:start -->

#### ** English **

[Web MVC](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-async-http-streaming)
#### ** Chinese **

[Web MVC](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-async-http-streaming)

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

When streaming to the HTTP response (for example, `text/event-stream`, `application/stream+json`), it is important to send data periodically, in order to reliably detect a disconnected client sooner rather than later. Such a send could be a comment-only, empty SSE event or any other "no-op" data that would effectively serve as a heartbeat.
#### ** Chinese **

当流向HTTP响应（例如，`text/event-stream`、`application/stream+json`）时，定期发送数据很重要，这样才能可靠地尽早而不是迟迟地检测到断开的客户端。这样的发送可以是一个仅有注释、空的SSE事件或任何其他 "无操作 "的数据，这些数据可以有效地起到心跳的作用。

<!-- tabs:end -->


### **`DataBuffer`** 

<!-- tabs:start -->

#### ** English **

`DataBuffer` is the representation for a byte buffer in WebFlux. The Spring Core part of this reference has more on that in the section on [Data Buffers and Codecs](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#databuffers). The key point to understand is that on some servers like Netty, byte buffers are pooled and reference counted, and must be released when consumed to avoid memory leaks.
#### ** Chinese **

`DataBuffer`是 WebFlux 中字节缓冲区的表示。这个参考的Spring Core部分在[数据缓冲区和编解码器](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#databuffers)部分有更多的介绍。需要理解的关键点是，在一些服务器上，如Netty，字节缓冲区是被池化和引用计数的，必须在消耗时释放，以避免内存泄漏。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

WebFlux applications generally do not need to be concerned with such issues, unless they consume or produce data buffers directly, as opposed to relying on codecs to convert to and from higher level objects, or unless they choose to create custom codecs. For such cases please review the information in [Data Buffers and Codecs](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#databuffers), especially the section on [Using DataBuffer](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#databuffers-using).
#### ** Chinese **

WebFlux应用程序通常不需要担心这些问题，除非它们直接消耗或产生数据缓冲区，而不是依赖编解码器来转换到或从更高层次的对象，或者除非它们选择创建自定义的编解码器。对于这种情况，请查看[数据缓冲区和编解码器](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#databuffers)中的信息，特别是[使用数据缓冲区](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#databuffers-using)。

<!-- tabs:end -->


### **1.2.6. Logging** 

<!-- tabs:start -->

#### ** English **

[Web MVC](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-logging)
#### ** Chinese **

[Web MVC](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-logging)

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

`DEBUG` level logging in Spring WebFlux is designed to be compact, minimal, and human-friendly. It focuses on high value bits of information that are useful over and over again vs others that are useful only when debugging a specific issue.
#### ** Chinese **

`DEBUG`级别日志在Spring WebFlux中的设计是紧凑、最小化和人性化的。它专注于高价值的信息，这些高价值的信息会被反复使用，而其他只有在调试特定问题时才会有用。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

`TRACE` level logging generally follows the same principles as `DEBUG` (and for example also should not be a firehose) but can be used for debugging any issue. In addition, some log messages may show a different level of detail at `TRACE` vs `DEBUG`.
#### ** Chinese **

`TRACE`级别的日志一般遵循与`DEBUG`相同的原则（例如，也不应该是火线），但可以用于调试任何问题。此外，有些日志消息可能会在`TRACE`与`DEBUG`中显示不同的细节。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Good logging comes from the experience of using the logs. If you spot anything that does not meet the stated goals, please let us know.
#### ** Chinese **

好的日志来自于对日志的使用体验。如果您发现有什么不符合既定目标的地方，请告知我们。

<!-- tabs:end -->


### **Log Id** 

<!-- tabs:start -->

#### ** English **

In WebFlux, a single request can be executed over multiple threads and the thread ID is not useful for correlating log messages that belong to a specific request. This is why WebFlux log messages are prefixed with a request-specific ID by default.
#### ** Chinese **

在WebFlux中，一个请求可以在多个线程中执行，而线程ID对于关联属于特定请求的日志消息是没有用的。这就是为什么 WebFlux 日志消息的前缀默认是特定于请求的 ID。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

On the server side, the log ID is stored in the `ServerWebExchange` attribute ([`LOG_ID_ATTRIBUTE`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/web/server/ServerWebExchange.html#LOG_ID_ATTRIBUTE)), while a fully formatted prefix based on that ID is available from `ServerWebExchange#getLogPrefix()`. On the `WebClient` side, the log ID is stored in the `ClientRequest` attribute ([`LOG_ID_ATTRIBUTE`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/web/reactive/function/client/ClientRequest.html#LOG_ID_ATTRIBUTE)) ,while a fully formatted prefix is available from `ClientRequest#logPrefix()`.
#### ** Chinese **

在服务器端，日志ID存储在`ServerWebExchange`属性([[`LOG_ID_ATTRIBUTE`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/web/server/ServerWebExchange.html#LOG_ID_ATTRIBUTE))中，而基于该ID的完全格式化的前缀可从`ServerWebExchange#getLogPrefix()`中获得。在`WebClient`端，日志ID存储在`ClientRequest`属性中([[`LOG_ID_ATTRIBUTE`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/web/reactive/function/client/ClientRequest.html#LOG_ID_ATTRIBUTE)) `ClientRequest#logPrefix()`，而完全格式化的前缀可以从`ClientRequest#logPrefix()`中获得。

<!-- tabs:end -->


### **Sensitive Data** 

<!-- tabs:start -->

#### ** English **

[Web MVC](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-logging-sensitive-data)
#### ** Chinese **

[Web MVC](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-logging-sensitive-data)

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

`DEBUG` and `TRACE` logging can log sensitive information. This is why form parameters and headers are masked by default and you must explicitly enable their logging in full.
#### ** Chinese **

`DEBUG`和`TRACE`记录可以记录敏感信息。这也是为什么表单参数和头文件默认被屏蔽的原因，您必须明确地启用它们的全部记录。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following example shows how to do so for server-side requests:
#### ** Chinese **

下面的例子显示了如何在服务器端请求中这样做。

<!-- tabs:end -->


```java
@Configuration
@EnableWebFlux
class MyConfig implements WebFluxConfigurer {

    @Override
    public void configureHttpMessageCodecs(ServerCodecConfigurer configurer) {
        configurer.defaultCodecs().enableLoggingRequestDetails(true);
    }
}
```

<!-- tabs:start -->

#### ** English **

The following example shows how to do so for client-side requests:
#### ** Chinese **

下面的例子显示了如何在客户端请求中这样做。

<!-- tabs:end -->


```java
Consumer<ClientCodecConfigurer> consumer = configurer ->
        configurer.defaultCodecs().enableLoggingRequestDetails(true);

WebClient webClient = WebClient.builder()
        .exchangeStrategies(strategies -> strategies.codecs(consumer))
        .build();
```

### **Custom codecs** 

<!-- tabs:start -->

#### ** English **

Applications can register custom codecs for supporting additional media types, or specific behaviors that are not supported by the default codecs.
#### ** Chinese **

应用程序可以注册自定义编解码器，以支持额外的媒体类型或默认编解码器不支持的特定行为。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Some configuration options expressed by developers are enforced on default codecs. Custom codecs might want to get a chance to align with those preferences, like [enforcing buffering limits](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-codecs-limits) or [logging sensitive data](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-logging-sensitive-data).
#### ** Chinese **

开发者表达的一些配置选项是对默认编解码器强制执行的。自定义编解码器可能希望有机会与这些偏好保持一致，比如[强制缓冲限制](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-codecs-limits)或[记录敏感数据](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-logging-sensitive-data)。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following example shows how to do so for client-side requests:
#### ** Chinese **

下面的例子显示了如何在客户端请求中这样做。

<!-- tabs:end -->


```java
WebClient webClient = WebClient.builder()
        .codecs(configurer -> {
                CustomDecoder decoder = new CustomDecoder();
                configurer.customCodecs().registerWithDefaultConfig(decoder);
        })
        .build();
```


[下一章](Spring-Framework-5.2.6.RELEASE/Web%20on%20Reactive%20Stack/1.3. DispatcherHandler.md)


[回目录](Spring-Framework-5.2.6.RELEASE/summary.md)

[回首页](/README)
