# 1. Remoting and Web Services

<!-- tabs:start -->

#### ** English **

Spring provides support for remoting with various technologies. The remoting support eases the development of remote-enabled services, implemented via Java interfaces and objects as input and output. Currently, Spring supports the following remoting technologies:
#### ** Chinese **

Spring提供了对各种技术的远程支持。远程支持简化了远程服务的开发，通过Java接口和对象作为输入和输出来实现远程服务。目前，Spring支持以下几种远程技术。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

- [Remote Method Invocation (RMI)](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#remoting-rmi): Through the use of `RmiProxyFactoryBean` and `RmiServiceExporter`, Spring supports both traditional RMI (with `java.rmi.Remote` interfaces and `java.rmi.RemoteException`) and transparent remoting through RMI invokers (with any Java interface).

- [Spring HTTP Invoker](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#remoting-httpinvoker): Spring provides a special remoting strategy that allows for Java serialization though HTTP, supporting any Java interface (as the RMI invoker does). The corresponding support classes are `HttpInvokerProxyFactoryBean` and `HttpInvokerServiceExporter`.

- [Hessian](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#remoting-caucho-protocols-hessian): By using Spring’s `HessianProxyFactoryBean` and the `HessianServiceExporter`, you can transparently expose your services through the lightweight binary HTTP-based protocol provided by Caucho.

- [Java Web Services](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#remoting-web-services): Spring provides remoting support for web services through JAX-WS.

- [JMS](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#remoting-jms): Remoting via JMS as the underlying protocol is supported through the `JmsInvokerServiceExporter` and `JmsInvokerProxyFactoryBean` classes in the `spring-jms` module.

- [AMQP](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#remoting-amqp): Remoting via AMQP as the underlying protocol is supported by the separate Spring AMQP project.

#### ** Chinese **

- Remote Method Invocation (RMI)](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#remoting-rmi)。通过使用`RmiProxyFactoryBean`和`RmiServiceExporter`，Spring既支持传统的RMI（使用`java.rmi.Remote`接口和`java.rmi.RemoteException`），也支持通过RMI调用器（使用任何Java接口）进行透明的远程调用。

- Spring HTTP Invoker](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#remoting-httpinvoker)。Spring提供了一种特殊的远程策略，允许通过HTTP实现Java序列化，支持任何Java接口（就像RMI invoker一样）。对应的支持类有`HttpInvokerProxyFactoryBean`和`HttpInvokerServiceExporter`。

- Hessian](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#remoting-caucho-protocols-hessian)。通过使用Spring的`HessianProxyFactoryBean`和`HessianServiceExporter`，你可以通过Caucho提供的轻量级二进制HTTP协议透明地公开你的服务。

- Java Web服务](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#remoting-web-services)。Spring通过JAX-WS为Web服务提供了远程支持。

- [JMS](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#remoting-jms)。通过`spring-jms`模块中的`JmsInvokerServiceExporter`和`JmsInvokerProxyFactoryBean`类支持通过JMS作为底层协议进行远程支持。

- AMQP](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#remoting-amqp)。通过AMQP作为底层协议，通过AMQP进行Remoting，由单独的Spring AMQP项目支持。


<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

While discussing the remoting capabilities of Spring, we use the following domain model and corresponding services:
#### ** Chinese **

在讨论Spring的远程功能时，我们使用以下领域模型和相应的服务。

<!-- tabs:end -->


```java
public class Account implements Serializable{

    private String name;

    public String getName(){
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
```

```java
public interface AccountService {

    public void insertAccount(Account account);

    public List<Account> getAccounts(String name);
}
```

```java
// the implementation doing nothing at the moment
public class AccountServiceImpl implements AccountService {

    public void insertAccount(Account acc) {
        // do something...
    }

    public List<Account> getAccounts(String name) {
        // do something...
    }
}
```

<!-- tabs:start -->

#### ** English **

This section starts by exposing the service to a remote client by using RMI and talk a bit about the drawbacks of using RMI. It then continues with an example that uses Hessian as the protocol.
#### ** Chinese **

本节首先通过使用RMI将服务暴露给远程客户端，并谈了一下使用RMI的缺点。然后继续以一个使用Hessian作为协议的例子来说明。

<!-- tabs:end -->


### **1.1. RMI** 

<!-- tabs:start -->

#### ** English **

By using Spring’s support for RMI, you can transparently expose your services through the RMI infrastructure. After having this set up, you basically have a configuration similar to remote EJBs, except for the fact that there is no standard support for security context propagation or remote transaction propagation. Spring does provide hooks for such additional invocation context when you use the RMI invoker, so you can, for example, plug in security frameworks or custom security credentials.
#### ** Chinese **

通过使用Spring对RMI的支持，你可以通过RMI基础架构透明地公开你的服务。有了这个设置后，你基本上有了一个类似于远程EJB的配置，只是没有标准的安全上下文传播或远程事务传播的支持。当你使用RMI invoker时，Spring确实为这种额外的调用上下文提供了钩子，所以你可以，例如，插入安全框架或自定义安全凭证。

<!-- tabs:end -->


### **1.1.1. Exporting the Service by Using** **`RmiServiceExporter`** 

<!-- tabs:start -->

#### ** English **

Using the `RmiServiceExporter`, we can expose the interface of our AccountService object as RMI object. The interface can be accessed by using `RmiProxyFactoryBean`, or via plain RMI in case of a traditional RMI service. The `RmiServiceExporter` explicitly supports the exposing of any non-RMI services via RMI invokers.
#### ** Chinese **

使用`RmiServiceExporter`，我们可以将AccountService对象的接口作为RMI对象公开。这个接口可以通过使用`RmiProxyFactoryBean`来访问，如果是传统的RMI服务，也可以通过纯RMI来访问。`RmiServiceExporter`明确地支持通过RMI调用器暴露任何非RMI服务。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

We first have to set up our service in the Spring container. The following example shows how to do so:
#### ** Chinese **

我们首先要在Spring容器中设置我们的服务。下面的例子显示了如何做到这一点。

<!-- tabs:end -->


```xml
<bean id="accountService" class="example.AccountServiceImpl">
    <!-- any additional properties, maybe a DAO? -->
</bean>
```

<!-- tabs:start -->

#### ** English **

Next, we have to expose our service by using `RmiServiceExporter`. The following example shows how to do so:
#### ** Chinese **

接下来，我们必须使用`RmiServiceExporter`来公开我们的服务。下面的例子显示了如何做到这一点。

<!-- tabs:end -->


```xml
<bean class="org.springframework.remoting.rmi.RmiServiceExporter">
    <!-- does not necessarily have to be the same name as the bean to be exported -->
    <property name="serviceName" value="AccountService"/>
    <property name="service" ref="accountService"/>
    <property name="serviceInterface" value="example.AccountService"/>
    <!-- defaults to 1099 -->
    <property name="registryPort" value="1199"/>
</bean>
```

<!-- tabs:start -->

#### ** English **

In the preceding example, we override the port for the RMI registry. Often, your application server also maintains an RMI registry, and it is wise to not interfere with that one. Furthermore, the service name is used to bind the service. So, in the preceding example, the service is bound at `'rmi://HOST:1199/AccountService'`. We use this URL later on to link in the service at the client side.
#### ** Chinese **

在前面的例子中，我们覆盖了 RMI 注册表的端口。通常情况下，你的应用服务器也会维护一个RMI注册表，不干扰这个注册表是明智的做法。此外，服务名称是用来绑定服务的。因此，在前面的例子中，服务被绑定在`'rmi://HOST:1199/AccountService'`。我们以后在客户端使用这个URL来链接服务。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The `servicePort` property has been omitted (it defaults to 0). This means that an anonymous port is used to communicate with the service.
#### ** Chinese **

`servicePort` 属性被省略了（默认为0）。这意味着一个匿名端口被用来与服务通信。

<!-- tabs:end -->


### **1.1.2. Linking in the Service at the Client** 

<!-- tabs:start -->

#### ** English **

Our client is a simple object that uses the `AccountService` to manage accounts, as the following example shows:
#### ** Chinese **

我们的客户端是一个简单的对象，它使用`AccountService`来管理账户，如下例所示。

<!-- tabs:end -->


```java
public class SimpleObject {

    private AccountService accountService;

    public void setAccountService(AccountService accountService) {
        this.accountService = accountService;
    }

    // additional methods using the accountService
}
```

<!-- tabs:start -->

#### ** English **

To link in the service on the client, we create a separate Spring container, to contain the following simple object and the service linking configuration bits:
#### ** Chinese **

为了在客户端上链接服务，我们创建一个单独的Spring容器，包含以下简单对象和服务链接配置位。

<!-- tabs:end -->


```xml
<bean class="example.SimpleObject">
    <property name="accountService" ref="accountService"/>
</bean>

<bean id="accountService" class="org.springframework.remoting.rmi.RmiProxyFactoryBean">
    <property name="serviceUrl" value="rmi://HOST:1199/AccountService"/>
    <property name="serviceInterface" value="example.AccountService"/>
</bean>
```

<!-- tabs:start -->

#### ** English **

That is all we need to do to support the remote account service on the client. Spring transparently creates an invoker and remotely enables the account service through the `RmiServiceExporter`. At the client, we link it in by using the `RmiProxyFactoryBean`.
#### ** Chinese **

这就是我们在客户端上支持远程账户服务所需要做的一切。Spring通过`RmiServiceExporter`透明地创建一个调用器，并通过`RmiServiceExporter`远程启用账户服务。在客户端，我们使用`RmiProxyFactoryBean`将其链接进来。

<!-- tabs:end -->


### **1.2. Using Hessian to Remotely Call Services through HTTP** 

<!-- tabs:start -->

#### ** English **

Hessian offers a binary HTTP-based remoting protocol. It is developed by Caucho, and you can find more information about Hessian itself at [https://www.caucho.com/](https://www.caucho.com/).
#### ** Chinese **

Hessian提供了一个基于二进制的HTTP远程协议。它是由Caucho开发的，你可以在[https://www.caucho.com/](https://www.caucho.com/)中找到更多关于Hessian本身的信息。

<!-- tabs:end -->


### **1.2.1. Hessian** 

<!-- tabs:start -->

#### ** English **

Hessian communicates through HTTP and does so by using a custom servlet. By using Spring’s `DispatcherServlet` principles (see [webmvc.html](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/webmvc.html#mvc-servlet)), we can wire up such a servlet to expose your services. First, we have to create a new servlet in our application, as shown in the following excerpt from `web.xml`:
#### ** Chinese **

Hessian通过HTTP进行通信，并通过使用一个自定义的servlet进行通信。通过使用Spring的`DispatcherServlet`原理（参见[webmvc.html](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/webmvc.html#mvc-servlet)），我们可以用这样的servlet来展示你的服务。首先，我们必须在我们的应用程序中创建一个新的servlet，如下`web.xml`中的摘录所示。

<!-- tabs:end -->


```java
<servlet>
    <servlet-name>remoting</servlet-name>
    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
    <load-on-startup>1</load-on-startup>
</servlet>

<servlet-mapping>
    <servlet-name>remoting</servlet-name>
    <url-pattern>/remoting/*</url-pattern>
</servlet-mapping>
```

<!-- tabs:start -->

#### ** English **

If you are familiar with Spring’s `DispatcherServlet` principles, you probably know that now you have to create a Spring container configuration resource named `remoting-servlet.xml` (after the name of your servlet) in the `WEB-INF` directory. The application context is used in the next section.
#### ** Chinese **

如果你熟悉Spring的`DispatcherServlet`原理，你可能知道，现在你必须在`WEB-INF`目录下创建一个名为`remoting-servlet.xml`的Spring容器配置资源（在你的servlet名称之后）。应用程序上下文将在下一节中使用。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Alternatively, consider the use of Spring’s simpler `HttpRequestHandlerServlet`. Doing so lets you embed the remote exporter definitions in your root application context (by default, in `WEB-INF/applicationContext.xml`), with individual servlet definitions pointing to specific exporter beans. In this case, each servlet name needs to match the bean name of its target exporter.
#### ** Chinese **

另外，可以考虑使用Spring更简单的`HttpRequestHandlerServlet`。这样做可以让你将远程exporter定义嵌入到根应用程序上下文中（默认情况下，在`WEB-INF/applicationContext.xml`中），并将单个servlet定义指向特定的exporter bean。在这种情况下，每个servlet的名称需要与目标exporter的Bean名相匹配。

<!-- tabs:end -->


### **1.2.2. Exposing Your Beans by Using** **`HessianServiceExporter`** 

<!-- tabs:start -->

#### ** English **

In the newly created application context called `remoting-servlet.xml`, we create a `HessianServiceExporter` to export our services, as the following example shows:
#### ** Chinese **

在新创建的名为`remoting-servlet.xml`的应用程序上下文中，我们创建一个`HessianServiceExporter`来导出我们的服务，如下例所示。

<!-- tabs:end -->


```xml
<bean id="accountService" class="example.AccountServiceImpl">
    <!-- any additional properties, maybe a DAO? -->
</bean>

<bean name="/AccountService" class="org.springframework.remoting.caucho.HessianServiceExporter">
    <property name="service" ref="accountService"/>
    <property name="serviceInterface" value="example.AccountService"/>
</bean>
```

<!-- tabs:start -->

#### ** English **

Now we are ready to link in the service at the client. No explicit handler mapping is specified (to map request URLs onto services), so we use `BeanNameUrlHandlerMapping` used. Hence, the service is exported at the URL indicated through its bean name within the containing `DispatcherServlet` instance’s mapping (as defined earlier): [`https://HOST:8080/remoting/AccountService`](https://host:8080/remoting/AccountService).
#### ** Chinese **

现在，我们准备好在客户端链接服务了。没有指定显式处理程序映射（将请求的URL映射到服务上），所以我们使用`BeanNameUrlHandlerMapping`使用。因此，服务在包含`DispatcherServlet`实例的映射（如前面定义的那样）中，通过其Bean名指示的URL导出。 [`https://HOST:8080/remoting/AccountService`](https://host:8080/remoting/AccountService)。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Alternatively, you can create a `HessianServiceExporter` in your root application context (for example, in `WEB-INF/applicationContext.xml`), as the following example shows:
#### ** Chinese **

或者，你可以在你的根应用程序上下文中创建一个`HessianServiceExporter`（例如，在`WEB-INF/applicationContext.xml`中），如下图所示。

<!-- tabs:end -->


```xml
<bean name="accountExporter" class="org.springframework.remoting.caucho.HessianServiceExporter">
    <property name="service" ref="accountService"/>
    <property name="serviceInterface" value="example.AccountService"/>
</bean>
```

<!-- tabs:start -->

#### ** English **

In the latter case, you should define a corresponding servlet for this exporter in `web.xml`, with the same end result: The exporter gets mapped to the request path at `/remoting/AccountService`. Note that the servlet name needs to match the bean name of the target exporter. The following example shows how to do so:
#### ** Chinese **

在后一种情况下，你应该在`web.xml`中为这个exporter定义一个相应的servlet，最终结果是一样的。输出器会被映射到`/remoting/AccountService`的请求路径。注意，servlet 的名称需要与目标 exporter 的 bean 名称相匹配。下面的例子显示了如何做到这一点。

<!-- tabs:end -->


```xml
<servlet>
    <servlet-name>accountExporter</servlet-name>
    <servlet-class>org.springframework.web.context.support.HttpRequestHandlerServlet</servlet-class>
</servlet>

<servlet-mapping>
    <servlet-name>accountExporter</servlet-name>
    <url-pattern>/remoting/AccountService</url-pattern>
</servlet-mapping>
```

### **1.2.3. Linking in the Service on the Client** 

<!-- tabs:start -->

#### ** English **

By using the `HessianProxyFactoryBean`, we can link in the service at the client. The same principles apply as with the RMI example. We create a separate bean factory or application context and mention the following beans where the `SimpleObject` is by using the `AccountService` to manage accounts, as the following example shows:
#### ** Chinese **

通过使用`HessianProxyFactoryBean`，我们可以在客户端链接服务。与RMI示例中的原理相同。我们创建一个单独的Bean工厂或应用程序上下文，并提到下面的Bean，其中的 `SimpleObject` 是通过使用 `AccountService` 来管理账户，如下例所示。

<!-- tabs:end -->


```xml
<bean class="example.SimpleObject">
    <property name="accountService" ref="accountService"/>
</bean>

<bean id="accountService" class="org.springframework.remoting.caucho.HessianProxyFactoryBean">
    <property name="serviceUrl" value="https://remotehost:8080/remoting/AccountService"/>
    <property name="serviceInterface" value="example.AccountService"/>
</bean>
```

### **1.2.4. Applying HTTP Basic Authentication to a Service Exposed through Hessian** 

<!-- tabs:start -->

#### ** English **

One of the advantages of Hessian is that we can easily apply HTTP basic authentication, because both protocols are HTTP-based. Your normal HTTP server security mechanism can be applied through using the `web.xml` security features, for example. Usually, you need not use per-user security credentials here. Rather, you can use shared credentials that you define at the `HessianProxyFactoryBean` level (similar to a JDBC `DataSource`), as the following example shows:
#### ** Chinese **

Hessian的优点之一就是我们可以很容易地应用HTTP基本认证，因为这两种协议都是基于HTTP的。你的正常的HTTP服务器安全机制可以通过使用`web.xml`的安全特性来应用，比如说。通常情况下，你不需要在这里使用每个用户的安全凭证。相反，您可以使用您在 `HessianProxyFactoryBean`层定义的共享凭证（类似于JDBC `DataSource`的数据源</x>），如下例所示。

<!-- tabs:end -->


```xml
<bean class="org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping">
    <property name="interceptors" ref="authorizationInterceptor"/>
</bean>

<bean id="authorizationInterceptor"
        class="org.springframework.web.servlet.handler.UserRoleAuthorizationInterceptor">
    <property name="authorizedRoles" value="administrator,operator"/>
</bean>
```

<!-- tabs:start -->

#### ** English **

In the preceding example, we explicitly mention the `BeanNameUrlHandlerMapping` and set an interceptor, to let only administrators and operators call the beans mentioned in this application context.
#### ** Chinese **

在前面的例子中，我们明确提到了`BeanNameUrlHandlerMapping`，并设置了一个拦截器，只让管理员和操作人员调用这个应用上下文中提到的Bean。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The preceding example does not show a flexible kind of security infrastructure. For more options as far as security is concerned, have a look at the Spring Security project at [https://projects.spring.io/spring-security/](https://projects.spring.io/spring-security/).
#### ** Chinese **

前面的例子并没有显示出一种灵活的安全基础架构。关于安全方面的更多选择，请看[https://projects.spring.io/spring-security/](https://projects.spring.io/spring-security/)的Spring Security项目。

<!-- tabs:end -->


### **1.3. Spring HTTP Invoker** 

<!-- tabs:start -->

#### ** English **

As opposed to Hessian, Spring HTTP invokers are both lightweight protocols that use their own slim serialization mechanisms and use the standard Java serialization mechanism to expose services through HTTP. This has a huge advantage if your arguments and return types are complex types that cannot be serialized by using the serialization mechanisms Hessian uses (see the next section for more considerations when you choose a remoting technology).
#### ** Chinese **

与Hessian相比，Spring HTTP调用器都是轻量级协议，它使用自己的纤细的序列化机制，并使用标准的Java序列化机制，通过HTTP来暴露服务。如果你的参数和返回类型是复杂的类型，无法通过使用Hessian使用的序列化机制进行序列化，那么这就有一个巨大的优势（当你选择远程技术时，更多的考虑因素请参见下一节）。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Under the hood, Spring uses either the standard facilities provided by the JDK or Apache `HttpComponents` to perform HTTP calls. If you need more advanced and easier-to-use functionality, use the latter. See [hc.apache.org/httpcomponents-client-ga/](https://hc.apache.org/httpcomponents-client-ga/) for more information.
#### ** Chinese **

在引擎盖下，Spring使用JDK提供的标准设施或Apache `HttpComponents`来执行HTTP调用。如果你需要更高级、更容易使用的功能，请使用后者。有关更多信息，请参阅[hc.apache.org/httpcomponents-client-ga/](https://hc.apache.org/httpcomponents-client-ga/)。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Be aware of vulnerabilities due to unsafe Java deserialization: Manipulated input streams can lead to unwanted code execution on the server during the deserialization step. As a consequence, do not expose HTTP invoker endpoints to untrusted clients. Rather, expose them only between your own services. In general, we strongly recommend using any other message format (such as JSON) instead.
#### ** Chinese **

要注意不安全的Java反序列化导致的漏洞。操纵输入流会导致在解串步骤期间在服务器上执行不需要的代码。因此，不要将HTTP调用器端点暴露给不信任的客户端。相反，只在自己的服务之间暴露它们。一般来说，我们强烈建议使用任何其他消息格式（如JSON）来代替。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

If you are concerned about security vulnerabilities due to Java serialization, consider the general-purpose serialization filter mechanism at the core JVM level, originally developed for JDK 9 but backported to JDK 8, 7 and 6 in the meantime. See [https://blogs.oracle.com/java-platform-group/entry/incoming_filter_serialization_data_a](https://blogs.oracle.com/java-platform-group/entry/incoming_filter_serialization_data_a) and [https://openjdk.java.net/jeps/290](https://openjdk.java.net/jeps/290).
#### ** Chinese **

如果你担心Java序列化导致的安全漏洞，可以考虑核心JVM层面的通用序列化过滤机制，该机制最初是为JDK 9开发的，但在此期间已经回传到了JDK 8、7和6。参见[https://blogs.oracle.com/java-platform-group/entry/incoming_filter_serialization_data_a](https://blogs.oracle.com/java-platform-group/entry/incoming_filter_serialization_data_a)和[https://openjdk.java.net/jeps/290](https://openjdk.java.net/jeps/290)。

<!-- tabs:end -->


### **1.3.1. Exposing the Service Object** 

<!-- tabs:start -->

#### ** English **

Setting up the HTTP invoker infrastructure for a service object closely resembles the way you would do the same by using Hessian. As Hessian support provides `HessianServiceExporter`, Spring’s HttpInvoker support provides `org.springframework.remoting.httpinvoker.HttpInvokerServiceExporter`.
#### ** Chinese **

为一个服务对象设置HTTP invoker基础架构与使用Hessian的方式非常相似。由于Hessian支持提供了`HessianServiceExporter`，Spring的HttpInvoker支持提供了`org.springframework.remoting.httpinvoker.HttpInvokerServiceExporter`。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

To expose the `AccountService` (mentioned earlier) within a Spring Web MVC `DispatcherServlet`, the following configuration needs to be in place in the dispatcher’s application context, as the following example shows:
#### ** Chinese **

要在Spring Web MVC `AccountService`（前面提到的）中公开`AccountService`（在Spring Web MVC `DispatcherServlet`中，需要在dispatcher的应用程序上下文中进行以下配置，如下例所示。

<!-- tabs:end -->


```xml
<bean name="/AccountService" class="org.springframework.remoting.httpinvoker.HttpInvokerServiceExporter">
    <property name="service" ref="accountService"/>
    <property name="serviceInterface" value="example.AccountService"/>
</bean>
```

<!-- tabs:start -->

#### ** English **

Such an exporter definition is exposed through the `DispatcherServlet` instance’s standard mapping facilities, as explained in [the section on Hessian](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#remoting-caucho-protocols).
#### ** Chinese **

这样的exporter定义是通过`DispatcherServlet`实例的标准映射设施暴露出来的，正如[关于Hessian](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#remoting-caucho-protocols)一节中所解释的那样。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Alternatively, you can create an `HttpInvokerServiceExporter` in your root application context (for example, in `'WEB-INF/applicationContext.xml'`), as the following example shows:
#### ** Chinese **

或者，你可以在你的根应用程序上下文中创建一个`HttpInvokerServiceExporter`（例如，在`'WEB-INF/applicationContext.xml'`中），如下图所示。

<!-- tabs:end -->


```xml
<bean name="accountExporter" class="org.springframework.remoting.httpinvoker.HttpInvokerServiceExporter">
    <property name="service" ref="accountService"/>
    <property name="serviceInterface" value="example.AccountService"/>
</bean>
```

<!-- tabs:start -->

#### ** English **

In addition, you can define a corresponding servlet for this exporter in `web.xml`, with the servlet name matching the bean name of the target exporter, as the following example shows:
#### ** Chinese **

此外，你可以在`web.xml`中为这个exporter定义一个相应的servlet，servlet的名称与目标exporter的bean名相匹配，如下例所示。

<!-- tabs:end -->


```xml
<servlet>
    <servlet-name>accountExporter</servlet-name>
    <servlet-class>org.springframework.web.context.support.HttpRequestHandlerServlet</servlet-class>
</servlet>

<servlet-mapping>
    <servlet-name>accountExporter</servlet-name>
    <url-pattern>/remoting/AccountService</url-pattern>
</servlet-mapping>
```

### **1.3.2. Linking in the Service at the Client** 

<!-- tabs:start -->

#### ** English **

Again, linking in the service from the client much resembles the way you would do it when you use Hessian. By using a proxy, Spring can translate your calls to HTTP POST requests to the URL that points to the exported service. The following example shows how to configure this arrangement:
#### ** Chinese **

同样，从客户端链接服务的方式与使用Hessian时的方式很相似。通过使用代理，Spring可以将您的 HTTP POST 请求调用转换为指向导出服务的 URL。下面的例子显示了如何配置这种安排。

<!-- tabs:end -->


```xml
<bean id="httpInvokerProxy" class="org.springframework.remoting.httpinvoker.HttpInvokerProxyFactoryBean">
    <property name="serviceUrl" value="https://remotehost:8080/remoting/AccountService"/>
    <property name="serviceInterface" value="example.AccountService"/>
</bean>
```

<!-- tabs:start -->

#### ** English **

As mentioned earlier, you can choose what HTTP client you want to use. By default, the `HttpInvokerProxy` uses the JDK’s HTTP functionality, but you can also use the Apache `HttpComponents` client by setting the `httpInvokerRequestExecutor` property. The following example shows how to do so:
#### ** Chinese **

如前所述，你可以选择你想使用的HTTP客户端。默认情况下，`HttpInvokerProxy`使用JDK的HTTP功能，但你也可以通过设置`httpInvokerRequestExecutor`属性来使用Apache`HttpComponents`客户端。下面的例子显示了如何做到这一点。

<!-- tabs:end -->


```xml
<property name="httpInvokerRequestExecutor">
    <bean class="org.springframework.remoting.httpinvoker.HttpComponentsHttpInvokerRequestExecutor"/>
</property>
```

### **1.4. Java Web Services** 

<!-- tabs:start -->

#### ** English **

Spring provides full support for the standard Java web services APIs:
#### ** Chinese **

Spring为标准的Java Web服务API提供了全面支持。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

- Exposing web services using JAX-WS

- Accessing web services using JAX-WS

#### ** Chinese **

- 使用JAX-WS暴露Web服务

- 使用JAX-WS访问Web服务


<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

In addition to stock support for JAX-WS in Spring Core, the Spring portfolio also features [Spring Web Services](http://www.springframework.org/spring-ws), which is a solution for contract-first, document-driven web services — highly recommended for building modern, future-proof web services.
#### ** Chinese **

除了在Spring Core中对JAX-WS的库存支持外，Spring组合还具有[Spring Web Services](http://www.springframework.org/spring-ws)，它是一个以合同为先、文档驱动的Web服务的解决方案---强烈推荐用于构建面向未来的现代Web服务。

<!-- tabs:end -->


### **1.4.1. Exposing Servlet-based Web Services by Using JAX-WS** 

<!-- tabs:start -->

#### ** English **

Spring provides a convenient base class for JAX-WS servlet endpoint implementations: `SpringBeanAutowiringSupport`. To expose our `AccountService`, we extend Spring’s `SpringBeanAutowiringSupport` class and implement our business logic here, usually delegating the call to the business layer. We use Spring’s `@Autowired` annotation to express such dependencies on Spring-managed beans. The following example shows our class that extends `SpringBeanAutowiringSupport`:
#### ** Chinese **

Spring为JAX-WS servlet端点实现提供了一个方便的基类。 `SpringBeanAutowiringSupport`。为了公开我们的`AccountService`，我们扩展Spring的`SpringBeanAutowiringSupport`类，并在这里实现我们的业务逻辑，通常是将调用委托给业务层。我们使用Spring的`@Autowired`注解来表达这种对Spring管理的Bean的依赖。下面的例子显示了我们的类，它扩展了`SpringBeanAutowiringSupport`。

<!-- tabs:end -->


```java
/**
 * JAX-WS compliant AccountService implementation that simply delegates
 * to the AccountService implementation in the root web application context.
 *
 * This wrapper class is necessary because JAX-WS requires working with dedicated
 * endpoint classes. If an existing service needs to be exported, a wrapper that
 * extends SpringBeanAutowiringSupport for simple Spring bean autowiring (through
 * the @Autowired annotation) is the simplest JAX-WS compliant way.
 *
 * This is the class registered with the server-side JAX-WS implementation.
 * In the case of a Java EE server, this would simply be defined as a servlet
 * in web.xml, with the server detecting that this is a JAX-WS endpoint and reacting
 * accordingly. The servlet name usually needs to match the specified WS service name.
 *
 * The web service engine manages the lifecycle of instances of this class.
 * Spring bean references will just be wired in here.
 */
import org.springframework.web.context.support.SpringBeanAutowiringSupport;

@WebService(serviceName="AccountService")
public class AccountServiceEndpoint extends SpringBeanAutowiringSupport {

    @Autowired
    private AccountService biz;

    @WebMethod
    public void insertAccount(Account acc) {
        biz.insertAccount(acc);
    }

    @WebMethod
    public Account[] getAccounts(String name) {
        return biz.getAccounts(name);
    }
}
```

<!-- tabs:start -->

#### ** English **

Our `AccountServiceEndpoint` needs to run in the same web application as the Spring context to allow for access to Spring’s facilities. This is the case by default in Java EE environments, using the standard contract for JAX-WS servlet endpoint deployment. See the various Java EE web service tutorials for details.
#### ** Chinese **

我们的`AccountServiceEndpoint`需要在与Spring上下文相同的Web应用程序中运行，以允许访问Spring的设施。在Java EE环境中，使用JAX-WS servlet端点部署的标准合约，默认情况是这样的。有关详细信息，请参阅各种 Java EE Web 服务教程。

<!-- tabs:end -->


### **1.4.2. Exporting Standalone Web Services by Using JAX-WS** 

<!-- tabs:start -->

#### ** English **

The built-in JAX-WS provider that comes with Oracle’s JDK supports exposure of web services by using the built-in HTTP server that is also included in the JDK. Spring’s `SimpleJaxWsServiceExporter` detects all `@WebService`-annotated beans in the Spring application context and exports them through the default JAX-WS server (the JDK HTTP server).
#### ** Chinese **

Oracle 的 JDK 自带的内置 JAX-WS 提供器通过使用 JDK 中的内置 HTTP 服务器支持 Web 服务的曝光。Spring的`SimpleJaxWsServiceExporter`检测到Spring应用程序上下文中的所有`@WebService`-annotated bean，并通过默认的JAX-WS服务器（JDK HTTP服务器）导出它们。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

In this scenario, the endpoint instances are defined and managed as Spring beans themselves. They are registered with the JAX-WS engine, but their lifecycle is up to the Spring application context. This means that you can apply Spring functionality (such as explicit dependency injection) to the endpoint instances. Annotation-driven injection through `@Autowired` works as well. The following example shows how to define these beans:
#### ** Chinese **

在这种情况下，端点实例是作为Spring Bean本身定义和管理的。它们在JAX-WS引擎中注册，但其生命周期由Spring应用上下文决定。这意味着您可以将Spring功能（如显式依赖注入）应用到端点实例中。通过`@Autowired`进行的注解驱动注入也可以工作。下面的例子显示了如何定义这些Bean。

<!-- tabs:end -->


```xml
<bean class="org.springframework.remoting.jaxws.SimpleJaxWsServiceExporter">
    <property name="baseAddress" value="http://localhost:8080/"/>
</bean>

<bean id="accountServiceEndpoint" class="example.AccountServiceEndpoint">
    ...
</bean>

...
```

<!-- tabs:start -->

#### ** English **

The `AccountServiceEndpoint` can but does not have to derive from Spring’s `SpringBeanAutowiringSupport`, since the endpoint in this example is a fully Spring-managed bean. This means that the endpoint implementation can be as follows (without any superclass declared — and Spring’s `@Autowired` configuration annotation is still honored):
#### ** Chinese **

`AccountServiceEndpoint`可以但不一定要从Spring的`SpringBeanAutowiringSupport`派生，因为这个例子中的端点是一个完全由Spring管理的Bean。这意味着端点的实现可以如下所示（没有声明任何超类--而且Spring的`@Autowired`配置注解仍然会被尊重）。

<!-- tabs:end -->


```java
@WebService(serviceName="AccountService")
public class AccountServiceEndpoint {

    @Autowired
    private AccountService biz;

    @WebMethod
    public void insertAccount(Account acc) {
        biz.insertAccount(acc);
    }

    @WebMethod
    public List<Account> getAccounts(String name) {
        return biz.getAccounts(name);
    }
}
```

### **1.4.3. Exporting Web Services by Using JAX-WS RI’s Spring Support** 

<!-- tabs:start -->

#### ** English **

Oracle’s JAX-WS RI, developed as part of the GlassFish project, ships Spring support as part of its JAX-WS Commons project. This allows for defining JAX-WS endpoints as Spring-managed beans, similar to the standalone mode discussed in the [previous section](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#remoting-web-services-jaxws-export-standalone) — but this time in a Servlet environment.
#### ** Chinese **

Oracle的JAX-WS RI，作为GlassFish项目的一部分开发的JAX-WS RI，作为其JAX-WS Commons项目的一部分提供了Spring支持。这允许将JAX-WS端点定义为Spring管理的Bean，类似于[上一节](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#remoting-web-services-jaxws-export-standalone)中讨论的独立模式--但这次是在Servlet环境中。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

This is not portable in a Java EE environment. It is mainly intended for non-EE environments, such as Tomcat, that embed the JAX-WS RI as part of the web application.
#### ** Chinese **

这在Java EE环境中并不具有可移植性。它主要是针对非EE环境，如Tomcat等非EE环境，将JAX-WS RI作为Web应用程序的一部分嵌入了JAX-WS RI。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The differences from the standard style of exporting servlet-based endpoints are that the lifecycle of the endpoint instances themselves are managed by Spring and that there is only one JAX-WS servlet defined in `web.xml`. With the standard Java EE style (as shown earlier), you have one servlet definition per service endpoint, with each endpoint typically delegating to Spring beans (through the use of `@Autowired`, as shown earlier).
#### ** Chinese **

与标准的基于servlet的端点导出样式不同的是，端点实例本身的生命周期由Spring管理，并且只有一个JAX-WS servlet定义在`web.xml`中。使用标准的Java EE风格（如前文所示），每个服务端点都有一个servlet定义，每个端点通常都会委托给Spring Bean（通过使用`@Autowired`，如前文所示）。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

See [https://jax-ws-commons.java.net/spring/](https://jax-ws-commons.java.net/spring/) for details on setup and usage style.
#### ** Chinese **

有关设置和使用方式的详细内容请参见[https://jax-ws-commons.java.net/spring/](https://jax-ws-commons.java.net/spring/)。

<!-- tabs:end -->


### **1.4.4. Accessing Web Services by Using JAX-WS** 

<!-- tabs:start -->

#### ** English **

Spring provides two factory beans to create JAX-WS web service proxies, namely `LocalJaxWsServiceFactoryBean` and `JaxWsPortProxyFactoryBean`. The former can return only a JAX-WS service class for us to work with. The latter is the full-fledged version that can return a proxy that implements our business service interface. In the following example, we use `JaxWsPortProxyFactoryBean` to create a proxy for the `AccountService` endpoint (again):
#### ** Chinese **

Spring提供了两个工厂Bean来创建JAX-WS web服务代理，即`LocalJaxWsServiceFactoryBean`和`JaxWsPortProxyFactoryBean`。前者只能返回一个JAX-WS服务类供我们使用。后者是完整的版本，可以返回一个实现我们的业务服务接口的代理。在下面的例子中，我们使用`JaxWsPortProxyFactoryBean`为`AccountService`端点创建一个代理（再次）。

<!-- tabs:end -->


```xml
<bean id="accountWebService" class="org.springframework.remoting.jaxws.JaxWsPortProxyFactoryBean">
    <property name="serviceInterface" value="example.AccountService"/> (1)
    <property name="wsdlDocumentUrl" value="http://localhost:8888/AccountServiceEndpoint?WSDL"/>
    <property name="namespaceUri" value="https://example/"/>
    <property name="serviceName" value="AccountService"/>
    <property name="portName" value="AccountServiceEndpointPort"/>
</bean>
```

<!-- tabs:start -->

#### ** English **

(1)Where `serviceInterface` is our business interface that the clients use.
#### ** Chinese **

(1)其中`serviceInterface`是我们的业务接口，客户使用的业务接口。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

`wsdlDocumentUrl` is the URL for the WSDL file. Spring needs this at startup time to create the JAX-WS Service. `namespaceUri` corresponds to the `targetNamespace` in the .wsdl file. `serviceName` corresponds to the service name in the .wsdl file. `portName` corresponds to the port name in the .wsdl file.
#### ** Chinese **

`wsdlDocumentUrl`是WSDL文件的URL。Spring 需要在启动时使用这个 URL 来创建 JAX-WS 服务。 `namespaceUri`对应于.wsdl文件中的`targetNamespace`。 `serviceName`对应于 .wsdl 文件中的服务名称。 `portName`对应于 .wsdl 文件中的端口名称。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Accessing the web service is easy, as we have a bean factory for it that exposes it as an interface called `AccountService`. The following example shows how we can wire this up in Spring:
#### ** Chinese **

访问web服务很容易，因为我们为它建立了一个Bean工厂，将其作为一个名为`AccountService`的接口暴露出来。下面的例子显示了我们如何在Spring中连接这个接口。

<!-- tabs:end -->


```xml
<bean id="client" class="example.AccountClientImpl">
    ...
    <property name="service" ref="accountWebService"/>
</bean>
```

<!-- tabs:start -->

#### ** English **

From the client code, we can access the web service as if it were a normal class, as the following example shows:
#### ** Chinese **

从客户端代码中，我们可以像访问普通类一样访问Web服务，如下例所示。

<!-- tabs:end -->


```java
public class AccountClientImpl {

    private AccountService service;

    public void setService(AccountService service) {
        this.service = service;
    }

    public void foo() {
        service.insertAccount(...);
    }
}
```

<!-- tabs:start -->

#### ** English **

The above is slightly simplified in that JAX-WS requires endpoint interfaces and implementation classes to be annotated with `@WebService`, `@SOAPBinding` etc annotations. This means that you cannot (easily) use plain Java interfaces and implementation classes as JAX-WS endpoint artifacts; you need to annotate them accordingly first. Check the JAX-WS documentation for details on those requirements.
#### ** Chinese **

上面的内容稍微简化了一下，因为JAX-WS要求端点接口和实现类必须用`@WebService`、`@SOAPBinding`等注释。这意味着你不能（很容易）将纯Java接口和实现类作为JAX-WS端点工件使用；你需要首先对它们进行相应的注释。有关这些要求的详细信息，请查看 JAX-WS 文档。

<!-- tabs:end -->


### **1.5. JMS** 

<!-- tabs:start -->

#### ** English **

You can also expose services transparently by using JMS as the underlying communication protocol. The JMS remoting support in the Spring Framework is pretty basic. It sends and receives on the `same thread` and in the same non-transactional `Session`. As a result, throughput is implementation-dependent. Note that these single-threaded and non-transactional constraints apply only to Spring’s JMS remoting support. See [JMS (Java Message Service)](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#jms) for information on Spring’s rich support for JMS-based messaging.
#### ** Chinese **

你也可以通过使用JMS作为底层通信协议来透明地公开服务。Spring框架中的JMS远程支持是非常基本的。它在`相同的线程`上发送和接收，并在同一个非事务性的`Session`中发送和接收。因此，吞吐量取决于实现。注意，这些单线程和非事务性约束只适用于Spring的JMS远程支持。有关Spring对基于JMS的消息传递的丰富支持，请参阅[JMS（Java Message Service）](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#jms)。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following interface is used on both the server and the client sides:
#### ** Chinese **

在服务器端和客户端都使用了以下界面。

<!-- tabs:end -->


```java
package com.foo;

public interface CheckingAccountService {

    public void cancelAccount(Long accountId);
}
```

<!-- tabs:start -->

#### ** English **

The following simple implementation of the preceding interface is used on the server-side:
#### ** Chinese **

下面是前面的接口的简单实现，在服务器端使用。

<!-- tabs:end -->


```java
package com.foo;

public class SimpleCheckingAccountService implements CheckingAccountService {

    public void cancelAccount(Long accountId) {
        System.out.println("Cancelling account [" + accountId + "]");
    }
}
```

<!-- tabs:start -->

#### ** English **

The following configuration file contains the JMS-infrastructure beans that are shared on both the client and the server:
#### ** Chinese **

下面的配置文件包含了在客户端和服务器上共享的JMS-infrastructure Bean。

<!-- tabs:end -->


```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="connectionFactory" class="org.apache.activemq.ActiveMQConnectionFactory">
        <property name="brokerURL" value="tcp://ep-t43:61616"/>
    </bean>

    <bean id="queue" class="org.apache.activemq.command.ActiveMQQueue">
        <constructor-arg value="mmm"/>
    </bean>

</beans>
```

### **1.5.1. Server-side Configuration** 

<!-- tabs:start -->

#### ** English **

On the server, you need to expose the service object that uses the `JmsInvokerServiceExporter`, as the following example shows:
#### ** Chinese **

在服务器上，你需要公开使用`JmsInvokerServiceExporter`的服务对象，如下例所示。

<!-- tabs:end -->


```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="checkingAccountService"
            class="org.springframework.jms.remoting.JmsInvokerServiceExporter">
        <property name="serviceInterface" value="com.foo.CheckingAccountService"/>
        <property name="service">
            <bean class="com.foo.SimpleCheckingAccountService"/>
        </property>
    </bean>

    <bean class="org.springframework.jms.listener.SimpleMessageListenerContainer">
        <property name="connectionFactory" ref="connectionFactory"/>
        <property name="destination" ref="queue"/>
        <property name="concurrentConsumers" value="3"/>
        <property name="messageListener" ref="checkingAccountService"/>
    </bean>

</beans>
```

```java
package com.foo;

import org.springframework.context.support.ClassPathXmlApplicationContext;

public class Server {

    public static void main(String[] args) throws Exception {
        new ClassPathXmlApplicationContext("com/foo/server.xml", "com/foo/jms.xml");
    }
}
```

### **1.5.2. Client-side Configuration** 

<!-- tabs:start -->

#### ** English **

The client merely needs to create a client-side proxy that implements the agreed-upon interface (`CheckingAccountService`).
#### ** Chinese **

客户端只需要创建一个客户端代理，实现约定的接口（`CheckingAccountService`）。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following example defines beans that you can inject into other client-side objects (and the proxy takes care of forwarding the call to the server-side object via JMS):
#### ** Chinese **

下面的例子定义了Bean，你可以将其注入到其他客户端对象中（代理负责通过JMS将调用转发到服务器端对象）。

<!-- tabs:end -->


```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="checkingAccountService"
            class="org.springframework.jms.remoting.JmsInvokerProxyFactoryBean">
        <property name="serviceInterface" value="com.foo.CheckingAccountService"/>
        <property name="connectionFactory" ref="connectionFactory"/>
        <property name="queue" ref="queue"/>
    </bean>

</beans>
```

```java
package com.foo;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class Client {

    public static void main(String[] args) throws Exception {
        ApplicationContext ctx = new ClassPathXmlApplicationContext("com/foo/client.xml", "com/foo/jms.xml");
        CheckingAccountService service = (CheckingAccountService) ctx.getBean("checkingAccountService");
        service.cancelAccount(new Long(10));
    }
}
```

### **1.6. AMQP** 

<!-- tabs:start -->

#### ** English **

Remoting via AMQP as the underlying protocol is supported in the Spring AMQP project. For further details please visit the [Spring Remoting](https://docs.spring.io/spring-amqp/docs/current/reference/html/#remoting) section of the Spring AMQP reference.
#### ** Chinese **

Spring AMQP项目支持通过AMQP作为底层协议进行重投。更多详情，请访问Spring AMQP参考资料中的[Spring Remoting](https://docs.spring.io/spring-amqp/docs/current/reference/html/#remoting)部分。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Auto-detection is not implemented for remote interfaces
#### ** Chinese **

远程接口没有实现自动检测。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The main reason why auto-detection of implemented interfaces does not occur for remote interfaces is to avoid opening too many doors to remote callers. The target object might implement internal callback interfaces, such as `InitializingBean` or `DisposableBean` which one would not want to expose to callers.
#### ** Chinese **

自动检测实现的接口不发生在远程接口上的主要原因是为了避免给远程调用者打开太多的门。目标对象可能会实现内部回调接口，比如`InitializingBean`或`DisposableBean`，这些接口是不愿意暴露给调用者的。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Offering a proxy with all interfaces implemented by the target usually does not matter in the local case. However, when you export a remote service, you should expose a specific service interface, with specific operations intended for remote usage. Besides internal callback interfaces, the target might implement multiple business interfaces, with only one of them intended for remote exposure. For these reasons, we require such a service interface to be specified.
#### ** Chinese **

在本地的情况下，提供一个具有目标实现的所有接口的代理通常并不重要。但是，当你导出一个远程服务时，你应该公开一个特定的服务接口，并为远程使用提供特定的操作。除了内部回调接口外，目标可能实现了多个业务接口，而目标只有一个业务接口是用于远程暴露的。基于这些原因，我们要求指定这样的服务接口。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

This is a trade-off between configuration convenience and the risk of accidental exposure of internal methods. Always specifying a service interface is not too much effort and puts you on the safe side regarding controlled exposure of specific methods.
#### ** Chinese **

这是在配置的方便性和内部方法意外暴露的风险之间的权衡。始终指定一个服务接口并不是太费劲，而且在控制特定方法的暴露方面，让你站在安全的一边。

<!-- tabs:end -->


### **1.7. Considerations when Choosing a Technology** 

<!-- tabs:start -->

#### ** English **

Each and every technology presented here has its drawbacks. When choosing a technology, you should carefully consider your needs, the services you expose, and the objects you send over the wire.
#### ** Chinese **

这里介绍的每一种技术都有其缺点。在选择技术时，你应该仔细考虑你的需求，你所暴露的服务，以及你通过电线发送的对象。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

When using RMI, you cannot access the objects through the HTTP protocol, unless you tunnel the RMI traffic. RMI is a fairly heavy-weight protocol, in that it supports full-object serialization, which is important when you use a complex data model that needs serialization over the wire. However, RMI-JRMP is tied to Java clients. It is a Java-to-Java remoting solution.
#### ** Chinese **

当使用RMI时，除非你对RMI流量进行隧道化，否则无法通过HTTP协议访问对象。RMI是一个相当重量级的协议，因为它支持全对象序列化，当你使用一个复杂的数据模型，需要通过线缆进行序列化时，这一点很重要。然而，RMI-JRMP是与Java客户端绑定的。它是一个Java到Java的远程解决方案。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Spring’s HTTP invoker is a good choice if you need HTTP-based remoting but also rely on Java serialization. It shares the basic infrastructure with RMI invokers but uses HTTP as transport. Note that HTTP invokers are not limited only to Java-to-Java remoting but also to Spring on both the client and the server side. (The latter also applies to Spring’s RMI invoker for non-RMI interfaces.)
#### ** Chinese **

如果你需要基于HTTP的远程控制，但又依赖Java序列化，Spring的HTTP invoker是个不错的选择。它与RMI invokers共享基本的基础设施，但使用HTTP作为传输方式。需要注意的是，HTTP invokers并不仅仅局限于Java到Java的远程化，在客户端和服务器端也适用于Spring。后者也适用于Spring的非RMI接口的RMI调用器）。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Hessian might provide significant value when operating in a heterogeneous environment, because they explicitly allow for non-Java clients. However, non-Java support is still limited. Known issues include the serialization of Hibernate objects in combination with lazily-initialized collections. If you have such a data model, consider using RMI or HTTP invokers instead of Hessian.
#### ** Chinese **

当在异构环境中运行时，Hessian可能会提供重要的价值，因为它们明确允许非Java客户端。然而，对非Java的支持仍然有限。已知的问题包括Hibernate对象与懒惰初始化集合相结合的序列化。如果你有这样的数据模型，可以考虑使用RMI或HTTP调用器来代替Hessian。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

JMS can be useful for providing clusters of services and letting the JMS broker take care of load balancing, discovery, and auto-failover. By default, Java serialization is used for JMS remoting, but the JMS provider could use a different mechanism for the wire formatting, such as XStream to let servers be implemented in other technologies.
#### ** Chinese **

JMS可以用于提供服务集群，并让JMS代理承担负载均衡、发现和自动故障转移等工作。默认情况下，Java序列化被用于JMS远程，但JMS提供者可以使用不同的线格式化机制，例如XStream，让服务器在其他技术中实现。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Last but not least, EJB has an advantage over RMI, in that it supports standard role-based authentication and authorization and remote transaction propagation. It is possible to get RMI invokers or HTTP invokers to support security context propagation as well, although this is not provided by core Spring. Spring offers only appropriate hooks for plugging in third-party or custom solutions.
#### ** Chinese **

最后但同样重要的是，EJB比RMI有一个优势，那就是它支持标准的角色认证和授权以及远程事务传播。可以让RMI调用器或HTTP调用器也支持安全上下文传播，尽管核心Spring没有提供这个功能。Spring只提供了适当的挂钩，用于插入第三方或定制解决方案。

<!-- tabs:end -->


### **1.8. REST Endpoints** 

<!-- tabs:start -->

#### ** English **

The Spring Framework provides two choices for making calls to REST endpoints:
#### ** Chinese **

Spring框架为REST端点的调用提供了两种选择。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

- [`RestTemplate`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#rest-resttemplate): The original Spring REST client with a synchronous, template method API.

- [WebClient](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-client): a non-blocking, reactive alternative that supports both synchronous and asynchronous as well as streaming scenarios.

#### ** Chinese **

- `RestTemplate`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#rest-resttemplate)。原始的Spring REST客户端，具有同步、模板方法API。

- [WebClient](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-client)：一个非阻塞的、反应式的替代方案，支持同步和异步以及流媒体场景。


<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

As of 5.0 the `RestTemplate` is in maintenance mode, with only minor requests for changes and bugs to be accepted going forward. Please, consider using the [WebClient](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-client) which offers a more modern API and supports sync, async, and streaming scenarios.
#### ** Chinese **

从5.0开始，`RestTemplate`处于维护模式，只接受一些小的修改和bug请求。请考虑使用[WebClient](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-client)，它提供了一个更现代的API，并支持同步、异步和流媒体场景。

<!-- tabs:end -->


### **1.8.1.** **`RestTemplate`** 

<!-- tabs:start -->

#### ** English **

The `RestTemplate` provides a higher level API over HTTP client libraries. It makes it easy to invoke REST endpoints in a single line. It exposes the following groups of overloaded methods:
#### ** Chinese **

`RestTemplate`提供了一个比HTTP客户端库更高级别的API。它使得在单行中调用REST端点很容易。它公开了以下几组超载方法。

<!-- tabs:end -->


Method group | Description 
-|-
getForObject | Retrieves a representation via GET. 
getForEntity | Retrieves a ResponseEntity (that is, status, headers, and body) by using GET. 
headForHeaders | Retrieves all headers for a resource by using HEAD. 
postForLocation | Creates a new resource by using POST and returns the Location header from the response. 
postForObject | Creates a new resource by using POST and returns the representation from the response. 
postForEntity | Creates a new resource by using POST and returns the representation from the response. 
put | Creates or updates a resource by using PUT. 
patchForObject | Updates a resource by using PATCH and returns the representation from the response. Note that the JDK HttpURLConnection does not support the PATCH, but Apache HttpComponents and others do. 
delete | Deletes the resources at the specified URI by using DELETE. 
optionsForAllow | Retrieves allowed HTTP methods for a resource by using ALLOW. 
exchange | More generalized (and less opinionated) version of the preceding methods that provides extra flexibility when needed. It accepts a RequestEntity (including HTTP method, URL, headers, and body as input) and returns a ResponseEntity.These methods allow the use of ParameterizedTypeReference instead of Class to specify a response type with generics. 
execute | The most generalized way to perform a request, with full control over request preparation and response extraction through callback interfaces. 


### **Initialization** 

<!-- tabs:start -->

#### ** English **

The default constructor uses `java.net.HttpURLConnection` to perform requests. You can switch to a different HTTP library with an implementation of `ClientHttpRequestFactory`. There is built-in support for the following:
#### ** Chinese **

默认的构造函数使用`java.net.HttpURLConnection`来执行请求。你可以通过`ClientHttpRequestFactory`ClientHttpRequestFactory的实现切换到不同的HTTP库。内建有以下的支持。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

- Apache HttpComponents

- Netty

- OkHttp

#### ** Chinese **

- Apache HttpComponents

- 网友

- OkHttp


<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

For example, to switch to Apache HttpComponents, you can use the following:
#### ** Chinese **

例如，要切换到Apache HttpComponents，可以使用以下方法。

<!-- tabs:end -->


```java
RestTemplate template = new RestTemplate(new HttpComponentsClientHttpRequestFactory());
```

<!-- tabs:start -->

#### ** English **

Each `ClientHttpRequestFactory` exposes configuration options specific to the underlying HTTP client library — for example, for credentials, connection pooling, and other details.
#### ** Chinese **

每个`ClientHttpRequestFactory`都显示了特定于底层HTTP客户机库的配置选项--例如，证书、连接池和其他细节。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Note that the `java.net` implementation for HTTP requests can raise an exception when accessing the status of a response that represents an error (such as 401). If this is an issue, switch to another HTTP client library.
#### ** Chinese **

请注意，当访问代表错误（如401）的响应状态时，用于HTTP请求的`java.net`实现会引发异常。如果这是一个问题，请切换到另一个HTTP客户端库。

<!-- tabs:end -->


### **URIs** 

<!-- tabs:start -->

#### ** English **

Many of the `RestTemplate` methods accept a URI template and URI template variables, either as a `String` variable argument, or as `Map<String,String>`.
#### ** Chinese **

许多`RestTemplate`方法都接受URI模板和URI模板变量，可以作为`String`变量参数，也可以作为`Map<String,String>`变量参数。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following example uses a `String` variable argument:
#### ** Chinese **

下面的例子使用了一个`String`变量参数。

<!-- tabs:end -->


```java
String result = restTemplate.getForObject(
        "https://example.com/hotels/{hotel}/bookings/{booking}", String.class, "42", "21");
```

<!-- tabs:start -->

#### ** English **

The following example uses a `Map<String, String>`:
#### ** Chinese **

下面的例子使用了`Map<String, String>`。

<!-- tabs:end -->


```java
Map<String, String> vars = Collections.singletonMap("hotel", "42");

String result = restTemplate.getForObject(
        "https://example.com/hotels/{hotel}/rooms/{hotel}", String.class, vars);
```

<!-- tabs:start -->

#### ** English **

Keep in mind URI templates are automatically encoded, as the following example shows:
#### ** Chinese **

请记住，URI模板是自动编码的，如下图所示。

<!-- tabs:end -->


```java
restTemplate.getForObject("https://example.com/hotel list", String.class);

// Results in request to "https://example.com/hotel%20list"
```

<!-- tabs:start -->

#### ** English **

You can use the `uriTemplateHandler` property of `RestTemplate` to customize how URIs are encoded. Alternatively, you can prepare a `java.net.URI` and pass it into one of the `RestTemplate` methods that accepts a `URI`.
#### ** Chinese **

您可以使用 `RestTemplate`的 `uriTemplateHandler` 属性来自定义URI的编码方式。或者，您可以准备一个`java.net.URI`，并将其传递到接受`URI`的`RestTemplate`方法中。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

For more details on working with and encoding URIs, see [URI Links](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-uri-building).
#### ** Chinese **

关于URI的工作和编码的更多细节，请参阅[URI链接](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-uri-building)。

<!-- tabs:end -->


### **Headers** 

<!-- tabs:start -->

#### ** English **

You can use the `exchange()` methods to specify request headers, as the following example shows:
#### ** Chinese **

你可以使用`exchange()`方法来指定请求头，如下例所示。

<!-- tabs:end -->


```java
String uriTemplate = "https://example.com/hotels/{hotel}";
URI uri = UriComponentsBuilder.fromUriString(uriTemplate).build(42);

RequestEntity<Void> requestEntity = RequestEntity.get(uri)
        .header(("MyRequestHeader", "MyValue")
        .build();

ResponseEntity<String> response = template.exchange(requestEntity, String.class);

String responseHeader = response.getHeaders().getFirst("MyResponseHeader");
String body = response.getBody();
```

<!-- tabs:start -->

#### ** English **

You can obtain response headers through many `RestTemplate` method variants that return `ResponseEntity`.
#### ** Chinese **

您可以通过许多`RestTemplate`方法变体获得响应头，这些变体返回`ResponseEntity`。

<!-- tabs:end -->


### **Body** 

<!-- tabs:start -->

#### ** English **

Objects passed into and returned from `RestTemplate` methods are converted to and from raw content with the help of an `HttpMessageConverter`.
#### ** Chinese **

`RestTemplate`方法传入和返回的对象在`HttpMessageConverter`的帮助下被转换为和从原始内容。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

On a POST, an input object is serialized to the request body, as the following example shows:
#### ** Chinese **

在POST中，一个输入对象被序列化为请求体，如下例所示。

<!-- tabs:end -->


```java
URI location = template.postForLocation("https://example.com/people", person);
```

<!-- tabs:start -->

#### ** English **

You need not explicitly set the Content-Type header of the request. In most cases, you can find a compatible message converter based on the source `Object` type, and the chosen message converter sets the content type accordingly. If necessary, you can use the `exchange` methods to explicitly provide the `Content-Type` request header, and that, in turn, influences what message converter is selected.
#### ** Chinese **

你不需要显式设置请求的内容类型头。在大多数情况下，你可以根据源`Object`类型找到一个兼容的消息转换器，选择的消息转换器会相应地设置内容类型。如果有必要，可以使用`exchange`方法来显式提供`Content-Type`请求头，这反过来又会影响选择什么样的消息转换器。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

On a GET, the body of the response is deserialized to an output `Object`, as the following example shows:
#### ** Chinese **

在GET中，响应的主体被反序列化为一个输出`Object`，如下例所示。

<!-- tabs:end -->


```java
Person person = restTemplate.getForObject("https://example.com/people/{id}", Person.class, 42);
```

<!-- tabs:start -->

#### ** English **

The `Accept` header of the request does not need to be explicitly set. In most cases, a compatible message converter can be found based on the expected response type, which then helps to populate the `Accept` header. If necessary, you can use the `exchange` methods to provide the `Accept` header explicitly.
#### ** Chinese **

请求的`Accept`头不需要显式设置。在大多数情况下，可以根据预期的响应类型找到一个兼容的消息转换器，然后帮助填充`Accept`头。如果有必要，可以使用`exchange`方法来显式提供`Accept`头。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

By default, `RestTemplate` registers all built-in [message converters](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#rest-message-conversion), depending on classpath checks that help to determine what optional conversion libraries are present. You can also set the message converters to use explicitly.
#### ** Chinese **

默认情况下，`RestTemplate`会注册所有内置的[消息转换器](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#rest-message-conversion)，这取决于classpath检查，该检查有助于确定存在哪些可选的转换库。你也可以设置要显式使用的消息转换器。

<!-- tabs:end -->


### **Message Conversion** 

<!-- tabs:start -->

#### ** English **

[WebFlux](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-codecs)
#### ** Chinese **

[WebFlux](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-codecs)

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The `spring-web` module contains the `HttpMessageConverter` contract for reading and writing the body of HTTP requests and responses through `InputStream` and `OutputStream`. `HttpMessageConverter` instances are used on the client side (for example, in the `RestTemplate`) and on the server side (for example, in Spring MVC REST controllers).
#### ** Chinese **

`spring-web`模块包含了`HttpMessageConverter`合约，用于通过`InputStream`和`OutputStream`读取和写入HTTP请求和响应的正文。 `HttpMessageConverter`实例用于客户端（例如，在`RestTemplate`中）和服务器端（例如，在Spring MVC REST控制器中）。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Concrete implementations for the main media (MIME) types are provided in the framework and are, by default, registered with the `RestTemplate` on the client side and with `RequestMethodHandlerAdapter` on the server side (see [Configuring Message Converters](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-config-message-converters)).
#### ** Chinese **

主媒体（MIME）类型的具体实现是在框架中提供的，默认情况下，在客户端的`RestTemplate`和服务器端的`RequestMethodHandlerAdapter`中注册（参见[配置消息转换器](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-config-message-converters)）。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The implementations of `HttpMessageConverter` are described in the following sections. For all converters, a default media type is used, but you can override it by setting the `supportedMediaTypes` bean property. The following table describes each implementation:
#### ** Chinese **

`HttpMessageConverter`的实现将在下面的章节中描述。对于所有的转换器，都使用了一个默认的媒体类型，但你可以通过设置`supportedMediaTypes` bean属性来覆盖它。下表描述了每个实现。

<!-- tabs:end -->


MessageConverter | Description 
-|-
StringHttpMessageConverter | An HttpMessageConverter implementation that can read and write String instances from the HTTP request and response. By default, this converter supports all text media types (text/*) and writes with a Content-Type of text/plain. 
FormHttpMessageConverter | An HttpMessageConverter implementation that can read and write form data from the HTTP request and response. By default, this converter reads and writes the application/x-www-form-urlencoded media type. Form data is read from and written into a MultiValueMap<String, String>. The converter can also write (but not read) multipart data read from a MultiValueMap<String, Object>. By default, multipart/form-data is supported. As of Spring Framework 5.2, additional multipart subtypes can be supported for writing form data. Consult the javadoc for FormHttpMessageConverter for further details. 
ByteArrayHttpMessageConverter | An HttpMessageConverter implementation that can read and write byte arrays from the HTTP request and response. By default, this converter supports all media types (*/*) and writes with a Content-Type of application/octet-stream. You can override this by setting the supportedMediaTypes property and overriding getContentType(byte[]). 
MarshallingHttpMessageConverter | An HttpMessageConverter implementation that can read and write XML by using Spring’s Marshaller and Unmarshaller abstractions from the org.springframework.oxm package. This converter requires a Marshaller and Unmarshaller before it can be used. You can inject these through constructor or bean properties. By default, this converter supports text/xml and application/xml. 
MappingJackson2HttpMessageConverter | An HttpMessageConverter implementation that can read and write JSON by using Jackson’s ObjectMapper. You can customize JSON mapping as needed through the use of Jackson’s provided annotations. When you need further control (for cases where custom JSON serializers/deserializers need to be provided for specific types), you can inject a custom ObjectMapper through the ObjectMapper property. By default, this converter supports application/json. 
MappingJackson2XmlHttpMessageConverter | An HttpMessageConverter implementation that can read and write XML by using Jackson XML extension’s XmlMapper. You can customize XML mapping as needed through the use of JAXB or Jackson’s provided annotations. When you need further control (for cases where custom XML serializers/deserializers need to be provided for specific types), you can inject a custom XmlMapper through the ObjectMapper property. By default, this converter supports application/xml. 
SourceHttpMessageConverter | An HttpMessageConverter implementation that can read and write javax.xml.transform.Source from the HTTP request and response. Only DOMSource, SAXSource, and StreamSource are supported. By default, this converter supports text/xml and application/xml. 
BufferedImageHttpMessageConverter | An HttpMessageConverter implementation that can read and write java.awt.image.BufferedImage from the HTTP request and response. This converter reads and writes the media type supported by the Java I/O API. 


### **Jackson JSON Views** 

<!-- tabs:start -->

#### ** English **

You can specify a [Jackson JSON View](https://www.baeldung.com/jackson-json-view-annotation) to serialize only a subset of the object properties, as the following example shows:
#### ** Chinese **

您可以指定一个[JSON JSON 视图](https://www.baeldung.com/jackson-json-view-annotation)，以便只对对象属性的一个子集进行序列化，如下例所示。

<!-- tabs:end -->


```java
MappingJacksonValue value = new MappingJacksonValue(new User("eric", "7!jd#h23"));
value.setSerializationView(User.WithoutPasswordView.class);

RequestEntity<MappingJacksonValue> requestEntity =
    RequestEntity.post(new URI("https://example.com/user")).body(value);

ResponseEntity<String> response = template.exchange(requestEntity, String.class);
```

### **Multipart** 

<!-- tabs:start -->

#### ** English **

To send multipart data, you need to provide a `MultiValueMap<String, Object>` whose values may be an `Object` for part content, a `Resource` for a file part, or an `HttpEntity` for part content with headers. For example:
#### ** Chinese **

要发送多部分数据，你需要提供一个`MultiValueMap<String, Object>`，其值可以是一个`Object`用于部分内容，一个`Resource`用于文件部分，或者一个`HttpEntity`用于部分内容的标题。例如。

<!-- tabs:end -->


```java
    MultiValueMap<String, Object> parts = new LinkedMultiValueMap<>();

    parts.add("fieldPart", "fieldValue");
    parts.add("filePart", new FileSystemResource("...logo.png"));
    parts.add("jsonPart", new Person("Jason"));

    HttpHeaders headers = new HttpHeaders();
    headers.setContentType(MediaType.APPLICATION_XML);
    parts.add("xmlPart", new HttpEntity<>(myBean, headers));
```

<!-- tabs:start -->

#### ** English **

In most cases, you do not have to specify the `Content-Type` for each part. The content type is determined automatically based on the `HttpMessageConverter` chosen to serialize it or, in the case of a `Resource` based on the file extension. If necessary, you can explicitly provide the `MediaType` with an `HttpEntity` wrapper.
#### ** Chinese **

在大多数情况下，您不必为每个部分指定`Content-Type`。内容类型是根据所选的`HttpMessageConverter`自动确定的，如果是`Resource`，则根据文件扩展名来确定。如果有必要，你可以显式地提供`MediaType`与`HttpEntity`包装器。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Once the `MultiValueMap` is ready, you can pass it to the `RestTemplate`, as show below:
#### ** Chinese **

一旦`MultiValueMap`准备好了，你可以把它传给`RestTemplate`，如下图所示。

<!-- tabs:end -->


```java
    MultiValueMap<String, Object> parts = ...;
    template.postForObject("https://example.com/upload", parts, Void.class);
```

<!-- tabs:start -->

#### ** English **

If the `MultiValueMap` contains at least one non-`String` value, the `Content-Type` is set to `multipart/form-data` by the `FormHttpMessageConverter`. If the `MultiValueMap` has `String` values the `Content-Type` is defaulted to `application/x-www-form-urlencoded`. If necessary the `Content-Type` may also be set explicitly.
#### ** Chinese **

如果`MultiValueMap`包含至少一个非`String`值，则`Content-Type`被`FormHttpMessageConverter`设置为`multipart/form-data`。如果`MultiValueMap`有`String`值，则`Content-Type`默认为`application/x-www-form-urlencoded`。如果有必要，也可以显式设置`Content-Type`。

<!-- tabs:end -->


### **1.8.2. Using** **`AsyncRestTemplate`** ** (Deprecated)** 

<!-- tabs:start -->

#### ** English **

The `AsyncRestTemplate` is deprecated. For all use cases where you might consider using `AsyncRestTemplate`, use the [WebClient](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-client) instead.
#### ** Chinese **

`AsyncRestTemplate`已被废弃。对于所有可能考虑使用`AsyncRestTemplate`的用例，请使用[WebClient](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-client)。

<!-- tabs:end -->



[下一章](Spring-Framework-5.2.6.RELEASE/Integration/2.%20Enterprise%20JavaBeans%20(EJB)%20Integration.md)


[回目录](Spring-Framework-5.2.6.RELEASE/summary.md)

[回首页](/README)
