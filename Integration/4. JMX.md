# 4. JMX

<!-- tabs:start -->

#### ** English **

The JMX (Java Management Extensions) support in Spring provides features that let you easily and transparently integrate your Spring application into a JMX infrastructure.
#### ** Chinese **

Spring 中的 JMX（Java 管理扩展）支持提供了一些功能，让您可以轻松、透明地将您的 Spring 应用程序集成到 JMX 基础架构中。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

JMX?
#### ** Chinese **

JMX?

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

This chapter is not an introduction to JMX. It does not try to explain why you might want to use JMX. If you are new to JMX, see [Further Resources](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#jmx-resources) at the end of this chapter.
#### ** Chinese **

本章不是JMX的介绍。本章并不试图解释为什么要使用JMX。如果你是JMX的新手，请参见本章末尾的[进一步资源](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#jmx-resources)。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Specifically, Spring’s JMX support provides four core features:
#### ** Chinese **

具体来说，Spring的JMX支持提供了四个核心功能。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

- The automatic registration of any Spring bean as a JMX MBean.

- A flexible mechanism for controlling the management interface of your beans.

- The declarative exposure of MBeans over remote, JSR-160 connectors.

- The simple proxying of both local and remote MBean resources.

#### ** Chinese **

- 将任何Spring Bean自动注册为JMX MBean。

- 一个灵活的机制来控制你的Bean的管理界面。

- 通过远程的JSR-160连接器对MBeans进行声明式曝光。

- 本地和远程MBean资源的简单代理。


<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

These features are designed to work without coupling your application components to either Spring or JMX interfaces and classes. Indeed, for the most part, your application classes need not be aware of either Spring or JMX in order to take advantage of the Spring JMX features.
#### ** Chinese **

这些功能的设计是为了在不将你的应用程序组件与Spring或JMX接口和类耦合的情况下工作。事实上，在大多数情况下，您的应用程序类不需要意识到Spring或JMX，就可以利用Spring JMX功能。

<!-- tabs:end -->


### **4.1. Exporting Your Beans to JMX** 

<!-- tabs:start -->

#### ** English **

The core class in Spring’s JMX framework is the `MBeanExporter`. This class is responsible for taking your Spring beans and registering them with a JMX `MBeanServer`. For example, consider the following class:
#### ** Chinese **

Spring的JMX框架的核心类是`MBeanExporter`。这个类负责获取你的Spring Bean并将其注册到JMX `MBeanServer`中。例如，考虑下面的类。

<!-- tabs:end -->


```java
package org.springframework.jmx;

public class JmxTestBean implements IJmxTestBean {

    private String name;
    private int age;
    private boolean isSuperman;

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public int add(int x, int y) {
        return x + y;
    }

    public void dontExposeMe() {
        throw new RuntimeException();
    }
}
```

<!-- tabs:start -->

#### ** English **

To expose the properties and methods of this bean as attributes and operations of an MBean, you can configure an instance of the `MBeanExporter` class in your configuration file and pass in the bean, as the following example shows:
#### ** Chinese **

要将这个Bean的属性和方法作为MBean的属性和操作，可以在配置文件中配置一个`MBeanExporter`类的实例，然后传入Bean，如下例所示。

<!-- tabs:end -->


```xml
<beans>
    <!-- this bean must not be lazily initialized if the exporting is to happen -->
    <bean id="exporter" class="org.springframework.jmx.export.MBeanExporter" lazy-init="false">
        <property name="beans">
            <map>
                <entry key="bean:name=testBean1" value-ref="testBean"/>
            </map>
        </property>
    </bean>
    <bean id="testBean" class="org.springframework.jmx.JmxTestBean">
        <property name="name" value="TEST"/>
        <property name="age" value="100"/>
    </bean>
</beans>
```

<!-- tabs:start -->

#### ** English **

The pertinent bean definition from the preceding configuration snippet is the `exporter` bean. The `beans` property tells the `MBeanExporter` exactly which of your beans must be exported to the JMX `MBeanServer`. In the default configuration, the key of each entry in the `beans` `Map` is used as the `ObjectName` for the bean referenced by the corresponding entry value. You can change this behavior, as described in [Controlling ](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#jmx-naming)[`ObjectName`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#jmx-naming)[ Instances for Your Beans](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#jmx-naming).
#### ** Chinese **

前面配置片段中的相关Bean定义是`exporter` bean。`beans`属性告诉`MBeanExporter`必须将哪些bean导出到JMX `MBeanServer`。在默认配置中，`beans` `Map`中的每个条目的键被用作相应的条目值所引用的Bean的`ObjectName`。您可以改变这种行为，如[控制](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#jmx-naming)[`ObjectName`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#jmx-naming)[Instances for Your Beans](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#jmx-naming)中所述。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

With this configuration, the `testBean` bean is exposed as an MBean under the `ObjectName` `bean:name=testBean1`. By default, all `public` properties of the bean are exposed as attributes and all `public` methods (except those inherited from the `Object` class) are exposed as operations.
#### ** Chinese **

使用此配置，`testBean` bean被作为一个MBean暴露在`ObjectName` `bean:name=testBean1`下。默认情况下，Bean的所有`public`属性都作为属性曝光，所有`public`方法（除了从`Object`类继承的方法）都作为操作曝光。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

`MBeanExporter` is a `Lifecycle` bean (see [Startup and Shutdown Callbacks](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-lifecycle-processor)). By default, MBeans are exported as late as possible during the application lifecycle. You can configure the `phase` at which the export happens or disable automatic registration by setting the `autoStartup` flag.
#### ** Chinese **

`MBeanExporter`是一个`Lifecycle` bean（参见[启动和关闭回调](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-lifecycle-processor)）。默认情况下，MBeans在应用程序生命周期中尽可能晚地导出。您可以通过设置`autoStartup`标志来配置导出发生的`阶段`，或者禁用自动注册。

<!-- tabs:end -->


### **4.1.1. Creating an MBeanServer** 

<!-- tabs:start -->

#### ** English **

The configuration shown in the [preceding section](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#jmx-exporting) assumes that the application is running in an environment that has one (and only one) `MBeanServer` already running. In this case, Spring tries to locate the running `MBeanServer` and register your beans with that server (if any). This behavior is useful when your application runs inside a container (such as Tomcat or IBM WebSphere) that has its own `MBeanServer`.
#### ** Chinese **

在[上一节](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#jmx-exporting)中显示的配置假设应用程序运行在一个已经有一个（而且只有一个）`MBeanServer`的环境中。在这种情况下，Spring会尝试定位正在运行的`MBeanServer`，并将您的Bean注册到该服务器上（如果有的话）。当您的应用程序运行在有自己的 `MBeanServer`的容器（如 Tomcat 或 IBM WebSphere）中时，这种行为很有用。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

However, this approach is of no use in a standalone environment or when running inside a container that does not provide an `MBeanServer`. To address this, you can create an `MBeanServer` instance declaratively by adding an instance of the `org.springframework.jmx.support.MBeanServerFactoryBean` class to your configuration. You can also ensure that a specific `MBeanServer` is used by setting the value of the `MBeanExporter` instance’s `server` property to the `MBeanServer` value returned by an `MBeanServerFactoryBean`, as the following example shows:
#### ** Chinese **

然而，这种方法在独立环境中或在没有提供 `MBeanServer`的容器内运行时，这种方法是没有用的。为了解决这个问题，您可以通过在配置中添加 `org.springframework.jmx.support.MBeanServerFactoryBean`类的实例来声明性地创建一个`MBeanServer`实例。您还可以通过将 `MBeanExporter`实例的 `server`属性的值设置为 `MBeanServerFactoryBean`返回的 `MBeanServer`值来确保使用特定的 `MBeanServer`，如下示例所示。

<!-- tabs:end -->


```xml
<beans>

    <bean id="mbeanServer" class="org.springframework.jmx.support.MBeanServerFactoryBean"/>

    <!--
    this bean needs to be eagerly pre-instantiated in order for the exporting to occur;
    this means that it must not be marked as lazily initialized
    -->
    <bean id="exporter" class="org.springframework.jmx.export.MBeanExporter">
        <property name="beans">
            <map>
                <entry key="bean:name=testBean1" value-ref="testBean"/>
            </map>
        </property>
        <property name="server" ref="mbeanServer"/>
    </bean>

    <bean id="testBean" class="org.springframework.jmx.JmxTestBean">
        <property name="name" value="TEST"/>
        <property name="age" value="100"/>
    </bean>

</beans>
```

<!-- tabs:start -->

#### ** English **

In the preceding example, an instance of `MBeanServer` is created by the `MBeanServerFactoryBean` and is supplied to the `MBeanExporter` through the `server` property. When you supply your own `MBeanServer` instance, the `MBeanExporter` does not try to locate a running `MBeanServer` and uses the supplied `MBeanServer` instance. For this to work correctly, you must have a JMX implementation on your classpath.
#### ** Chinese **

在前面的例子中，`MBeanServer`实例由`MBeanServerFactoryBean`创建，并通过`server`属性提供给`MBeanExporter`。当您提供自己的 `MBeanServer`实例时，`MBeanExporter`不会尝试定位正在运行的`MBeanServer`，而是使用提供的`MBeanServer`实例。为了使其正常工作，您必须在classpath上有一个JMX实现。

<!-- tabs:end -->


### **4.1.2. Reusing an Existing** **`MBeanServer`** 

<!-- tabs:start -->

#### ** English **

If no server is specified, the `MBeanExporter` tries to automatically detect a running `MBeanServer`. This works in most environments, where only one `MBeanServer` instance is used. However, when multiple instances exist, the exporter might pick the wrong server. In such cases, you should use the `MBeanServer` `agentId` to indicate which instance to be used, as the following example shows:
#### ** Chinese **

如果没有指定服务器，`MBeanExporter`将尝试自动检测正在运行的`MBeanServer`。这在大多数环境中都能正常工作，因为在大多数环境中只使用一个 `MBeanServer`实例。但是，当存在多个实例时，输出者可能会选择错误的服务器。在这种情况下，您应该使用 `MBeanServer` `agentId`来指示要使用哪个实例，如下例所示。

<!-- tabs:end -->


```xml
<beans>
    <bean id="mbeanServer" class="org.springframework.jmx.support.MBeanServerFactoryBean">
        <!-- indicate to first look for a server -->
        <property name="locateExistingServerIfPossible" value="true"/>
        <!-- search for the MBeanServer instance with the given agentId -->
        <property name="agentId" value="MBeanServer_instance_agentId>"/>
    </bean>
    <bean id="exporter" class="org.springframework.jmx.export.MBeanExporter">
        <property name="server" ref="mbeanServer"/>
        ...
    </bean>
</beans>
```

<!-- tabs:start -->

#### ** English **

For platforms or cases where the existing `MBeanServer` has a dynamic (or unknown) `agentId` that is retrieved through lookup methods, you should use [factory-method](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-class-static-factory-method), as the following example shows:
#### ** Chinese **

对于现有的`MBeanServer`有一个动态的（或未知的）`agentId`的平台或情况，你应该使用[factory-method](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-class-static-factory-method)，如下例所示。

<!-- tabs:end -->


```xml
<beans>
    <bean id="exporter" class="org.springframework.jmx.export.MBeanExporter">
        <property name="server">
            <!-- Custom MBeanServerLocator -->
            <bean class="platform.package.MBeanServerLocator" factory-method="locateMBeanServer"/>
        </property>
    </bean>

    <!-- other beans here -->

</beans>
```

### **4.1.3. Lazily Initialized MBeans** 

<!-- tabs:start -->

#### ** English **

If you configure a bean with an `MBeanExporter` that is also configured for lazy initialization, the `MBeanExporter` does not break this contract and avoids instantiating the bean. Instead, it registers a proxy with the `MBeanServer` and defers obtaining the bean from the container until the first invocation on the proxy occurs.
#### ** Chinese **

如果您配置了一个带有`MBeanExporter`的Bean，而该Bean也被配置为懒惰初始化，那么`MBeanExporter`不会破坏此契约，并避免实例化Bean。相反，它在`MBeanServer`中注册了一个代理，并将从容器中获取Bean推迟到代理上的第一次调用发生时再从容器中获取Bean。

<!-- tabs:end -->


### **4.1.4. Automatic Registration of MBeans** 

<!-- tabs:start -->

#### ** English **

Any beans that are exported through the `MBeanExporter` and are already valid MBeans are registered as-is with the `MBeanServer` without further intervention from Spring. You can cause MBeans to be automatically detected by the `MBeanExporter` by setting the `autodetect` property to `true`, as the following example shows:
#### ** Chinese **

任何通过 `MBeanExporter`导出的、已经是有效的 MBeans 的 Bean 都会在 `MBeanServer` 中注册，而无需 Spring 进一步干预。您可以通过将 `MBeanExporter` 属性设置为 `autodetect` 为 `true`，从而使 MBeans 被 `MBeanExporter` 自动检测到，如下示例所示。

<!-- tabs:end -->


```xml
<bean id="exporter" class="org.springframework.jmx.export.MBeanExporter">
    <property name="autodetect" value="true"/>
</bean>

<bean name="spring:mbean=true" class="org.springframework.jmx.export.TestDynamicMBean"/>
```

<!-- tabs:start -->

#### ** English **

In the preceding example, the bean called `spring:mbean=true` is already a valid JMX MBean and is automatically registered by Spring. By default, a bean that is autodetected for JMX registration has its bean name used as the `ObjectName`. You can override this behavior, as detailed in [Controlling ](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#jmx-naming)[`ObjectName`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#jmx-naming)[ Instances for Your Beans](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#jmx-naming).
#### ** Chinese **

在前面的例子中，名为`spring:mbean=true`的Bean已经是一个有效的JMX MBean，并被Spring自动注册。默认情况下，被自动检测为 JMX 注册的 bean 会使用其 bean 名作为 `ObjectName`。您可以覆盖此行为，详见 [Control](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#jmx-naming)[`ObjectName`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#jmx-naming)[Instances for Your Beans](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#jmx-naming)。

<!-- tabs:end -->


### **4.1.5. Controlling the Registration Behavior** 

<!-- tabs:start -->

#### ** English **

Consider the scenario where a Spring `MBeanExporter` attempts to register an `MBean` with an `MBeanServer` by using the `ObjectName` `bean:name=testBean1`. If an `MBean` instance has already been registered under that same `ObjectName`, the default behavior is to fail (and throw an `InstanceAlreadyExistsException`).
#### ** Chinese **

考虑这样的场景：Spring `MBeanExporter`试图通过使用`ObjectName` `ObjectName` `bean:name=testBean1`将一个`MBean`注册到一个`MBeanServer`。如果一个`MBean`实例已经在同一`ObjectName`下注册了，默认行为是失败（并抛出一个`InstanceAlreadyExistsException`）。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can control exactly what happens when an `MBean` is registered with an `MBeanServer`. Spring’s JMX support allows for three different registration behaviors to control the registration behavior when the registration process finds that an `MBean` has already been registered under the same `ObjectName`. The following table summarizes these registration behaviors:
#### ** Chinese **

您可以精确控制当一个`MBean`与一个`MBeanServer`注册时发生的事情。Spring 的 JMX 支持三种不同的注册行为，当注册过程中发现 `MBean`已经在同一个 `ObjectName`下注册了一个 `MBean`时，可以控制注册行为。下表总结了这些注册行为。

<!-- tabs:end -->


Registration behavior | Explanation 
-|-
FAIL_ON_EXISTING | This is the default registration behavior. If an MBean instance has already been registered under the same ObjectName, the MBean that is being registered is not registered, and an InstanceAlreadyExistsException is thrown. The existing MBean is unaffected. 
IGNORE_EXISTING | If an MBean instance has already been registered under the same ObjectName, the MBean that is being registered is not registered. The existing MBean is unaffected, and no Exception is thrown. This is useful in settings where multiple applications want to share a common MBean in a shared MBeanServer. 
REPLACE_EXISTING | If an MBean instance has already been registered under the same ObjectName, the existing MBean that was previously registered is unregistered, and the new MBean is registered in its place (the new MBean effectively replaces the previous instance). 


<!-- tabs:start -->

#### ** English **

The values in the preceding table are defined as enums on the `RegistrationPolicy` class. If you want to change the default registration behavior, you need to set the value of the `registrationPolicy` property on your `MBeanExporter` definition to one of those values.
#### ** Chinese **

上表中的值是在`RegistrationPolicy`类中定义为enums。如果您想改变默认的注册行为，您需要将`MBeanExporter`定义中的`registrationPolicy`属性的值设置为这些值中的一个。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following example shows how to change from the default registration behavior to the `REPLACE_EXISTING` behavior:
#### ** Chinese **

下面的示例显示了如何将默认注册行为改为`REPLACE_EXISTING`行为。

<!-- tabs:end -->


```xml
<beans>

    <bean id="exporter" class="org.springframework.jmx.export.MBeanExporter">
        <property name="beans">
            <map>
                <entry key="bean:name=testBean1" value-ref="testBean"/>
            </map>
        </property>
        <property name="registrationPolicy" value="REPLACE_EXISTING"/>
    </bean>

    <bean id="testBean" class="org.springframework.jmx.JmxTestBean">
        <property name="name" value="TEST"/>
        <property name="age" value="100"/>
    </bean>

</beans>
```

### **4.2. Controlling the Management Interface of Your Beans** 

<!-- tabs:start -->

#### ** English **

In the example in the [preceding section](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#jmx-exporting-registration-behavior), you had little control over the management interface of your bean. All of the `public` properties and methods of each exported bean were exposed as JMX attributes and operations, respectively. To exercise finer-grained control over exactly which properties and methods of your exported beans are actually exposed as JMX attributes and operations, Spring JMX provides a comprehensive and extensible mechanism for controlling the management interfaces of your beans.
#### ** Chinese **

在[上一节](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#jmx-exporting-registration-behavior)的例子中，你对Bean的管理界面几乎没有什么控制权。每个导出的Bean的所有`public`属性和方法都分别以JMX属性和操作的形式暴露出来。为了对导出的Bean的哪些属性和方法作为JMX属性和操作进行更精细的控制，Spring JMX提供了一个全面和可扩展的机制来控制Bean的管理接口。

<!-- tabs:end -->


### **4.2.1. Using the** **`MBeanInfoAssembler`** ** Interface** 

<!-- tabs:start -->

#### ** English **

Behind the scenes, the `MBeanExporter` delegates to an implementation of the `org.springframework.jmx.export.assembler.MBeanInfoAssembler` interface, which is responsible for defining the management interface of each bean that is exposed. The default implementation, `org.springframework.jmx.export.assembler.SimpleReflectiveMBeanInfoAssembler`, defines a management interface that exposes all public properties and methods (as you saw in the examples in the preceding sections). Spring provides two additional implementations of the `MBeanInfoAssembler` interface that let you control the generated management interface by using either source-level metadata or any arbitrary interface.
#### ** Chinese **

在幕后，`MBeanExporter`委托给`org.springframework.jmx.export.assembler.MBeanInfoAssembler`接口的实现，该接口负责定义每个Bean暴露的管理接口。默认的实现`org.springframework.jmx.export.assembler.SimpleReflectiveMBeanInfoAssembler`定义了一个管理接口，它公开了所有的公共属性和方法（正如你在前面的例子中看到的那样）。Spring 提供了两个额外的 `MBeanInfoAssembler`接口的实现，让你可以通过使用源级元数据或任意接口来控制生成的管理接口。

<!-- tabs:end -->


### **4.2.2. Using Source-level Metadata: Java Annotations** 

<!-- tabs:start -->

#### ** English **

By using the `MetadataMBeanInfoAssembler`, you can define the management interfaces for your beans by using source-level metadata. The reading of metadata is encapsulated by the `org.springframework.jmx.export.metadata.JmxAttributeSource` interface. Spring JMX provides a default implementation that uses Java annotations, namely `org.springframework.jmx.export.annotation.AnnotationJmxAttributeSource`. You must configure the `MetadataMBeanInfoAssembler` with an implementation instance of the `JmxAttributeSource` interface for it to function correctly (there is no default).
#### ** Chinese **

通过使用`MetadataMBeanInfoAssembler`，你可以使用源级元数据来定义你的Bean的管理接口。元数据的读取由`org.springframework.jmx.export.metadata.JmxAttributeSource`接口封装。Spring JMX提供了一个使用Java注释的默认实现，即`org.springframework.jmx.export.annotation.AnnotationJmxAttributeSource`。您必须将 `MetadataMBeanInfoAssembler`配置为`JmxAttributeSource`接口的实现实例，这样它才能正常运行（没有默认的）。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

To mark a bean for export to JMX, you should annotate the bean class with the `ManagedResource` annotation. You must mark each method you wish to expose as an operation with the `ManagedOperation` annotation and mark each property you wish to expose with the `ManagedAttribute` annotation. When marking properties, you can omit either the annotation of the getter or the setter to create a write-only or read-only attribute, respectively.
#### ** Chinese **

要标记一个Bean导出到JMX，你应该用`ManagedResource`注释来注释Bean类。你必须用 `ManagedOperation` 注解标记每个你想作为操作暴露的方法，并用 `ManagedAttribute` 注解标记每个属性。在标记属性时，你可以省略getter或setter的注解，分别创建一个只写或只读属性。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

A `ManagedResource`-annotated bean must be public, as must the methods exposing an operation or an attribute.
#### ** Chinese **

一个`ManagedResource`-annotated bean必须是公共的，暴露操作或属性的方法也必须是公共的。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following example shows the annotated version of the `JmxTestBean` class that we used in [Creating an MBeanServer](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#jmx-exporting-mbeanserver):
#### ** Chinese **

下面的示例显示了我们在[创建MBeanServer](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#jmx-exporting-mbeanserver)中使用的`JmxTestBean`类的注释版本。

<!-- tabs:end -->


```java
package org.springframework.jmx;

import org.springframework.jmx.export.annotation.ManagedResource;
import org.springframework.jmx.export.annotation.ManagedOperation;
import org.springframework.jmx.export.annotation.ManagedAttribute;

@ManagedResource(
        objectName="bean:name=testBean4",
        description="My Managed Bean",
        log=true,
        logFile="jmx.log",
        currencyTimeLimit=15,
        persistPolicy="OnUpdate",
        persistPeriod=200,
        persistLocation="foo",
        persistName="bar")
public class AnnotationTestBean implements IJmxTestBean {

    private String name;
    private int age;

    @ManagedAttribute(description="The Age Attribute", currencyTimeLimit=15)
    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @ManagedAttribute(description="The Name Attribute",
            currencyTimeLimit=20,
            defaultValue="bar",
            persistPolicy="OnUpdate")
    public void setName(String name) {
        this.name = name;
    }

    @ManagedAttribute(defaultValue="foo", persistPeriod=300)
    public String getName() {
        return name;
    }

    @ManagedOperation(description="Add two numbers")
    @ManagedOperationParameters({
        @ManagedOperationParameter(name = "x", description = "The first number"),
        @ManagedOperationParameter(name = "y", description = "The second number")})
    public int add(int x, int y) {
        return x + y;
    }

    public void dontExposeMe() {
        throw new RuntimeException();
    }

}
```

<!-- tabs:start -->

#### ** English **

In the preceding example, you can see that the `JmxTestBean` class is marked with the `ManagedResource` annotation and that this `ManagedResource` annotation is configured with a set of properties. These properties can be used to configure various aspects of the MBean that is generated by the `MBeanExporter` and are explained in greater detail later in [Source-level Metadata Types](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#jmx-interface-metadata-types).
#### ** Chinese **

在前面的例子中，你可以看到`JmxTestBean`类被标记为`ManagedResource`注释，并且这个`ManagedResource`注释被配置了一组属性。这些属性可以用来配置由`MBeanExporter`生成的MBean的各个方面，并在后面的[源级元数据类型](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#jmx-interface-metadata-types)中详细说明。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Both the `age` and `name` properties are annotated with the `ManagedAttribute` annotation, but, in the case of the `age` property, only the getter is marked. This causes both of these properties to be included in the management interface as attributes, but the `age` attribute is read-only.
#### ** Chinese **

`age`和`name`属性都被注释为`ManagedAttribute`属性，但对于`age`属性，只有getter被标记为属性。这导致这两个属性都作为属性包含在管理界面中，但`age`属性是只读的。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Finally, the `add(int, int)` method is marked with the `ManagedOperation` attribute, whereas the `dontExposeMe()` method is not. This causes the management interface to contain only one operation (`add(int, int)`) when you use the `MetadataMBeanInfoAssembler`.
#### ** Chinese **

最后，`add(int,int)`方法被标记为`ManagedOperation`属性，而`dontExposeMe()`方法没有。这导致当您使用 `MetadataMBeanInfoAssembler`时，管理界面只包含一个操作(`add(int, int)`)。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following configuration shows how you can configure the `MBeanExporter` to use the `MetadataMBeanInfoAssembler`:
#### ** Chinese **

下面的配置显示了如何配置`MBeanExporter`来使用`MetadataMBeanInfoAssembler`。

<!-- tabs:end -->


```xml
<beans>
    <bean id="exporter" class="org.springframework.jmx.export.MBeanExporter">
        <property name="assembler" ref="assembler"/>
        <property name="namingStrategy" ref="namingStrategy"/>
        <property name="autodetect" value="true"/>
    </bean>

    <bean id="jmxAttributeSource"
            class="org.springframework.jmx.export.annotation.AnnotationJmxAttributeSource"/>

    <!-- will create management interface using annotation metadata -->
    <bean id="assembler"
            class="org.springframework.jmx.export.assembler.MetadataMBeanInfoAssembler">
        <property name="attributeSource" ref="jmxAttributeSource"/>
    </bean>

    <!-- will pick up the ObjectName from the annotation -->
    <bean id="namingStrategy"
            class="org.springframework.jmx.export.naming.MetadataNamingStrategy">
        <property name="attributeSource" ref="jmxAttributeSource"/>
    </bean>

    <bean id="testBean" class="org.springframework.jmx.AnnotationTestBean">
        <property name="name" value="TEST"/>
        <property name="age" value="100"/>
    </bean>
</beans>
```

<!-- tabs:start -->

#### ** English **

In the preceding example, an `MetadataMBeanInfoAssembler` bean has been configured with an instance of the `AnnotationJmxAttributeSource` class and passed to the `MBeanExporter` through the assembler property. This is all that is required to take advantage of metadata-driven management interfaces for your Spring-exposed MBeans.
#### ** Chinese **

在前面的例子中，一个`MetadataMBeanInfoAssembler` bean已经配置了一个`AnnotationJmxAttributeSource`类的实例，并通过assembler属性传递给`MBeanExporter`。这就是利用元数据驱动的管理接口为您的Spring暴露的MBeans提供的所有必要条件。

<!-- tabs:end -->


### **4.2.3. Source-level Metadata Types** 

<!-- tabs:start -->

#### ** English **

The following table describes the source-level metadata types that are available for use in Spring JMX:
#### ** Chinese **

下表描述了Spring JMX中可用的源级元数据类型。

<!-- tabs:end -->


Purpose | Annotation | Annotation Type 
-|-|-
Mark all instances of a Class as JMX managed resources. | @ManagedResource | Class 
Mark a method as a JMX operation. | @ManagedOperation | Method 
Mark a getter or setter as one half of a JMX attribute. | @ManagedAttribute | Method (only getters and setters) 
Define descriptions for operation parameters. | @ManagedOperationParameter and @ManagedOperationParameters | Method 


<!-- tabs:start -->

#### ** English **

The following table describes the configuration parameters that are available for use on these source-level metadata types:
#### ** Chinese **

下表描述了可用于这些源级元数据类型的配置参数。

<!-- tabs:end -->


Parameter | Description | Applies to 
-|-|-
ObjectName | Used by MetadataNamingStrategy to determine the ObjectName of a managed resource. | ManagedResource 
description | Sets the friendly description of the resource, attribute or operation. | ManagedResource, ManagedAttribute, ManagedOperation, or ManagedOperationParameter 
currencyTimeLimit | Sets the value of the currencyTimeLimit descriptor field. | ManagedResource or ManagedAttribute 
defaultValue | Sets the value of the defaultValue descriptor field. | ManagedAttribute 
log | Sets the value of the log descriptor field. | ManagedResource 
logFile | Sets the value of the logFile descriptor field. | ManagedResource 
persistPolicy | Sets the value of the persistPolicy descriptor field. | ManagedResource 
persistPeriod | Sets the value of the persistPeriod descriptor field. | ManagedResource 
persistLocation | Sets the value of the persistLocation descriptor field. | ManagedResource 
persistName | Sets the value of the persistName descriptor field. | ManagedResource 
name | Sets the display name of an operation parameter. | ManagedOperationParameter 
index | Sets the index of an operation parameter. | ManagedOperationParameter 


### **4.2.4. Using the** **`AutodetectCapableMBeanInfoAssembler`** ** Interface** 

<!-- tabs:start -->

#### ** English **

To simplify configuration even further, Spring includes the `AutodetectCapableMBeanInfoAssembler` interface, which extends the `MBeanInfoAssembler` interface to add support for autodetection of MBean resources. If you configure the `MBeanExporter` with an instance of `AutodetectCapableMBeanInfoAssembler`, it is allowed to “vote” on the inclusion of beans for exposure to JMX.
#### ** Chinese **

为了进一步简化配置，Spring包含了`AutodetectCapableMBeanInfoAssembler`接口，它扩展了`MBeanInfoAssembler`接口，以增加对MBean资源自动检测的支持。如果您用`AutodetectCapableMBeanInfoAssembler`的实例配置了`MBeanExporter`，则允许它 投票 将Bean包含在JMX中。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The only implementation of the `AutodetectCapableMBeanInfo` interface is the `MetadataMBeanInfoAssembler`, which votes to include any bean that is marked with the `ManagedResource` attribute. The default approach in this case is to use the bean name as the `ObjectName`, which results in a configuration similar to the following:
#### ** Chinese **

`AutodetectCapableMBeanInfo`接口的唯一实现是`MetadataMBeanInfoAssembler`，它投票包含任何标记有`ManagedResource`属性的Bean。在这种情况下，默认的方法是使用bean名称作为`ObjectName`，其结果是类似于下面的配置。

<!-- tabs:end -->


```xml
<beans>

    <bean id="exporter" class="org.springframework.jmx.export.MBeanExporter">
        <!-- notice how no 'beans' are explicitly configured here -->
        <property name="autodetect" value="true"/>
        <property name="assembler" ref="assembler"/>
    </bean>

    <bean id="testBean" class="org.springframework.jmx.JmxTestBean">
        <property name="name" value="TEST"/>
        <property name="age" value="100"/>
    </bean>

    <bean id="assembler" class="org.springframework.jmx.export.assembler.MetadataMBeanInfoAssembler">
        <property name="attributeSource">
            <bean class="org.springframework.jmx.export.annotation.AnnotationJmxAttributeSource"/>
        </property>
    </bean>

</beans>
```

<!-- tabs:start -->

#### ** English **

Notice that, in the preceding configuration, no beans are passed to the `MBeanExporter`. However, the `JmxTestBean` is still registered, since it is marked with the `ManagedResource` attribute and the `MetadataMBeanInfoAssembler` detects this and votes to include it. The only problem with this approach is that the name of the `JmxTestBean` now has business meaning. You can address this issue by changing the default behavior for `ObjectName` creation as defined in [Controlling ](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#jmx-naming)[`ObjectName`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#jmx-naming)[ Instances for Your Beans](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#jmx-naming).
#### ** Chinese **

注意，在前面的配置中，没有向`MBeanExporter`传递任何Bean。然而，`JmxTestBean`仍然被注册，因为它被标记为`ManagedResource`属性，而`MetadataMBeanInfoAssembler`检测到这一点并投票将其包含在内。这种方法的唯一问题是`JmxTestBean`的名称现在具有商业意义。你可以通过改变`ObjectName`创建`的默认行为来解决这个问题，如[Controlling](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#jmx-naming)[<x>ObjectName`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#jmx-naming)[Instances for Your Beans](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#jmx-naming)中定义的那样。

<!-- tabs:end -->


### **4.2.5. Defining Management Interfaces by Using Java Interfaces** 

<!-- tabs:start -->

#### ** English **

In addition to the `MetadataMBeanInfoAssembler`, Spring also includes the `InterfaceBasedMBeanInfoAssembler`, which lets you constrain the methods and properties that are exposed based on the set of methods defined in a collection of interfaces.
#### ** Chinese **

除了`MetadataMBeanInfoAssembler`之外，Spring还包括`InterfaceBasedMBeanInfoAssembler`，它可以让您根据在接口集合中定义的方法集来约束暴露的方法和属性。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Although the standard mechanism for exposing MBeans is to use interfaces and a simple naming scheme, `InterfaceBasedMBeanInfoAssembler` extends this functionality by removing the need for naming conventions, letting you use more than one interface and removing the need for your beans to implement the MBean interfaces.
#### ** Chinese **

尽管暴露 MBeans 的标准机制是使用接口和简单的命名方案，但 `InterfaceBasedMBeanInfoAssembler`通过取消了对命名惯例的需求，让您可以使用一个以上的接口，并取消了对您的 bean 实现 MBean 接口的需求，从而扩展了这一功能。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Consider the following interface, which is used to define a management interface for the `JmxTestBean` class that we showed earlier:
#### ** Chinese **

考虑一下下面的接口，它用于为我们前面展示的`JmxTestBean`类定义一个管理接口。

<!-- tabs:end -->


```java
public interface IJmxTestBean {

    public int add(int x, int y);

    public long myOperation();

    public int getAge();

    public void setAge(int age);

    public void setName(String name);

    public String getName();

}
```

<!-- tabs:start -->

#### ** English **

This interface defines the methods and properties that are exposed as operations and attributes on the JMX MBean. The following code shows how to configure Spring JMX to use this interface as the definition for the management interface:
#### ** Chinese **

这个接口定义了JMX MBean上作为操作和属性的方法和属性。下面的代码显示了如何配置Spring JMX使用此接口作为管理接口的定义。

<!-- tabs:end -->


```xml
<beans>

    <bean id="exporter" class="org.springframework.jmx.export.MBeanExporter">
        <property name="beans">
            <map>
                <entry key="bean:name=testBean5" value-ref="testBean"/>
            </map>
        </property>
        <property name="assembler">
            <bean class="org.springframework.jmx.export.assembler.InterfaceBasedMBeanInfoAssembler">
                <property name="managedInterfaces">
                    <value>org.springframework.jmx.IJmxTestBean</value>
                </property>
            </bean>
        </property>
    </bean>

    <bean id="testBean" class="org.springframework.jmx.JmxTestBean">
        <property name="name" value="TEST"/>
        <property name="age" value="100"/>
    </bean>

</beans>
```

<!-- tabs:start -->

#### ** English **

In the preceding example, the `InterfaceBasedMBeanInfoAssembler` is configured to use the `IJmxTestBean` interface when constructing the management interface for any bean. It is important to understand that beans processed by the `InterfaceBasedMBeanInfoAssembler` are not required to implement the interface used to generate the JMX management interface.
#### ** Chinese **

在前面的例子中，`InterfaceBasedMBeanInfoAssembler`被配置为使用`IJmxTestBean`接口，为任何Bean构建管理接口时，都要使用`IJmxTestBean`接口。重要的是要明白，由 `InterfaceBasedMBeanInfoAssembler`处理的 Bean 不需要实现用于生成 JMX 管理接口的接口。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

In the preceding case, the `IJmxTestBean` interface is used to construct all management interfaces for all beans. In many cases, this is not the desired behavior, and you may want to use different interfaces for different beans. In this case, you can pass `InterfaceBasedMBeanInfoAssembler` a `Properties` instance through the `interfaceMappings` property, where the key of each entry is the bean name and the value of each entry is a comma-separated list of interface names to use for that bean.
#### ** Chinese **

在前面的例子中，`IJmxTestBean`接口用于构造所有Bean的所有管理接口。在许多情况下，这不是理想的行为，你可能希望对不同的Bean使用不同的接口。在这种情况下，您可以通过`interfaceMappings`属性向`InterfaceBasedMBeanInfoAssembler`传递一个`Properties`实例，其中每个条目的键是Bean的名称，而每个条目的值是由逗号分隔的接口名称列表，用于该Bean。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

If no management interface is specified through either the `managedInterfaces` or `interfaceMappings` properties, the `InterfaceBasedMBeanInfoAssembler` reflects on the bean and uses all of the interfaces implemented by that bean to create the management interface.
#### ** Chinese **

如果没有通过`managedInterfaces`或`interfaceMappings`属性指定管理接口，`InterfaceBasedMBeanInfoAssembler`就会反映到Bean上，并使用该Bean实现的所有接口来创建管理接口。

<!-- tabs:end -->


### **4.2.6. Using** **`MethodNameBasedMBeanInfoAssembler`** 

<!-- tabs:start -->

#### ** English **

`MethodNameBasedMBeanInfoAssembler` lets you specify a list of method names that are exposed to JMX as attributes and operations. The following code shows a sample configuration:
#### ** Chinese **

`MethodNameBasedMBeanInfoAssembler`可以让你指定一个方法名列表，这些方法名作为属性和操作暴露给JMX。下面的代码显示了一个示例配置。

<!-- tabs:end -->


```xml
<bean id="exporter" class="org.springframework.jmx.export.MBeanExporter">
    <property name="beans">
        <map>
            <entry key="bean:name=testBean5" value-ref="testBean"/>
        </map>
    </property>
    <property name="assembler">
        <bean class="org.springframework.jmx.export.assembler.MethodNameBasedMBeanInfoAssembler">
            <property name="managedMethods">
                <value>add,myOperation,getName,setName,getAge</value>
            </property>
        </bean>
    </property>
</bean>
```

<!-- tabs:start -->

#### ** English **

In the preceding example, you can see that the `add` and `myOperation` methods are exposed as JMX operations, and `getName()`, `setName(String)`, and `getAge()` are exposed as the appropriate half of a JMX attribute. In the preceding code, the method mappings apply to beans that are exposed to JMX. To control method exposure on a bean-by-bean basis, you can use the `methodMappings` property of `MethodNameMBeanInfoAssembler` to map bean names to lists of method names.
#### ** Chinese **

在前面的示例中，可以看到 `add`和`myOperation`方法被作为JMX操作暴露出来，而`getName()`、`setName(String)`和`getAge()`则作为JMX属性的适当一半暴露出来。在前面的代码中，方法映射适用于暴露在JMX中的Bean。要逐一控制方法曝光，可以使用 `MethodNameMBeanInfoAssembler`的 `methodMappings` 属性来将bean名映射到方法名列表。

<!-- tabs:end -->


### **4.3. Controlling** **`ObjectName`** ** Instances for Your Beans** 

<!-- tabs:start -->

#### ** English **

Behind the scenes, the `MBeanExporter` delegates to an implementation of the `ObjectNamingStrategy` to obtain an `ObjectName` instance for each of the beans it registers. By default, the default implementation, `KeyNamingStrategy` uses the key of the `beans` `Map` as the `ObjectName`. In addition, the `KeyNamingStrategy` can map the key of the `beans` `Map` to an entry in a `Properties` file (or files) to resolve the `ObjectName`. In addition to the `KeyNamingStrategy`, Spring provides two additional `ObjectNamingStrategy` implementations: the `IdentityNamingStrategy` (which builds an `ObjectName` based on the JVM identity of the bean) and the `MetadataNamingStrategy` (which uses source-level metadata to obtain the `ObjectName`).
#### ** Chinese **

在幕后，`MBeanExporter`委托给`ObjectNamingStrategy`的实现，以便为它注册的每个bean获取一个`ObjectName`实例。默认情况下，默认实现`KeyNamingStrategy`使用`beans` `Map`的key作为`ObjectName`的`ObjectName`。此外，`KeyNamingStrategy`可以将`beans` `Map`中的键映射到`Properties`文件（或文件）中的条目，以解析`ObjectName`。除了`KeyNamingStrategy`之外，Spring还提供了两个额外的`ObjectNamingStrategy`实现。`IdentityNamingStrategy`（它基于Bean的JVM身份建立一个`ObjectName`）和`MetadataNamingStrategy`（它使用源级元数据来获取`ObjectName`）。

<!-- tabs:end -->


### **4.3.1. Reading** **`ObjectName`** ** Instances from Properties** 

<!-- tabs:start -->

#### ** English **

You can configure your own `KeyNamingStrategy` instance and configure it to read `ObjectName` instances from a `Properties` instance rather than use a bean key. The `KeyNamingStrategy` tries to locate an entry in the `Properties` with a key that corresponds to the bean key. If no entry is found or if the `Properties` instance is `null`, the bean key itself is used.
#### ** Chinese **

您可以配置自己的`KeyNamingStrategy`实例，并将其配置为从`Properties`实例中读取`ObjectName`实例，而不是使用Bean键。`KeyNamingStrategy`试图在`Properties`中找到一个与Bean键相对应的条目。如果没有找到条目，或者`Properties`实例为`null`，则使用Bean键本身。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following code shows a sample configuration for the `KeyNamingStrategy`:
#### ** Chinese **

下面的代码显示了`KeyNamingStrategy`的示例配置。

<!-- tabs:end -->


```xml
<beans>

    <bean id="exporter" class="org.springframework.jmx.export.MBeanExporter">
        <property name="beans">
            <map>
                <entry key="testBean" value-ref="testBean"/>
            </map>
        </property>
        <property name="namingStrategy" ref="namingStrategy"/>
    </bean>

    <bean id="testBean" class="org.springframework.jmx.JmxTestBean">
        <property name="name" value="TEST"/>
        <property name="age" value="100"/>
    </bean>

    <bean id="namingStrategy" class="org.springframework.jmx.export.naming.KeyNamingStrategy">
        <property name="mappings">
            <props>
                <prop key="testBean">bean:name=testBean1</prop>
            </props>
        </property>
        <property name="mappingLocations">
            <value>names1.properties,names2.properties</value>
        </property>
    </bean>

</beans>
```

<!-- tabs:start -->

#### ** English **

The preceding example configures an instance of `KeyNamingStrategy` with a `Properties` instance that is merged from the `Properties` instance defined by the mapping property and the properties files located in the paths defined by the mappings property. In this configuration, the `testBean` bean is given an `ObjectName` of `bean:name=testBean1`, since this is the entry in the `Properties` instance that has a key corresponding to the bean key.
#### ** Chinese **

前面的例子配置了一个`KeyNamingStrategy`的实例，该实例是由映射属性定义的`Properties`实例和位于mappings属性定义的路径中的属性文件合并而成的。在此配置中，`testBean` bean被赋予了`bean:name=testBean1`的`ObjectName`，因为这是`Properties`实例中的条目，该条目具有与Bean键相对应的键。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

If no entry in the `Properties` instance can be found, the bean key name is used as the `ObjectName`.
#### ** Chinese **

如果在`Properties`实例中没有找到条目，则使用Bean键名作为`ObjectName`。

<!-- tabs:end -->


### **4.3.2. Using** **`MetadataNamingStrategy`** 

<!-- tabs:start -->

#### ** English **

`MetadataNamingStrategy` uses the `objectName` property of the `ManagedResource` attribute on each bean to create the `ObjectName`. The following code shows the configuration for the `MetadataNamingStrategy`:
#### ** Chinese **

`MetadataNamingStrategy`使用每个Bean上的`ManagedResource`属性的`objectName`属性来创建`ObjectName`。下面的代码显示了`MetadataNamingStrategy`的配置。

<!-- tabs:end -->


```xml
<beans>

    <bean id="exporter" class="org.springframework.jmx.export.MBeanExporter">
        <property name="beans">
            <map>
                <entry key="testBean" value-ref="testBean"/>
            </map>
        </property>
        <property name="namingStrategy" ref="namingStrategy"/>
    </bean>

    <bean id="testBean" class="org.springframework.jmx.JmxTestBean">
        <property name="name" value="TEST"/>
        <property name="age" value="100"/>
    </bean>

    <bean id="namingStrategy" class="org.springframework.jmx.export.naming.MetadataNamingStrategy">
        <property name="attributeSource" ref="attributeSource"/>
    </bean>

    <bean id="attributeSource"
            class="org.springframework.jmx.export.annotation.AnnotationJmxAttributeSource"/>

</beans>
```

<!-- tabs:start -->

#### ** English **

If no `objectName` has been provided for the `ManagedResource` attribute, an `ObjectName` is created with the following format: *[fully-qualified-package-name]:type=[short-classname],name=[bean-name]*. For example, the generated `ObjectName` for the following bean would be `com.example:type=MyClass,name=myBean`:
#### ** Chinese **

如果没有为`ManagedResource`属性提供`objectName`，则会创建一个`ObjectName`，其格式如下。 *[完全限定-包名]:type=[short-classname],name=[bean-name]*。例如，为下面的Bean生成的`ObjectName`将是`com.example:type=MyClass,name=myBean`。

<!-- tabs:end -->


```xml
<bean id="myBean" class="com.example.MyClass"/>
```

### **4.3.3. Configuring Annotation-based MBean Export** 

<!-- tabs:start -->

#### ** English **

If you prefer to use [the annotation-based approach](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#jmx-interface-metadata) to define your management interfaces, a convenience subclass of `MBeanExporter` is available: `AnnotationMBeanExporter`. When defining an instance of this subclass, you no longer need the `namingStrategy`, `assembler`, and `attributeSource` configuration, since it always uses standard Java annotation-based metadata (autodetection is always enabled as well). In fact, rather than defining an `MBeanExporter` bean, an even simpler syntax is supported by the `@EnableMBeanExport` `@Configuration` annotation, as the following example shows:
#### ** Chinese **

如果你喜欢使用[基于注释的方法](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#jmx-interface-metadata)来定义你的管理接口，那么`MBeanExporter`的一个方便的子类就可以使用。 `AnnotationMBeanExporter`的方便子类：`AnnotationMBeanExporter`。在定义这个子类的实例时，您不再需要`namingStrategy`、`assembler`和`attributeSource`配置，因为它总是使用标准的基于Java注释的元数据（自动检测也总是被启用）。事实上，与其定义一个`MBeanExporter` bean，不如定义一个`@EnableMBeanExport` `@Configuration`注解支持一个更简单的语法，如下例所示。

<!-- tabs:end -->


```java
@Configuration
@EnableMBeanExport
public class AppConfig {

}
```

<!-- tabs:start -->

#### ** English **

If you prefer XML-based configuration, the `<context:mbean-export/>` element serves the same purpose and is shown in the following listing:
#### ** Chinese **

如果你喜欢基于XML的配置，`<context:mbean-export/>`元素也有同样的作用，如下表所示。

<!-- tabs:end -->


```xml
<context:mbean-export/>
```

<!-- tabs:start -->

#### ** English **

If necessary, you can provide a reference to a particular MBean `server`, and the `defaultDomain` attribute (a property of `AnnotationMBeanExporter`) accepts an alternate value for the generated MBean `ObjectName` domains. This is used in place of the fully qualified package name as described in the previous section on [MetadataNamingStrategy](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#jmx-naming-metadata), as the following example shows:
#### ** Chinese **

如果需要，您可以提供一个特定 MBean `server`的引用，而 `defaultDomain`属性（`AnnotationMBeanExporter`的一个属性）可以接受生成的 MBean `ObjectName`域的替代值。如下面的例子所示，它用来代替前面关于[MetadataNamingStrategy](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#jmx-naming-metadata)一节中描述的完全限定的包名，这一点在下面的例子中显示。

<!-- tabs:end -->


```java
@EnableMBeanExport(server="myMBeanServer", defaultDomain="myDomain")
@Configuration
ContextConfiguration {

}
```

<!-- tabs:start -->

#### ** English **

The following example shows the XML equivalent of the preceding annotation-based example:
#### ** Chinese **

下面的例子显示了与前面的基于注释的例子的XML等价物。

<!-- tabs:end -->


```xml
<context:mbean-export server="myMBeanServer" default-domain="myDomain"/>
```

<!-- tabs:start -->

#### ** English **

Do not use interface-based AOP proxies in combination with autodetection of JMX annotations in your bean classes. Interface-based proxies “hide” the target class, which also hides the JMX-managed resource annotations. Hence, you should use target-class proxies in that case (through setting the 'proxy-target-class' flag on `<aop:config/>`, `<tx:annotation-driven/>` and so on). Otherwise, your JMX beans might be silently ignored at startup.
#### ** Chinese **

不要将基于接口的AOP代理与Bean类中的JMX注释的自动检测结合起来使用。基于接口的代理会 隐藏 目标类，而目标类也会隐藏JMX管理的资源注释。因此，在这种情况下应该使用目标类代理（通过在 `<aop:config/>`、`<tx:annotation-driven/>`等处设置 proxy-target-class 标志）。否则，您的 JMX Bean 可能会在启动时被忽略。

<!-- tabs:end -->


### **4.4. Using JSR-160 Connectors** 

<!-- tabs:start -->

#### ** English **

For remote access, Spring JMX module offers two `FactoryBean` implementations inside the `org.springframework.jmx.support` package for creating both server- and client-side connectors.
#### ** Chinese **

对于远程访问，Spring JMX模块在`org.springframework.jmx.support`包内提供了两个`FactoryBean`实现，用于创建服务器端和客户端连接器。

<!-- tabs:end -->


### **4.4.1. Server-side Connectors** 

<!-- tabs:start -->

#### ** English **

To have Spring JMX create, start, and expose a JSR-160 `JMXConnectorServer`, you can use the following configuration:
#### ** Chinese **

要让Spring JMX创建、启动并暴露JSR-160 `JMXConnectorServer`，可以使用以下配置。

<!-- tabs:end -->


```xml
<bean id="serverConnector" class="org.springframework.jmx.support.ConnectorServerFactoryBean"/>
```

<!-- tabs:start -->

#### ** English **

By default, `ConnectorServerFactoryBean` creates a `JMXConnectorServer` bound to `service:jmx:jmxmp://localhost:9875`. The `serverConnector` bean thus exposes the local `MBeanServer` to clients through the JMXMP protocol on localhost, port 9875. Note that the JMXMP protocol is marked as optional by the JSR 160 specification. Currently, the main open-source JMX implementation, MX4J, and the one provided with the JDK do not support JMXMP.
#### ** Chinese **

默认情况下，`ConnectorServerFactoryBean`会创建一个`JMXConnectorServer`绑定到`service:jmx:jmxmp://localhost:9875`。这样，`serverConnector` bean就通过localhost上的JMXMP协议，即9875端口，将本地的`MBeanServer`暴露给客户端。注意，JMXMP协议在JSR 160规范中被标记为可选的。目前，主要的开源JMX实现MX4J和JDK提供的JMXMP实现都不支持JMXMP。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

To specify another URL and register the `JMXConnectorServer` itself with the `MBeanServer`, you can use the `serviceUrl` and `ObjectName` properties, respectively, as the following example shows:
#### ** Chinese **

要指定另一个URL并将`JMXConnectorServer`本身与`MBeanServer`注册，可以分别使用`serviceUrl`和`ObjectName`属性，如下例所示。

<!-- tabs:end -->


```xml
<bean id="serverConnector"
        class="org.springframework.jmx.support.ConnectorServerFactoryBean">
    <property name="objectName" value="connector:name=rmi"/>
    <property name="serviceUrl"
            value="service:jmx:rmi://localhost/jndi/rmi://localhost:1099/myconnector"/>
</bean>
```

<!-- tabs:start -->

#### ** English **

If the `ObjectName` property is set, Spring automatically registers your connector with the `MBeanServer` under that `ObjectName`. The following example shows the full set of parameters that you can pass to the `ConnectorServerFactoryBean` when creating a `JMXConnector`:
#### ** Chinese **

如果设置了 `ObjectName` 属性，Spring 将自动在该 `ObjectName`下的 `MBeanServer` 中注册连接器。下面的示例显示了创建 `JMXConnector`时可以传递给 `ConnectorServerFactoryBean`的完整参数集。

<!-- tabs:end -->


```xml
<bean id="serverConnector"
        class="org.springframework.jmx.support.ConnectorServerFactoryBean">
    <property name="objectName" value="connector:name=iiop"/>
    <property name="serviceUrl"
        value="service:jmx:iiop://localhost/jndi/iiop://localhost:900/myconnector"/>
    <property name="threaded" value="true"/>
    <property name="daemon" value="true"/>
    <property name="environment">
        <map>
            <entry key="someKey" value="someValue"/>
        </map>
    </property>
</bean>
```

<!-- tabs:start -->

#### ** English **

Note that, when you use a RMI-based connector, you need the lookup service (`tnameserv` or `rmiregistry`) to be started in order for the name registration to complete. If you use Spring to export remote services for you through RMI, Spring has already constructed an RMI registry. If not, you can easily start a registry by using the following snippet of configuration:
#### ** Chinese **

请注意，当您使用基于 RMI 的连接器时，需要启动查找服务（`tnameserv`或`rmiregistry`）才能完成名称注册。如果您使用Spring通过RMI为您导出远程服务，Spring已经构建了一个RMI注册表。如果没有，您可以通过使用下面的配置片段轻松启动一个注册表。

<!-- tabs:end -->


```xml
<bean id="registry" class="org.springframework.remoting.rmi.RmiRegistryFactoryBean">
    <property name="port" value="1099"/>
</bean>
```

### **4.4.2. Client-side Connectors** 

<!-- tabs:start -->

#### ** English **

To create an `MBeanServerConnection` to a remote JSR-160-enabled `MBeanServer`, you can use the `MBeanServerConnectionFactoryBean`, as the following example shows:
#### ** Chinese **

要创建一个`MBeanServerConnection`到一个远程的JSR-160支持的`MBeanServer`，可以使用`MBeanServerConnectionFactoryBean`，如下例所示。

<!-- tabs:end -->


```xml
<bean id="clientConnector" class="org.springframework.jmx.support.MBeanServerConnectionFactoryBean">
    <property name="serviceUrl" value="service:jmx:rmi://localhost/jndi/rmi://localhost:1099/jmxrmi"/>
</bean>
```

### **4.4.3. JMX over Hessian or SOAP** 

<!-- tabs:start -->

#### ** English **

JSR-160 permits extensions to the way in which communication is done between the client and the server. The examples shown in the preceding sections use the mandatory RMI-based implementation required by the JSR-160 specification (IIOP and JRMP) and the (optional) JMXMP. By using other providers or JMX implementations (such as [MX4J](http://mx4j.sourceforge.net/)) you can take advantage of protocols such as SOAP or Hessian over simple HTTP or SSL and others, as the following example shows:
#### ** Chinese **

JSR-160允许对客户机和服务器之间的通信方式进行扩展。前面的例子使用了JSR-160规范要求的基于RMI的强制实现（IIOP和JRMP）和（可选）JMXMP。通过使用其他提供商或JMX实现（如[MX4J](http://mx4j.sourceforge.net/)），你可以利用诸如SOAP或Hessian等协议的优势，而不是简单的HTTP或SSL和其他协议，如下例所示。

<!-- tabs:end -->


```xml
<bean id="serverConnector" class="org.springframework.jmx.support.ConnectorServerFactoryBean">
    <property name="objectName" value="connector:name=burlap"/>
    <property name="serviceUrl" value="service:jmx:burlap://localhost:9874"/>
</bean>
```

<!-- tabs:start -->

#### ** English **

In the preceding example, we used MX4J 3.0.0. See the official MX4J documentation for more information.
#### ** Chinese **

在前面的例子中，我们使用的是MX4J 3.0.0.0，更多信息请参见MX4J官方文档。

<!-- tabs:end -->


### **4.5. Accessing MBeans through Proxies** 

<!-- tabs:start -->

#### ** English **

Spring JMX lets you create proxies that re-route calls to MBeans that are registered in a local or remote `MBeanServer`. These proxies provide you with a standard Java interface, through which you can interact with your MBeans. The following code shows how to configure a proxy for an MBean running in a local `MBeanServer`:
#### ** Chinese **

Spring JMX 允许您创建代理服务器，用于重定向调用在本地或远程 `MBeanServer`中注册的 MBeans。这些代理为您提供了一个标准的Java接口，您可以通过它与您的MBeans进行交互。下面的代码显示了如何为运行在本地`MBeanServer`中的MBean配置代理。

<!-- tabs:end -->


```xml
<bean id="proxy" class="org.springframework.jmx.access.MBeanProxyFactoryBean">
    <property name="objectName" value="bean:name=testBean"/>
    <property name="proxyInterface" value="org.springframework.jmx.IJmxTestBean"/>
</bean>
```

<!-- tabs:start -->

#### ** English **

In the preceding example, you can see that a proxy is created for the MBean registered under the `ObjectName` of `bean:name=testBean`. The set of interfaces that the proxy implements is controlled by the `proxyInterfaces` property, and the rules for mapping methods and properties on these interfaces to operations and attributes on the MBean are the same rules used by the `InterfaceBasedMBeanInfoAssembler`.
#### ** Chinese **

在前面的例子中，可以看到在`bean:name=testBean`的`ObjectName`下注册的MBean创建了一个代理。代理实现的接口集由`proxyInterfaces`属性控制，而将这些接口上的方法和属性映射到MBean上的操作和属性的规则与`InterfaceBasedMBeanInfoAssembler`使用的规则相同。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The `MBeanProxyFactoryBean` can create a proxy to any MBean that is accessible through an `MBeanServerConnection`. By default, the local `MBeanServer` is located and used, but you can override this and provide an `MBeanServerConnection` that points to a remote `MBeanServer` to cater for proxies that point to remote MBeans:
#### ** Chinese **

`MBeanProxyFactoryBean`可以创建一个通过`MBeanServerConnection`访问的任何MBean的代理。默认情况下，本地的 `MBeanServer`被定位和使用，但您可以覆盖这一点，并提供一个指向远程的 `MBeanServerConnection`，以满足指向远程 MBeans 的代理。

<!-- tabs:end -->


```xml
<bean id="clientConnector"
        class="org.springframework.jmx.support.MBeanServerConnectionFactoryBean">
    <property name="serviceUrl" value="service:jmx:rmi://remotehost:9875"/>
</bean>

<bean id="proxy" class="org.springframework.jmx.access.MBeanProxyFactoryBean">
    <property name="objectName" value="bean:name=testBean"/>
    <property name="proxyInterface" value="org.springframework.jmx.IJmxTestBean"/>
    <property name="server" ref="clientConnector"/>
</bean>
```

<!-- tabs:start -->

#### ** English **

In the preceding example, we create an `MBeanServerConnection` that points to a remote machine that uses the `MBeanServerConnectionFactoryBean`. This `MBeanServerConnection` is then passed to the `MBeanProxyFactoryBean` through the `server` property. The proxy that is created forwards all invocations to the `MBeanServer` through this `MBeanServerConnection`.
#### ** Chinese **

在前面的例子中，我们创建一个`MBeanServerConnection`，它指向使用`MBeanServerConnectionFactoryBean`的远程机器。这个`MBeanServerConnection`通过`server`属性传递给`MBeanProxyFactoryBean`。创建的代理通过这个`MBeanServerConnection`将所有调用转发到`MBeanServer`。

<!-- tabs:end -->


### **4.6. Notifications** 

<!-- tabs:start -->

#### ** English **

Spring’s JMX offering includes comprehensive support for JMX notifications.
#### ** Chinese **

Spring 的 JMX 产品包括对 JMX 通知的全面支持。

<!-- tabs:end -->


### **4.6.1. Registering Listeners for Notifications** 

<!-- tabs:start -->

#### ** English **

Spring’s JMX support makes it easy to register any number of `NotificationListeners` with any number of MBeans (this includes MBeans exported by Spring’s `MBeanExporter` and MBeans registered through some other mechanism). For example, consider the scenario where one would like to be informed (through a `Notification`) each and every time an attribute of a target MBean changes. The following example writes notifications to the console:
#### ** Chinese **

Spring 的 JMX 支持可以很容易地将任意数量的 `NotificationListeners`注册到任意数量的 MBeans（这包括由 Spring 的 `MBeanExporter`导出的 MBeans 和通过其他机制注册的 MBeans）。例如，考虑这样一种情况：每次目标MBeans的属性发生变化时，都希望得到通知（通过`Notification`）。下面的例子将通知写到控制台中。

<!-- tabs:end -->


```java
package com.example;

import javax.management.AttributeChangeNotification;
import javax.management.Notification;
import javax.management.NotificationFilter;
import javax.management.NotificationListener;

public class ConsoleLoggingNotificationListener
        implements NotificationListener, NotificationFilter {

    public void handleNotification(Notification notification, Object handback) {
        System.out.println(notification);
        System.out.println(handback);
    }

    public boolean isNotificationEnabled(Notification notification) {
        return AttributeChangeNotification.class.isAssignableFrom(notification.getClass());
    }

}
```

<!-- tabs:start -->

#### ** English **

The following example adds `ConsoleLoggingNotificationListener` (defined in the preceding example) to `notificationListenerMappings`:
#### ** Chinese **

下面的示例将 `ConsoleLoggingNotificationListener`（在前面的示例中定义）添加到 `notificationListenerMappings`中。

<!-- tabs:end -->


```xml
<beans>

    <bean id="exporter" class="org.springframework.jmx.export.MBeanExporter">
        <property name="beans">
            <map>
                <entry key="bean:name=testBean1" value-ref="testBean"/>
            </map>
        </property>
        <property name="notificationListenerMappings">
            <map>
                <entry key="bean:name=testBean1">
                    <bean class="com.example.ConsoleLoggingNotificationListener"/>
                </entry>
            </map>
        </property>
    </bean>

    <bean id="testBean" class="org.springframework.jmx.JmxTestBean">
        <property name="name" value="TEST"/>
        <property name="age" value="100"/>
    </bean>

</beans>
```

<!-- tabs:start -->

#### ** English **

With the preceding configuration in place, every time a JMX `Notification` is broadcast from the target MBean (`bean:name=testBean1`), the `ConsoleLoggingNotificationListener` bean that was registered as a listener through the `notificationListenerMappings` property is notified. The `ConsoleLoggingNotificationListener` bean can then take whatever action it deems appropriate in response to the `Notification`.
#### ** Chinese **

在上述配置到位后，每次从目标 MBean (`bean:name=testBean1`)广播 JMX `Notification`时，通过 `notificationListenerMappings` 属性注册为监听器的 `ConsoleLoggingNotificationListenerMappings` bean 就会被通知。然后，`ConsoleLoggingNotificationListener` bean可以对`Notification`采取它认为合适的任何动作来响应`Notification`。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can also use straight bean names as the link between exported beans and listeners, as the following example shows:
#### ** Chinese **

你也可以使用直接的Bean名作为导出的Bean和听众之间的链接，如下例所示。

<!-- tabs:end -->


```xml
<beans>

    <bean id="exporter" class="org.springframework.jmx.export.MBeanExporter">
        <property name="beans">
            <map>
                <entry key="bean:name=testBean1" value-ref="testBean"/>
            </map>
        </property>
        <property name="notificationListenerMappings">
            <map>
                <entry key="testBean">
                    <bean class="com.example.ConsoleLoggingNotificationListener"/>
                </entry>
            </map>
        </property>
    </bean>

    <bean id="testBean" class="org.springframework.jmx.JmxTestBean">
        <property name="name" value="TEST"/>
        <property name="age" value="100"/>
    </bean>

</beans>
```

<!-- tabs:start -->

#### ** English **

If you want to register a single `NotificationListener` instance for all of the beans that the enclosing `MBeanExporter` exports, you can use the special wildcard (`*`) as the key for an entry in the `notificationListenerMappings` property map, as the following example shows:
#### ** Chinese **

如果您想为包围的`MBeanExporter`导出的所有豆子注册一个单一的`NotificationListener`实例，您可以使用特殊的通配符(`*`)作为`notificationListenerMappings`属性图中的一个条目的键，如下例所示。

<!-- tabs:end -->


```xml
<property name="notificationListenerMappings">
    <map>
        <entry key="*">
            <bean class="com.example.ConsoleLoggingNotificationListener"/>
        </entry>
    </map>
</property>
```

<!-- tabs:start -->

#### ** English **

If you need to do the inverse (that is, register a number of distinct listeners against an MBean), you must instead use the `notificationListeners` list property (in preference to the `notificationListenerMappings` property). This time, instead of configuring a `NotificationListener` for a single MBean, we configure `NotificationListenerBean` instances. A `NotificationListenerBean` encapsulates a `NotificationListener` and the `ObjectName` (or `ObjectNames`) that it is to be registered against in an `MBeanServer`. The `NotificationListenerBean` also encapsulates a number of other properties, such as a `NotificationFilter` and an arbitrary handback object that can be used in advanced JMX notification scenarios.
#### ** Chinese **

如果您需要进行反转（即针对一个 MBean 注册多个不同的监听器），您必须使用 `notificationListeners` 列表属性（优先于 `notificationListenerMappings` 属性）。这一次，我们不再为单个MBean配置`NotificationListener`，而是配置`NotificationListenerBean`实例。一个 `NotificationListenerBean`封装了一个`NotificationListener`和它要在`MBeanServer`中注册的`ObjectName`（或`ObjectNames`）。`NotificationListenerBean`还封装了许多其他属性，如`NotificationFilter`和一个可用于高级JMX通知场景的任意handback对象。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The configuration when using `NotificationListenerBean` instances is not wildly different to what was presented previously, as the following example shows:
#### ** Chinese **

使用`NotificationListenerBean`实例时的配置与之前所展示的没有什么不同，如下例所示。

<!-- tabs:end -->


```xml
<beans>

    <bean id="exporter" class="org.springframework.jmx.export.MBeanExporter">
        <property name="beans">
            <map>
                <entry key="bean:name=testBean1" value-ref="testBean"/>
            </map>
        </property>
        <property name="notificationListeners">
            <list>
                <bean class="org.springframework.jmx.export.NotificationListenerBean">
                    <constructor-arg>
                        <bean class="com.example.ConsoleLoggingNotificationListener"/>
                    </constructor-arg>
                    <property name="mappedObjectNames">
                        <list>
                            <value>bean:name=testBean1</value>
                        </list>
                    </property>
                </bean>
            </list>
        </property>
    </bean>

    <bean id="testBean" class="org.springframework.jmx.JmxTestBean">
        <property name="name" value="TEST"/>
        <property name="age" value="100"/>
    </bean>

</beans>
```

<!-- tabs:start -->

#### ** English **

The preceding example is equivalent to the first notification example. Assume, then, that we want to be given a handback object every time a `Notification` is raised and that we also want to filter out extraneous `Notifications` by supplying a `NotificationFilter`. The following example accomplishes these goals:
#### ** Chinese **

前面的例子相当于第一个通知的例子。那么，假设我们希望在每次提出一个 `Notification`时，都能得到一个handback对象，并且我们还希望通过提供一个`NotificationFilter`来过滤掉不相干的`Notifications`。下面的例子实现了这些目标。

<!-- tabs:end -->


```xml
<beans>

    <bean id="exporter" class="org.springframework.jmx.export.MBeanExporter">
        <property name="beans">
            <map>
                <entry key="bean:name=testBean1" value-ref="testBean1"/>
                <entry key="bean:name=testBean2" value-ref="testBean2"/>
            </map>
        </property>
        <property name="notificationListeners">
            <list>
                <bean class="org.springframework.jmx.export.NotificationListenerBean">
                    <constructor-arg ref="customerNotificationListener"/>
                    <property name="mappedObjectNames">
                        <list>
                            <!-- handles notifications from two distinct MBeans -->
                            <value>bean:name=testBean1</value>
                            <value>bean:name=testBean2</value>
                        </list>
                    </property>
                    <property name="handback">
                        <bean class="java.lang.String">
                            <constructor-arg value="This could be anything..."/>
                        </bean>
                    </property>
                    <property name="notificationFilter" ref="customerNotificationListener"/>
                </bean>
            </list>
        </property>
    </bean>

    <!-- implements both the NotificationListener and NotificationFilter interfaces -->
    <bean id="customerNotificationListener" class="com.example.ConsoleLoggingNotificationListener"/>

    <bean id="testBean1" class="org.springframework.jmx.JmxTestBean">
        <property name="name" value="TEST"/>
        <property name="age" value="100"/>
    </bean>

    <bean id="testBean2" class="org.springframework.jmx.JmxTestBean">
        <property name="name" value="ANOTHER TEST"/>
        <property name="age" value="200"/>
    </bean>

</beans>
```

<!-- tabs:start -->

#### ** English **

(For a full discussion of what a handback object is and, indeed, what a `NotificationFilter` is, see the section of the JMX specification (1.2) entitled 'The JMX Notification Model'.)
#### ** Chinese **

(关于什么是回传对象以及什么是`NotificationFilter`的完整讨论，请参阅JMX规范(1.2)中题为 The JMX Notification Model 的章节)。

<!-- tabs:end -->


### **4.6.2. Publishing Notifications** 

<!-- tabs:start -->

#### ** English **

Spring provides support not only for registering to receive `Notifications` but also for publishing `Notifications`.
#### ** Chinese **

Spring不仅支持注册接收`Notifications`，还支持发布`Notifications`。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

This section is really only relevant to Spring-managed beans that have been exposed as MBeans through an `MBeanExporter`. Any existing user-defined MBeans should use the standard JMX APIs for notification publication.
#### ** Chinese **

本节仅适用于通过`MBeanExporter`以MBeans形式公开的Spring管理的Bean。任何现有的用户定义的MBeans都应该使用标准的JMX API来发布通知。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The key interface in Spring’s JMX notification publication support is the `NotificationPublisher` interface (defined in the `org.springframework.jmx.export.notification` package). Any bean that is going to be exported as an MBean through an `MBeanExporter` instance can implement the related `NotificationPublisherAware` interface to gain access to a `NotificationPublisher` instance. The `NotificationPublisherAware` interface supplies an instance of a `NotificationPublisher` to the implementing bean through a simple setter method, which the bean can then use to publish `Notifications`.
#### ** Chinese **

Spring 的 JMX 通知发布支持的关键接口是 `NotificationPublisher` 接口（定义于 `org.springframework.jmx.export.notification` 包中）。任何要通过`MBeanExporter`实例导出为MBean的Bean都可以实现相关的`NotificationPublisherAware`接口来访问`NotificationPublisher`实例。`NotificationPublisherAware`接口通过一个简单的setter方法向实现的Bean提供一个`NotificationPublisher`实例，然后Bean可以用它来发布`Notifications`。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

As stated in the javadoc of the [`NotificationPublisher`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/jmx/export/notification/NotificationPublisher.html) interface, managed beans that publish events through the `NotificationPublisher` mechanism are not responsible for the state management of notification listeners. Spring’s JMX support takes care of handling all the JMX infrastructure issues. All you need to do, as an application developer, is implement the `NotificationPublisherAware` interface and start publishing events by using the supplied `NotificationPublisher` instance. Note that the `NotificationPublisher` is set after the managed bean has been registered with an `MBeanServer`.
#### ** Chinese **

正如[`NotificationPublisher`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/jmx/export/notification/NotificationPublisher.html)接口的javadoc中所述，通过`NotificationPublisher`机制发布事件的托管Bean不负责通知监听器的状态管理。Spring的JMX支持负责处理所有的JMX基础设施问题。作为应用程序开发者，您只需要实现`NotificationPublisherAware`接口，并使用提供的`NotificationPublisher`实例开始发布事件。请注意，`NotificationPublisher`是在被管理的Bean注册了`MBeanServer`之后设置的。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Using a `NotificationPublisher` instance is quite straightforward. You create a JMX `Notification` instance (or an instance of an appropriate `Notification` subclass), populate the notification with the data pertinent to the event that is to be published, and invoke the `sendNotification(Notification)` on the `NotificationPublisher` instance, passing in the `Notification`.
#### ** Chinese **

使用 `NotificationPublisher`实例非常简单。您可以创建一个 JMX `Notification` 实例（或适当的 `Notification` 子类的实例），用与要发布的事件相关的数据填充通知，然后在 `NotificationPublisher` 实例上调用 `sendNotification(Notification)`，并传递 `Notification`。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

In the following example, exported instances of the `JmxTestBean` publish a `NotificationEvent` every time the `add(int, int)` operation is invoked:
#### ** Chinese **

在下面的例子中，每次调用`add(int, int)`操作时，导出的`JmxTestBean`的实例都会发布一个`NotificationEvent`。

<!-- tabs:end -->


```java
package org.springframework.jmx;

import org.springframework.jmx.export.notification.NotificationPublisherAware;
import org.springframework.jmx.export.notification.NotificationPublisher;
import javax.management.Notification;

public class JmxTestBean implements IJmxTestBean, NotificationPublisherAware {

    private String name;
    private int age;
    private boolean isSuperman;
    private NotificationPublisher publisher;

    // other getters and setters omitted for clarity

    public int add(int x, int y) {
        int answer = x + y;
        this.publisher.sendNotification(new Notification("add", this, 0));
        return answer;
    }

    public void dontExposeMe() {
        throw new RuntimeException();
    }

    public void setNotificationPublisher(NotificationPublisher notificationPublisher) {
        this.publisher = notificationPublisher;
    }

}
```

<!-- tabs:start -->

#### ** English **

The `NotificationPublisher` interface and the machinery to get it all working is one of the nicer features of Spring’s JMX support. It does, however, come with the price tag of coupling your classes to both Spring and JMX. As always, the advice here is to be pragmatic. If you need the functionality offered by the `NotificationPublisher` and you can accept the coupling to both Spring and JMX, then do so.
#### ** Chinese **

`NotificationPublisher`接口和实现这一切的机器是Spring的JMX支持中比较好的功能之一。但是，它也有一个代价，那就是将你的类与Spring和JMX耦合在一起。一如既往，这里的建议是要务实。如果你需要`NotificationPublisher`所提供的功能，并且你可以接受与Spring和JMX的耦合，那么就这样做吧。

<!-- tabs:end -->


### **4.7. Further Resources** 

<!-- tabs:start -->

#### ** English **

This section contains links to further resources about JMX:
#### ** Chinese **

本节包含有关JMX的进一步资源链接。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

- The [JMX homepage](https://www.oracle.com/technetwork/java/javase/tech/javamanagement-140525.html) at Oracle.

- The [JMX specification](https://jcp.org/aboutJava/communityprocess/final/jsr003/index3.html) (JSR-000003).

- The [JMX Remote API specification](https://jcp.org/aboutJava/communityprocess/final/jsr160/index.html) (JSR-000160).

- The [MX4J homepage](http://mx4j.sourceforge.net/). (MX4J is an open-source implementation of various JMX specs.)


#### ** Chinese **

- 在Oracle的[JMX主页](https://www.oracle.com/technetwork/java/javase/tech/javamanagement-140525.html)。

- JMX 规范](https://jcp.org/aboutJava/communityprocess/final/jsr003/index3.html)(JSR-000003)。

- JMX 远程 API 规范](https://jcp.org/aboutJava/communityprocess/final/jsr160/index.html)(JSR-000160)。

- MX4J 主页](http://mx4j.sourceforge.net/)。(MX4J是各种JMX规范的开源实现。)


<!-- tabs:end -->

[下一章](Spring-Framework-5.2.6.RELEASE/Integration/5.%20JCA%20CCI.md)


[回目录](Spring-Framework-5.2.6.RELEASE/summary.md)

[回首页](/README)
