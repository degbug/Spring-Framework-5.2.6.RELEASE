# 3. JMS (Java Message Service)

<!-- tabs:start -->

#### ** English **

Spring provides a JMS integration framework that simplifies the use of the JMS API in much the same way as Spring’s integration does for the JDBC API.
#### ** Chinese **

Spring提供了一个JMS集成框架，它简化了JMS API的使用，就像Spring对JDBC API的集成一样。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

JMS can be roughly divided into two areas of functionality, namely the production and consumption of messages. The `JmsTemplate` class is used for message production and synchronous message reception. For asynchronous reception similar to Java EE’s message-driven bean style, Spring provides a number of message-listener containers that you can use to create Message-Driven POJOs (MDPs). Spring also provides a declarative way to create message listeners.
#### ** Chinese **

JMS的功能大致可以分为两个方面，即消息的制作和消费。`JmsTemplate`类用于消息生产和同步消息接收。对于类似于Java EE的消息驱动Bean风格的异步接收，Spring提供了一些消息监听容器，可以用来创建消息驱动的POJOs（MDP）。Spring还提供了一种声明式的方式来创建消息监听器。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The `org.springframework.jms.core` package provides the core functionality for using JMS. It contains JMS template classes that simplify the use of the JMS by handling the creation and release of resources, much like the `JdbcTemplate` does for JDBC. The design principle common to Spring template classes is to provide helper methods to perform common operations and, for more sophisticated usage, delegate the essence of the processing task to user-implemented callback interfaces. The JMS template follows the same design. The classes offer various convenience methods for sending messages, consuming messages synchronously, and exposing the JMS session and message producer to the user.
#### ** Chinese **

`org.springframework.jms.core`包提供了使用JMS的核心功能。它包含了JMS模板类，通过处理资源的创建和发布，简化了JMS的使用，就像`JdbcTemplate`对JDBC所做的那样。Spring 模板类的共同设计原则是提供辅助方法来执行常见的操作，对于更复杂的使用，则将处理任务的本质委托给用户实现的回调接口。JMS模板也遵循了同样的设计。这些类提供了各种方便的方法来发送消息，同步消耗消息，并将JMS会话和消息生成器暴露给用户。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The `org.springframework.jms.support` package provides `JMSException` translation functionality. The translation converts the checked `JMSException` hierarchy to a mirrored hierarchy of unchecked exceptions. If any provider-specific subclasses of the checked `javax.jms.JMSException` exist, this exception is wrapped in the unchecked `UncategorizedJmsException`.
#### ** Chinese **

`org.springframework.jms.support`包提供了`JMSException`翻译功能。该翻译将检查过的 `JMSException`层次结构转换为未检查过的异常的镜像层次结构。如果检查过的 `javax.jms.JMSException`存在任何特定于提供者的子类，那么这个异常将被封装在未检查过的 `UncategorizedJmsException`中。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The `org.springframework.jms.support.converter` package provides a `MessageConverter` abstraction to convert between Java objects and JMS messages.
#### ** Chinese **

`org.springframework.jms.support.converter`包提供了一个`MessageConverter`抽象，用于在Java对象和JMS消息之间进行转换。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The `org.springframework.jms.support.destination` package provides various strategies for managing JMS destinations, such as providing a service locator for destinations stored in JNDI.
#### ** Chinese **

`org.springframework.jms.support.destination`包提供了管理JMS目的地的各种策略，例如为存储在JNDI中的目的地提供服务定位器。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The `org.springframework.jms.annotation` package provides the necessary infrastructure to support annotation-driven listener endpoints by using `@JmsListener`.
#### ** Chinese **

`org.springframework.jms.annotation`包通过使用`@JmsListener`提供了必要的基础架构，以支持由注释驱动的监听器端点。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The `org.springframework.jms.config` package provides the parser implementation for the `jms` namespace as well as the java config support to configure listener containers and create listener endpoints.
#### ** Chinese **

`org.springframework.jms.config`包提供了`jms`命名空间的解析器实现，以及java config支持的java config，用于设置监听器容器和创建监听器端点。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Finally, the `org.springframework.jms.connection` package provides an implementation of the `ConnectionFactory` suitable for use in standalone applications. It also contains an implementation of Spring’s `PlatformTransactionManager` for JMS (the cunningly named `JmsTransactionManager`). This allows for seamless integration of JMS as a transactional resource into Spring’s transaction management mechanisms.
#### ** Chinese **

最后，`org.springframework.jms.connection`包提供了一个`ConnectionFactory`的实现，适合在独立的应用程序中使用。它还包含了Spring的`PlatformTransactionManager`的实现，用于JMS（巧妙地命名为`JmsTransactionManager`）。这允许将JMS作为事务资源无缝集成到Spring的事务管理机制中。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

As of Spring Framework 5, Spring’s JMS package fully supports JMS 2.0 and requires the JMS 2.0 API to be present at runtime. We recommend the use of a JMS 2.0 compatible provider.
#### ** Chinese **

从Spring Framework 5开始，Spring的JMS包完全支持JMS 2.0，并且要求运行时必须有JMS 2.0 API。我们建议使用JMS 2.0兼容的提供者。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

If you happen to use an older message broker in your system, you may try upgrading to a JMS 2.0 compatible driver for your existing broker generation. Alternatively, you may also try to run against a JMS 1.1 based driver, simply putting the JMS 2.0 API jar on the classpath but only using JMS 1.1 compatible API against your driver. Spring’s JMS support adheres to JMS 1.1 conventions by default, so with corresponding configuration it does support such a scenario. However, please consider this for transition scenarios only.
#### ** Chinese **

如果你的系统中使用的是旧的消息代理，你可以尝试升级到一个JMS 2.0兼容的驱动，以支持你现有的代理。或者，你也可以尝试运行基于JMS 1.1的驱动，只需将JMS 2.0 API jar放在classpath上，但只使用JMS 1.1兼容的API来运行你的驱动。Spring的JMS支持默认遵循JMS 1.1的约定，所以通过相应的配置，它确实支持这样的场景。但是，请考虑这仅适用于过渡场景。

<!-- tabs:end -->


### **3.1. Using Spring JMS** 

<!-- tabs:start -->

#### ** English **

This section describes how to use Spring’s JMS components.
#### ** Chinese **

本节介绍如何使用Spring的JMS组件。

<!-- tabs:end -->


### **3.1.1. Using** **`JmsTemplate`** 

<!-- tabs:start -->

#### ** English **

The `JmsTemplate` class is the central class in the JMS core package. It simplifies the use of JMS, since it handles the creation and release of resources when sending or synchronously receiving messages.
#### ** Chinese **

`JmsTemplate`类是JMS核心包中的核心类。它简化了JMS的使用，因为当发送或同步接收消息时，它处理资源的创建和释放。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Code that uses the `JmsTemplate` needs only to implement callback interfaces that give them a clearly defined high-level contract. The `MessageCreator` callback interface creates a message when given a `Session` provided by the calling code in `JmsTemplate`. To allow for more complex usage of the JMS API, `SessionCallback` provides the JMS session, and `ProducerCallback` exposes a `Session` and `MessageProducer` pair.
#### ** Chinese **

使用`JmsTemplate`的代码只需要实现回调接口，给它们一个明确定义的高级合约。`MessageCreator`回调接口在`JmsTemplate`中的调用代码提供的`Session`时创建一个消息。为了允许更复杂地使用 JMS API，`SessionCallback`提供了 JMS 会话，而 `ProducerCallback`则提供了 `Session`和 `MessageProducer`对。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The JMS API exposes two types of send methods, one that takes delivery mode, priority, and time-to-live as Quality of Service (QOS) parameters and one that takes no QOS parameters and uses default values. Since `JmsTemplate` has many send methods, setting the QOS parameters have been exposed as bean properties to avoid duplication in the number of send methods. Similarly, the timeout value for synchronous receive calls is set by using the `setReceiveTimeout` property.
#### ** Chinese **

JMS API公开了两种类型的发送方法，一种是以交付模式、优先级和时间-生存时间作为服务质量(QOS)参数，另一种是不取QOS参数，使用默认值。由于`JmsTemplate`有很多发送方法，所以设置QOS参数作为Bean属性暴露出来，以避免发送方法的数量重复。同样，同步接收调用的超时值也是通过使用`setReceiveTimeout`属性设置的。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Some JMS providers allow the setting of default QOS values administratively through the configuration of the `ConnectionFactory`. This has the effect that a call to a `MessageProducer` instance’s `send` method (`send(Destination destination, Message message)`) uses different QOS default values than those specified in the JMS specification. In order to provide consistent management of QOS values, the `JmsTemplate` must, therefore, be specifically enabled to use its own QOS values by setting the boolean property `isExplicitQosEnabled` to `true`.
#### ** Chinese **

一些JMS提供者允许通过配置`ConnectionFactory`来管理设置默认的QOS值。这样做的效果是，对`MessageProducer`实例的`send`方法(`send(Destination destination, Message message)`)的调用会使用与JMS规范中指定的QOS默认值不同。因此，为了提供一致的QOS值管理，`JmsTemplate`必须通过将布尔属性`isExplicitQosEnabled`设置为`true`，使其能够使用自己的QOS值。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

For convenience, `JmsTemplate` also exposes a basic request-reply operation that allows for sending a message and waiting for a reply on a temporary queue that is created as part of the operation.
#### ** Chinese **

为了方便起见，`JmsTemplate`还提供了一个基本的请求-回复操作，允许发送消息并在作为操作的一部分创建的临时队列中等待回复。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Instances of the `JmsTemplate` class are thread-safe, once configured. This is important, because it means that you can configure a single instance of a `JmsTemplate` and then safely inject this shared reference into multiple collaborators. To be clear, the `JmsTemplate` is stateful, in that it maintains a reference to a `ConnectionFactory`, but this state is not conversational state.
#### ** Chinese **

`JmsTemplate`类的实例一旦配置好了，就是线程安全的。这一点很重要，因为这意味着您可以配置一个`JmsTemplate`的单个实例，然后将这个共享引用安全地注入到多个协作者中。要明确的是，`JmsTemplate`是有状态的，因为它维护着一个指向`ConnectionFactory`的引用，但这个状态不是会话状态。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

As of Spring Framework 4.1, `JmsMessagingTemplate` is built on top of `JmsTemplate` and provides an integration with the messaging abstraction — that is, `org.springframework.messaging.Message`. This lets you create the message to send in a generic manner.
#### ** Chinese **

从Spring Framework 4.1开始，`JmsMessagingTemplate`是建立在`JmsTemplate`之上，并提供了一个与消息传递抽象的集成--即`org.springframework.messaging.Message`。这让你可以以一种通用的方式创建要发送的消息。

<!-- tabs:end -->


### **3.1.2. Connections** 

<!-- tabs:start -->

#### ** English **

The `JmsTemplate` requires a reference to a `ConnectionFactory`. The `ConnectionFactory` is part of the JMS specification and serves as the entry point for working with JMS. It is used by the client application as a factory to create connections with the JMS provider and encapsulates various configuration parameters, many of which are vendor-specific, such as SSL configuration options.
#### ** Chinese **

`JmsTemplate`要求引用一个`ConnectionFactory`。`ConnectionFactory`是JMS规范的一部分，是与JMS一起工作的入口。它被客户机应用程序作为一个工厂，用于创建与JMS提供者的连接，并封装了各种配置参数，其中许多参数都是厂商特有的，如SSL配置选项。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

When using JMS inside an EJB, the vendor provides implementations of the JMS interfaces so that they can participate in declarative transaction management and perform pooling of connections and sessions. In order to use this implementation, Java EE containers typically require that you declare a JMS connection factory as a `resource-ref` inside the EJB or servlet deployment descriptors. To ensure the use of these features with the `JmsTemplate` inside an EJB, the client application should ensure that it references the managed implementation of the `ConnectionFactory`.
#### ** Chinese **

当在EJB内使用JMS时，厂商提供了JMS接口的实现，使其能够参与声明式事务管理，并执行连接和会话池化。为了使用这种实现，Java EE 容器通常要求你在 EJB 或 servlet 部署描述符中声明一个 JMS 连接工厂作为 `resource-ref` 内的 `resource-ref`。为了确保在EJB中使用这些功能与`JmsTemplate`内部的`JmsTemplate`，客户机应用程序应该确保它引用了`ConnectionFactory`的托管实现。

<!-- tabs:end -->


### **Caching Messaging Resources** 

<!-- tabs:start -->

#### ** English **

The standard API involves creating many intermediate objects. To send a message, the following 'API' walk is performed:
#### ** Chinese **

标准的API涉及到创建许多中间对象。要发送一个消息，需要执行下面的 API 步进。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

ConnectionFactory->Connection->Session->MessageProducer->send
#### ** Chinese **

ConnectionFactory->Connection->Session->MessageProducer->send

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Between the `ConnectionFactory` and the `Send` operation, three intermediate objects are created and destroyed. To optimize the resource usage and increase performance, Spring provides two implementations of `ConnectionFactory`.
#### ** Chinese **

在 `ConnectionFactory`和`Send`操作之间，要创建和销毁三个中间对象。为了优化资源的使用和提高性能，Spring提供了两种`ConnectionFactory`的实现。

<!-- tabs:end -->


### **Using** **`SingleConnectionFactory`** 

<!-- tabs:start -->

#### ** English **

Spring provides an implementation of the `ConnectionFactory` interface, `SingleConnectionFactory`, that returns the same `Connection` on all `createConnection()` calls and ignores calls to `close()`. This is useful for testing and standalone environments so that the same connection can be used for multiple `JmsTemplate` calls that may span any number of transactions. `SingleConnectionFactory` takes a reference to a standard `ConnectionFactory` that would typically come from JNDI.
#### ** Chinese **

Spring 提供了 `ConnectionFactory` 接口 `SingleConnectionFactory`的实现，它在所有 `createConnection()` 调用中返回相同的 `Connection`，并且忽略了对 `close()` 的调用。这对于测试和独立环境非常有用，这样，同一连接可以用于多个 `JmsTemplate` 调用，而这些调用可以跨越任何数量的事务。 `SingleConnectionFactory`需要引用一个标准的`ConnectionFactory`，它通常来自于JNDI。

<!-- tabs:end -->


### **Using** **`CachingConnectionFactory`** 

<!-- tabs:start -->

#### ** English **

The `CachingConnectionFactory` extends the functionality of `SingleConnectionFactory` and adds the caching of `Session`, `MessageProducer`, and `MessageConsumer` instances. The initial cache size is set to `1`. You can use the `sessionCacheSize` property to increase the number of cached sessions. Note that the number of actual cached sessions is more than that number, as sessions are cached based on their acknowledgment mode, so there can be up to four cached session instances (one for each acknowledgment mode) when `sessionCacheSize` is set to one . `MessageProducer` and `MessageConsumer` instances are cached within their owning session and also take into account the unique properties of the producers and consumers when caching. MessageProducers are cached based on their destination. MessageConsumers are cached based on a key composed of the destination, selector, noLocal delivery flag, and the durable subscription name (if creating durable consumers).
#### ** Chinese **

`CachingConnectionFactory`扩展了`SingleConnectionFactory`的功能，并增加了`Session`、`MessageProducer`和`MessageConsumer`实例的缓存。初始缓存大小被设置为`1`。您可以使用`sessionCacheSize`属性来增加缓存会话的数量。请注意，实际缓存的会话数量要比这个数字多，因为会话是根据其确认模式来缓存的，所以当`sessionCacheSize`设置为1时，最多可以有4个缓存的会话实例（每个确认模式一个）。 `MessageProducer`和`MessageConsumer`实例被缓存在自己的会话中，并且在缓存时也会考虑到生产者和消费者的独特属性。MessageProducer是根据其目的地进行缓存。MessageConsumers是基于由目的地、选择器、noLocal交付标志和持久订阅名称（如果创建持久消费者）组成的密钥进行缓存。

<!-- tabs:end -->


### **3.1.3. Destination Management** 

<!-- tabs:start -->

#### ** English **

Destinations, as `ConnectionFactory` instances, are JMS administered objects that you can store and retrieved in JNDI. When configuring a Spring application context, you can use the JNDI `JndiObjectFactoryBean` factory class or `<jee:jndi-lookup>` to perform dependency injection on your object’s references to JMS destinations. However, this strategy is often cumbersome if there are a large number of destinations in the application or if there are advanced destination management features unique to the JMS provider. Examples of such advanced destination management include the creation of dynamic destinations or support for a hierarchical namespace of destinations. The `JmsTemplate` delegates the resolution of a destination name to a JMS destination object that implements the `DestinationResolver` interface. `DynamicDestinationResolver` is the default implementation used by `JmsTemplate` and accommodates resolving dynamic destinations. A `JndiDestinationResolver` is also provided to act as a service locator for destinations contained in JNDI and optionally falls back to the behavior contained in `DynamicDestinationResolver`.
#### ** Chinese **

作为`ConnectionFactory`实例，目的地是JMS管理的对象，您可以在JNDI中存储和检索。在配置Spring应用上下文时，可以使用JNDI `JndiObjectFactoryBean`工厂类或`<jee:jndi-lookup>`来对对象对JMS目的地的引用执行依赖注入。然而，如果应用程序中存在大量的目的地，或者有JMS提供者特有的高级目的地管理功能，那么这种策略通常会很麻烦。这种高级目的地管理的例子包括创建动态目的地或支持目的地的分层命名空间。`JmsTemplate`将目的地名称的解析委托给实现了`DestinationResolver`接口的JMS目的地对象。 `DynamicDestinationResolver`是`JmsTemplate`所使用的默认实现，它可以解析动态目的地。`JndiDestinationResolver`也提供了一个`JndiDestinationResolver`，作为JNDI中包含的目的地的服务定位器，并可选择返回到`DynamicDestinationResolver`中包含的行为。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Quite often, the destinations used in a JMS application are only known at runtime and, therefore, cannot be administratively created when the application is deployed. This is often because there is shared application logic between interacting system components that create destinations at runtime according to a well-known naming convention. Even though the creation of dynamic destinations is not part of the JMS specification, most vendors have provided this functionality. Dynamic destinations are created with a user-defined name, which differentiates them from temporary destinations, and are often not registered in JNDI. The API used to create dynamic destinations varies from provider to provider since the properties associated with the destination are vendor-specific. However, a simple implementation choice that is sometimes made by vendors is to disregard the warnings in the JMS specification and to use the method `TopicSession` `createTopic(String topicName)` or the `QueueSession` `createQueue(String queueName)` method to create a new destination with default destination properties. Depending on the vendor implementation, `DynamicDestinationResolver` can then also create a physical destination instead of only resolving one.
#### ** Chinese **

很多时候，JMS应用程序中使用的目的地只有在运行时才知道，因此，在部署应用程序时无法通过管理方式创建。这通常是因为交互式系统组件之间存在着共享的应用逻辑，这些组件在运行时根据一个众所周知的命名惯例创建目的地。尽管创建动态目的地不是JMS规范的一部分，但大多数厂商都提供了这种功能。动态目的地是用用户定义的名称来创建的，它与临时目的地有区别，而且通常不在JNDI中注册。用于创建动态目的地的API因提供商而异，因为与目的地相关联的属性是厂商特有的。然而，有时供应商会选择一个简单的实现方法，即无视 JMS 规范中的警告，使用 `TopicSession` `createTopic(String topicName)`方法或 `QueueSession` `createQueue(String queueName)`方法来创建一个具有默认目的地属性的新目的地。根据供应商的实现，`DynamicDestinationResolver`还可以创建一个物理目的地，而不是只解析一个目的地。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The boolean property `pubSubDomain` is used to configure the `JmsTemplate` with knowledge of what JMS domain is being used. By default, the value of this property is false, indicating that the point-to-point domain, `Queues`, is to be used. This property (used by `JmsTemplate`) determines the behavior of dynamic destination resolution through implementations of the `DestinationResolver` interface.
#### ** Chinese **

布尔值属性`pubSubDomain`用于配置`JmsTemplate`中使用的JMS域。默认情况下，该属性的值为false，表示要使用点对点域`Queues`。该属性（由`JmsTemplate`使用）通过`DestinationResolver`接口的实现来决定动态目标解析的行为。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can also configure the `JmsTemplate` with a default destination through the property `defaultDestination`. The default destination is with send and receive operations that do not refer to a specific destination.
#### ** Chinese **

您还可以通过属性`defaultDestination`来配置`JmsTemplate`的默认目的地。默认目的地是指不指向特定目的地的发送和接收操作。

<!-- tabs:end -->


### **3.1.4. Message Listener Containers** 

<!-- tabs:start -->

#### ** English **

One of the most common uses of JMS messages in the EJB world is to drive message-driven beans (MDBs). Spring offers a solution to create message-driven POJOs (MDPs) in a way that does not tie a user to an EJB container. (See [Asynchronous reception: Message-Driven POJOs](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#jms-receiving-async) for detailed coverage of Spring’s MDP support.) Since Spring Framework 4.1, endpoint methods can be annotated with `@JmsListener` — see [Annotation-driven Listener Endpoints](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#jms-annotated) for more details.
#### ** Chinese **

在EJB世界中，JMS消息最常见的用途之一是驱动消息驱动的Bean（MDBs）。Spring提供了一种解决方案，可以用不将用户与EJB容器绑定的方式创建消息驱动的POJOs (MDPs)。(参见[异步接收：消息驱动的POJOs](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#jms-receiving-async)，了解Spring的MDP支持的详细内容。) 自Spring Framework 4.1以来，端点方法可以用`@JmsListener`来注解--详情请参见[Annotation-driven Listener Endpoints](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#jms-annotated)。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

A message listener container is used to receive messages from a JMS message queue and drive the `MessageListener` that is injected into it. The listener container is responsible for all threading of message reception and dispatches into the listener for processing. A message listener container is the intermediary between an MDP and a messaging provider and takes care of registering to receive messages, participating in transactions, resource acquisition and release, exception conversion, and so on. This lets you write the (possibly complex) business logic associated with receiving a message (and possibly respond to it), and delegates boilerplate JMS infrastructure concerns to the framework.
#### ** Chinese **

消息监听器容器用于接收来自JMS消息队列的消息，并驱动注入到其中的`MessageListener`。该监听器容器负责消息接收的所有线程，并将消息派遣到监听器中进行处理。消息监听器容器是MDP和消息提供者之间的中介，负责注册接收消息、参与事务、资源获取和释放、异常转换等等。这让你可以编写与接收消息相关的（可能是复杂的）业务逻辑（可能是响应消息），并将繁琐的JMS基础架构问题交给框架来处理。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

There are two standard JMS message listener containers packaged with Spring, each with its specialized feature set.
#### ** Chinese **

有两个标准的JMS消息监听器容器与Spring打包，每个容器都有其专门的功能集。

<!-- tabs:end -->


### **Using** **`SimpleMessageListenerContainer`** 

<!-- tabs:start -->

#### ** English **

This message listener container is the simpler of the two standard flavors. It creates a fixed number of JMS sessions and consumers at startup, registers the listener by using the standard JMS `MessageConsumer.setMessageListener()` method, and leaves it up the JMS provider to perform listener callbacks. This variant does not allow for dynamic adaption to runtime demands or for participation in externally managed transactions. Compatibility-wise, it stays very close to the spirit of the standalone JMS specification, but is generally not compatible with Java EE’s JMS restrictions.
#### ** Chinese **

这个消息监听器容器是两种标准口味中比较简单的一种。它在启动时创建一个固定数量的JMS会话和消费者，通过使用标准的JMS `MessageConsumer.setMessageListener()`方法注册监听器，然后由JMS提供者来执行监听器回调。这个变体不允许动态适应运行时需求或参与外部管理的事务。在兼容性方面，它非常接近于独立的JMS规范的精神，但通常不兼容Java EE的JMS限制。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

While `SimpleMessageListenerContainer` does not allow for participation in externally managed transactions, it does support native JMS transactions. To enable this feature, you can switch the `sessionTransacted` flag to `true` or, in the XML namespace, set the `acknowledge` attribute to `transacted`. Exceptions thrown from your listener then lead to a rollback, with the message getting redelivered. Alternatively, consider using `CLIENT_ACKNOWLEDGE` mode, which provides redelivery in case of an exception as well but does not use transacted `Session` instances and, therefore, does not include any other `Session` operations (such as sending response messages) in the transaction protocol.
#### ** Chinese **

虽然`SimpleMessageListenerContainer`不允许参与外部管理的事务，但它确实支持本地JMS事务。要启用此功能，您可以将`sessionTransacted`标志切换为`true`，或者在XML命名空间中，将`acknowledge`属性设置为`transacted`。然后从你的监听器抛出的异常会导致回滚，消息会被重发。另外，可以考虑使用 `CLIENT_ACKNOWLEDGE`模式，该模式也可以在异常情况下提供重发，但不使用已交易的`Session`实例，因此，在事务协议中不包括任何其他的`Session`操作（如发送响应消息）。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The default `AUTO_ACKNOWLEDGE` mode does not provide proper reliability guarantees. Messages can get lost when listener execution fails (since the provider automatically acknowledges each message after listener invocation, with no exceptions to be propagated to the provider) or when the listener container shuts down (you can configure this by setting the `acceptMessagesWhileStopping` flag). Make sure to use transacted sessions in case of reliability needs (for example, for reliable queue handling and durable topic subscriptions).
#### ** Chinese **

默认的`AUTO_ACKNOWLEDGE`模式不能提供适当的可靠性保证。当监听器执行失败时，消息可能会丢失（因为提供者在监听器调用后会自动确认每条消息，不会向提供者传播任何异常），或者当监听器容器关闭时，消息可能会丢失（你可以通过设置`acceptMessagesWhileStopping`标志来配置）。确保在有可靠性需求的情况下使用交易会话（例如，用于可靠的队列处理和持久的主题订阅）。

<!-- tabs:end -->


### **Using** **`DefaultMessageListenerContainer`** 

<!-- tabs:start -->

#### ** English **

This message listener container is used in most cases. In contrast to `SimpleMessageListenerContainer`, this container variant allows for dynamic adaptation to runtime demands and is able to participate in externally managed transactions. Each received message is registered with an XA transaction when configured with a `JtaTransactionManager`. As a result, processing may take advantage of XA transaction semantics. This listener container strikes a good balance between low requirements on the JMS provider, advanced functionality (such as participation in externally managed transactions), and compatibility with Java EE environments.
#### ** Chinese **

这种消息监听器容器在大多数情况下都会用到。与`SimpleMessageListenerContainer`相比，这个容器变体允许动态适应运行时的需求，并且能够参与外部管理的事务。当配置了`JtaTransactionManager`时，每个收到的消息都会被注册为XA事务。因此，处理可以利用XA事务的语义。这种监听器容器在对JMS提供者的低要求、高级功能（如参与外部管理事务）和与Java EE环境的兼容性之间取得了良好的平衡。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can customize the cache level of the container. Note that, when no caching is enabled, a new connection and a new session is created for each message reception. Combining this with a non-durable subscription with high loads may lead to message loss. Make sure to use a proper cache level in such a case.
#### ** Chinese **

您可以自定义容器的缓存级别。请注意，当没有启用缓存时，每次接收消息都会创建一个新的连接和新的会话。将其与高负载的非耐用订阅结合起来，可能会导致消息丢失。在这种情况下，请确保使用适当的缓存级别。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

This container also has recoverable capabilities when the broker goes down. By default, a simple `BackOff` implementation retries every five seconds. You can specify a custom `BackOff` implementation for more fine-grained recovery options. See api-spring-framework/util/backoff/ExponentialBackOff.html[`ExponentialBackOff`] for an example.
#### ** Chinese **

这个容器还具有在经纪商宕机时的可恢复能力。默认情况下，一个简单的 `BackOff` 实现每五秒重试一次。您可以指定一个自定义的 `BackOff`实现，以获得更精细的恢复选项。请参见 api-spring-framework/util/backoff/ExponentialBackOff.html[`ExponentialBackOff`]以了解一个例子。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Like its sibling ([`SimpleMessageListenerContainer`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#jms-mdp-simple)), `DefaultMessageListenerContainer` supports native JMS transactions and allows for customizing the acknowledgment mode. If feasible for your scenario, This is strongly recommended over externally managed transactions — that is, if you can live with occasional duplicate messages in case of the JVM dying. Custom duplicate message detection steps in your business logic can cover such situations — for example, in the form of a business entity existence check or a protocol table check. Any such arrangements are significantly more efficient than the alternative: wrapping your entire processing with an XA transaction (through configuring your `DefaultMessageListenerContainer` with an `JtaTransactionManager`) to cover the reception of the JMS message as well as the execution of the business logic in your message listener (including database operations etc).
#### ** Chinese **

和它的兄弟姐妹（[[`SimpleMessageListenerContainer`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#jms-mdp-simple)）一样，`DefaultMessageListenerContainer`支持原生的JMS事务，并允许自定义确认模式。如果对你的方案可行，强烈建议使用这种模式，而不是外部管理的事务--也就是说，如果你能在JVM死掉的情况下，偶尔出现重复消息的情况，就可以忍受。你的业务逻辑中的自定义重复消息检测步骤可以覆盖这种情况--例如，以业务实体存在检查或协议表检查的形式。任何这样的安排都要比替代方案更有效率：用一个XA事务包裹你的整个处理（通过配置你的`DefaultMessageListenerContainer`和`JtaTransactionManager`），以覆盖JMS消息的接收以及消息监听器中业务逻辑的执行（包括数据库操作等）。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The default `AUTO_ACKNOWLEDGE` mode does not provide proper reliability guarantees. Messages can get lost when listener execution fails (since the provider automatically acknowledges each message after listener invocation, with no exceptions to be propagated to the provider) or when the listener container shuts down (you can configure this by setting the `acceptMessagesWhileStopping` flag). Make sure to use transacted sessions in case of reliability needs (for example, for reliable queue handling and durable topic subscriptions).
#### ** Chinese **

默认的`AUTO_ACKNOWLEDGE`模式不能提供适当的可靠性保证。当监听器执行失败时，消息可能会丢失（因为提供者在监听器调用后会自动确认每条消息，不会向提供者传播任何异常），或者当监听器容器关闭时，消息可能会丢失（你可以通过设置`acceptMessagesWhileStopping`标志来配置）。确保在有可靠性需求的情况下使用交易会话（例如，用于可靠的队列处理和持久的主题订阅）。

<!-- tabs:end -->


### **3.1.5. Transaction Management** 

<!-- tabs:start -->

#### ** English **

Spring provides a `JmsTransactionManager` that manages transactions for a single JMS `ConnectionFactory`. This lets JMS applications leverage the managed-transaction features of Spring, as described in [Transaction Management section of the Data Access chapter](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/data-access.html#transaction). The `JmsTransactionManager` performs local resource transactions, binding a JMS Connection/Session pair from the specified `ConnectionFactory` to the thread. `JmsTemplate` automatically detects such transactional resources and operates on them accordingly.
#### ** Chinese **

Spring提供了一个`JmsTransactionManager`，可以为单个JMS `ConnectionFactory`管理事务。这使得JMS应用程序可以利用Spring的事务管理功能，如[数据访问章节中的事务管理部分](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/data-access.html#transaction)所述。`JmsTransactionManager`执行本地资源事务，将指定的`ConnectionFactory`中的JMS连接/会话对绑定到线程。 `JmsTemplate`自动检测到这种事务性资源，并对其进行相应的操作。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

In a Java EE environment, the `ConnectionFactory` pools Connection and Session instances, so those resources are efficiently reused across transactions. In a standalone environment, using Spring’s `SingleConnectionFactory` result in a shared JMS `Connection`, with each transaction having its own independent `Session`. Alternatively, consider the use of a provider-specific pooling adapter, such as ActiveMQ’s `PooledConnectionFactory` class.
#### ** Chinese **

在Java EE环境中，`ConnectionFactory`汇集了Connection和Session实例，因此这些资源可以在不同事务之间有效地重用。在独立的环境中，使用 Spring 的 `SingleConnectionFactory`会产生一个共享的 JMS `Connection`，每个事务都有自己独立的 `Session`。另外，可以考虑使用特定于提供者的池化适配器，例如ActiveMQ的`PooledConnectionFactory`类。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can also use `JmsTemplate` with the `JtaTransactionManager` and an XA-capable JMS `ConnectionFactory` to perform distributed transactions. Note that this requires the use of a JTA transaction manager as well as a properly XA-configured ConnectionFactory. (Check your Java EE server’s or JMS provider’s documentation.)
#### ** Chinese **

您也可以使用`JmsTemplate`与`JtaTransactionManager`和支持XA的JMS `ConnectionFactory`来执行分布式事务。注意，这需要使用一个JTA事务管理器以及一个正确配置的XA连接工厂（ConnectionFactory）。请查看你的Java EE服务器或JMS提供商的文档）。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Reusing code across a managed and unmanaged transactional environment can be confusing when using the JMS API to create a `Session` from a `Connection`. This is because the JMS API has only one factory method to create a `Session`, and it requires values for the transaction and acknowledgment modes. In a managed environment, setting these values is the responsibility of the environment’s transactional infrastructure, so these values are ignored by the vendor’s wrapper to the JMS Connection. When you use the `JmsTemplate` in an unmanaged environment, you can specify these values through the use of the properties `sessionTransacted` and `sessionAcknowledgeMode`. When you use a `PlatformTransactionManager` with `JmsTemplate`, the template is always given a transactional JMS `Session`.
#### ** Chinese **

当使用 JMS API 从 `Connection`创建一个 `Session`连接</x>时，在有管理和无管理的事务处理环境中重复使用代码可能会造成混乱。这是因为 JMS API 只有一个工厂方法来创建 `Session`，而且它需要为事务和确认模式设置值。在托管环境中，设置这些值是环境的事务基础架构的责任，所以这些值会被厂商的JMS连接的封装器忽略。当您在非管理环境中使用`JmsTemplate`时，您可以通过使用属性`sessionTransacted`和`sessionAcknowledgeMode`来指定这些值。当您使用`PlatformTransactionManager`和`JmsTemplate`时，该模板总是被赋予一个事务性的JMS `Session`。

<!-- tabs:end -->


### **3.2. Sending a Message** 

<!-- tabs:start -->

#### ** English **

The `JmsTemplate` contains many convenience methods to send a message. Send methods specify the destination by using a `javax.jms.Destination` object, and others specify the destination by using a `String` in a JNDI lookup. The `send` method that takes no destination argument uses the default destination.
#### ** Chinese **

`JmsTemplate`包含许多方便的方法来发送消息。发送方法通过使用`javax.jms.Destination`对象来指定目的地，而其他方法则通过使用JNDI查询中的`String`来指定目的地。`send`方法不使用目的地参数，而是使用默认的目的地。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following example uses the `MessageCreator` callback to create a text message from the supplied `Session` object:
#### ** Chinese **

下面的示例使用 `MessageCreator`回调来从提供的`Session`对象中创建一个文本消息。

<!-- tabs:end -->


```java
import javax.jms.ConnectionFactory;
import javax.jms.JMSException;
import javax.jms.Message;
import javax.jms.Queue;
import javax.jms.Session;

import org.springframework.jms.core.MessageCreator;
import org.springframework.jms.core.JmsTemplate;

public class JmsQueueSender {

    private JmsTemplate jmsTemplate;
    private Queue queue;

    public void setConnectionFactory(ConnectionFactory cf) {
        this.jmsTemplate = new JmsTemplate(cf);
    }

    public void setQueue(Queue queue) {
        this.queue = queue;
    }

    public void simpleSend() {
        this.jmsTemplate.send(this.queue, new MessageCreator() {
            public Message createMessage(Session session) throws JMSException {
                return session.createTextMessage("hello queue world");
            }
        });
    }
}
```

<!-- tabs:start -->

#### ** English **

In the preceding example, the `JmsTemplate` is constructed by passing a reference to a `ConnectionFactory`. As an alternative, a zero-argument constructor and `connectionFactory` is provided and can be used for constructing the instance in JavaBean style (using a `BeanFactory` or plain Java code). Alternatively, consider deriving from Spring’s `JmsGatewaySupport` convenience base class, which provides pre-built bean properties for JMS configuration.
#### ** Chinese **

在前面的例子中，`JmsTemplate`是通过传递一个引用到`ConnectionFactory`来构造的。作为替代方案，我们提供了一个零参数构造函数和 `connectionFactory`，可以用 JavaBean 样式构造实例（使用 `BeanFactory`或纯 Java 代码）。另外，可以考虑从Spring的`JmsGatewaySupport`方便类基类中派生出来，它为JMS配置提供了预建的Bean属性。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The `send(String destinationName, MessageCreator creator)` method lets you send a message by using the string name of the destination. If these names are registered in JNDI, you should set the `destinationResolver` property of the template to an instance of `JndiDestinationResolver`.
#### ** Chinese **

`send(String destinationName, MessageCreator creator)`方法可以让你使用目的地的字符串名来发送消息。如果这些名称在JNDI中注册了，那么应该将模板的`destinationResolver`属性设置为`JndiDestinationResolver`的实例。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

If you created the `JmsTemplate` and specified a default destination, the `send(MessageCreator c)` sends a message to that destination.
#### ** Chinese **

如果您创建了`JmsTemplate`并指定了一个默认的目的地，那么`send(MessageCreator c)`就会向该目的地发送消息。

<!-- tabs:end -->


### **3.2.1. Using Message Converters** 

<!-- tabs:start -->

#### ** English **

To facilitate the sending of domain model objects, the `JmsTemplate` has various send methods that take a Java object as an argument for a message’s data content. The overloaded methods `convertAndSend()` and `receiveAndConvert()` methods in `JmsTemplate` delegate the conversion process to an instance of the `MessageConverter` interface. This interface defines a simple contract to convert between Java objects and JMS messages. The default implementation (`SimpleMessageConverter`) supports conversion between `String` and `TextMessage`, `byte[]` and `BytesMesssage`, and `java.util.Map` and `MapMessage`. By using the converter, you and your application code can focus on the business object that is being sent or received through JMS and not be concerned with the details of how it is represented as a JMS message.
#### ** Chinese **

为了方便发送域模型对象，`JmsTemplate`中的`JmsTemplate`有各种发送方法，这些方法将Java对象作为消息数据内容的参数。`JmsTemplate`中的重载方法`convertAndSend()`和`receiveAndConvert()`方法将转换过程委托给`MessageConverter`接口的实例。这个接口定义了一个简单的契约，用于在Java对象和JMS消息之间进行转换。默认实现(`SimpleMessageConverter`)支持在`String`和`TextMessage`、`byte[]`和`BytesMesssage`以及`java.util.Map`和`MapMessage`之间进行转换。通过使用该转换器，您和您的应用程序代码可以专注于通过JMS发送或接收的业务对象，而不必担心如何将其表示为JMS消息的细节。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The sandbox currently includes a `MapMessageConverter`, which uses reflection to convert between a JavaBean and a `MapMessage`. Other popular implementation choices you might implement yourself are converters that use an existing XML marshalling package (such as JAXB or XStream) to create a `TextMessage` that represents the object.
#### ** Chinese **

沙盒目前包括一个`MapMessageConverter`，它使用反射在JavaBean和`MapMessage`之间进行转换。你可以自己实现的其他流行的实现选择是使用现有的 XML 调用包（如 JAXB 或 XStream）来创建表示对象的 `TextMessage`的转换器。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

To accommodate the setting of a message’s properties, headers, and body that can not be generically encapsulated inside a converter class, the `MessagePostProcessor` interface gives you access to the message after it has been converted but before it is sent. The following example shows how to modify a message header and a property after a `java.util.Map` is converted to a message:
#### ** Chinese **

为了适应不能在转换器类中通用地封装的消息的属性、标题和正文的设置，`MessagePostProcessor`接口为您提供了在消息转换后但在发送之前访问消息的权限。下面的例子显示了如何在`java.util.Map`转换为消息后修改消息头和属性。

<!-- tabs:end -->


```java
public void sendWithConversion() {
    Map map = new HashMap();
    map.put("Name", "Mark");
    map.put("Age", new Integer(47));
    jmsTemplate.convertAndSend("testQueue", map, new MessagePostProcessor() {
        public Message postProcessMessage(Message message) throws JMSException {
            message.setIntProperty("AccountID", 1234);
            message.setJMSCorrelationID("123-00001");
            return message;
        }
    });
}
```

<!-- tabs:start -->

#### ** English **

This results in a message of the following form:
#### ** Chinese **

这就导致了以下形式的信息：

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

MapMessage={ Header={ ... standard headers ... CorrelationID={123-00001} } Properties={ AccountID={Integer:1234} } Fields={ Name={String:Mark} Age={Integer:47} }
#### ** Chinese **

MapMessage={ Header={.....标准标题.....。CorrelationID={123-00001} } 属性={ AccountID={Integer:1234} } 字段={名称={String:Mark} 年龄={Integer:47} }

<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

}
#### ** Chinese **

}

<!-- tabs:end -->


### **3.2.2. Using** **`SessionCallback`** ** and** **`ProducerCallback`** 

<!-- tabs:start -->

#### ** English **

While the send operations cover many common usage scenarios, you might sometimes want to perform multiple operations on a JMS `Session` or `MessageProducer`. The `SessionCallback` and `ProducerCallback` expose the JMS `Session` and `Session` / `MessageProducer` pair, respectively. The `execute()` methods on `JmsTemplate` execute these callback methods.
#### ** Chinese **

虽然发送操作涵盖了许多常见的使用场景，但有时您可能希望对一个JMS `Session`或`MessageProducer`执行多个操作。`SessionCallback`和`ProducerCallback`分别暴露了JMS的`Session`和`Session`/`MessageProducer`对。`execute()`方法在`JmsTemplate`上的`execute()`方法执行这些回调方法。

<!-- tabs:end -->


### **3.3. Receiving a Message** 

<!-- tabs:start -->

#### ** English **

This describes how to receive messages with JMS in Spring.
#### ** Chinese **

这里介绍的是如何在Spring中使用JMS接收消息。

<!-- tabs:end -->


### **3.3.1. Synchronous Reception** 

<!-- tabs:start -->

#### ** English **

While JMS is typically associated with asynchronous processing, you can consume messages synchronously. The overloaded `receive(..)` methods provide this functionality. During a synchronous receive, the calling thread blocks until a message becomes available. This can be a dangerous operation, since the calling thread can potentially be blocked indefinitely. The `receiveTimeout` property specifies how long the receiver should wait before giving up waiting for a message.
#### ** Chinese **

虽然JMS通常与异步处理相关联，但你可以同步消耗消息。重载的`receive(..)`方法提供了这个功能。在同步接收期间，调用线程会阻塞，直到有消息可用为止。这可能是一个危险的操作，因为调用线程有可能被无限期地阻塞。`receiveTimeout` 属性指定了接收方在放弃等待消息之前应该等待多长时间。

<!-- tabs:end -->


### **3.3.2. Asynchronous reception: Message-Driven POJOs** 

<!-- tabs:start -->

#### ** English **

Spring also supports annotated-listener endpoints through the use of the `@JmsListener` annotation and provides an open infrastructure to register endpoints programmatically. This is, by far, the most convenient way to setup an asynchronous receiver. See [Enable Listener Endpoint Annotations](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#jms-annotated-support) for more details.
#### ** Chinese **

Spring还通过使用`@JmsListener`注解来支持注解-监听器端点，并提供了一个开放的基础架构来编程注册端点。到目前为止，这是设置异步接收器最方便的方法。更多详情，请参阅[启用监听器端点注释](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#jms-annotated-support)。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

In a fashion similar to a Message-Driven Bean (MDB) in the EJB world, the Message-Driven POJO (MDP) acts as a receiver for JMS messages. The one restriction (but see [Using ](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#jms-receiving-async-message-listener-adapter)[`MessageListenerAdapter`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#jms-receiving-async-message-listener-adapter)) on an MDP is that it must implement the `javax.jms.MessageListener` interface. Note that, if your POJO receives messages on multiple threads, it is important to ensure that your implementation is thread-safe.
#### ** Chinese **

以类似于EJB世界中的消息驱动Bean(MDB)的方式，消息驱动的POJO(MDP)作为JMS消息的接收器。在MDP上的一个限制（但请参见[使用](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#jms-receiving-async-message-listener-adapter)[`MessageListenerAdapter`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#jms-receiving-async-message-listener-adapter)）是它必须实现`javax.jms.MessageListener`接口。请注意，如果你的POJO在多个线程上接收消息，必须确保你的实现是线程安全的。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following example shows a simple implementation of an MDP:
#### ** Chinese **

下面的例子是一个MDP的简单实现。

<!-- tabs:end -->


```java
import javax.jms.JMSException;
import javax.jms.Message;
import javax.jms.MessageListener;
import javax.jms.TextMessage;

public class ExampleListener implements MessageListener {

    public void onMessage(Message message) {
        if (message instanceof TextMessage) {
            try {
                System.out.println(((TextMessage) message).getText());
            }
            catch (JMSException ex) {
                throw new RuntimeException(ex);
            }
        }
        else {
            throw new IllegalArgumentException("Message must be of type TextMessage");
        }
    }
}
```

<!-- tabs:start -->

#### ** English **

Once you have implemented your `MessageListener`, it is time to create a message listener container.
#### ** Chinese **

一旦你实现了`MessageListener`，是时候创建一个消息监听器容器了。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following example shows how to define and configure one of the message listener containers that ships with Spring (in this case, `DefaultMessageListenerContainer`):
#### ** Chinese **

下面的示例显示了如何定义和配置 Spring 自带的消息监听器容器之一（在本例中，`DefaultMessageListenerContainer`）。

<!-- tabs:end -->


```xml
<!-- this is the Message Driven POJO (MDP) -->
<bean id="messageListener" class="jmsexample.ExampleListener"/>

<!-- and this is the message listener container -->
<bean id="jmsContainer" class="org.springframework.jms.listener.DefaultMessageListenerContainer">
    <property name="connectionFactory" ref="connectionFactory"/>
    <property name="destination" ref="destination"/>
    <property name="messageListener" ref="messageListener"/>
</bean>
```

<!-- tabs:start -->

#### ** English **

See the Spring javadoc of the various message listener containers (all of which implement [MessageListenerContainer](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/jms/listener/MessageListenerContainer.html)) for a full description of the features supported by each implementation.
#### ** Chinese **

有关每个实现所支持的功能的完整描述，请参见各种消息监听器容器的Spring javadoc（所有这些容器都实现了[MessageListenerContainer](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/jms/listener/MessageListenerContainer.html)）。

<!-- tabs:end -->


### **3.3.3. Using the** **`SessionAwareMessageListener`** ** Interface** 

<!-- tabs:start -->

#### ** English **

The `SessionAwareMessageListener` interface is a Spring-specific interface that provides a similar contract to the JMS `MessageListener` interface but also gives the message-handling method access to the JMS `Session` from which the `Message` was received. The following listing shows the definition of the `SessionAwareMessageListener` interface:
#### ** Chinese **

`SessionAwareMessageListener`接口是一个特定于Spring的接口，它提供了一个类似于JMS `MessageListener`接口的契约，但同时也为消息处理方法提供了对JMS `Session`的访问权限，而JMS `Session`是从哪个JMS `Message`接收到的消息。下面的列表显示了`SessionAwareMessageListener`接口的定义。

<!-- tabs:end -->


```java
package org.springframework.jms.listener;

public interface SessionAwareMessageListener {

    void onMessage(Message message, Session session) throws JMSException;
}
```

<!-- tabs:start -->

#### ** English **

You can choose to have your MDPs implement this interface (in preference to the standard JMS `MessageListener` interface) if you want your MDPs to be able to respond to any received messages (by using the `Session` supplied in the `onMessage(Message, Session)` method). All of the message listener container implementations that ship with Spring have support for MDPs that implement either the `MessageListener` or `SessionAwareMessageListener` interface. Classes that implement the `SessionAwareMessageListener` come with the caveat that they are then tied to Spring through the interface. The choice of whether or not to use it is left entirely up to you as an application developer or architect.
#### ** Chinese **

如果您希望您的MDP能够响应任何收到的消息（通过使用`onMessage(Message, Session)`方法中提供的`Session`），您可以选择让您的MDP实现此接口（优先于标准的JMS `MessageListener`接口）。所有与Spring一起发布的消息监听器容器实现都支持实现了`MessageListener`或`SessionAwareMessageListener`接口的MDP。实现了 `SessionAwareMessageListener`的类有一个注意事项，即通过该接口与Spring绑定。至于是否使用它，完全由你作为应用开发者或架构师来决定。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Note that the `onMessage(..)` method of the `SessionAwareMessageListener` interface throws `JMSException`. In contrast to the standard JMS `MessageListener` interface, when using the `SessionAwareMessageListener` interface, it is the responsibility of the client code to handle any thrown exceptions.
#### ** Chinese **

注意，`SessionAwareMessageListener`接口的`onMessage(..)`方法会抛出`JMSException`。与标准的JMS `MessageListener`接口不同，当使用`SessionAwareMessageListener`接口时，客户端代码有责任处理任何抛出的异常。

<!-- tabs:end -->


### **3.3.4. Using** **`MessageListenerAdapter`** 

<!-- tabs:start -->

#### ** English **

The `MessageListenerAdapter` class is the final component in Spring’s asynchronous messaging support. In a nutshell, it lets you expose almost any class as an MDP (though there are some constraints).
#### ** Chinese **

`MessageListenerAdapter`类是Spring异步消息支持中的最后一个组件。简而言之，它可以让你把几乎所有的类都作为MDP暴露出来（尽管有一些限制）。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Consider the following interface definition:
#### ** Chinese **

考虑下面的接口定义。

<!-- tabs:end -->


```java
public interface MessageDelegate {

    void handleMessage(String message);

    void handleMessage(Map message);

    void handleMessage(byte[] message);

    void handleMessage(Serializable message);
}
```

<!-- tabs:start -->

#### ** English **

Notice that, although the interface extends neither the `MessageListener` nor the `SessionAwareMessageListener` interface, you can still use it as an MDP by using the `MessageListenerAdapter` class. Notice also how the various message handling methods are strongly typed according to the contents of the various `Message` types that they can receive and handle.
#### ** Chinese **

请注意，虽然该接口既没有扩展`MessageListener`，也没有扩展`SessionAwareMessageListener`接口，但你仍然可以通过使用`MessageListenerAdapter`类将其作为MDP使用。还请注意，各种消息处理方法是如何根据它们可以接收和处理的各种`Message`类型的内容进行强类型化的。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Now consider the following implementation of the `MessageDelegate` interface:
#### ** Chinese **

现在考虑以下`MessageDelegate`接口的实现。

<!-- tabs:end -->


```java
public class DefaultMessageDelegate implements MessageDelegate {
    // implementation elided for clarity...
}
```

<!-- tabs:start -->

#### ** English **

In particular, note how the preceding implementation of the `MessageDelegate` interface (the `DefaultMessageDelegate` class) has no JMS dependencies at all. It truly is a POJO that we can make into an MDP through the following configuration:
#### ** Chinese **

特别要注意的是，前面的`MessageDelegate`接口（`DefaultMessageDelegate`类）完全没有JMS的依赖。它确实是一个POJO，我们可以通过下面的配置将其变成一个MDP。

<!-- tabs:end -->


```xml
<!-- this is the Message Driven POJO (MDP) -->
<bean id="messageListener" class="org.springframework.jms.listener.adapter.MessageListenerAdapter">
    <constructor-arg>
        <bean class="jmsexample.DefaultMessageDelegate"/>
    </constructor-arg>
</bean>

<!-- and this is the message listener container... -->
<bean id="jmsContainer" class="org.springframework.jms.listener.DefaultMessageListenerContainer">
    <property name="connectionFactory" ref="connectionFactory"/>
    <property name="destination" ref="destination"/>
    <property name="messageListener" ref="messageListener"/>
</bean>
```

<!-- tabs:start -->

#### ** English **

The next example shows another MDP that can handle only receiving JMS `TextMessage` messages. Notice how the message handling method is actually called `receive` (the name of the message handling method in a `MessageListenerAdapter` defaults to `handleMessage`), but it is configurable (as you can see later in this section). Notice also how the `receive(..)` method is strongly typed to receive and respond only to JMS `TextMessage` messages. The following listing shows the definition of the `TextMessageDelegate` interface:
#### ** Chinese **

下面的例子显示了另一个MDP，它只能处理接收JMS `TextMessage`消息。注意消息处理方法实际上是如何调用`receive`的（`MessageListenerAdapter`中的消息处理方法的名称默认为`handleMessage`），但它是可以配置的（你可以在本节后面的章节中看到）。另外，请注意`receive(..)`方法是如何被强行键入的，以接收并仅响应JMS `TextMessage`消息。下面的列表显示了`TextMessageDelegate`接口的定义。

<!-- tabs:end -->


```java
public interface TextMessageDelegate {

    void receive(TextMessage message);
}
```

<!-- tabs:start -->

#### ** English **

The following listing shows a class that implements the `TextMessageDelegate` interface:
#### ** Chinese **

下面列出了一个实现了`TextMessageDelegate`接口的类。

<!-- tabs:end -->


```java
public class DefaultTextMessageDelegate implements TextMessageDelegate {
    // implementation elided for clarity...
}
```

<!-- tabs:start -->

#### ** English **

The configuration of the attendant `MessageListenerAdapter` would then be as follows:
#### ** Chinese **

然后，出席者`MessageListenerAdapter`的配置如下。

<!-- tabs:end -->


```xml
<bean id="messageListener" class="org.springframework.jms.listener.adapter.MessageListenerAdapter">
    <constructor-arg>
        <bean class="jmsexample.DefaultTextMessageDelegate"/>
    </constructor-arg>
    <property name="defaultListenerMethod" value="receive"/>
    <!-- we don't want automatic message context extraction -->
    <property name="messageConverter">
        <null/>
    </property>
</bean>
```

<!-- tabs:start -->

#### ** English **

Note that, if the `messageListener` receives a JMS `Message` of a type other than `TextMessage`, an `IllegalStateException` is thrown (and subsequently swallowed). Another of the capabilities of the `MessageListenerAdapter` class is the ability to automatically send back a response `Message` if a handler method returns a non-void value. Consider the following interface and class:
#### ** Chinese **

请注意，如果`messageListener`接收到的JMS `Message`的类型不是`TextMessage`，则会抛出一个`IllegalStateException`（并随后被吞噬）。`MessageListenerAdapter`类的另一个功能是，如果处理程序方法返回一个非void值，可以自动发送回一个响应`Message`。考虑下面的接口和类。

<!-- tabs:end -->


```java
public interface ResponsiveTextMessageDelegate {

    // notice the return type...
    String receive(TextMessage message);
}
```

```java
public class DefaultResponsiveTextMessageDelegate implements ResponsiveTextMessageDelegate {
    // implementation elided for clarity...
}
```

<!-- tabs:start -->

#### ** English **

If you use the `DefaultResponsiveTextMessageDelegate` in conjunction with a `MessageListenerAdapter`, any non-null value that is returned from the execution of the `'receive(..)'` method is (in the default configuration) converted into a `TextMessage`. The resulting `TextMessage` is then sent to the `Destination` (if one exists) defined in the JMS `Reply-To` property of the original `Message` or the default `Destination` set on the `MessageListenerAdapter` (if one has been configured). If no `Destination` is found, an `InvalidDestinationException` is thrown (note that this exception is not swallowed and propagates up the call stack).
#### ** Chinese **

如果您将`DefaultResponsiveTextMessageDelegate`与`MessageListenerAdapter`结合使用，那么从执行`'receive(..)'`方法中返回的任何非空值都会（在默认配置中）被转换为`TextMessage`。然后将生成的`TextMessage`发送到在原始`Message`的JMS `Reply-To`属性中定义的`Destination`（如果有的话），或者在`MessageListenerAdapter`上设置的默认`Destination`（如果配置了的话）。如果没有找到 `Destination`，则会抛出一个 `InvalidDestinationException`（注意，这个异常不会被吞噬，并在调用栈中向上传播）。

<!-- tabs:end -->


### **3.3.5. Processing Messages Within Transactions** 

<!-- tabs:start -->

#### ** English **

Invoking a message listener within a transaction requires only reconfiguration of the listener container.
#### ** Chinese **

在事务中调用消息监听器只需要重新配置监听器容器。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can activate local resource transactions through the `sessionTransacted` flag on the listener container definition. Each message listener invocation then operates within an active JMS transaction, with message reception rolled back in case of listener execution failure. Sending a response message (through `SessionAwareMessageListener`) is part of the same local transaction, but any other resource operations (such as database access) operate independently. This usually requires duplicate message detection in the listener implementation, to cover the case where database processing has committed but message processing failed to commit.
#### ** Chinese **

你可以通过监听器容器定义上的`sessionTransacted`标志激活本地资源事务。然后，每个消息监听器调用都会在活动的JMS事务中运行，如果监听器执行失败，消息接收会回滚。发送一个响应消息（通过`SessionAwareMessageListener`）是同一个本地事务的一部分，但任何其他资源操作（如数据库访问）都是独立运行的。这通常需要在监听器实现中进行重复消息检测，以覆盖数据库处理已经提交但消息处理失败的情况。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Consider the following bean definition:
#### ** Chinese **

考虑以下豆子的定义。

<!-- tabs:end -->


```xml
<bean id="jmsContainer" class="org.springframework.jms.listener.DefaultMessageListenerContainer">
    <property name="connectionFactory" ref="connectionFactory"/>
    <property name="destination" ref="destination"/>
    <property name="messageListener" ref="messageListener"/>
    <property name="sessionTransacted" value="true"/>
</bean>
```

<!-- tabs:start -->

#### ** English **

To participate in an externally managed transaction, you need to configure a transaction manager and use a listener container that supports externally managed transactions (typically, `DefaultMessageListenerContainer`).
#### ** Chinese **

要参与外部管理的事务，需要配置事务管理器并使用支持外部管理事务的监听器容器（通常是`DefaultMessageListenerContainer`）。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

To configure a message listener container for XA transaction participation, you want to configure a `JtaTransactionManager` (which, by default, delegates to the Java EE server’s transaction subsystem). Note that the underlying JMS `ConnectionFactory` needs to be XA-capable and properly registered with your JTA transaction coordinator. (Check your Java EE server’s configuration of JNDI resources.) This lets message reception as well as (for example) database access be part of the same transaction (with unified commit semantics, at the expense of XA transaction log overhead).
#### ** Chinese **

要为XA事务参与配置一个消息监听器容器，需要配置一个`JtaTransactionManager`（默认情况下，该容器委托给Java EE服务器的事务子系统）。请注意，底层的 JMS `ConnectionFactory`需要具备 XA 功能，并在 JTA 事务协调器中正确注册。(检查你的Java EE服务器的JNDI资源配置。)这使得消息接收和(例如)数据库访问都是同一事务的一部分(具有统一的提交语义，但牺牲了XA事务日志开销)。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following bean definition creates a transaction manager:
#### ** Chinese **

下面的Bean定义创建了一个事务管理器。

<!-- tabs:end -->


```xml
<bean id="transactionManager" class="org.springframework.transaction.jta.JtaTransactionManager"/>
```

<!-- tabs:start -->

#### ** English **

Then we need to add it to our earlier container configuration. The container takes care of the rest. The following example shows how to do so:
#### ** Chinese **

然后我们需要将其添加到我们之前的容器配置中。剩下的事情就交给容器来处理了。下面的例子显示了如何做到这一点。

<!-- tabs:end -->


```xml
<bean id="jmsContainer" class="org.springframework.jms.listener.DefaultMessageListenerContainer">
    <property name="connectionFactory" ref="connectionFactory"/>
    <property name="destination" ref="destination"/>
    <property name="messageListener" ref="messageListener"/>
    <property name="transactionManager" ref="transactionManager"/> (1)
</bean>
```

<!-- tabs:start -->

#### ** English **

(1)Our transaction manager.
#### ** Chinese **

(1)我们的交易经理。

<!-- tabs:end -->


### **3.4. Support for JCA Message Endpoints** 

<!-- tabs:start -->

#### ** English **

Beginning with version 2.5, Spring also provides support for a JCA-based `MessageListener` container. The `JmsMessageEndpointManager` tries to automatically determine the `ActivationSpec` class name from the provider’s `ResourceAdapter` class name. Therefore, it is typically possible to provide Spring’s generic `JmsActivationSpecConfig`, as the following example shows:
#### ** Chinese **

从2.5版本开始，Spring还提供了对基于JCA的`MessageListener`容器的支持。`JmsMessageEndpointManager`试图从提供者的`ResourceAdapter`类名称中自动确定`ActivationSpec`类名称。因此，通常可以提供Spring的通用`JmsActivationSpecConfig`，如下例所示。

<!-- tabs:end -->


```xml
<bean class="org.springframework.jms.listener.endpoint.JmsMessageEndpointManager">
    <property name="resourceAdapter" ref="resourceAdapter"/>
    <property name="activationSpecConfig">
        <bean class="org.springframework.jms.listener.endpoint.JmsActivationSpecConfig">
            <property name="destinationName" value="myQueue"/>
        </bean>
    </property>
    <property name="messageListener" ref="myMessageListener"/>
</bean>
```

<!-- tabs:start -->

#### ** English **

Alternatively, you can set up a `JmsMessageEndpointManager` with a given `ActivationSpec` object. The `ActivationSpec` object may also come from a JNDI lookup (using `<jee:jndi-lookup>`). The following example shows how to do so:
#### ** Chinese **

另外，你也可以用给定的 `ActivationSpec`对象来设置`JmsMessageEndpointManager`。`ActivationSpec`对象也可以来自JNDI查询（使用`<jee:jndi-lookup>`）。下面的例子显示了如何做到这一点。

<!-- tabs:end -->


```xml
<bean class="org.springframework.jms.listener.endpoint.JmsMessageEndpointManager">
    <property name="resourceAdapter" ref="resourceAdapter"/>
    <property name="activationSpec">
        <bean class="org.apache.activemq.ra.ActiveMQActivationSpec">
            <property name="destination" value="myQueue"/>
            <property name="destinationType" value="javax.jms.Queue"/>
        </bean>
    </property>
    <property name="messageListener" ref="myMessageListener"/>
</bean>
```

<!-- tabs:start -->

#### ** English **

Using Spring’s `ResourceAdapterFactoryBean`, you can configure the target `ResourceAdapter` locally, as the following example shows:
#### ** Chinese **

使用Spring的`ResourceAdapterFactoryBean`，你可以在本地配置目标`ResourceAdapter`，如下例所示。

<!-- tabs:end -->


```xml
<bean id="resourceAdapter" class="org.springframework.jca.support.ResourceAdapterFactoryBean">
    <property name="resourceAdapter">
        <bean class="org.apache.activemq.ra.ActiveMQResourceAdapter">
            <property name="serverUrl" value="tcp://localhost:61616"/>
        </bean>
    </property>
    <property name="workManager">
        <bean class="org.springframework.jca.work.SimpleTaskWorkManager"/>
    </property>
</bean>
```

<!-- tabs:start -->

#### ** English **

The specified `WorkManager` can also point to an environment-specific thread pool — typically through a `SimpleTaskWorkManager` instance’s `asyncTaskExecutor` property. Consider defining a shared thread pool for all your `ResourceAdapter` instances if you happen to use multiple adapters.
#### ** Chinese **

指定的`WorkManager`也可以指向环境特定的线程池 - 通常通过`SimpleTaskWorkManager`实例的`asyncTaskExecutor`属性。如果您碰巧使用多个适配器，请考虑为所有的 `ResourceAdapter`实例定义一个共享线程池。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

In some environments (such as WebLogic 9 or above), you can instead obtain the entire `ResourceAdapter` object from JNDI (by using `<jee:jndi-lookup>`). The Spring-based message listeners can then interact with the server-hosted `ResourceAdapter`, which also use the server’s built-in `WorkManager`.
#### ** Chinese **

在某些环境中（如 WebLogic 9 或更高版本），可以从 JNDI 中获取整个 `ResourceAdapter`对象（通过使用 `<jee:jndi-lookup>`）。然后，基于Spring的消息监听器可以与服务器托管的`ResourceAdapter`进行交互，后者也使用服务器内置的`WorkManager`。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

See the javadoc for [`JmsMessageEndpointManager`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/jms/listener/endpoint/JmsMessageEndpointManager.html), [`JmsActivationSpecConfig`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/jms/listener/endpoint/JmsActivationSpecConfig.html), and [`ResourceAdapterFactoryBean`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/jca/support/ResourceAdapterFactoryBean.html) for more details.
#### ** Chinese **

有关详细信息，请参见 [`JmsMessageEndpointManager`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/jms/listener/endpoint/JmsMessageEndpointManager.html)、[`JmsActivationSpecConfig`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/jms/listener/endpoint/JmsActivationSpecConfig.html)和[`ResourceAdapterFactoryBean`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/jca/support/ResourceAdapterFactoryBean.html)的 javadoc。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Spring also provides a generic JCA message endpoint manager that is not tied to JMS: `org.springframework.jca.endpoint.GenericMessageEndpointManager`. This component allows for using any message listener type (such as a CCI `MessageListener`) and any provider-specific `ActivationSpec` object. See your JCA provider’s documentation to find out about the actual capabilities of your connector, and see the [`GenericMessageEndpointManager`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/jca/endpoint/GenericMessageEndpointManager.html) javadoc for the Spring-specific configuration details.
#### ** Chinese **

Spring还提供了一个不与JMS绑定的通用JCA消息端点管理器：`org.springframework.jca.endpoint.GenericMessageEndpointManager`。该组件允许使用任何消息监听器类型（如CCI `MessageListener`）和任何特定于提供者的`ActivationSpec`对象。请参阅您的 JCA 提供商的文档，了解您的连接器的实际功能，并参阅 [`GenericMessageEndpointManager`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/jca/endpoint/GenericMessageEndpointManager.html) javadoc，了解 Spring 特定配置细节。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

JCA-based message endpoint management is very analogous to EJB 2.1 Message-Driven Beans. It uses the same underlying resource provider contract. As with EJB 2.1 MDBs, you can use any message listener interface supported by your JCA provider in the Spring context as well. Spring nevertheless provides explicit “convenience” support for JMS, because JMS is the most common endpoint API used with the JCA endpoint management contract.
#### ** Chinese **

基于JCA的消息端点管理与EJB 2.1消息驱动的Beans非常相似。它使用相同的底层资源提供者合约。与EJB 2.1 MDB一样，你也可以在Spring上下文中使用JCA提供者支持的任何消息监听器接口。尽管如此，Spring还是为JMS提供了明确的 方便 支持，因为JMS是与JCA端点管理合约一起使用的最常见的端点API。

<!-- tabs:end -->


### **3.5. Annotation-driven Listener Endpoints** 

<!-- tabs:start -->

#### ** English **

The easiest way to receive a message asynchronously is to use the annotated listener endpoint infrastructure. In a nutshell, it lets you expose a method of a managed bean as a JMS listener endpoint. The following example shows how to use it:
#### ** Chinese **

异步接收消息的最简单的方法是使用注释的监听器端点基础设施。一言以蔽之，它可以让你把一个被管理的Bean的方法作为JMS监听器端点暴露出来。下面的例子显示了如何使用它。

<!-- tabs:end -->


```java
@Component
public class MyService {

    @JmsListener(destination = "myDestination")
    public void processOrder(String data) { ... }
}
```

<!-- tabs:start -->

#### ** English **

The idea of the preceding example is that, whenever a message is available on the `javax.jms.Destination` `myDestination`, the `processOrder` method is invoked accordingly (in this case, with the content of the JMS message, similar to what the [`MessageListenerAdapter`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#jms-receiving-async-message-listener-adapter) provides).
#### ** Chinese **

前面这个例子的想法是，每当在`javax.jms.Destination` `javax.jms.Destination` `myDestination`上有消息时，就会相应地调用`processOrder`方法（在这种情况下，使用JMS消息的内容，类似于[`MessageListenerAdapter`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#jms-receiving-async-message-listener-adapter)提供的内容）。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The annotated endpoint infrastructure creates a message listener container behind the scenes for each annotated method, by using a `JmsListenerContainerFactory`. Such a container is not registered against the application context but can be easily located for management purposes by using the `JmsListenerEndpointRegistry` bean.
#### ** Chinese **

注解的端点基础架构通过使用`JmsListenerContainerFactory` Bean，为每个被注释的方法创建一个消息监听器容器。这样的容器不会在应用上下文中注册，但可以通过使用`JmsListenerEndpointRegistry` bean来方便地定位，以便于管理。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

`@JmsListener` is a repeatable annotation on Java 8, so you can associate several JMS destinations with the same method by adding additional `@JmsListener` declarations to it.
#### ** Chinese **

`@JmsListener`是Java 8上的一个可重复注释，因此您可以通过向其添加额外的`@JmsListener`声明，将多个JMS目的地与同一个方法关联起来。

<!-- tabs:end -->


### **3.5.1. Enable Listener Endpoint Annotations** 

<!-- tabs:start -->

#### ** English **

To enable support for `@JmsListener` annotations, you can add `@EnableJms` to one of your `@Configuration` classes, as the following example shows:
#### ** Chinese **

要启用对`@JmsListener`注释的支持，可以在`@Configuration`类中添加`@EnableJms`，如下例所示。

<!-- tabs:end -->


```java
@Configuration
@EnableJms
public class AppConfig {

    @Bean
    public DefaultJmsListenerContainerFactory jmsListenerContainerFactory() {
        DefaultJmsListenerContainerFactory factory = new DefaultJmsListenerContainerFactory();
        factory.setConnectionFactory(connectionFactory());
        factory.setDestinationResolver(destinationResolver());
        factory.setSessionTransacted(true);
        factory.setConcurrency("3-10");
        return factory;
    }
}
```

<!-- tabs:start -->

#### ** English **

By default, the infrastructure looks for a bean named `jmsListenerContainerFactory` as the source for the factory to use to create message listener containers. In this case (and ignoring the JMS infrastructure setup), you can invoke the `processOrder` method with a core poll size of three threads and a maximum pool size of ten threads.
#### ** Chinese **

默认情况下，基础架构会寻找一个名为`jmsListenerContainerFactory`的Bean，作为用于创建消息监听容器的工厂的源。在这种情况下（并且忽略JMS基础架构设置），可以调用`processOrder`方法，核心轮询大小为三个线程，最大池子大小为十个线程。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can customize the listener container factory to use for each annotation or you can configure an explicit default by implementing the `JmsListenerConfigurer` interface. The default is required only if at least one endpoint is registered without a specific container factory. See the javadoc of classes that implement [`JmsListenerConfigurer`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/jms/annotation/JmsListenerConfigurer.html) for details and examples.
#### ** Chinese **

您可以为每个注释自定义监听器容器工厂，或通过实现`JmsListenerConfigurer`接口配置一个显式默认值。只有在至少有一个端点注册了没有特定的容器工厂的情况下，才需要使用默认值。有关详细信息和示例，请参阅实现 [`JmsListenerConfigurer`的类的 javadoc](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/jms/annotation/JmsListenerConfigurer.html)。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

If you prefer [XML configuration](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#jms-namespace), you can use the `<jms:annotation-driven>` element, as the following example shows:
#### ** Chinese **

如果你喜欢[XML配置](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#jms-namespace)，你可以使用`<jms:annotation-driven>`元素，如下例所示。

<!-- tabs:end -->


```xml
<jms:annotation-driven/>

<bean id="jmsListenerContainerFactory"
        class="org.springframework.jms.config.DefaultJmsListenerContainerFactory">
    <property name="connectionFactory" ref="connectionFactory"/>
    <property name="destinationResolver" ref="destinationResolver"/>
    <property name="sessionTransacted" value="true"/>
    <property name="concurrency" value="3-10"/>
</bean>
```

### **3.5.2. Programmatic Endpoint Registration** 

<!-- tabs:start -->

#### ** English **

`JmsListenerEndpoint` provides a model of a JMS endpoint and is responsible for configuring the container for that model. The infrastructure lets you programmatically configure endpoints in addition to the ones that are detected by the `JmsListener` annotation. The following example shows how to do so:
#### ** Chinese **

`JmsListenerEndpoint`提供了一个JMS端点模型，并负责为该模型配置容器。除了 `JmsListener` 注解所检测到的端点之外，该基础架构还允许您对端点进行编程配置。下面的例子显示了如何做到这一点。

<!-- tabs:end -->


```java
@Configuration
@EnableJms
public class AppConfig implements JmsListenerConfigurer {

    @Override
    public void configureJmsListeners(JmsListenerEndpointRegistrar registrar) {
        SimpleJmsListenerEndpoint endpoint = new SimpleJmsListenerEndpoint();
        endpoint.setId("myJmsEndpoint");
        endpoint.setDestination("anotherQueue");
        endpoint.setMessageListener(message -> {
            // processing
        });
        registrar.registerEndpoint(endpoint);
    }
}
```

<!-- tabs:start -->

#### ** English **

In the preceding example, we used `SimpleJmsListenerEndpoint`, which provides the actual `MessageListener` to invoke. However, you could also build your own endpoint variant to describe a custom invocation mechanism.
#### ** Chinese **

在前面的例子中，我们使用了`SimpleJmsListenerEndpoint`，它提供了实际的`MessageListener`来调用。不过，你也可以建立自己的端点变体来描述一个自定义的调用机制。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Note that you could skip the use of `@JmsListener` altogether and programmatically register only your endpoints through `JmsListenerConfigurer`.
#### ** Chinese **

注意，你可以完全跳过使用`@JmsListener`，只通过`JmsListenerConfigurer`来编程注册你的端点。

<!-- tabs:end -->


### **3.5.3. Annotated Endpoint Method Signature** 

<!-- tabs:start -->

#### ** English **

So far, we have been injecting a simple `String` in our endpoint, but it can actually have a very flexible method signature. In the following example, we rewrite it to inject the `Order` with a custom header:
#### ** Chinese **

到目前为止，我们一直在端点中注入一个简单的`String`，但实际上它可以有一个非常灵活的方法签名。在下面的例子中，我们将其重写为注入`Order`，并加上一个自定义的头。

<!-- tabs:end -->


```java
@Component
public class MyService {

    @JmsListener(destination = "myDestination")
    public void processOrder(Order order, @Header("order_type") String orderType) {
        ...
    }
}
```

<!-- tabs:start -->

#### ** English **

The main elements you can inject in JMS listener endpoints are as follows:
#### ** Chinese **

你可以在JMS监听器端点中注入的主要元素如下。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

- [`SimpleMessageListenerContainer`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#jms-mdp-simple)

- [`DefaultMessageListenerContainer`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#jms-mdp-default)

- The raw `javax.jms.Message` or any of its subclasses (provided that it matches the incoming message type).

- The `javax.jms.Session` for optional access to the native JMS API (for example, for sending a custom reply).

- The `org.springframework.messaging.Message` that represents the incoming JMS message. Note that this message holds both the custom and the standard headers (as defined by `JmsHeaders`).

- `@Header`-annotated method arguments to extract a specific header value, including standard JMS headers.

- A `@Headers`-annotated argument that must also be assignable to `java.util.Map` for getting access to all headers.

- A non-annotated element that is not one of the supported types (`Message` or `Session`) is considered to be the payload. You can make that explicit by annotating the parameter with `@Payload`. You can also turn on validation by adding an extra `@Valid`.

#### ** Chinese **

- [`SimpleMessageListenerContainer`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#jms-mdp-simple)

- [`DefaultMessageListenerContainer`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#jms-mdp-default)

- 原始的`javax.jms.Message`或其任何子类（只要它与传入的消息类型匹配）。

- `javax.jms.Session`用于可选地访问本地JMS API（例如，用于发送自定义回复）。

- 表示传入的JMS消息的`org.springframework.messaging.Message`。请注意，这个消息同时包含自定义和标准头（由 `JmsHeaders`定义）。

- `@Header`--注释的方法参数，用于提取特定的报头值，包括标准的JMS报头。

- `@Headers`-注释参数，该参数必须也可以分配给`java.util.Map`，以获得对所有头文件的访问。

- 一个不属于支持的类型（`Message`或`Session`）的非注释元素被认为是有效载荷。您可以通过在参数上标注`@Payload`来显式化。您也可以通过添加额外的 `@Valid`来开启验证。


<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

The ability to inject Spring’s `Message` abstraction is particularly useful to benefit from all the information stored in the transport-specific message without relying on transport-specific API. The following example shows how to do so:
#### ** Chinese **

- [`SimpleMessageListenerContainer`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#jms-mdp-simple)

- [`DefaultMessageListenerContainer`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#jms-mdp-default)

- 原始的`javax.jms.Message`或其任何子类（只要它与传入的消息类型匹配）。

- `javax.jms.Session`用于可选地访问本地JMS API（例如，用于发送自定义回复）。

- 表示传入的JMS消息的`org.springframework.messaging.Message`。请注意，这个消息同时包含自定义和标准头（由 `JmsHeaders`定义）。

- `@Header`--注释的方法参数，用于提取特定的报头值，包括标准的JMS报头。

- `@Headers`-注释参数，该参数必须也可以分配给`java.utilite.Map`，以获得对所有头文件的访问。

- 一个不属于支持的类型（`Message`或`Session`）的非注释元素被认为是有效载荷。您可以通过在参数上标注`@Payload`来显式化。您也可以通过添加额外的 `@Valid`来开启验证。


<!-- tabs:end -->


```java
@JmsListener(destination = "myDestination")
public void processOrder(Message<Order> order) { ... }
```

<!-- tabs:start -->

#### ** English **

Handling of method arguments is provided by `DefaultMessageHandlerMethodFactory`, which you can further customize to support additional method arguments. You can customize the conversion and validation support there as well.
#### ** Chinese **

方法参数的处理由 `DefaultMessageHandlerMethodFactory` 提供，你可以进一步自定义以支持额外的方法参数。你也可以在这里定制转换和验证支持。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

For instance, if we want to make sure our `Order` is valid before processing it, we can annotate the payload with `@Valid` and configure the necessary validator, as the following example shows:
#### ** Chinese **

例如，如果我们想确保我们的 `Order` 在处理之前是有效的，我们可以用`@Valid` 来注释有效载荷，并配置必要的验证器，如下例所示。

<!-- tabs:end -->


```java
@Configuration
@EnableJms
public class AppConfig implements JmsListenerConfigurer {

    @Override
    public void configureJmsListeners(JmsListenerEndpointRegistrar registrar) {
        registrar.setMessageHandlerMethodFactory(myJmsHandlerMethodFactory());
    }

    @Bean
    public DefaultMessageHandlerMethodFactory myHandlerMethodFactory() {
        DefaultMessageHandlerMethodFactory factory = new DefaultMessageHandlerMethodFactory();
        factory.setValidator(myValidator());
        return factory;
    }
}
```

### **3.5.4. Response Management** 

<!-- tabs:start -->

#### ** English **

The existing support in [`MessageListenerAdapter`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#jms-receiving-async-message-listener-adapter) already lets your method have a non-`void` return type. When that is the case, the result of the invocation is encapsulated in a `javax.jms.Message`, sent either in the destination specified in the `JMSReplyTo` header of the original message or in the default destination configured on the listener. You can now set that default destination by using the `@SendTo` annotation of the messaging abstraction.
#### ** Chinese **

`MessageListenerAdapter`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#jms-receiving-async-message-listener-adapter)中的现有支持已经允许你的方法有一个非`void`的返回类型。在这种情况下，调用的结果被封装在一个`javax.jms.Message`中，在原始消息的`JMSReplyTo`头中指定的目的地或在监听器上配置的默认目的地中发送。现在，您可以通过使用消息抽象的 `@SendTo` 注解来设置默认目的地。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Assuming that our `processOrder` method should now return an `OrderStatus`, we can write it to automatically send a response, as the following example shows:
#### ** Chinese **

假设我们的`processOrder`方法现在应该返回一个`OrderStatus`，我们可以把它写成自动发送一个响应，如下例所示。

<!-- tabs:end -->


```java
@JmsListener(destination = "myDestination")
@SendTo("status")
public OrderStatus processOrder(Order order) {
    // order processing
    return status;
}
```

<!-- tabs:start -->

#### ** English **

If you have several `@JmsListener`-annotated methods, you can also place the `@SendTo` annotation at the class level to share a default reply destination.
#### ** Chinese **

如果你有几个`@JmsListener`注解的方法，你也可以在类级别上放置`@SendTo`注解，以共享一个默认的回复目的地。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

If you need to set additional headers in a transport-independent manner, you can return a `Message` instead, with a method similar to the following:
#### ** Chinese **

如果你需要以独立于传输的方式设置额外的headers，你可以用类似于下面的方法返回一个`Message`。

<!-- tabs:end -->


```java
@JmsListener(destination = "myDestination")
@SendTo("status")
public Message<OrderStatus> processOrder(Order order) {
    // order processing
    return MessageBuilder
            .withPayload(status)
            .setHeader("code", 1234)
            .build();
}
```

<!-- tabs:start -->

#### ** English **

If you need to compute the response destination at runtime, you can encapsulate your response in a `JmsResponse` instance that also provides the destination to use at runtime. We can rewrite the previous example as follows:
#### ** Chinese **

如果你需要在运行时计算响应目的地，你可以将你的响应封装在一个`JmsResponse`实例中，该实例也提供了在运行时使用的目的地。我们可以将前面的例子重写如下。

<!-- tabs:end -->


```java
@JmsListener(destination = "myDestination")
public JmsResponse<Message<OrderStatus>> processOrder(Order order) {
    // order processing
    Message<OrderStatus> response = MessageBuilder
            .withPayload(status)
            .setHeader("code", 1234)
            .build();
    return JmsResponse.forQueue(response, "status");
}
```

<!-- tabs:start -->

#### ** English **

Finally, if you need to specify some QoS values for the response such as the priority or the time to live, you can configure the `JmsListenerContainerFactory` accordingly, as the following example shows:
#### ** Chinese **

最后，如果你需要为响应指定一些QoS值，比如优先级或活期时间，你可以相应地配置`JmsListenerContainerFactory`，如下例所示。

<!-- tabs:end -->


```java
@Configuration
@EnableJms
public class AppConfig {

    @Bean
    public DefaultJmsListenerContainerFactory jmsListenerContainerFactory() {
        DefaultJmsListenerContainerFactory factory = new DefaultJmsListenerContainerFactory();
        factory.setConnectionFactory(connectionFactory());
        QosSettings replyQosSettings = new QosSettings();
        replyQosSettings.setPriority(2);
        replyQosSettings.setTimeToLive(10000);
        factory.setReplyQosSettings(replyQosSettings);
        return factory;
    }
}
```

### **3.6. JMS Namespace Support** 

<!-- tabs:start -->

#### ** English **

Spring provides an XML namespace for simplifying JMS configuration. To use the JMS namespace elements, you need to reference the JMS schema, as the following example shows:
#### ** Chinese **

Spring提供了一个XML命名空间来简化JMS配置。要使用JMS命名空间元素，需要引用JMS模式，如下例所示。

<!-- tabs:end -->


```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xmlns:jms="http://www.springframework.org/schema/jms" (1)
        xsi:schemaLocation="
            http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd
            http://www.springframework.org/schema/jms https://www.springframework.org/schema/jms/spring-jms.xsd">

    <!-- bean definitions here -->

</beans>
```

<!-- tabs:start -->

#### ** English **

(1)Referencing the JMS schema.
#### ** Chinese **

(1)引用JMS模式。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The namespace consists of three top-level elements: `<annotation-driven/>`, `<listener-container/>` and `<jca-listener-container/>`. `<annotation-driven/>` enables the use of [annotation-driven listener endpoints](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#jms-annotated). `<listener-container/>` and `<jca-listener-container/>` define shared listener container configuration and can contain `<listener/>` child elements. The following example shows a basic configuration for two listeners:
#### ** Chinese **

该命名空间由三个顶层元素组成。 `<annotation-driven/>`、`<listener-container/>`和`<jca-listener-container/>`。 `<annotation-driven/>`可以使用[注释驱动的监听器端点](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#jms-annotated)。 `<listener-container/>`和`<jca-listener-container/>`定义了共享的监听器容器配置，可以包含`<listener/>`子元素。下面的例子显示了两个监听器的基本配置。

<!-- tabs:end -->


```xml
<jms:listener-container>

    <jms:listener destination="queue.orders" ref="orderService" method="placeOrder"/>

    <jms:listener destination="queue.confirmations" ref="confirmationLogger" method="log"/>

</jms:listener-container>
```

<!-- tabs:start -->

#### ** English **

The preceding example is equivalent to creating two distinct listener container bean definitions and two distinct `MessageListenerAdapter` bean definitions, as shown in [Using ](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#jms-receiving-async-message-listener-adapter)[`MessageListenerAdapter`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#jms-receiving-async-message-listener-adapter). In addition to the attributes shown in the preceding example, the `listener` element can contain several optional ones. The following table describes all of the available attributes:
#### ** Chinese **

上面的例子相当于创建了两个不同的listener容器bean定义和两个不同的`MessageListenerAdapter`bean定义，如[使用](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#jms-receiving-async-message-listener-adapter)[`MessageListenerAdapter`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#jms-receiving-async-message-listener-adapter)所示。除了前面例子中显示的属性外，`listener`元素还可以包含几个可选的属性。下表描述了所有可用的属性。

<!-- tabs:end -->


Attribute | Description 
-|-
id | A bean name for the hosting listener container. If not specified, a bean name is automatically generated. 
destination (required) | The destination name for this listener, resolved through the DestinationResolver strategy. 
ref (required) | The bean name of the handler object. 
method | The name of the handler method to invoke. If the ref attribute points to a MessageListener or Spring SessionAwareMessageListener, you can omit this attribute. 
response-destination | The name of the default response destination to which to send response messages. This is applied in case of a request message that does not carry a JMSReplyTo field. The type of this destination is determined by the listener-container’s response-destination-type attribute. Note that this applies only to a listener method with a return value, for which each result object is converted into a response message. 
subscription | The name of the durable subscription, if any. 
selector | An optional message selector for this listener. 
concurrency | The number of concurrent sessions or consumers to start for this listener. This value can either be a simple number indicating the maximum number (for example, 5) or a range indicating the lower as well as the upper limit (for example, 3-5). Note that a specified minimum is only a hint and might be ignored at runtime. The default is the value provided by the container. 


<!-- tabs:start -->

#### ** English **

The `<listener-container/>` element also accepts several optional attributes. This allows for customization of the various strategies (for example, `taskExecutor` and `destinationResolver`) as well as basic JMS settings and resource references. By using these attributes, you can define highly-customized listener containers while still benefiting from the convenience of the namespace.
#### ** Chinese **

`<listener-container/>`元素还接受几个可选的属性。这允许自定义各种策略（例如，`taskExecutor`和`destinationResolver`）以及基本的JMS设置和资源引用。通过使用这些属性，你可以定义高度自定义的监听器容器，同时仍然可以从命名空间的便利性中受益。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can automatically expose such settings as a `JmsListenerContainerFactory` by specifying the `id` of the bean to expose through the `factory-id` attribute, as the following example shows:
#### ** Chinese **

你可以通过`JmsListenerContainerFactory`属性指定要通过`factory-id`属性来自动暴露这样的设置，如下例所示。

<!-- tabs:end -->


```xml
<jms:listener-container connection-factory="myConnectionFactory"
        task-executor="myTaskExecutor"
        destination-resolver="myDestinationResolver"
        transaction-manager="myTransactionManager"
        concurrency="10">

    <jms:listener destination="queue.orders" ref="orderService" method="placeOrder"/>

    <jms:listener destination="queue.confirmations" ref="confirmationLogger" method="log"/>

</jms:listener-container>
```

<!-- tabs:start -->

#### ** English **

The following table describes all available attributes. See the class-level javadoc of the [`AbstractMessageListenerContainer`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/jms/listener/AbstractMessageListenerContainer.html) and its concrete subclasses for more details on the individual properties. The javadoc also provides a discussion of transaction choices and message redelivery scenarios.
#### ** Chinese **

下表描述了所有可用的属性。有关单个属性的更多细节，请参阅 [`AbstractMessageListenerContainer`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/jms/listener/AbstractMessageListenerContainer.html)及其具体子类的类级javadoc。该javadoc还提供了关于事务选择和消息重发场景的讨论。

<!-- tabs:end -->


Attribute | Description 
-|-
container-type | The type of this listener container. The available options are default, simple, default102, or simple102 (the default option is default). 
container-class | A custom listener container implementation class as a fully qualified class name. The default is Spring’s standard DefaultMessageListenerContainer or SimpleMessageListenerContainer, according to the container-type attribute. 
factory-id | Exposes the settings defined by this element as a JmsListenerContainerFactory with the specified id so that they can be reused with other endpoints. 
connection-factory | A reference to the JMS ConnectionFactory bean (the default bean name is connectionFactory). 
task-executor | A reference to the Spring TaskExecutor for the JMS listener invokers. 
destination-resolver | A reference to the DestinationResolver strategy for resolving JMS Destination instances. 
message-converter | A reference to the MessageConverter strategy for converting JMS Messages to listener method arguments. The default is a SimpleMessageConverter. 
error-handler | A reference to an ErrorHandler strategy for handling any uncaught exceptions that may occur during the execution of the MessageListener. 
destination-type | The JMS destination type for this listener: queue, topic, durableTopic, sharedTopic, or sharedDurableTopic. This potentially enables the pubSubDomain, subscriptionDurable and subscriptionShared properties of the container. The default is queue (which disables those three properties). 
response-destination-type | The JMS destination type for responses: queue or topic. The default is the value of the destination-type attribute. 
client-id | The JMS client ID for this listener container. You must specify it when you use durable subscriptions. 
cache | The cache level for JMS resources: none, connection, session, consumer, or auto. By default (auto), the cache level is effectively consumer, unless an external transaction manager has been specified — in which case, the effective default will be none (assuming Java EE-style transaction management, where the given ConnectionFactory is an XA-aware pool). 
acknowledge | The native JMS acknowledge mode: auto, client, dups-ok, or transacted. A value of transacted activates a locally transacted Session. As an alternative, you can specify the transaction-manager attribute, described later in table. The default is auto. 
transaction-manager | A reference to an external PlatformTransactionManager (typically an XA-based transaction coordinator, such as Spring’s JtaTransactionManager). If not specified, native acknowledging is used (see the acknowledge attribute). 
concurrency | The number of concurrent sessions or consumers to start for each listener. It can either be a simple number indicating the maximum number (for example, 5) or a range indicating the lower as well as the upper limit (for example, 3-5). Note that a specified minimum is just a hint and might be ignored at runtime. The default is 1. You should keep concurrency limited to 1 in case of a topic listener or if queue ordering is important. Consider raising it for general queues. 
prefetch | The maximum number of messages to load into a single session. Note that raising this number might lead to starvation of concurrent consumers. 
receive-timeout | The timeout (in milliseconds) to use for receive calls. The default is 1000 (one second). -1 indicates no timeout. 
back-off | Specifies the BackOff instance to use to compute the interval between recovery attempts. If the BackOffExecution implementation returns BackOffExecution#STOP, the listener container does not further try to recover. The recovery-interval value is ignored when this property is set. The default is a FixedBackOff with an interval of 5000 milliseconds (that is, five seconds). 
recovery-interval | Specifies the interval between recovery attempts, in milliseconds. It offers a convenient way to create a FixedBackOff with the specified interval. For more recovery options, consider specifying a BackOff instance instead. The default is 5000 milliseconds (that is, five seconds). 
phase | The lifecycle phase within which this container should start and stop. The lower the value, the earlier this container starts and the later it stops. The default is Integer.MAX_VALUE, meaning that the container starts as late as possible and stops as soon as possible. 


<!-- tabs:start -->

#### ** English **

Configuring a JCA-based listener container with the `jms` schema support is very similar, as the following example shows:
#### ** Chinese **

配置一个基于JCA的监听器容器，并支持`jms`模式，就像下面的例子所显示的那样，非常相似。

<!-- tabs:end -->


```xml
<jms:jca-listener-container resource-adapter="myResourceAdapter"
        destination-resolver="myDestinationResolver"
        transaction-manager="myTransactionManager"
        concurrency="10">

    <jms:listener destination="queue.orders" ref="myMessageListener"/>

</jms:jca-listener-container>
```

<!-- tabs:start -->

#### ** English **

The following table describes the available configuration options for the JCA variant:
#### ** Chinese **

下表描述了JCA变体的可用配置选项。

<!-- tabs:end -->


Attribute | Description 
-|-
factory-id | Exposes the settings defined by this element as a JmsListenerContainerFactory with the specified id so that they can be reused with other endpoints. 
resource-adapter | A reference to the JCA ResourceAdapter bean (the default bean name is resourceAdapter). 
activation-spec-factory | A reference to the JmsActivationSpecFactory. The default is to autodetect the JMS provider and its ActivationSpec class (see DefaultJmsActivationSpecFactory). 
destination-resolver | A reference to the DestinationResolver strategy for resolving JMS Destinations. 
message-converter | A reference to the MessageConverter strategy for converting JMS Messages to listener method arguments. The default is SimpleMessageConverter. 
destination-type | The JMS destination type for this listener: queue, topic, durableTopic, sharedTopic. or sharedDurableTopic. This potentially enables the pubSubDomain, subscriptionDurable, and subscriptionShared properties of the container. The default is queue (which disables those three properties). 
response-destination-type | The JMS destination type for responses: queue or topic. The default is the value of the destination-type attribute. 
client-id | The JMS client ID for this listener container. It needs to be specified when using durable subscriptions. 
acknowledge | The native JMS acknowledge mode: auto, client, dups-ok, or transacted. A value of transacted activates a locally transacted Session. As an alternative, you can specify the transaction-manager attribute described later. The default is auto. 
transaction-manager | A reference to a Spring JtaTransactionManager or a javax.transaction.TransactionManager for kicking off an XA transaction for each incoming message. If not specified, native acknowledging is used (see the acknowledge attribute). 
concurrency | The number of concurrent sessions or consumers to start for each listener. It can either be a simple number indicating the maximum number (for example 5) or a range indicating the lower as well as the upper limit (for example, 3-5). Note that a specified minimum is only a hint and is typically ignored at runtime when you use a JCA listener container. The default is 1. 
prefetch | The maximum number of messages to load into a single session. Note that raising this number might lead to starvation of concurrent consumers. 



[下一章](Spring-Framework-5.2.6.RELEASE/Integration/4.%20JMX.md)


[回目录](Spring-Framework-5.2.6.RELEASE/summary.md)

[回首页](/README)
