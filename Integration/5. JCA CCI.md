# 5. JCA CCI

<!-- tabs:start -->

#### ** English **

Java EE provides a specification to standardize access to enterprise information systems (EIS): the JCA (Java EE Connector Architecture). This specification is divided into two different parts:
#### ** Chinese **

Java EE提供了一个规范来规范对企业信息系统（EIS）的标准化访问：JCA（Java EE Connector Architecture）。这个规范分为两个不同的部分。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

- SPI (Service Provider Interfaces) that the connector provider must implement. These interfaces constitute a resource adapter that can be deployed on a Java EE application server. In such a scenario, the server manages connection pooling, transactions, and security (managed mode). The application server is also responsible for managing the configuration, which is held outside the client application. A connector can be used without an application server as well. In this case, the application must configure it directly (non-managed mode).

- CCI (Common Client Interface) that an application can use to interact with the connector and, thus, communicate with an EIS. An API for local transaction demarcation is provided as well.

#### ** Chinese **

- 连接器提供者必须实现的SPI（Service Provider Interfaces）。这些接口构成了可以部署在Java EE应用服务器上的资源适配器。在这种情况下，服务器负责管理连接池、事务和安全（托管模式）。应用服务器还负责管理配置，而这些配置是在客户端应用程序之外举行的。连接器也可以在没有应用服务器的情况下使用。在这种情况下，应用程序必须直接配置它（非管理模式）。

- CCI（Common Client Interface），应用程序可以用来与连接器进行交互，从而与EIS进行通信。还提供了一个用于本地事务划分的API。


<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

The aim of the Spring CCI support is to provide classes to access a CCI connector in typical Spring style, using the Spring Framework’s general resource and transaction management facilities.
#### ** Chinese **

Spring CCI支持的目的是提供类，使用Spring框架的一般资源和事务管理设施，以典型的Spring风格访问CCI连接器。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The client side of connectors does not always use CCI. Some connectors expose their own APIs, providing a JCA resource adapter to use the system contracts of a Java EE container (connection pooling, global transactions, and security). Spring does not offer special support for such connector-specific APIs.
#### ** Chinese **

连接器的客户端并不总是使用CCI。有些连接器暴露了自己的API，提供了一个JCA资源适配器来使用Java EE容器的系统合约（连接池、全局事务和安全）。Spring并没有为这类连接器专用的API提供特殊的支持。

<!-- tabs:end -->


### **5.1. Configuring CCI** 

<!-- tabs:start -->

#### ** English **

This section covers how to configure a Common Client Interface (CCI). It includes the following topics:
#### ** Chinese **

本节涉及如何配置通用客户端接口 (CCI)。它包括以下主题。

<!-- tabs:end -->


### **5.1.1. Connector Configuration** 

<!-- tabs:start -->

#### ** English **

The base resource to use JCA CCI is the `ConnectionFactory` interface. The connector you use must provide an implementation of this interface.
#### ** Chinese **

使用JCA CCI的基础资源是`ConnectionFactory`接口。您使用的连接器必须提供该接口的实现。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

To use your connector, you can deploy it on your application server and fetch the `ConnectionFactory` from the server’s JNDI environment (managed mode). The connector must be packaged as a RAR file (resource adapter archive) and contain a `ra.xml` file to describe its deployment characteristics. The actual name of the resource is specified when you deploy it. To access it within Spring, you can use Spring’s `JndiObjectFactoryBean` or `<jee:jndi-lookup>` to fetch the factory by its JNDI name.
#### ** Chinese **

要使用你的连接器，你可以在你的应用服务器上部署它，并从服务器的JNDI环境（管理模式）中获取`ConnectionFactory`。连接器必须被打包成RAR文件（资源适配器存档），并包含一个`ra.xml`文件来描述其部署特性。资源的实际名称是在部署时指定的。要在Spring中访问它，可以使用Spring的`JndiObjectFactoryBean`或`<jee:jndi-lookup>`通过其JNDI名称来获取工厂。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Another way to use a connector is to embed it in your application (non-managed mode) and not use an application server to deploy and configure it. Spring offers the possibility to configure a connector as a bean, through a `FactoryBean` implementation called (`LocalConnectionFactoryBean`). In this manner, you only need the connector library in the classpath (no RAR file and no `ra.xml` descriptor needed). The library must be extracted from the connector’s RAR file, if necessary.
#### ** Chinese **

另一种使用连接器的方法是将其嵌入到你的应用程序中（非管理模式），而不是使用应用程序服务器来部署和配置它。Spring提供了将连接器配置为Bean的可能性，通过一个名为（`FactoryBean`的实现（`LocalConnectionFactoryBean`）。以这种方式，你只需要在classpath中的连接器库（不需要RAR文件，也不需要`ra.xml`描述符）。如果需要，必须从连接器的RAR文件中提取库。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Once you have access to your `ConnectionFactory` instance, you can inject it into your components. These components can either be coded against the plain CCI API or use Spring’s support classes for CCI access (e.g. `CciTemplate`).
#### ** Chinese **

一旦你访问了`ConnectionFactory`实例，你就可以将其注入到你的组件中。这些组件可以根据纯CCI API编码，或者使用Spring的支持类来访问CCI（例如，`CciTemplate`）。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

When you use a connector in non-managed mode, you cannot use global transactions, because the resource is never enlisted or delisted in the current global transaction of the current thread. The resource is not aware of any global Java EE transactions that might be running.
#### ** Chinese **

当您在非管理模式下使用连接器时，不能使用全局事务，因为该资源永远不会在当前线程的全局事务中加入或除名。该资源不知道任何可能正在运行的全局 Java EE 事务。

<!-- tabs:end -->


### **5.1.2.** **`ConnectionFactory`** ** Configuration in Spring** 

<!-- tabs:start -->

#### ** English **

To make connections to the EIS, you need to obtain a `ConnectionFactory` from the application server (if you are in a managed mode) or directly from Spring (if you are in a non-managed mode).
#### ** Chinese **

要连接到EIS，您需要从应用程序服务器（如果您处于托管模式）或直接从Spring（如果您处于非托管模式）获取`ConnectionFactory`。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

In managed mode, you can access a `ConnectionFactory` from JNDI. Its properties are configured in the application server. The following example shows how to do so:
#### ** Chinese **

在托管模式下，你可以从JNDI中访问一个`ConnectionFactory`。其属性在应用程序服务器中配置。下面的示例显示了如何做到这一点。

<!-- tabs:end -->


```xml
<jee:jndi-lookup id="eciConnectionFactory" jndi-name="eis/cicseci"/>
```

<!-- tabs:start -->

#### ** English **

In non-managed mode, you must configure the `ConnectionFactory` you want to use in the configuration of Spring as a JavaBean. The `LocalConnectionFactoryBean` class offers this setup style, passing in the `ManagedConnectionFactory` implementation of your connector, exposing the application-level CCI `ConnectionFactory`. The following example shows how to do so:
#### ** Chinese **

在非管理模式下，您必须配置要在Spring作为JavaBean的配置中使用的`ConnectionFactory`。`LocalConnectionFactoryBean`类提供了这种设置样式，它传递了你的连接器的`ManagedConnectionFactory`实现，暴露了应用级CCI `ConnectionFactory`。下面的示例显示了如何实现。

<!-- tabs:end -->


```xml
<bean id="eciManagedConnectionFactory" class="com.ibm.connector2.cics.ECIManagedConnectionFactory">
    <property name="serverName" value="TXSERIES"/>
    <property name="connectionURL" value="tcp://localhost/"/>
    <property name="portNumber" value="2006"/>
</bean>

<bean id="eciConnectionFactory" class="org.springframework.jca.support.LocalConnectionFactoryBean">
    <property name="managedConnectionFactory" ref="eciManagedConnectionFactory"/>
</bean>
```

<!-- tabs:start -->

#### ** English **

You cannot directly instantiate a specific `ConnectionFactory`. You need to go through the corresponding implementation of the `ManagedConnectionFactory` interface for your connector. This interface is part of the JCA SPI specification.
#### ** Chinese **

您不能直接实例化一个特定的`ConnectionFactory`。您需要通过相应的`ManagedConnectionFactory`接口来实现您的连接器。该接口是 JCA SPI 规范的一部分。

<!-- tabs:end -->


### **5.1.3. Configuring CCI Connections** 

<!-- tabs:start -->

#### ** English **

JCA CCI lets you configure the connections to the EIS by using the `ConnectionSpec` implementation of your connector. To configure its properties, you need to wrap the target connection factory with a dedicated adapter, `ConnectionSpecConnectionFactoryAdapter`. You can configure the dedicated `ConnectionSpec` with the `connectionSpec` property (as an inner bean).
#### ** Chinese **

JCA CCI允许你通过使用连接器的`ConnectionSpec`实现来配置到EIS的连接。要配置其属性，您需要用一个专用适配器`ConnectionSpecConnectionFactoryAdapter`包裹目标连接工厂。你可以用`ConnectionSpec`属性配置专用的`ConnectionSpec`（作为一个内部Bean）。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

This property is not mandatory, because the CCI `ConnectionFactory` interface defines two different methods to obtain a CCI connection. You can often configure some of the `ConnectionSpec` properties in the application server (in managed mode) or on the corresponding local `ManagedConnectionFactory` implementation. The following listing shows the relevant parts of the `ConnectionFactory` interface definition:
#### ** Chinese **

此属性不是强制性的，因为CCI `ConnectionFactory`接口定义了两种不同的方法来获取CCI连接。您通常可以在应用服务器（在托管模式下）或相应的本地 `ManagedConnectionFactory`实现上配置一些 `ConnectionSpec`属性。下面的列表显示了 `ConnectionFactory` 接口定义的相关部分。

<!-- tabs:end -->


```java
public interface ConnectionFactory implements Serializable, Referenceable {
    ...
    Connection getConnection() throws ResourceException;
    Connection getConnection(ConnectionSpec connectionSpec) throws ResourceException;
    ...
}
```

<!-- tabs:start -->

#### ** English **

Spring provides a `ConnectionSpecConnectionFactoryAdapter` that lets you specify a `ConnectionSpec` instance to use for all operations on a given factory. If the adapter’s `connectionSpec` property is specified, the adapter uses the `getConnection` variant with the `ConnectionSpec` argument. Otherwise, the adapter uses the variant without that argument. The following example shows how to configure a `ConnectionSpecConnectionFactoryAdapter`:
#### ** Chinese **

Spring 提供了一个 `ConnectionSpecConnectionFactoryAdapter`，可以让您指定一个`ConnectionSpec`实例，用于指定工厂上的所有操作。如果指定了适配器的 `connectionSpec` 属性，适配器将使用带有 `ConnectionSpec` 参数的 `getConnection` 变体。否则，适配器使用没有该参数的变体。下面的示例显示了如何配置`ConnectionSpecConnectionFactoryAdapter`。

<!-- tabs:end -->


```xml
<bean id="managedConnectionFactory"
        class="com.sun.connector.cciblackbox.CciLocalTxManagedConnectionFactory">
    <property name="connectionURL" value="jdbc:hsqldb:hsql://localhost:9001"/>
    <property name="driverName" value="org.hsqldb.jdbcDriver"/>
</bean>

<bean id="targetConnectionFactory"
        class="org.springframework.jca.support.LocalConnectionFactoryBean">
    <property name="managedConnectionFactory" ref="managedConnectionFactory"/>
</bean>

<bean id="connectionFactory"
        class="org.springframework.jca.cci.connection.ConnectionSpecConnectionFactoryAdapter">
    <property name="targetConnectionFactory" ref="targetConnectionFactory"/>
    <property name="connectionSpec">
        <bean class="com.sun.connector.cciblackbox.CciConnectionSpec">
            <property name="user" value="sa"/>
            <property name="password" value=""/>
        </bean>
    </property>
</bean>
```

### **5.1.4. Using a Single CCI Connection** 

<!-- tabs:start -->

#### ** English **

If you want to use a single CCI connection, Spring provides a further `ConnectionFactory` adapter to manage this. The `SingleConnectionFactory` adapter class lazily opens a single connection and closes it when this bean is destroyed at application shutdown. This class exposes special `Connection` proxies that behave accordingly, all sharing the same underlying physical connection. The following example shows how to use the `SingleConnectionFactory` adapter class:
#### ** Chinese **

如果你想使用单一的CCI连接，Spring提供了一个进一步的`ConnectionFactory`适配器来管理。`SingleConnectionFactory`适配器类会懒散地打开一个单一的连接，并在应用程序关闭时销毁这个Bean时关闭它。这个类暴露了特殊的 `Connection`代理类，这些代理类的行为也是如此，它们都共享相同的底层物理连接。下面的示例显示了如何使用`SingleConnectionFactory`适配器类。

<!-- tabs:end -->


```xml
<bean id="eciManagedConnectionFactory"
        class="com.ibm.connector2.cics.ECIManagedConnectionFactory">
    <property name="serverName" value="TEST"/>
    <property name="connectionURL" value="tcp://localhost/"/>
    <property name="portNumber" value="2006"/>
</bean>

<bean id="targetEciConnectionFactory"
        class="org.springframework.jca.support.LocalConnectionFactoryBean">
    <property name="managedConnectionFactory" ref="eciManagedConnectionFactory"/>
</bean>

<bean id="eciConnectionFactory"
        class="org.springframework.jca.cci.connection.SingleConnectionFactory">
    <property name="targetConnectionFactory" ref="targetEciConnectionFactory"/>
</bean>
```

<!-- tabs:start -->

#### ** English **

This `ConnectionFactory` adapter cannot directly be configured with a `ConnectionSpec`. You can use an intermediary `ConnectionSpecConnectionFactoryAdapter` that the `SingleConnectionFactory` talks to if you require a single connection for a specific `ConnectionSpec`.
#### ** Chinese **

此 `ConnectionFactory`适配器不能直接与 `ConnectionSpec`配置。如果您需要为特定的 `ConnectionSpec`ConnectionSpec</x>建立一个单一连接，您可以使用中间的 `ConnectionSpecConnectionFactoryAdapter`，如果您需要为特定的 `ConnectionSpec`建立一个连接，您可以使用中间的 `ConnectionSpecConnectionFactoryAdapter`，该 `SingleConnectionFactory`会与之对话。

<!-- tabs:end -->


### **5.2. Using Spring’s CCI Access Support** 

<!-- tabs:start -->

#### ** English **

This section describes how to use Spring’s support for CCI to achieve various purposes. It includes the following topics:
#### ** Chinese **

本节介绍如何使用Spring对CCI的支持来实现各种目的。它包括以下主题。

<!-- tabs:end -->


### **5.2.1. Record Conversion** 

<!-- tabs:start -->

#### ** English **

One of the aims of Spring’s JCA CCI support is to provide convenient facilities for manipulating CCI records. You can specify the strategy to create records and extract data from records, for use with Spring’s `CciTemplate`. The interfaces described in this section configure the strategy to use input and output records if you do not want to work with records directly in your application.
#### ** Chinese **

Spring的JCA CCI支持的目的之一是提供操作CCI记录的方便设施。您可以指定创建记录和从记录中提取数据的策略，用于Spring的`CciTemplate`。如果您不想在应用程序中直接处理记录，本节中描述的接口可以配置策略使用输入和输出记录。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

To create an input `Record`, you can use a dedicated implementation of the `RecordCreator` interface. The following listing shows the `RecordCreator` interface definition:
#### ** Chinese **

要创建一个输入`Record`，可以使用`RecordCreator`接口的专用实现。下面的列表显示了`RecordCreator`接口的定义。

<!-- tabs:end -->


```java
public interface RecordCreator {

    Record createRecord(RecordFactory recordFactory) throws ResourceException, DataAccessException;

}
```

<!-- tabs:start -->

#### ** English **

The `createRecord(..)` method receives a `RecordFactory` instance as a parameter, which corresponds to the `RecordFactory` of the `ConnectionFactory` used. You can use this reference to create `IndexedRecord` or `MappedRecord` instances. The following sample shows how to use the `RecordCreator` interface and indexed or mapped records:
#### ** Chinese **

`createRecord(..)`方法接收一个`RecordFactory`实例作为参数，它对应于所使用的`ConnectionFactory`的`RecordFactory`。您可以使用这个引用来创建 `IndexedRecord`或`MappedRecord`实例。下面的示例显示了如何使用 `RecordCreator`接口和索引记录或映射记录。

<!-- tabs:end -->


```java
public class MyRecordCreator implements RecordCreator {

    public Record createRecord(RecordFactory recordFactory) throws ResourceException {
        IndexedRecord input = recordFactory.createIndexedRecord("input");
        input.add(new Integer(id));
        return input;
    }

}
```

<!-- tabs:start -->

#### ** English **

You can use an output `Record` to receive data back from the EIS. Hence, you can pass a specific implementation of the `RecordExtractor` interface to Spring’s `CciTemplate` to extract data from the output `Record`. The following listing shows the `RecordExtractor` interface definition:
#### ** Chinese **

可以使用输出`Record`来接收来自EIS的数据。因此，您可以将 `RecordExtractor`接口的特定实现传递给Spring的`CciTemplate`，以从输出的`Record`中提取数据。下面的列表显示了`RecordExtractor`接口的定义。

<!-- tabs:end -->


```java
public interface RecordExtractor {

    Object extractData(Record record) throws ResourceException, SQLException, DataAccessException;

}
```

<!-- tabs:start -->

#### ** English **

The following example shows how to use the `RecordExtractor` interface:
#### ** Chinese **

下面的例子显示了如何使用`RecordExtractor`接口。

<!-- tabs:end -->


```java
public class MyRecordExtractor implements RecordExtractor {

    public Object extractData(Record record) throws ResourceException {
        CommAreaRecord commAreaRecord = (CommAreaRecord) record;
        String str = new String(commAreaRecord.toByteArray());
        String field1 = string.substring(0,6);
        String field2 = string.substring(6,1);
        return new OutputObject(Long.parseLong(field1), field2);
    }

}
```

### **5.2.2. Using** **`CciTemplate`** 

<!-- tabs:start -->

#### ** English **

The `CciTemplate` is the central class of the core CCI support package ( `org.springframework.jca.cci.core`). It simplifies the use of CCI, since it handles the creation and release of resources. This helps to avoid common errors, such as forgetting to always close the connection. It cares for the lifecycle of connection and interaction objects, letting application code focus on generating input records from application data and extracting application data from output records.
#### ** Chinese **

`CciTemplate`是CCI核心支持包（`org.springframework.jca.cci.core`）的核心类。它简化了CCI的使用，因为它处理了资源的创建和发布。这有助于避免常见的错误，如忘记总是关闭连接等。它照顾到了连接和交互对象的生命周期，让应用程序代码专注于从应用程序数据中生成输入记录，并从输出记录中提取应用程序数据。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The JCA CCI specification defines two distinct methods to call operations on an EIS. The CCI `Interaction` interface provides two execute method signatures, as the following listing shows:
#### ** Chinese **

JCA CCI规范定义了两种不同的方法来调用EIS上的操作。CCI `Interaction`接口提供了两个执行方法的签名，如下所示。

<!-- tabs:end -->


```java
public interface javax.resource.cci.Interaction {

    ...

    boolean execute(InteractionSpec spec, Record input, Record output) throws ResourceException;

    Record execute(InteractionSpec spec, Record input) throws ResourceException;

    ...

}
```

<!-- tabs:start -->

#### ** English **

Depending on the template method called, `CciTemplate` knows which `execute` method to call on the interaction. In any case, a correctly initialized `InteractionSpec` instance is mandatory.
#### ** Chinese **

根据调用的模板方法，`CciTemplate`知道要在交互上调用哪个`执行`方法。在任何情况下，正确初始化的`InteractionSpec`实例是必须的。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can use `CciTemplate.execute(..)` in two ways:
#### ** Chinese **

你可以通过两种方式使用`CciTemplate.execute(..)`。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

- [Connector Configuration](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#cci-config-connector)

- [`ConnectionFactory`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#cci-config-connectionfactory)[ Configuration in Spring](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#cci-config-connectionfactory)

- [Configuring CCI Connections](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#cci-config-cci-connections)

- [Using a Single CCI Connection](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#cci-config-single-connection)

- [Record Conversion](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#cci-record-creator)

- [Using ](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#cci-using-template)[`CciTemplate`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#cci-using-template)

- [Using DAO Support](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#cci-using-dao)

- [Automatic Output Record Generation](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#automatic-output-generation)

- [`CciTemplate`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#template-summary)[ ](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#template-summary)[`Interaction`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#template-summary)[ Summary](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#template-summary)

- [Using a CCI Connection and an Interaction Directly](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#cci-straight)

- [Example of ](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#cci-template-example)[`CciTemplate`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#cci-template-example)[ Usage](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#cci-template-example)

- With direct `Record` arguments. In this case, you need to pass in the CCI input record, and the returned object is the corresponding CCI output record.

- With application objects, by using record mapping. In this case, you need to provide corresponding `RecordCreator` and `RecordExtractor` instances.

#### ** Chinese **

- 连接器配置](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#cci-config-connector)

- [`ConnectionFactory`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#cci-config-connectionfactory)[ConnectionFactory</x>](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#cci-config-connectionfactory)[在Spring中的配置](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#cci-config-connectionfactory)

- 配置CCI连接](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#cci-config-cci-connections)

- [使用单一CCI连接](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#cci-config-single-connection)

- [记录转换](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#cci-record-creator)

- [使用](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#cci-using-template)[`CciTemplate`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#cci-using-template)

- [使用DAO支持](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#cci-using-dao)

- 自动输出记录生成](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#automatic-output-generation)

- [`CciTemplate`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#template-summary)[ ](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#template-summary)[`互动`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#template-summary)[ 摘要](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#template-summary)

- 直接使用CCI连接和交互](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#cci-straight)

- 例子】(https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#cci-template-example)[`CciTemplate`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#cci-template-example)[ 使用方法](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#cci-template-example)

- 用直接`Record`参数。在这种情况下，需要传入CCI输入记录，返回的对象是相应的CCI输出记录。

- 使用应用对象，通过使用记录映射。在这种情况下，你需要提供相应的`RecordCreator`和`RecordExtractor`实例。


<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

With the first approach, the following methods (which directly correspond to those on the `Interaction` interface) of the template are used:
#### ** Chinese **

在第一种方法中，使用以下方法（直接对应于模板的`Interaction`接口上的方法）。

<!-- tabs:end -->


```java
public class CciTemplate implements CciOperations {

    public Record execute(InteractionSpec spec, Record inputRecord)
            throws DataAccessException { ... }

    public void execute(InteractionSpec spec, Record inputRecord, Record outputRecord)
            throws DataAccessException { ... }

}
```

<!-- tabs:start -->

#### ** English **

With the second approach, we need to specify the record creation and record extraction strategies as arguments. The interfaces used are those describe in the [previous section on record conversion](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#cci-record-creator). The following listing shows the corresponding `CciTemplate` methods:
#### ** Chinese **

在第二种方法中，我们需要指定记录创建和记录提取策略作为参数。使用的接口是[上一节记录转换](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#cci-record-creator)中描述的接口。下面列出了相应的`CciTemplate`方法。

<!-- tabs:end -->


```java
public class CciTemplate implements CciOperations {

    public Record execute(InteractionSpec spec,
            RecordCreator inputCreator) throws DataAccessException {
        // ...
    }

    public Object execute(InteractionSpec spec, Record inputRecord,
            RecordExtractor outputExtractor) throws DataAccessException {
        // ...
    }

    public Object execute(InteractionSpec spec, RecordCreator creator,
            RecordExtractor extractor) throws DataAccessException {
        // ...
    }

}
```

<!-- tabs:start -->

#### ** English **

Unless the `outputRecordCreator` property is set on the template (see the following section), every method calls the corresponding `execute` method of the CCI `Interaction` with two parameters: `InteractionSpec` and an input `Record`. It receives an output `Record` as its return value.
#### ** Chinese **

除非在模板上设置了`outputRecordCreator`属性（见下节），否则每个方法都会调用CCI`Interaction`的相应的`execute`方法，并带有两个参数。 `InteractionSpec`和一个输入`Record`。它接收一个输出`Record`作为其返回值。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

`CciTemplate` also provides methods to create `IndexRecord` and `MappedRecord` outside of a `RecordCreator` implementation, through its `createIndexRecord(..)` and `createMappedRecord(..)` methods. You can use this within DAO implementations to create `Record` instances to pass into corresponding `CciTemplate.execute(..)` methods. The following listing shows the `CciTemplate` interface definition:
#### ** Chinese **

`CciTemplate`还提供了在`RecordCreator`实现之外创建`IndexRecord`和`MappedRecord`的方法，通过其`createIndexRecord(..)`和`createMappedRecord(.)`方法来创建。你可以在DAO实现中使用它来创建`Record`实例，以传递给相应的`CciTemplate.execute(..)`方法。下面的列表显示了`CciTemplate`接口定义。

<!-- tabs:end -->


```java
public class CciTemplate implements CciOperations {

    public IndexedRecord createIndexedRecord(String name) throws DataAccessException { ... }

    public MappedRecord createMappedRecord(String name) throws DataAccessException { ... }

}
```

### **5.2.3. Using DAO Support** 

<!-- tabs:start -->

#### ** English **

Spring’s CCI support provides an abstract class for DAOs, supporting injection of a `ConnectionFactory` or a `CciTemplate` instance. The name of the class is `CciDaoSupport`. It provides simple `setConnectionFactory` and `setCciTemplate` methods. Internally, this class creates a `CciTemplate` instance for a passed-in `ConnectionFactory`, exposing it to concrete data access implementations in subclasses. The following example shows how to use `CciDaoSupport`:
#### ** Chinese **

Spring的CCI支持为DAO提供了一个抽象类，支持注入`ConnectionFactory`或`CciTemplate`实例。该类的名称是`CciDaoSupport`。它提供了简单的`setConnectionFactory`和`setCciTemplate`方法。在内部，该类为传入的`ConnectionFactory`创建了一个`CciTemplate`实例，在子类中向子类中的具体数据访问实现开放。下面的示例显示了如何使用 `CciDaoSupport`。

<!-- tabs:end -->


```java
public abstract class CciDaoSupport {

    public void setConnectionFactory(ConnectionFactory connectionFactory) {
        // ...
    }

    public ConnectionFactory getConnectionFactory() {
        // ...
    }

    public void setCciTemplate(CciTemplate cciTemplate) {
        // ...
    }

    public CciTemplate getCciTemplate() {
        // ...
    }

}
```

### **5.2.4. Automatic Output Record Generation** 

<!-- tabs:start -->

#### ** English **

If the connector you use supports only the `Interaction.execute(..)` method with input and output records as parameters (that is, it requires the desired output record to be passed in instead of returning an appropriate output record), you can set the `outputRecordCreator` property of the `CciTemplate` to automatically generate an output record to be filled by the JCA connector when the response is received. This record is then returned to the caller of the template.
#### ** Chinese **

如果您使用的连接器只支持以输入和输出记录作为参数的`Interaction.execute(..)`方法（也就是说，它要求传递所需的输出记录，而不是返回适当的输出记录），您可以设置`CciTemplate`的`outputRecordCreator`属性，以便在收到响应时自动生成一个输出记录，由JCA连接器填充。然后，该记录将返回给模板的调用者。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

This property holds an implementation of the [`RecordCreator`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#cci-record-creator)[ interface](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#cci-record-creator), to be used for that purpose. You must directly specify the `outputRecordCreator` property on the `CciTemplate`. The following example shows how to do so:
#### ** Chinese **

该属性持有[`RecordCreator`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#cci-record-creator)[interface](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#cci-record-creator)的实现，用于该目的。您必须直接在 `CciTemplate`中指定 `outputRecordCreator` 属性。下面的例子说明了如何做到这一点。

<!-- tabs:end -->


```xml
cciTemplate.setOutputRecordCreator(new EciOutputRecordCreator());
```

<!-- tabs:start -->

#### ** English **

Alternatively (and we recommend this approach), in the Spring configuration, if the `CciTemplate` is configured as a dedicated bean instance, you can define beans in the following fashion:
#### ** Chinese **

另外（我们推荐这种方法），在Spring配置中，如果`CciTemplate`被配置为一个专用的Bean实例，可以用以下方式定义Bean。

<!-- tabs:end -->


```xml
<bean id="eciOutputRecordCreator" class="eci.EciOutputRecordCreator"/>

<bean id="cciTemplate" class="org.springframework.jca.cci.core.CciTemplate">
    <property name="connectionFactory" ref="eciConnectionFactory"/>
    <property name="outputRecordCreator" ref="eciOutputRecordCreator"/>
</bean>
```

<!-- tabs:start -->

#### ** English **

As the `CciTemplate` class is thread-safe, it is usually configured as a shared instance.
#### ** Chinese **

由于`CciTemplate`类是线程安全的，所以它通常被配置为共享实例。

<!-- tabs:end -->


### **5.2.5.** **`CciTemplate`** **** **** **`Interaction`** ** Summary** 

<!-- tabs:start -->

#### ** English **

The following table summarizes the mechanisms of the `CciTemplate` class and the corresponding methods called on the CCI `Interaction` interface:
#### ** Chinese **

下表总结了`CciTemplate`类的机制以及在CCI`Interaction`接口上调用的相应方法。

<!-- tabs:end -->


CciTemplate method signature | CciTemplate outputRecordCreator property | execute method called on the CCI Interaction 
-|-|-
Record execute(InteractionSpec, Record) | Not set | Record execute(InteractionSpec, Record) 
Record execute(InteractionSpec, Record) | Set | boolean execute(InteractionSpec, Record, Record) 
void execute(InteractionSpec, Record, Record) | Not set | void execute(InteractionSpec, Record, Record) 
void execute(InteractionSpec, Record, Record) | Set | void execute(InteractionSpec, Record, Record) 
Record execute(InteractionSpec, RecordCreator) | Not set | Record execute(InteractionSpec, Record) 
Record execute(InteractionSpec, RecordCreator) | Set | void execute(InteractionSpec, Record, Record) 
Record execute(InteractionSpec, Record, RecordExtractor) | Not set | Record execute(InteractionSpec, Record) 
Record execute(InteractionSpec, Record, RecordExtractor) | Set | void execute(InteractionSpec, Record, Record) 
Record execute(InteractionSpec, RecordCreator, RecordExtractor) | Not set | Record execute(InteractionSpec, Record) 
Record execute(InteractionSpec, RecordCreator, RecordExtractor) | Set | void execute(InteractionSpec, Record, Record) 


### **5.2.6. Using a CCI Connection and an Interaction Directly** 

<!-- tabs:start -->

#### ** English **

`CciTemplate` also lets you work directly with CCI connections and interactions, in the same manner as `JdbcTemplate` and `JmsTemplate`. This is useful when you want to perform multiple operations on a CCI connection or interaction, for example.
#### ** Chinese **

`CciTemplate`还可以让您直接使用CCI连接和交互，其方式与`JdbcTemplate`和`JmsTemplate`相同。这在您想在一个CCI连接或交互上执行多个操作时非常有用，例如。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The `ConnectionCallback` interface provides a CCI `Connection` as an argument (to perform custom operations on it) plus the CCI `ConnectionFactory` with which the `Connection` was created. The latter can be useful (for example, to get an associated `RecordFactory` instance and create indexed/mapped records). The following listing shows the `ConnectionCallback` interface definition:
#### ** Chinese **

`ConnectionCallback`接口提供了一个CCI `Connection`作为参数（用于对其执行自定义操作），再加上CCI `ConnectionFactory`，其中`Connection`是用它创建的。后者很有用（例如，获取关联的`RecordFactory`实例，并创建索引/映射记录）。下面的列表显示了 `ConnectionCallback` 接口定义。

<!-- tabs:end -->


```java
public interface ConnectionCallback {

    Object doInConnection(Connection connection, ConnectionFactory connectionFactory)
            throws ResourceException, SQLException, DataAccessException;

}
```

<!-- tabs:start -->

#### ** English **

The `InteractionCallback` interface provides the CCI `Interaction` (to perform custom operations on it) plus the corresponding CCI `ConnectionFactory`. The following listing shows the `InteractionCallback` interface definition:
#### ** Chinese **

`InteractionCallback`接口提供了CCI `Interaction`（对其执行自定义操作）和相应的CCI `ConnectionFactory`。下面的列表显示了`InteractionCallback`接口的定义。

<!-- tabs:end -->


```java
public interface InteractionCallback {

    Object doInInteraction(Interaction interaction, ConnectionFactory connectionFactory)
        throws ResourceException, SQLException, DataAccessException;

}
```

<!-- tabs:start -->

#### ** English **

`InteractionSpec` objects can either be shared across multiple template calls or be newly created inside every callback method. This is completely up to the DAO implementation.
#### ** Chinese **

`InteractionSpec`对象既可以在多个模板调用中共享，也可以在每个回调方法内部新创建。这完全由DAO实现来决定。

<!-- tabs:end -->


### **5.2.7. Example of** **`CciTemplate`** ** Usage** 

<!-- tabs:start -->

#### ** English **

In this section, we show the usage of the `CciTemplate` to access a CICS with ECI mode, with the IBM CICS ECI connector.
#### ** Chinese **

在本节中，我们将展示`CciTemplate`的使用方法，通过IBM CICS ECI连接器访问CICS的ECI模式。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

First, we must do some initializations on the CCI `InteractionSpec` to specify which CICS program to access and how to interact with it, as the following example shows:
#### ** Chinese **

首先，我们必须对CCI`InteractionSpec`进行一些初始化，以指定要访问哪个CICS程序以及如何与之交互，如下例所示。

<!-- tabs:end -->


```java
ECIInteractionSpec interactionSpec = new ECIInteractionSpec();
interactionSpec.setFunctionName("MYPROG");
interactionSpec.setInteractionVerb(ECIInteractionSpec.SYNC_SEND_RECEIVE);
```

<!-- tabs:start -->

#### ** English **

Then the program can use CCI through Spring’s template and specify mappings between custom objects and CCI `Records`, as the following example shows:
#### ** Chinese **

然后，程序可以通过Spring的模板使用CCI，并在自定义对象和CCI`Records`之间指定映射，如下例所示。

<!-- tabs:end -->


```java
public class MyDaoImpl extends CciDaoSupport implements MyDao {

    public OutputObject getData(InputObject input) {
        ECIInteractionSpec interactionSpec = ...;

    OutputObject output = (ObjectOutput) getCciTemplate().execute(interactionSpec,
        new RecordCreator() {
            public Record createRecord(RecordFactory recordFactory) throws ResourceException {
                return new CommAreaRecord(input.toString().getBytes());
            }
        },
        new RecordExtractor() {
            public Object extractData(Record record) throws ResourceException {
                CommAreaRecord commAreaRecord = (CommAreaRecord)record;
                String str = new String(commAreaRecord.toByteArray());
                String field1 = string.substring(0,6);
                String field2 = string.substring(6,1);
                return new OutputObject(Long.parseLong(field1), field2);
            }
        });

        return output;
    }
}
```

<!-- tabs:start -->

#### ** English **

As discussed previously, you can use callbacks to work directly on CCI connections or interactions. The following example shows how to do so:
#### ** Chinese **

正如前面所讨论的那样，你可以使用回调来直接对CCI连接或交互进行工作。下面的例子显示了如何做到这一点。

<!-- tabs:end -->


```java
public class MyDaoImpl extends CciDaoSupport implements MyDao {

    public OutputObject getData(InputObject input) {
        ObjectOutput output = (ObjectOutput) getCciTemplate().execute(
            new ConnectionCallback() {
                public Object doInConnection(Connection connection,
                        ConnectionFactory factory) throws ResourceException {

                    // do something...

                }
            });
        }
        return output;
    }

}
```

<!-- tabs:start -->

#### ** English **

With a `ConnectionCallback`, the `Connection` used is managed and closed by the `CciTemplate`, but the callback implementation must manage any interactions created on the connection.
#### ** Chinese **

使用`ConnectionCallback`，使用的`Connection`由`CciTemplate`管理和关闭，但回调实现必须管理在连接上创建的任何交互。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

For a more specific callback, you can implement an `InteractionCallback`. If you do so, the passed-in `Interaction` is managed and closed by the `CciTemplate`. The following example shows how to do so:
#### ** Chinese **

对于更具体的回调，你可以实现一个`InteractionCallback`。如果你这样做了，传入的`Interaction`将由`CciTemplate`管理和关闭。下面的例子显示了如何做到这一点。

<!-- tabs:end -->


```java
public class MyDaoImpl extends CciDaoSupport implements MyDao {

    public String getData(String input) {
        ECIInteractionSpec interactionSpec = ...;
        String output = (String) getCciTemplate().execute(interactionSpec,
            new InteractionCallback() {
                public Object doInInteraction(Interaction interaction,
                        ConnectionFactory factory) throws ResourceException {
                    Record input = new CommAreaRecord(inputString.getBytes());
                    Record output = new CommAreaRecord();
                    interaction.execute(holder.getInteractionSpec(), input, output);
                    return new String(output.toByteArray());
                }
            });
        return output;
    }

}
```

<!-- tabs:start -->

#### ** English **

For the preceding examples, the corresponding configuration of the involved Spring beans could resemble the following example in non-managed mode:
#### ** Chinese **

在前面的例子中，所涉及的Spring豆的相应配置可以类似于下面的非管理模式下的例子。

<!-- tabs:end -->


```xml
<bean id="managedConnectionFactory" class="com.ibm.connector2.cics.ECIManagedConnectionFactory">
    <property name="serverName" value="TXSERIES"/>
    <property name="connectionURL" value="local:"/>
    <property name="userName" value="CICSUSER"/>
    <property name="password" value="CICS"/>
</bean>

<bean id="connectionFactory" class="org.springframework.jca.support.LocalConnectionFactoryBean">
    <property name="managedConnectionFactory" ref="managedConnectionFactory"/>
</bean>

<bean id="component" class="mypackage.MyDaoImpl">
    <property name="connectionFactory" ref="connectionFactory"/>
</bean>
```

<!-- tabs:start -->

#### ** English **

In managed mode (that is, in a Java EE environment), the configuration could resemble the following example:
#### ** Chinese **

在托管模式下（也就是在Java EE环境中），配置可能类似于下面的例子。

<!-- tabs:end -->


```xml
<jee:jndi-lookup id="connectionFactory" jndi-name="eis/cicseci"/>

<bean id="component" class="MyDaoImpl">
    <property name="connectionFactory" ref="connectionFactory"/>
</bean>
```

### **5.3. Modeling CCI Access as Operation Objects** 

<!-- tabs:start -->

#### ** English **

The `org.springframework.jca.cci.object` package contains support classes that let you access the EIS in a different style: through reusable operation objects, analogous to Spring’s JDBC operation objects (see the [JDBC section of the Data Access chapter](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/data-access.html#jdbc)). This usually encapsulates the CCI API. An application-level input object is passed to the operation object, so it can construct the input record and then convert the received record data to an application-level output object and return it.
#### ** Chinese **

`org.springframework.jca.cci.object`包中包含支持类，可以让你以不同的方式访问EIS：通过可重用的操作对象，类似于Spring的JDBC操作对象（参见[数据访问章节的JDBC部分](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/data-access.html#jdbc)）。这通常封装了CCI API。一个应用级的输入对象被传递给操作对象，这样它就可以构造输入记录，然后将接收到的记录数据转换为应用级的输出对象并返回。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

This approach is internally based on the `CciTemplate` class and the `RecordCreator` or `RecordExtractor` interfaces, reusing the machinery of Spring’s core CCI support.
#### ** Chinese **

这种方法在内部基于`CciTemplate`类和`RecordCreator`或`RecordExtractor`接口，重用了Spring的核心CCI支持机制。

<!-- tabs:end -->


### **5.3.1. Using** **`MappingRecordOperation`** 

<!-- tabs:start -->

#### ** English **

`MappingRecordOperation` essentially performs the same work as `CciTemplate` but represents a specific, pre-configured operation as an object. It provides two template methods to specify how to convert an input object to an input record and how to convert an output record to an output object (record mapping):
#### ** Chinese **

`MappingRecordOperation`本质上执行与`CciTemplate`相同的工作，但表示一个特定的、预先配置好的操作为对象。它提供了两个模板方法来指定如何将输入对象转换为输入记录，以及如何将输出记录转换为输出对象（记录映射）。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

- `createInputRecord(..)`: to specify how to convert an input object to an input `Record`

- `extractOutputData(..)`: to specify how to extract an output object from an output `Record`

#### ** Chinese **

- `createInputRecord(..)`：指定如何将输入对象转换为输入`Record`的方法

- `extractOutputData(..)`：指定如何从输出`Record`中提取输出对象


<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

The following listing shows the signatures of these methods:
#### ** Chinese **

下面列出了这些方法的标志。

<!-- tabs:end -->


```java
public abstract class MappingRecordOperation extends EisOperation {

    ...

    protected abstract Record createInputRecord(RecordFactory recordFactory,
            Object inputObject) throws ResourceException, DataAccessException {
        // ...
    }

    protected abstract Object extractOutputData(Record outputRecord)
            throws ResourceException, SQLException, DataAccessException {
        // ...
    }

    ...

}
```

<!-- tabs:start -->

#### ** English **

Thereafter, ito execute an EIS operation, you need to use a single `execute` method, passing in an application-level input object and receiving an application-level output object as the result. The following example shows how to do so:
#### ** Chinese **

此后，执行一个EIS操作，需要使用一个`execute`方法，传递一个应用级的输入对象，并接收一个应用级的输出对象作为结果。下面的例子显示了如何执行。

<!-- tabs:end -->


```java
public abstract class MappingRecordOperation extends EisOperation {

    ...

    public Object execute(Object inputObject) throws DataAccessException {
    }

    ...
}
```

<!-- tabs:start -->

#### ** English **

Contrary to the `CciTemplate` class, this `execute(..)` method does not have an `InteractionSpec` as an argument. Instead, the `InteractionSpec` is global to the operation. You must use the following constructor to instantiate an operation object with a specific `InteractionSpec`. The following example shows how to do so:
#### ** Chinese **

与`CciTemplate`类相反，这个`execute(..)`方法没有`InteractionSpec`作为参数。相反，`InteractionSpec`是操作的全局值。您必须使用下面的构造函数来实例化一个具有特定 `InteractionSpec`的操作对象。下面的示例显示了如何做到这一点。

<!-- tabs:end -->


```java
InteractionSpec spec = ...;
MyMappingRecordOperation eisOperation = new MyMappingRecordOperation(getConnectionFactory(), spec);
...
```

### **5.3.2. Using** **`MappingCommAreaOperation`** 

<!-- tabs:start -->

#### ** English **

Some connectors use records based on a COMMAREA, which represents an array of bytes that contain parameters to send to the EIS and the data returned by it. Spring provides a special operation class for working directly on COMMAREA rather than on records. The `MappingCommAreaOperation` class extends the `MappingRecordOperation` class to provide this special COMMAREA support. It implicitly uses the `CommAreaRecord` class as the input and output record type and provides two new methods to convert an input object into an input COMMAREA and convert the output COMMAREA into an output object. The following listing shows the relevant method signatures:
#### ** Chinese **

一些连接器使用基于COMMAREA的记录，COMMAREA表示一个包含参数的字节数组，这些字节数组包含要发送给EIS的参数和它返回的数据。Spring提供了一个特殊的操作类，用于直接在COMMAREA而不是记录上工作。`MappingCommAreaOperation`类扩展了`MappingRecordOperation`类，以提供这种特殊的COMMAREA支持。它隐式地使用`CommAreaRecord`类作为输入和输出记录类型，并提供了两个新的方法来将输入对象转换为输入COMMAREA和将输出COMMAREA转换为输出对象。下面的列表显示了相关的方法签名。

<!-- tabs:end -->


```java
public abstract class MappingCommAreaOperation extends MappingRecordOperation {

    ...

    protected abstract byte[] objectToBytes(Object inObject)
            throws IOException, DataAccessException;

    protected abstract Object bytesToObject(byte[] bytes)
        throws IOException, DataAccessException;

    ...

}
```

### **5.3.3. Automatic Output Record Generation** 

<!-- tabs:start -->

#### ** English **

As every `MappingRecordOperation` subclass is based on CciTemplate internally, the same way to automatically generate output records as with `CciTemplate` is available. Every operation object provides a corresponding `setOutputRecordCreator(..)` method. For further information, see [Automatic Output Record Generation](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#automatic-output-generation).
#### ** Chinese **

由于每个`MappingRecordOperation`子类内部都是基于CciTemplate，所以自动生成输出记录的方法与`CciTemplate`相同。每个操作对象都提供了相应的`setOutputRecordCreator(..)`方法。更多信息，请参阅[自动输出记录生成](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#automatic-output-generation)。

<!-- tabs:end -->


### **5.3.4. Summary** 

<!-- tabs:start -->

#### ** English **

The operation object approach uses records in the same manner as the `CciTemplate` class.
#### ** Chinese **

操作对象方法使用记录的方式与`CciTemplate`类相同。

<!-- tabs:end -->


MappingRecordOperation method signature | MappingRecordOperation outputRecordCreator property | execute method called on the CCI Interaction 
-|-|-
Object execute(Object) | Not set | Record execute(InteractionSpec, Record) 
Object execute(Object) | Set | boolean execute(InteractionSpec, Record, Record) 


### **5.3.5. Example of** **`MappingRecordOperation`** ** Usage** 

<!-- tabs:start -->

#### ** English **

In this section, we show how to use `MappingRecordOperation` to access a database with the Blackbox CCI connector.
#### ** Chinese **

在本节中，我们将展示如何使用`MappingRecordOperation`使用Blackbox CCI连接器访问数据库。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The original version of this connector is provided by the Java EE SDK (version 1.3), which is available from Oracle.
#### ** Chinese **

该连接器的原始版本由Java EE SDK（1.3版）提供，可从Oracle获得。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

First, you must do some initializations on the CCI `InteractionSpec` to specify which SQL request to execute. In the following example, we directly define the way to convert the parameters of the request to a CCI record and the way to convert the CCI result record to an instance of the `Person` class:
#### ** Chinese **

首先，必须对CCI`InteractionSpec`做一些初始化，指定执行哪一个SQL请求。在下面的例子中，我们直接定义了将请求的参数转换为CCI记录的方式，以及将CCI结果记录转换为`Person`类的实例的方式。

<!-- tabs:end -->


```java
public class PersonMappingOperation extends MappingRecordOperation {

    public PersonMappingOperation(ConnectionFactory connectionFactory) {
        setConnectionFactory(connectionFactory);
        CciInteractionSpec interactionSpec = new CciConnectionSpec();
        interactionSpec.setSql("select * from person where person_id=?");
        setInteractionSpec(interactionSpec);
    }

    protected Record createInputRecord(RecordFactory recordFactory,
            Object inputObject) throws ResourceException {
        Integer id = (Integer) inputObject;
        IndexedRecord input = recordFactory.createIndexedRecord("input");
        input.add(new Integer(id));
        return input;
    }

    protected Object extractOutputData(Record outputRecord)
            throws ResourceException, SQLException {
        ResultSet rs = (ResultSet) outputRecord;
        Person person = null;
        if (rs.next()) {
            Person person = new Person();
            person.setId(rs.getInt("person_id"));
            person.setLastName(rs.getString("person_last_name"));
            person.setFirstName(rs.getString("person_first_name"));
        }
        return person;
    }
}
```

<!-- tabs:start -->

#### ** English **

Then the application can execute the operation object, with the person identifier as an argument. Note that you could set up the operation object as a shared instance, as it is thread-safe. The following executes the operation object with the person identifier as an argument:
#### ** Chinese **

然后应用程序可以执行操作对象，并以人名标识符作为参数。注意，你可以将操作对象设置为共享实例，因为它是线程安全的。下面是以人名标识符作为参数来执行操作对象。

<!-- tabs:end -->


```java
public class MyDaoImpl extends CciDaoSupport implements MyDao {

    public Person getPerson(int id) {
        PersonMappingOperation query = new PersonMappingOperation(getConnectionFactory());
        Person person = (Person) query.execute(new Integer(id));
        return person;
    }
}
```

<!-- tabs:start -->

#### ** English **

The corresponding configuration of Spring beans could be as follows in non-managed mode:
#### ** Chinese **

在非管理模式下，Spring Bean的相应配置可以如下。

<!-- tabs:end -->


```xml
<bean id="managedConnectionFactory"
        class="com.sun.connector.cciblackbox.CciLocalTxManagedConnectionFactory">
    <property name="connectionURL" value="jdbc:hsqldb:hsql://localhost:9001"/>
    <property name="driverName" value="org.hsqldb.jdbcDriver"/>
</bean>

<bean id="targetConnectionFactory"
        class="org.springframework.jca.support.LocalConnectionFactoryBean">
    <property name="managedConnectionFactory" ref="managedConnectionFactory"/>
</bean>

<bean id="connectionFactory"
        class="org.springframework.jca.cci.connection.ConnectionSpecConnectionFactoryAdapter">
    <property name="targetConnectionFactory" ref="targetConnectionFactory"/>
    <property name="connectionSpec">
        <bean class="com.sun.connector.cciblackbox.CciConnectionSpec">
            <property name="user" value="sa"/>
            <property name="password" value=""/>
        </bean>
    </property>
</bean>

<bean id="component" class="MyDaoImpl">
    <property name="connectionFactory" ref="connectionFactory"/>
</bean>
```

<!-- tabs:start -->

#### ** English **

In managed mode (that is, in a Java EE environment), the configuration could be as follows:
#### ** Chinese **

在管理模式下（也就是在Java EE环境中），配置可能如下。

<!-- tabs:end -->


```xml
<jee:jndi-lookup id="targetConnectionFactory" jndi-name="eis/blackbox"/>

<bean id="connectionFactory"
        class="org.springframework.jca.cci.connection.ConnectionSpecConnectionFactoryAdapter">
    <property name="targetConnectionFactory" ref="targetConnectionFactory"/>
    <property name="connectionSpec">
        <bean class="com.sun.connector.cciblackbox.CciConnectionSpec">
            <property name="user" value="sa"/>
            <property name="password" value=""/>
        </bean>
    </property>
</bean>

<bean id="component" class="MyDaoImpl">
    <property name="connectionFactory" ref="connectionFactory"/>
</bean>
```

### **5.3.6. Example of** **`MappingCommAreaOperation`** ** Usage** 

<!-- tabs:start -->

#### ** English **

In this section, we show how to use the usage of the `MappingCommAreaOperation` to access a CICS with ECI mode with the IBM CICS ECI connector.
#### ** Chinese **

在本节中，我们将展示如何使用`MappingCommAreaOperation`的使用方法，利用IBM CICS ECI连接器访问具有ECI模式的CICS。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

First, we need to initialize the CCI `InteractionSpec` to specify which CICS program to access and how to interact with it, as the following example shows:
#### ** Chinese **

首先，我们需要初始化CCI`InteractionSpec`来指定要访问哪个CICS程序以及如何与之交互，如下例所示。

<!-- tabs:end -->


```java
public abstract class EciMappingOperation extends MappingCommAreaOperation {

    public EciMappingOperation(ConnectionFactory connectionFactory, String programName) {
        setConnectionFactory(connectionFactory);
        ECIInteractionSpec interactionSpec = new ECIInteractionSpec(),
        interactionSpec.setFunctionName(programName);
        interactionSpec.setInteractionVerb(ECIInteractionSpec.SYNC_SEND_RECEIVE);
        interactionSpec.setCommareaLength(30);
        setInteractionSpec(interactionSpec);
        setOutputRecordCreator(new EciOutputRecordCreator());
    }

    private static class EciOutputRecordCreator implements RecordCreator {
        public Record createRecord(RecordFactory recordFactory) throws ResourceException {
            return new CommAreaRecord();
        }
    }

}
```

<!-- tabs:start -->

#### ** English **

We can then subclass the abstract `EciMappingOperation` class to specify mappings between custom objects and `Records`, as the following example shows:
#### ** Chinese **

然后，我们可以将抽象的`EciMappingOperation`类进行子类化，以指定自定义对象和`Records`之间的映射，如下例所示。

<!-- tabs:end -->


```java
public class MyDaoImpl extends CciDaoSupport implements MyDao {

    public OutputObject getData(Integer id) {
        EciMappingOperation query = new EciMappingOperation(getConnectionFactory(), "MYPROG") {

            protected abstract byte[] objectToBytes(Object inObject) throws IOException {
                Integer id = (Integer) inObject;
                return String.valueOf(id);
            }

            protected abstract Object bytesToObject(byte[] bytes) throws IOException;
                String str = new String(bytes);
                String field1 = str.substring(0,6);
                String field2 = str.substring(6,1);
                String field3 = str.substring(7,1);
                return new OutputObject(field1, field2, field3);
            }
        });

        return (OutputObject) query.execute(new Integer(id));
    }

}
```

<!-- tabs:start -->

#### ** English **

The corresponding configuration of Spring beans could be as follows in non-managed mode:
#### ** Chinese **

在非管理模式下，Spring Bean的相应配置可以如下。

<!-- tabs:end -->


```xml
<bean id="managedConnectionFactory" class="com.ibm.connector2.cics.ECIManagedConnectionFactory">
    <property name="serverName" value="TXSERIES"/>
    <property name="connectionURL" value="local:"/>
    <property name="userName" value="CICSUSER"/>
    <property name="password" value="CICS"/>
</bean>

<bean id="connectionFactory" class="org.springframework.jca.support.LocalConnectionFactoryBean">
    <property name="managedConnectionFactory" ref="managedConnectionFactory"/>
</bean>

<bean id="component" class="MyDaoImpl">
    <property name="connectionFactory" ref="connectionFactory"/>
</bean>
```

<!-- tabs:start -->

#### ** English **

In managed mode (that is, in a Java EE environment), the configuration could be as follows:
#### ** Chinese **

在管理模式下（也就是在Java EE环境中），配置可能如下。

<!-- tabs:end -->


```xml
<jee:jndi-lookup id="connectionFactory" jndi-name="eis/cicseci"/>

<bean id="component" class="MyDaoImpl">
    <property name="connectionFactory" ref="connectionFactory"/>
</bean>
```

### **5.4. Transactions** 

<!-- tabs:start -->

#### ** English **

JCA specifies several levels of transaction support for resource adapters. The kind of transactions that your resource adapter supports is specified in its `ra.xml` file. There are essentially three options: none (for example, with the CICS EPI connector), local transactions (for example, with a CICS ECI connector), and global transactions (for example, with an IMS connector). The following example configures the global option:
#### ** Chinese **

JCA为资源适配器指定了几个级别的事务支持。资源适配器支持的事务类型在其`ra.xml`文件中指定。基本上有三个选项：无（例如，使用 CICS EPI 连接器）、本地事务（例如，使用 CICS ECI 连接器）和全局事务（例如，使用 IMS 连接器）。下面的例子配置了全局选项。

<!-- tabs:end -->


```xml
<connector>
    <resourceadapter>
        <!-- <transaction-support>NoTransaction</transaction-support> -->
        <!-- <transaction-support>LocalTransaction</transaction-support> -->
        <transaction-support>XATransaction</transaction-support>
    <resourceadapter>
<connector>
```

<!-- tabs:start -->

#### ** English **

For global transactions, you can use Spring’s generic transaction infrastructure to demarcate transactions, with `JtaTransactionManager` as the backend (delegating to the Java EE server’s distributed transaction coordinator underneath).
#### ** Chinese **

对于全局事务，你可以使用Spring的通用事务基础架构来划分事务，用`JtaTransactionManager`作为后台（委托给Java EE服务器下面的分布式事务协调器）。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

For local transactions on a single CCI `ConnectionFactory`, Spring provides a specific transaction-management strategy for CCI, analogous to the `DataSourceTransactionManager` for JDBC. The CCI API defines a local transaction object and corresponding local transaction demarcation methods. Spring’s `CciLocalTransactionManager` executes such local CCI transactions in a fashion that is fully compliant with Spring’s generic `PlatformTransactionManager` abstraction. The following example configures a `CciLocalTransactionManager`:
#### ** Chinese **

对于单个CCI`ConnectionFactory`上的本地事务，Spring为CCI提供了一个特定的事务管理策略，类似于JDBC的`DataSourceTransactionManager`。CCI API定义了一个本地事务对象和相应的本地事务划分方法。Spring的`CciLocalTransactionManager`以完全符合Spring的通用`PlatformTransactionManager`抽象的方式执行这样的CCI事务。下面的示例配置了一个`CciLocalTransactionManager`。

<!-- tabs:end -->


```xml
<jee:jndi-lookup id="eciConnectionFactory" jndi-name="eis/cicseci"/>

<bean id="eciTransactionManager"
        class="org.springframework.jca.cci.connection.CciLocalTransactionManager">
    <property name="connectionFactory" ref="eciConnectionFactory"/>
</bean>
```

<!-- tabs:start -->

#### ** English **

You can use both transaction strategies with any of Spring’s transaction demarcation facilities, be it declarative or programmatic. This is a consequence of Spring’s generic `PlatformTransactionManager` abstraction, which decouples transaction demarcation from the actual execution strategy. You can switch between `JtaTransactionManager` and `CciLocalTransactionManager` as needed, keeping your transaction demarcation as-is.
#### ** Chinese **

你可以用Spring的任何事务划分设施来使用这两种事务策略，无论是声明式的还是程序式的。这是Spring的通用的`PlatformTransactionManager`抽象的结果，它将事务划分与实际执行策略脱钩。你可以根据需要在`JtaTransactionManager`和`CciLocalTransactionManager`之间进行切换，保持事务划分的原样。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

For more information on Spring’s transaction facilities, see [Transaction Management](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/data-access.html#transaction).
#### ** Chinese **

有关Spring的交易设施的更多信息，请参阅[交易管理](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/data-access.html#transaction)。

<!-- tabs:end -->



[下一章](Spring-Framework-5.2.6.RELEASE/Integration/6.%20Email.md)


[回目录](Spring-Framework-5.2.6.RELEASE/summary.md)

[回首页](/README)
