# 8. Cache Abstraction

<!-- tabs:start -->

#### ** English **

Since version 3.1, the Spring Framework provides support for transparently adding caching to an existing Spring application. Similar to the [transaction](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/data-access.html#transaction) support, the caching abstraction allows consistent use of various caching solutions with minimal impact on the code.
#### ** Chinese **

自3.1版本以来，Spring框架提供了对在现有Spring应用程序中透明地添加缓存的支持。与[事务](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/data-access.html#transaction)支持类似，该缓存抽象允许一致使用各种缓存解决方案，并且对代码的影响最小。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

As from Spring 4.1, the cache abstraction has been significantly extended with the support of [JSR-107 annotations](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#cache-jsr-107) and more customization options.
#### ** Chinese **

从Spring 4.1开始，随着[JSR-107注释](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#cache-jsr-107)和更多的自定义选项的支持，缓存抽象得到了大幅扩展。

<!-- tabs:end -->


### **8.1. Understanding the Cache Abstraction** 

<!-- tabs:start -->

#### ** English **

Cache vs Buffer
#### ** Chinese **

缓存与缓冲区

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The terms, `buffer` and `cache,` tend to be used interchangeably. Note, however, that they represent different things. Traditionally, a buffer is used as an intermediate temporary store for data between a fast and a slow entity. As one party would have to wait for the other (which affects performance), the buffer alleviates this by allowing entire blocks of data to move at once rather than in small chunks. The data is written and read only once from the buffer. Furthermore, the buffers are visible to at least one party that is aware of it.
#### ** Chinese **

`buffer`和`cache,`这两个术语往往可以互换使用。但是，请注意，它们代表的是不同的东西。传统上，缓冲区被用作快速实体和慢实体之间的数据中间临时存储。由于一方必须等待另一方（这将影响性能），缓冲区通过允许整块数据一次移动而不是小块移动来缓解这种情况。数据只从缓冲区中写入和读取一次。此外，缓冲区至少有一方知道它的存在。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

A cache, on the other hand, is, by definition, hidden, and neither party is aware that caching occurs. It also improves performance but does so by letting the same data be read multiple times in a fast fashion.
#### ** Chinese **

而缓存，顾名思义是隐藏的，双方都不知道缓存的发生。它也可以提高性能，但通过让相同的数据被多次快速读取来实现。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can find a further explanation of the differences between a buffer and a cache [here](https://en.wikipedia.org/wiki/Cache_(computing)#The_difference_between_buffer_and_cache).
#### ** Chinese **

你可以在这里找到关于缓冲区和缓存的区别的进一步解释[https://en.wikipedia.org/wiki/Cache_(https://en.wikipedia.org/wiki/Cache_(计算)#The_differ_between_buffer_and_cache)]。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

At its core, the cache abstraction applies caching to Java methods, thus reducing the number of executions based on the information available in the cache. That is, each time a targeted method is invoked, the abstraction applies a caching behavior that checks whether the method has been already executed for the given arguments. If it has been executed, the cached result is returned without having to execute the actual method. If the method has not been executed, then it is executed, and the result is cached and returned to the user so that, the next time the method is invoked, the cached result is returned. This way, expensive methods (whether CPU- or IO-bound) can be executed only once for a given set of parameters and the result reused without having to actually execute the method again. The caching logic is applied transparently without any interference to the invoker.
#### ** Chinese **

就其核心而言，缓存抽象将缓存应用到Java方法上，从而根据缓存中的可用信息减少执行次数。也就是说，每次调用一个目标方法时，该抽象会应用一个缓存行为，检查该方法是否已经执行了给定的参数。如果已经执行了，则返回缓存的结果，而不需要执行实际的方法。如果该方法没有被执行，那么它就被执行了，结果被缓存并返回给用户，这样，当下一次调用该方法时，就会返回缓存结果。这样一来，昂贵的方法（不管是CPU-绑定的还是IO-绑定的）可以对给定的参数集只执行一次，结果就可以重复使用，而不需要再次实际执行该方法。缓存逻辑的应用是透明的，不会对调用者造成任何干扰。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

This approach works only for methods that are guaranteed to return the same output (result) for a given input (or arguments) no matter how many times it is executed.
#### ** Chinese **

这种方法只适用于保证对给定的输入（或参数）无论执行多少次都能返回相同的输出（结果）的方法。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The caching abstraction provides other cache-related operations, such as the ability to update the content of the cache or to remove one or all entries. These are useful if the cache deals with data that can change during the course of the application.
#### ** Chinese **

缓存抽象提供了其他与缓存相关的操作，例如更新缓存内容或删除一个或全部条目的能力。如果缓存处理的数据在应用过程中会发生变化，这些都是有用的。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

As with other services in the Spring Framework, the caching service is an abstraction (not a cache implementation) and requires the use of actual storage to store the cache data — that is, the abstraction frees you from having to write the caching logic but does not provide the actual data store. This abstraction is materialized by the `org.springframework.cache.Cache` and `org.springframework.cache.CacheManager` interfaces.
#### ** Chinese **

与Spring框架中的其他服务一样，缓存服务是一个抽象（不是缓存实现），需要使用实际的存储来存储缓存数据--也就是说，这个抽象让你无需编写缓存逻辑，但不提供实际的数据存储。这个抽象通过 `org.springframework.cache.Cache`和`org.springframework.cache.CacheManager`接口来实现。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Spring provides [a few implementations](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#cache-store-configuration) of that abstraction: JDK `java.util.concurrent.ConcurrentMap` based caches, [Ehcache 2.x](https://www.ehcache.org/), Gemfire cache, [Caffeine](https://github.com/ben-manes/caffeine/wiki), and JSR-107 compliant caches (such as Ehcache 3.x). See [Plugging-in Different Back-end Caches](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#cache-plug) for more information on plugging in other cache stores and providers.
#### ** Chinese **

Spring提供了[一些实现](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#cache-store-configuration)这个抽象。基于 JDK `java.util.concurrent.ConcurrentMap`的缓存、[Ehcache 2.x](https://www.ehcache.org/)、Gemfire 缓存、[Caffeine](https://github.com/ben-manes/caffeine/wiki)，以及符合 JSR-107 的缓存（如 Ehcache 3.x）。请参阅[插入不同的后端缓存](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#cache-plug)，了解更多关于插入其他缓存存储和提供者的信息。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The caching abstraction has no special handling for multi-threaded and multi-process environments, as such features are handled by the cache implementation. .
#### ** Chinese **

缓存抽象对于多线程和多进程环境没有特殊的处理方法，因为这样的特性由缓存实现来处理。.

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

If you have a multi-process environment (that is, an application deployed on several nodes), you need to configure your cache provider accordingly. Depending on your use cases, a copy of the same data on several nodes can be enough. However, if you change the data during the course of the application, you may need to enable other propagation mechanisms.
#### ** Chinese **

如果你有一个多进程环境（即在多个节点上部署的应用程序），你需要相应地配置你的缓存提供者。根据你的用例，在多个节点上复制相同的数据就足够了。但是，如果你在应用过程中改变了数据，你可能需要启用其他传播机制。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Caching a particular item is a direct equivalent of the typical get-if-not-found-then- proceed-and-put-eventually code blocks found with programmatic cache interaction. No locks are applied, and several threads may try to load the same item concurrently. The same applies to eviction. If several threads are trying to update or evict data concurrently, you may use stale data. Certain cache providers offer advanced features in that area. See the documentation of your cache provider for more details.
#### ** Chinese **

缓存一个特定的项目是直接等同于典型的get-if-not-found-then- proceed-and-put-eventually的代码块，与程序式缓存交互的典型代码块。没有应用锁，多个线程可以同时尝试加载同一个项目。同样的道理也适用于驱逐。如果几个线程同时尝试更新或驱逐数据，可能会使用陈旧的数据。某些缓存提供者在这方面提供了高级功能。有关详细信息，请参阅缓存提供商的文档。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

To use the cache abstraction, you need to take care of two aspects:
#### ** Chinese **

要使用缓存抽象，需要注意两个方面的问题。

<!-- tabs:end -->


### **8.2. Declarative Annotation-based Caching** 

<!-- tabs:start -->

#### ** English **

For caching declaration, Spring’s caching abstraction provides a set of Java annotations:
#### ** Chinese **

对于缓存声明，Spring的缓存抽象提供了一组Java注释。

<!-- tabs:end -->


### **8.2.1. The** **`@Cacheable`** ** Annotation** 

<!-- tabs:start -->

#### ** English **

As the name implies, you can use `@Cacheable` to demarcate methods that are cacheable — that is, methods for which the result is stored in the cache so that, on subsequent invocations (with the same arguments), the value in the cache is returned without having to actually execute the method. In its simplest form, the annotation declaration requires the name of the cache associated with the annotated method, as the following example shows:
#### ** Chinese **

顾名思义，你可以使用`@Cacheable`来划分可缓存的方法--也就是说，结果存储在缓存中的方法，这样，在后续调用时（用相同的参数），缓存中的值就会被返回，而不需要实际执行该方法。在其最简单的形式下，注释声明要求使用与注释方法相关联的缓存名称，如下例所示。

<!-- tabs:end -->


```java
@Cacheable("books")
public Book findBook(ISBN isbn) {...}
```

<!-- tabs:start -->

#### ** English **

In the preceding snippet, the `findBook` method is associated with the cache named `books`. Each time the method is called, the cache is checked to see whether the invocation has already been executed and does not have to be repeated. While in most cases, only one cache is declared, the annotation lets multiple names be specified so that more than one cache is being used. In this case, each of the caches is checked before executing the method — if at least one cache is hit, the associated value is returned.
#### ** Chinese **

在前面的代码段中，`findBook`方法与名为`books`的缓存关联。每次调用该方法时，都会检查缓存，看看这个调用是否已经被执行过，不需要重复。虽然在大多数情况下，只声明一个缓存，但注释允许指定多个名称，这样就可以使用多个缓存。在这种情况下，在执行方法之前，每个缓存都会被检查--如果至少有一个缓存被选中，则会返回相关的值。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

All the other caches that do not contain the value are also updated, even though the cached method was not actually executed.
#### ** Chinese **

所有其他不包含该值的缓存也会被更新，即使缓存方法没有被实际执行。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following example uses `@Cacheable` on the `findBook` method:
#### ** Chinese **

下面的示例在`findBook`方法上使用了`@Cacheable`。

<!-- tabs:end -->


```java
@Cacheable({"books", "isbns"})
public Book findBook(ISBN isbn) {...}
```

### **Default Key Generation** 

<!-- tabs:start -->

#### ** English **

Since caches are essentially key-value stores, each invocation of a cached method needs to be translated into a suitable key for cache access. The caching abstraction uses a simple `KeyGenerator` based on the following algorithm:
#### ** Chinese **

由于缓存本质上是键值存储，所以缓存方法的每一次调用都需要翻译成一个合适的键来进行缓存访问。缓存抽象使用了一个简单的`KeyGenerator`，其算法如下。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

- Caching declaration: Identify the methods that need to be cached and their policy.

- Cache configuration: The backing cache where the data is stored and from which it is read.

- `@Cacheable`: Triggers cache population.

- `@CacheEvict`: Triggers cache eviction.

- `@CachePut`: Updates the cache without interfering with the method execution.

- `@Caching`: Regroups multiple cache operations to be applied on a method.

- `@CacheConfig`: Shares some common cache-related settings at class-level.

- If no params are given, return `SimpleKey.EMPTY`.

- If only one param is given, return that instance.

- If more than one param is given, return a `SimpleKey` that contains all parameters.

#### ** Chinese **

- 缓存声明。确定需要缓存的方法及其策略。

- 缓存配置。存储数据的备份缓存，并从其中读取数据。

- `@Cacheable`：触发缓存人口。

- `@CacheEvict`：触发缓存驱逐。

- `@CachePut`: 更新缓存。在不干扰方法执行的情况下更新缓存。

- `@Caching`：重组要应用于一个方法的多个缓存操作。

- `@CacheConfig`：在类级共享一些常见的缓存相关设置。

- 如果没有给出参数，返回`SimpleKey.EMPTY`。

- 如果只给了一个参数，则返回该实例。

- 如果给出了一个以上的参数，则返回包含所有参数的`SimpleKey`。


<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

This approach works well for most use-cases, as long as parameters have natural keys and implement valid `hashCode()` and `equals()` methods. If that is not the case, you need to change the strategy.
#### ** Chinese **

这种方法对大多数使用情况下都很有效，只要参数有自然键，并实现有效的`hashCode()`和`equals()`方法，就可以很好地使用。如果不是这样，你需要改变策略。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

To provide a different default key generator, you need to implement the `org.springframework.cache.interceptor.KeyGenerator` interface.
#### ** Chinese **

要提供不同的默认密钥生成器，需要实现`org.springframework.cache.interceptor.KeyGenerator`接口。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The default key generation strategy changed with the release of Spring 4.0. Earlier versions of Spring used a key generation strategy that, for multiple key parameters, considered only the `hashCode()` of parameters and not `equals()`. This could cause unexpected key collisions (see [SPR-10237](https://jira.spring.io/browse/SPR-10237) for background). The new `SimpleKeyGenerator` uses a compound key for such scenarios.
#### ** Chinese **

随着Spring 4.0版本的发布，默认的密钥生成策略发生了变化。早期版本的Spring使用的密钥生成策略，对于多个密钥参数，只考虑参数的`hashCode()`，而不是`equals()`。这可能会导致意外的密钥碰撞（背景见[SPR-10237](https://jira.spring.io/browse/SPR-10237)）。新的`SimpleKeyGenerator`使用复合键来处理这种情况。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

If you want to keep using the previous key strategy, you can configure the deprecated `org.springframework.cache.interceptor.DefaultKeyGenerator` class or create a custom hash-based `KeyGenerator` implementation.
#### ** Chinese **

如果你想继续使用之前的密钥策略，你可以配置已废弃的`org.springframework.cache.interceptor.DefaultKeyGenerator`类，或者创建一个基于哈希的`KeyGenerator`实现。

<!-- tabs:end -->


### **Custom Key Generation Declaration** 

<!-- tabs:start -->

#### ** English **

Since caching is generic, the target methods are quite likely to have various signatures that cannot be readily mapped on top of the cache structure. This tends to become obvious when the target method has multiple arguments out of which only some are suitable for caching (while the rest are used only by the method logic). Consider the following example:
#### ** Chinese **

由于缓存是通用的，所以目标方法很可能有各种不能轻易映射到缓存结构之上的签名。当目标方法有多个参数时，这种情况就会变得很明显，其中只有一些参数适合于缓存（其余的只被方法逻辑使用）。考虑一下下面的例子。

<!-- tabs:end -->


```java
@Cacheable("books")
public Book findBook(ISBN isbn, boolean checkWarehouse, boolean includeUsed)
```

<!-- tabs:start -->

#### ** English **

At first glance, while the two `boolean` arguments influence the way the book is found, they are no use for the cache. Furthermore, what if only one of the two is important while the other is not?
#### ** Chinese **

乍一看，虽然这两个`boolean`论点影响了书的查找方式，但对于缓存来说，这两个论点并没有什么用处。此外，如果两者中只有一个重要，而另一个不重要呢？

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

For such cases, the `@Cacheable` annotation lets you specify how the key is generated through its `key` attribute. You can use [SpEL](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#expressions) to pick the arguments of interest (or their nested properties), perform operations, or even invoke arbitrary methods without having to write any code or implement any interface. This is the recommended approach over the [default generator](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#cache-annotations-cacheable-default-key), since methods tend to be quite different in signatures as the code base grows. While the default strategy might work for some methods, it rarely works for all methods.
#### ** Chinese **

对于这种情况，`@Cacheable` 注释可以让你指定如何通过其`key`属性来生成密钥。你可以使用[SpEL](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#expressions)来选择感兴趣的参数（或它们的嵌套属性），执行操作，甚至调用任意方法，而不需要编写任何代码或实现任何接口。这是比[default generator](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#cache-annotations-cacheable-default-key)更值得推荐的方法，因为随着代码库的增长，方法的签名往往会有很大的差异。虽然默认策略可能对某些方法有效，但很少对所有方法都有效。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following examples use various SpEL declarations (if you are not familiar with SpEL, do yourself a favor and read [Spring Expression Language](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#expressions)):
#### ** Chinese **

下面的例子使用了各种SpEL声明（如果你对SpEL不熟悉，请帮自己一个忙，阅读[Spring表达式语言](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#expressions)）。

<!-- tabs:end -->


```java
@Cacheable(cacheNames="books", key="#isbn")
public Book findBook(ISBN isbn, boolean checkWarehouse, boolean includeUsed)

@Cacheable(cacheNames="books", key="#isbn.rawNumber")
public Book findBook(ISBN isbn, boolean checkWarehouse, boolean includeUsed)

@Cacheable(cacheNames="books", key="T(someType).hash(#isbn)")
public Book findBook(ISBN isbn, boolean checkWarehouse, boolean includeUsed)
```

<!-- tabs:start -->

#### ** English **

The preceding snippets show how easy it is to select a certain argument, one of its properties, or even an arbitrary (static) method.
#### ** Chinese **

前面的片段显示了选择某个参数、其属性之一，甚至是任意（静态）方法是多么容易。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

If the algorithm responsible for generating the key is too specific or if it needs to be shared, you can define a custom `keyGenerator` on the operation. To do so, specify the name of the `KeyGenerator` bean implementation to use, as the following example shows:
#### ** Chinese **

如果负责生成密钥的算法过于特殊或者需要共享，可以在操作上定义一个自定义的`keyGenerator`。要这样做，请指定要使用的`KeyGenerator` bean实现的名称，如下例所示。

<!-- tabs:end -->


```java
@Cacheable(cacheNames="books", keyGenerator="myKeyGenerator")
public Book findBook(ISBN isbn, boolean checkWarehouse, boolean includeUsed)
```

<!-- tabs:start -->

#### ** English **

The `key` and `keyGenerator` parameters are mutually exclusive and an operation that specifies both results in an exception.
#### ** Chinese **

`key`和`keyGenerator`参数是相互排斥的，指定这两个参数的操作会导致异常。

<!-- tabs:end -->


### **Default Cache Resolution** 

<!-- tabs:start -->

#### ** English **

The caching abstraction uses a simple `CacheResolver` that retrieves the caches defined at the operation level by using the configured `CacheManager`.
#### ** Chinese **

缓存抽象使用一个简单的`CacheResolver`，通过使用配置的`CacheManager`来检索在操作层定义的缓存。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

To provide a different default cache resolver, you need to implement the `org.springframework.cache.interceptor.CacheResolver` interface.
#### ** Chinese **

要提供不同的默认缓存解析器，需要实现`org.springframework.cache.interceptor.CacheResolver`接口。

<!-- tabs:end -->


### **Custom Cache Resolution** 

<!-- tabs:start -->

#### ** English **

The default cache resolution fits well for applications that work with a single `CacheManager` and have no complex cache resolution requirements.
#### ** Chinese **

默认的缓存分辨率非常适合于使用单个`CacheManager`工作且没有复杂的缓存分辨率要求的应用程序。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

For applications that work with several cache managers, you can set the `cacheManager` to use for each operation, as the following example shows:
#### ** Chinese **

对于使用多个缓存管理器工作的应用程序，可以设置`cacheManager`用于每个操作，如下例所示。

<!-- tabs:end -->


```java
@Cacheable(cacheNames="books", cacheManager="anotherCacheManager") (1)
public Book findBook(ISBN isbn) {...}

//(1)Specifying `anotherCacheManager`.
```

#### ** English **

You can also replace the `CacheResolver` entirely in a fashion similar to that of replacing [key generation](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#cache-annotations-cacheable-key). The resolution is requested for every cache operation, letting the implementation actually resolve the caches to use based on runtime arguments. The following example shows how to specify a `CacheResolver`:
#### ** Chinese **

你也可以用类似于替换[key generation](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#cache-annotations-cacheable-key)的方式完全替换`CacheResolver`。在每次缓存操作中都会请求解析，让实现根据运行时参数实际解析要使用的缓存。下面的例子显示了如何指定一个`CacheResolver`。

<!-- tabs:end -->


```java
@Cacheable(cacheResolver="runtimeCacheResolver") (1)
public Book findBook(ISBN isbn) {...}
```

<!-- tabs:start -->

#### ** English **

(1)Specifying the `CacheResolver`.
#### ** Chinese **

(1)指定`CacheResolver`。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Since Spring 4.1, the `value` attribute of the cache annotations are no longer mandatory, since this particular information can be provided by the `CacheResolver` regardless of the content of the annotation.
#### ** Chinese **

自Spring 4.1以来，缓存注释的`value`属性不再是强制性的，因为无论注释的内容如何，这个特定信息都可以由`CacheResolver`提供。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Similarly to `key` and `keyGenerator`, the `cacheManager` and `cacheResolver` parameters are mutually exclusive, and an operation specifying both results in an exception. as a custom `CacheManager` is ignored by the `CacheResolver` implementation. This is probably not what you expect.
#### ** Chinese **

与`key`和`keyGenerator`类似，`cacheManager`和`cacheResolver`参数是相互排斥的，指定这两个参数的操作会导致异常。作为自定义的 `CacheManager` 被 `CacheResolver` 实现忽略。这可能不是你所期望的那样。

<!-- tabs:end -->


### **Synchronized Caching** 

<!-- tabs:start -->

#### ** English **

In a multi-threaded environment, certain operations might be concurrently invoked for the same argument (typically on startup). By default, the cache abstraction does not lock anything, and the same value may be computed several times, defeating the purpose of caching.
#### ** Chinese **

在多线程环境中，某些操作可能会并发地调用同一个参数（通常在启动时）。默认情况下，缓存抽象不会锁定任何东西，同一个值可能会被计算多次，这就违背了缓存的目的。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

For those particular cases, you can use the `sync` attribute to instruct the underlying cache provider to lock the cache entry while the value is being computed. As a result, only one thread is busy computing the value, while the others are blocked until the entry is updated in the cache. The following example shows how to use the `sync` attribute:
#### ** Chinese **

对于这些特殊情况，你可以使用`sync`属性来指示底层缓存提供者在计算值时锁定缓存条目。这样，只有一个线程忙于计算该值，而其他线程被阻塞，直到缓存中的条目被更新。下面的示例显示了如何使用`sync`属性。

<!-- tabs:end -->


```java
@Cacheable(cacheNames="foos", sync=true) (1)
public Foo executeExpensiveOperation(String id) {...}
```

<!-- tabs:start -->

#### ** English **

(1)Using the `sync` attribute.
#### ** Chinese **

(1)使用`sync`属性。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

This is an optional feature, and your favorite cache library may not support it. All `CacheManager` implementations provided by the core framework support it. See the documentation of your cache provider for more details.
#### ** Chinese **

这是一个可选的功能，你喜欢的缓存库可能不支持。核心框架提供的所有`CacheManager`实现都支持它。更多细节请参见缓存提供者的文档。

<!-- tabs:end -->


### **Conditional Caching** 

<!-- tabs:start -->

#### ** English **

Sometimes, a method might not be suitable for caching all the time (for example, it might depend on the given arguments). The cache annotations support such functionality through the `condition` parameter, which takes a `SpEL` expression that is evaluated to either `true` or `false`. If `true`, the method is cached. If not, it behaves as if the method is not cached (that is, the method is executed every time no matter what values are in the cache or what arguments are used). For example, the following method is cached only if the argument `name` has a length shorter than 32:
#### ** Chinese **

有时，一个方法可能并不适合一直缓存（例如，它可能取决于给定的参数）。缓存注解通过`condition`参数支持这样的功能，该参数接受一个`SpEL`表达式，该表达式被评价为`true`或`false`。如果`true`，该方法被缓存。如果不是，则表现为该方法没有被缓存（也就是说，无论缓存中的值是什么值或使用了什么参数，该方法每次都会被执行）。例如，以下方法只有在参数`name`长度小于32时才会被缓存。

<!-- tabs:end -->


```java
@Cacheable(cacheNames="book", condition="#name.length() < 32") (1)
public Book findBook(String name)
```

<!-- tabs:start -->

#### ** English **

(1)Setting a condition on `@Cacheable`.
#### ** Chinese **

(1)对`@Cacheable`设置一个条件。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

In addition to the `condition` parameter, you can use the `unless` parameter to veto the adding of a value to the cache. Unlike `condition`, `unless` expressions are evaluated after the method has been called. To expand on the previous example, perhaps we only want to cache paperback books, as the following example does:
#### ** Chinese **

除了`condition`参数外，还可以使用`unless`参数来否决向缓存中添加值。与`condition`不同的是，`unless`表达式是在方法被调用后才被评价的。拓展一下前面的例子，也许我们只想缓存平装书，就像下面的例子一样。

<!-- tabs:end -->


```java
@Cacheable(cacheNames="book", condition="#name.length() < 32", unless="#result.hardback") (1)
public Book findBook(String name)
```

<!-- tabs:start -->

#### ** English **

(1)Using the `unless` attribute to block hardbacks.
#### ** Chinese **

(1)使用`unless`属性来阻止硬拷贝。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The cache abstraction supports `java.util.Optional`, using its content as the cached value only if it is present. `#result` always refers to the business entity and never a supported wrapper, so the previous example can be rewritten as follows:
#### ** Chinese **

缓存抽象支持`java.util.Optional`，只有当它存在时，才使用它的内容作为缓存值。 `#result`总是指的是业务实体，而不是支持的封装器，所以前面的例子可以改写成如下。

<!-- tabs:end -->


```java
@Cacheable(cacheNames="book", condition="#name.length() < 32", unless="#result?.hardback")
public Optional<Book> findBook(String name)
```

<!-- tabs:start -->

#### ** English **

Note that `result` still refers to `Book` and not `Optional`. As it might be `null`, we should use the safe navigation operator.
#### ** Chinese **

注意，`result`仍然是指`Book`而不是`Optional`。因为它可能是`null`，所以我们应该使用安全导航操作符。

<!-- tabs:end -->


### **Available Caching SpEL Evaluation Context** 

<!-- tabs:start -->

#### ** English **

Each `SpEL` expression evaluates against a dedicated [`context`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#expressions-language-ref). In addition to the built-in parameters, the framework provides dedicated caching-related metadata, such as the argument names. The following table describes the items made available to the context so that you can use them for key and conditional computations:
#### ** Chinese **

每个`SpEL`表达式都会针对一个专用的[`context`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#expressions-language-ref)进行评估。除了内置参数之外，框架还提供了专用的缓存相关元数据，比如参数名。下表描述了提供给上下文的项目，以便你可以使用它们进行键和条件计算。

<!-- tabs:end -->


Name | Location | Description | Example 
-|-|-|-
methodName | Root object | The name of the method being invoked | #root.methodName 
method | Root object | The method being invoked | #root.method.name 
target | Root object | The target object being invoked | #root.target 
targetClass | Root object | The class of the target being invoked | #root.targetClass 
args | Root object | The arguments (as array) used for invoking the target | #root.args[0] 
caches | Root object | Collection of caches against which the current method is executed | #root.caches[0].name 
Argument name | Evaluation context | Name of any of the method arguments. If the names are not available (perhaps due to having no debug information), the argument names are also available under the #a<#arg> where #arg stands for the argument index (starting from 0). | #iban or #a0 (you can also use #p0 or #p<#arg> notation as an alias). 
result | Evaluation context | The result of the method call (the value to be cached). Only available in unless expressions, cache put expressions (to compute the key), or cache evict expressions (when beforeInvocation is false). For supported wrappers (such as Optional), #result refers to the actual object, not the wrapper. | #result 


### **8.2.2. The** **`@CachePut`** ** Annotation** 

<!-- tabs:start -->

#### ** English **

When the cache needs to be updated without interfering with the method execution, you can use the `@CachePut` annotation. That is, the method is always executed and its result is placed into the cache (according to the `@CachePut` options). It supports the same options as `@Cacheable` and should be used for cache population rather than method flow optimization. The following example uses the `@CachePut` annotation:
#### ** Chinese **

当需要在不干扰方法执行的情况下更新缓存时，可以使用`@CachePut`注释。也就是说，该方法总是被执行，其结果被放置到缓存中（根据`@CachePut`选项）。它支持与`@Cacheable`相同的选项，应该用于缓存人口而不是方法流优化。下面的示例使用了 `@CachePut` 注解。

<!-- tabs:end -->


```java
@CachePut(cacheNames="book", key="#isbn")
public Book updateBook(ISBN isbn, BookDescriptor descriptor)
```

<!-- tabs:start -->

#### ** English **

Using `@CachePut` and `@Cacheable` annotations on the same method is generally strongly discouraged because they have different behaviors. While the latter causes the method execution to be skipped by using the cache, the former forces the execution in order to execute a cache update. This leads to unexpected behavior and, with the exception of specific corner-cases (such as annotations having conditions that exclude them from each other), such declarations should be avoided. Note also that such conditions should not rely on the result object (that is, the `#result` variable), as these are validated up-front to confirm the exclusion.
#### ** Chinese **

在同一个方法上使用 `@CachePut` 和 `@Cacheable` 注解一般不建议使用，因为它们有不同的行为。后者会通过使用缓存导致方法的执行被跳过，而前者会强制执行，以便执行缓存更新。这导致了意想不到的行为，而且除了特定的转角情况（如注解具有相互排斥的条件）外，应该避免这样的声明。还要注意的是，这样的条件不应该依赖于结果对象（即`#result`变量），因为这些条件都是预先验证过的，以确认排除。

<!-- tabs:end -->


### **8.2.3. The** **`@CacheEvict`** ** annotation** 

<!-- tabs:start -->

#### ** English **

The cache abstraction allows not just population of a cache store but also eviction. This process is useful for removing stale or unused data from the cache. As opposed to `@Cacheable`, `@CacheEvict` demarcates methods that perform cache eviction (that is, methods that act as triggers for removing data from the cache). Similarly to its sibling, `@CacheEvict` requires specifying one or more caches that are affected by the action, allows a custom cache and key resolution or a condition to be specified, and features an extra parameter (`allEntries`) that indicates whether a cache-wide eviction needs to be performed rather than just an entry eviction (based on the key). The following example evicts all entries from the `books` cache:
#### ** Chinese **

缓存抽象不仅允许缓存存储的人口，还允许驱逐。这个过程对于从缓存中删除陈旧或未使用的数据是非常有用的。与`@Cacheable`不同，`@CacheEvict`划定了执行缓存驱逐的方法（即作为从缓存中删除数据的触发器的方法）。与它的同胞方法类似，`@CacheEvict`需要指定一个或多个受操作影响的缓存，允许指定一个自定义的缓存和密钥解析或条件，并且有一个额外的参数(`allEntries`)，用于指示是否需要执行缓存范围内的驱逐，而不是只执行一个条目驱逐(基于密钥)。下面的例子是从`books`缓存中驱逐所有条目。

<!-- tabs:end -->


```java
@CacheEvict(cacheNames="books", allEntries=true) (1)
public void loadBooks(InputStream batch)
```

<!-- tabs:start -->

#### ** English **

(1)Using the `allEntries` attribute to evict all entries from the cache.
#### ** Chinese **

(1)使用`allEntries`属性从缓存中驱逐所有条目。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

This option comes in handy when an entire cache region needs to be cleared out. Rather than evicting each entry (which would take a long time, since it is inefficient), all the entries are removed in one operation, as the preceding example shows. Note that the framework ignores any key specified in this scenario as it does not apply (the entire cache is evicted, not only one entry).
#### ** Chinese **

当需要清除整个缓存区域时，这个选项就会派上用场。正如前面的例子所示，所有的条目都会在一次操作中被清除，而不是逐个清除（这将花费很长时间，因为效率很低）。请注意，框架忽略了这个场景中指定的任何键，因为它并不适用（整个缓存被清除，而不是只清除一个条目）。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can also indicate whether the eviction should occur after (the default) or before the method executes by using the `beforeInvocation` attribute. The former provides the same semantics as the rest of the annotations: Once the method completes successfully, an action (in this case, eviction) on the cache is executed. If the method does not execute (as it might be cached) or an exception is thrown, the eviction does not occur. The latter (`beforeInvocation=true`) causes the eviction to always occur before the method is invoked. This is useful in cases where the eviction does not need to be tied to the method outcome.
#### ** Chinese **

您还可以通过使用`beforeInvocation`属性来指示驱逐应该在方法执行之后（默认情况下）还是在方法执行之前发生。前者提供了与其他注释相同的语义。一旦方法成功完成，缓存上的一个动作（在本例中是驱逐）就会被执行。如果该方法没有执行（因为它可能被缓存）或抛出异常，则驱逐不会发生。后者(`beforeInvocation=true`)导致eviction总是在方法被调用之前发生。这在不需要将驱逐与方法结果绑定的情况下很有用。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Note that `void` methods can be used with `@CacheEvict` - as the methods act as a trigger, the return values are ignored (as they do not interact with the cache). This is not the case with `@Cacheable` which adds or updates data into the cache and, thus, requires a result.
#### ** Chinese **

注意，`void`方法可以与`@CacheEvict`一起使用--因为这些方法作为一个触发器，返回值被忽略（因为它们不与缓存交互）。而`@Cacheable`方法则不然，它将数据添加或更新到缓存中，因此需要一个结果。

<!-- tabs:end -->


### **8.2.4. The** **`@Caching`** ** Annotation** 

<!-- tabs:start -->

#### ** English **

Sometimes, multiple annotations of the same type (such as `@CacheEvict` or `@CachePut`) need to be specified — for example, because the condition or the key expression is different between different caches. `@Caching` lets multiple nested `@Cacheable`, `@CachePut`, and `@CacheEvict` annotations be used on the same method. The following example uses two `@CacheEvict` annotations:
#### ** Chinese **

有时，需要指定相同类型的多个注释（如 `@CacheEvict`或`@CachePut`）--例如，因为条件或键表达式在不同的缓存之间是不同的。 `@Caching`可以在同一个方法上使用多个嵌套的`@Cacheable`、`@CachePut`和`@CacheEvict`注释。下面的示例使用了两个 `@CacheEvict` 注解。

<!-- tabs:end -->


```java
@Caching(evict = { @CacheEvict("primary"), @CacheEvict(cacheNames="secondary", key="#p0") })
public Book importBooks(String deposit, Date date)
```

### **8.2.5. The** **`@CacheConfig`** ** annotation** 

<!-- tabs:start -->

#### ** English **

So far, we have seen that caching operations offer many customization options and that you can set these options for each operation. However, some of the customization options can be tedious to configure if they apply to all operations of the class. For instance, specifying the name of the cache to use for every cache operation of the class can be replaced by a single class-level definition. This is where `@CacheConfig` comes into play. The following examples uses `@CacheConfig` to set the name of the cache:
#### ** Chinese **

到目前为止，我们已经看到，缓存操作提供了许多自定义选项，你可以为每个操作设置这些选项。但是，如果有些自定义选项适用于类的所有操作，那么配置起来就会比较繁琐。例如，指定类的每个缓存操作都要使用的缓存名称，可以用一个类级定义来代替。这就是`@CacheConfig`发挥作用的地方。下面的示例使用`@CacheConfig`来设置缓存的名称。

<!-- tabs:end -->


```java
@CacheConfig("books") (1)
public class BookRepositoryImpl implements BookRepository {

    @Cacheable
    public Book findBook(ISBN isbn) {...}
}
```

<!-- tabs:start -->

#### ** English **

(1)Using `@CacheConfig` to set the name of the cache.
#### ** Chinese **

(1)使用`@CacheConfig`设置缓存的名称。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

`@CacheConfig` is a class-level annotation that allows sharing the cache names, the custom `KeyGenerator`, the custom `CacheManager`, and the custom `CacheResolver`. Placing this annotation on the class does not turn on any caching operation.
#### ** Chinese **

`@CacheConfig`是一个类级注释，它允许共享缓存名称、自定义的`KeyGenerator`、自定义的`CacheManager`和自定义的`CacheResolver`。在类上放置这个注释并不会开启任何缓存操作。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

An operation-level customization always overrides a customization set on `@CacheConfig`. Therefore, this gives three levels of customizations for each cache operation:
#### ** Chinese **

操作级的自定义总是会覆盖`@CacheConfig`上的自定义设置。因此，这为每个缓存操作提供了三个级别的自定义。

<!-- tabs:end -->


### **8.2.6. Enabling Caching Annotations** 

<!-- tabs:start -->

#### ** English **

It is important to note that even though declaring the cache annotations does not automatically trigger their actions - like many things in Spring, the feature has to be declaratively enabled (which means if you ever suspect caching is to blame, you can disable it by removing only one configuration line rather than all the annotations in your code).
#### ** Chinese **

值得注意的是，即使声明缓存注释并不能自动触发它们的操作--就像Spring中的许多东西一样，该功能必须声明性地启用（这意味着如果你怀疑是缓存的问题，你可以通过删除代码中的一个配置行而不是所有的注释来禁用它）。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

To enable caching annotations add the annotation `@EnableCaching` to one of your `@Configuration` classes:
#### ** Chinese **

要启用缓存注释，请将注释`@EnableCaching`添加到您的`@Configuration`类中。

<!-- tabs:end -->


```java
@Configuration
@EnableCaching
public class AppConfig {
}
```

<!-- tabs:start -->

#### ** English **

Alternatively, for XML configuration you can use the `cache:annotation-driven` element:
#### ** Chinese **

或者，对于XML配置，你可以使用`cache:annotation-driven`元素。

<!-- tabs:end -->


```xml
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:cache="http://www.springframework.org/schema/cache"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/cache https://www.springframework.org/schema/cache/spring-cache.xsd">

        <cache:annotation-driven/>
</beans>
```

<!-- tabs:start -->

#### ** English **

Both the `cache:annotation-driven` element and the `@EnableCaching` annotation let you specify various options that influence the way the caching behavior is added to the application through AOP. The configuration is intentionally similar with that of [`@Transactional`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/data-access.html#tx-annotation-driven-settings).
#### ** Chinese **

`cache:annotation-driven`元素和`@EnableCaching`注解都可以让你指定各种选项，以影响通过AOP将缓存行为添加到应用程序中的方式。该配置有意与[`@Transactional`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/data-access.html#tx-annotation-driven-settings)的配置相似。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The default advice mode for processing caching annotations is `proxy`, which allows for interception of calls through the proxy only. Local calls within the same class cannot get intercepted that way. For a more advanced mode of interception, consider switching to `aspectj` mode in combination with compile-time or load-time weaving.
#### ** Chinese **

处理缓存注释的默认建议模式是`proxy`，它只允许通过代理拦截调用。同一类中的本地调用不能以这种方式被拦截。对于更高级的拦截模式，可以考虑切换到`aspectj`模式，并结合编译时或加载时编织。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

For more detail about advanced customizations (using Java configuration) that are required to implement `CachingConfigurer`, see the [javadoc](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/cache/annotation/CachingConfigurer.html).
#### ** Chinese **

有关实现`CachingConfigurer`所需的高级定制（使用Java配置）的更多细节，请参阅[javadoc](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/cache/annotation/CachingConfigurer.html)。

<!-- tabs:end -->


XML Attribute | Annotation Attribute | Default | Description 
-|-|-|-
cache-manager | N/A (see the CachingConfigurer javadoc) | cacheManager | The name of the cache manager to use. A default CacheResolver is initialized behind the scenes with this cache manager (or cacheManager if not set). For more fine-grained management of the cache resolution, consider setting the 'cache-resolver' attribute. 
cache-resolver | N/A (see the CachingConfigurer javadoc) | A SimpleCacheResolver using the configured cacheManager. | The bean name of the CacheResolver that is to be used to resolve the backing caches. This attribute is not required and needs to be specified only as an alternative to the 'cache-manager' attribute. 
key-generator | N/A (see the CachingConfigurer javadoc) | SimpleKeyGenerator | Name of the custom key generator to use. 
error-handler | N/A (see the CachingConfigurer javadoc) | SimpleCacheErrorHandler | The name of the custom cache error handler to use. By default, any exception thrown during a cache related operation is thrown back at the client. 
mode | mode | proxy | The default mode (proxy) processes annotated beans to be proxied by using Spring’s AOP framework (following proxy semantics, as discussed earlier, applying to method calls coming in through the proxy only). The alternative mode (aspectj) instead weaves the affected classes with Spring’s AspectJ caching aspect, modifying the target class byte code to apply to any kind of method call. AspectJ weaving requires spring-aspects.jar in the classpath as well as load-time weaving (or compile-time weaving) enabled. (See Spring configuration for details on how to set up load-time weaving.) 
proxy-target-class | proxyTargetClass | false | Applies to proxy mode only. Controls what type of caching proxies are created for classes annotated with the @Cacheable or @CacheEvict annotations. If the proxy-target-class attribute is set to true, class-based proxies are created. If proxy-target-class is false or if the attribute is omitted, standard JDK interface-based proxies are created. (See Proxying Mechanisms for a detailed examination of the different proxy types.) 
order | order | Ordered.LOWEST_PRECEDENCE | Defines the order of the cache advice that is applied to beans annotated with @Cacheable or @CacheEvict. (For more information about the rules related to ordering AOP advice, see Advice Ordering.) No specified ordering means that the AOP subsystem determines the order of the advice. 


<!-- tabs:start -->

#### ** English **

`<cache:annotation-driven/>` looks for `@Cacheable/@CachePut/@CacheEvict/@Caching` only on beans in the same application context in which it is defined. This means that, if you put `<cache:annotation-driven/>` in a `WebApplicationContext` for a `DispatcherServlet`, it checks for beans only in your controllers, not your services. See [the MVC section](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-servlet) for more information.
#### ** Chinese **

`<cache:annotation-driven/>`只在定义了`@Cacheable/@CachePut/@CacheEvict/@Caching`的同一应用上下文中的Bean上寻找`@Cacheable/@CachePut/@CacheEvict/@Caching`。这意味着，如果你把`<cache:annotation-driven/>`放在`WebApplicationContext`中的`DispatcherServlet`中，它只检查你的控制器中的bean，而不是你的服务。更多信息请参见[MVC部分](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-servlet)。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Method visibility and cache annotations
#### ** Chinese **

方法的可见性和缓存注释

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

When you use proxies, you should apply the cache annotations only to methods with public visibility. If you do annotate protected, private, or package-visible methods with these annotations, no error is raised, but the annotated method does not exhibit the configured caching settings. Consider using AspectJ (see the rest of this section) if you need to annotate non-public methods, as it changes the bytecode itself.
#### ** Chinese **

当你使用代理时，你应该只对具有公共可见性的方法应用缓存注释。如果你用这些注释对受保护的、私有的或包可见的方法进行注释，则不会产生错误，但被注释的方法不会显示配置的缓存设置。如果需要对非公共方法进行注释，请考虑使用AspectJ（见本节的其余部分），因为它改变了字节码本身。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Spring recommends that you only annotate concrete classes (and methods of concrete classes) with the `@Cache*` annotation, as opposed to annotating interfaces. You certainly can place the `@Cache*` annotation on an interface (or an interface method), but this works only as you would expect it to if you use interface-based proxies. The fact that Java annotations are not inherited from interfaces means that, if you use class-based proxies (`proxy-target-class="true"`) or the weaving-based aspect (`mode="aspectj"`), the caching settings are not recognized by the proxying and weaving infrastructure, and the object is not wrapped in a caching proxy.
#### ** Chinese **

Spring 建议你只用 `@Cache*` 注解具体类（和具体类的方法），而不是用接口注解。你当然可以将 `@Cache*` 注解放在接口（或接口方法）上，但如果你使用基于接口的代理，这只在你的预期中起作用。Java 注释没有从接口继承的事实意味着，如果您使用基于类的代理（`proxy-target-class="true"`）或基于编织的方面（`mode="aspectj"`），缓存设置不会被代理和编织基础架构识别，并且对象不会被缓存代理包裹。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

In proxy mode (the default), only external method calls coming in through the proxy are intercepted. This means that self-invocation (in effect, a method within the target object that calls another method of the target object) does not lead to actual caching at runtime even if the invoked method is marked with `@Cacheable`. Consider using the `aspectj` mode in this case. Also, the proxy must be fully initialized to provide the expected behavior, so you should not rely on this feature in your initialization code (that is, `@PostConstruct`).
#### ** Chinese **

在代理模式下（默认情况下），只有通过代理进来的外部方法调用才会被拦截。这意味着，即使被调用的方法被标记为`@Cacheable`，在运行时，自调用（实际上，目标对象内的方法调用目标对象的另一个方法）也不会导致实际的缓存。在这种情况下，考虑使用`aspectj`模式。另外，代理必须完全初始化才能提供预期的行为，所以在初始化代码中不应该依赖这个特性（即`@PostConstruct`）。

<!-- tabs:end -->


### **8.2.7. Using Custom Annotations** 

<!-- tabs:start -->

#### ** English **

Custom annotation and AspectJ
#### ** Chinese **

自定义注释和AspectJ

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

This feature works only with the proxy-based approach but can be enabled with a bit of extra effort by using AspectJ.
#### ** Chinese **

此功能仅在基于代理的方法中有效，但可以通过使用AspectJ来启用。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The `spring-aspects` module defines an aspect for the standard annotations only. If you have defined your own annotations, you also need to define an aspect for those. Check `AnnotationCacheAspect` for an example.
#### ** Chinese **

`spring-aspects`模块仅为标准注释定义了一个方面。如果你定义了自己的注释，你也需要为这些注释定义一个方面。请查看`AnnotationCacheAspect`的例子。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The caching abstraction lets you use your own annotations to identify what method triggers cache population or eviction. This is quite handy as a template mechanism, as it eliminates the need to duplicate cache annotation declarations, which is especially useful if the key or condition are specified or if the foreign imports (`org.springframework`) are not allowed in your code base. Similarly to the rest of the [stereotype](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-stereotype-annotations) annotations, you can use `@Cacheable`, `@CachePut`, `@CacheEvict`, and `@CacheConfig` as [meta-annotations](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-meta-annotations) (that is, annotations that can annotate other annotations). In the following example, we replace a common `@Cacheable` declaration with our own custom annotation:
#### ** Chinese **

缓存抽象让你可以使用自己的注释来识别什么方法触发缓存人口或驱逐。这作为模板机制相当方便，因为它省去了重复的缓存注释声明，如果指定了key或条件，或者在你的代码库中不允许使用国外的导入(`org.springframework`)，这一点特别有用。类似于其他的[stereotype](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-stereotype-annotations)注释，你可以使用`@Cacheable`、`@CachePut`、`@CacheEvict`和`@CacheConfig`作为[meta-annotations](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-meta-annotations)（也就是可以注释其他注释的注释）。在下面的例子中，我们用自己的自定义注释替换了一个常用的`@Cacheable`声明。

<!-- tabs:end -->


```java
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.METHOD})
@Cacheable(cacheNames="books", key="#isbn")
public @interface SlowService {
}
```

<!-- tabs:start -->

#### ** English **

In the preceding example, we have defined our own `SlowService` annotation, which itself is annotated with `@Cacheable`. Now we can replace the following code:
#### ** Chinese **

在前面的例子中，我们已经定义了自己的`SlowService`注释，它本身就被注释为`@Cacheable`。现在，我们可以替换下面的代码。

<!-- tabs:end -->


```java
@Cacheable(cacheNames="books", key="#isbn")
public Book findBook(ISBN isbn, boolean checkWarehouse, boolean includeUsed)
```

<!-- tabs:start -->

#### ** English **

The following example shows the custom annotation with which we can replace the preceding code:
#### ** Chinese **

下面的例子显示了我们可以用它来替换前面的代码的自定义注释。

<!-- tabs:end -->


```java
@SlowService
public Book findBook(ISBN isbn, boolean checkWarehouse, boolean includeUsed)
```

<!-- tabs:start -->

#### ** English **

Even though `@SlowService` is not a Spring annotation, the container automatically picks up its declaration at runtime and understands its meaning. Note that, as mentioned [earlier](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#cache-annotation-enable), annotation-driven behavior needs to be enabled.
#### ** Chinese **

即使`@SlowService`不是一个Spring注释，容器也会在运行时自动拾取其声明并理解其含义。注意，正如前面提到的[https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#cache-annotation-enable]，需要启用注解驱动行为。

<!-- tabs:end -->


### **8.3. JCache (JSR-107) Annotations** 

<!-- tabs:start -->

#### ** English **

Since version 4.1, Spring’s caching abstraction fully supports the JCache standard annotations: `@CacheResult`, `@CachePut`, `@CacheRemove`, and `@CacheRemoveAll` as well as the `@CacheDefaults`, `@CacheKey`, and `@CacheValue` companions. You can use these annotations even without migrating your cache store to JSR-107. The internal implementation uses Spring’s caching abstraction and provides default `CacheResolver` and `KeyGenerator` implementations that are compliant with the specification. In other words, if you are already using Spring’s caching abstraction, you can switch to these standard annotations without changing your cache storage (or configuration, for that matter).
#### ** Chinese **

从4.1版本开始，Spring的缓存抽象完全支持JCache标准注释。 `@CacheResult`、`@CachePut`、`@CacheRemove`和`@CacheRemoveAll`，以及`@CacheDefaults`、`@CacheKey`和`@CacheValue`的同伴。即使没有将缓存存储迁移到JSR-107，你也可以使用这些注释。内部实现使用Spring的缓存抽象，并提供了符合规范的默认`CacheResolver`和`KeyGenerator`实现。换句话说，如果你已经在使用Spring的缓存抽象，你可以在不改变缓存存储（或配置的情况下）的情况下切换到这些标准注释。

<!-- tabs:end -->


### **8.3.1. Feature Summary** 

<!-- tabs:start -->

#### ** English **

For those who are familiar with Spring’s caching annotations, the following table describes the main differences between the Spring annotations and the JSR-107 counterpart:
#### ** Chinese **

对于那些熟悉Spring的缓存注释的人来说，下面的表格描述了Spring注释和JSR-107对应的JSR-107之间的主要区别。

<!-- tabs:end -->


Spring | JSR-107 | Remark 
-|-|-
@Cacheable | @CacheResult | Fairly similar. @CacheResult can cache specific exceptions and force the execution of the method regardless of the content of the cache. 
@CachePut | @CachePut | While Spring updates the cache with the result of the method invocation, JCache requires that it be passed it as an argument that is annotated with @CacheValue. Due to this difference, JCache allows updating the cache before or after the actual method invocation. 
@CacheEvict | @CacheRemove | Fairly similar. @CacheRemove supports conditional eviction when the method invocation results in an exception. 
@CacheEvict(allEntries=true) | @CacheRemoveAll | See @CacheRemove. 
@CacheConfig | @CacheDefaults | Lets you configure the same concepts, in a similar fashion. 


<!-- tabs:start -->

#### ** English **

JCache has the notion of `javax.cache.annotation.CacheResolver`, which is identical to the Spring’s `CacheResolver` interface, except that JCache supports only a single cache. By default, a simple implementation retrieves the cache to use based on the name declared on the annotation. It should be noted that, if no cache name is specified on the annotation, a default is automatically generated. See the javadoc of `@CacheResult#cacheName()` for more information.
#### ** Chinese **

JCache有`javax.cache.annotation.CacheResolver`的概念，它与Spring的`CacheResolver`接口相同，只是JCache只支持单个缓存。默认情况下，一个简单的实现会根据注解上声明的名称来检索要使用的缓存。需要注意的是，如果在注解上没有指定缓存名称，会自动生成一个默认值。有关更多信息，请参阅 `@CacheResult#cacheName()`的 javadoc。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

`CacheResolver` instances are retrieved by a `CacheResolverFactory`. It is possible to customize the factory for each cache operation, as the following example shows:
#### ** Chinese **

`CacheResolver`实例通过`CacheResolverFactory`来检索。可以为每个缓存操作自定义工厂，如下面的例子所示。

<!-- tabs:end -->


```java
@CacheResult(cacheNames="books", cacheResolverFactory=MyCacheResolverFactory.class) (1)
public Book findBook(ISBN isbn)
```

<!-- tabs:start -->

#### ** English **

(1)Customizing the factory for this operation.
#### ** Chinese **

(1)定制工厂进行此操作。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

For all referenced classes, Spring tries to locate a bean with the given type. If more than one match exists, a new instance is created and can use the regular bean lifecycle callbacks, such as dependency injection.
#### ** Chinese **

对于所有被引用的类，Spring会尝试定位一个具有给定类型的Bean。如果存在一个以上的匹配，就会创建一个新的实例，并可以使用常规的bean生命周期回调，如依赖注入等。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Keys are generated by a `javax.cache.annotation.CacheKeyGenerator` that serves the same purpose as Spring’s `KeyGenerator`. By default, all method arguments are taken into account, unless at least one parameter is annotated with `@CacheKey`. This is similar to Spring’s [custom key generation declaration](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#cache-annotations-cacheable-key). For instance, the following are identical operations, one using Spring’s abstraction and the other using JCache:
#### ** Chinese **

密钥由 `javax.cache.annotation.CacheKeyGenerator`生成，其作用与Spring的`KeyGenerator`相同。默认情况下，所有的方法参数都被考虑在内，除非至少有一个参数被注释为`@CacheKey`。这与Spring的[自定义密钥生成声明](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#cache-annotations-cacheable-key)类似。例如，以下是相同的操作，一个使用Spring的抽象，另一个使用JCache。

<!-- tabs:end -->


```java
@Cacheable(cacheNames="books", key="#isbn")
public Book findBook(ISBN isbn, boolean checkWarehouse, boolean includeUsed)

@CacheResult(cacheName="books")
public Book findBook(@CacheKey ISBN isbn, boolean checkWarehouse, boolean includeUsed)
```

<!-- tabs:start -->

#### ** English **

You can also specify the `CacheKeyResolver` on the operation, similar to how you can specify the `CacheResolverFactory`.
#### ** Chinese **

你也可以在操作上指定`CacheKeyResolver`，类似于指定`CacheResolverFactory`。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

JCache can manage exceptions thrown by annotated methods. This can prevent an update of the cache, but it can also cache the exception as an indicator of the failure instead of calling the method again. Assume that `InvalidIsbnNotFoundException` is thrown if the structure of the ISBN is invalid. This is a permanent failure (no book could ever be retrieved with such a parameter). The following caches the exception so that further calls with the same, invalid, ISBN throw the cached exception directly instead of invoking the method again:
#### ** Chinese **

JCache可以管理被注释方法抛出的异常。这可以防止更新缓存，但它也可以将异常作为失败的指示器缓存起来，而不是再次调用方法。假设`InvalidIsbnNotFoundException`如果ISBN结构无效，则会抛出`InvalidIsbnNotFoundException`。这是一个永久的失败（没有任何一本书可以用这样的参数被检索到）。下面将异常缓存起来，这样进一步调用相同的、无效的ISBN就会直接抛出缓存的异常，而不是再次调用该方法。

<!-- tabs:end -->


```java
@CacheResult(cacheName="books", exceptionCacheName="failures"
            cachedExceptions = InvalidIsbnNotFoundException.class)
public Book findBook(ISBN isbn)
```

### **8.3.2. Enabling JSR-107 Support** 

<!-- tabs:start -->

#### ** English **

You need do nothing specific to enable the JSR-107 support alongside Spring’s declarative annotation support. Both `@EnableCaching` and the `cache:annotation-driven` element automatically enable the JCache support if both the JSR-107 API and the `spring-context-support` module are present in the classpath.
#### ** Chinese **

您不需要做任何特定的事情来启用JSR-107支持和Spring的声明式注释支持。如果在classpath中同时存在JSR-107 API和`spring-context-support`模块，那么`@EnableCaching`和`cache:annotation-driven`元素都会自动启用JCache支持。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Depending on your use case, the choice is basically yours. You can even mix and match services by using the JSR-107 API on some and using Spring’s own annotations on others. However, if these services impact the same caches, you should use a consistent and identical key generation implementation.
#### ** Chinese **

根据你的用例，基本上是由你来选择。你甚至可以通过在一些服务上使用JSR-107 API，在其他服务上使用Spring自己的注释来混合和匹配服务。但是，如果这些服务影响到相同的缓存，你应该使用一致和相同的密钥生成实现。

<!-- tabs:end -->


### **8.4. Declarative XML-based Caching** 

<!-- tabs:start -->

#### ** English **

If annotations are not an option (perhaps due to having no access to the sources or no external code), you can use XML for declarative caching. So, instead of annotating the methods for caching, you can specify the target method and the caching directives externally (similar to the declarative transaction management [advice](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/data-access.html#transaction-declarative-first-example)). The example from the previous section can be translated into the following example:
#### ** Chinese **

如果注释不是一个选项（可能是由于没有访问源码或没有外部代码），你可以使用XML进行声明式缓存。所以，你可以不需要对缓存方法进行注释，而是在外部指定目标方法和缓存指令（类似于声明式事务管理[建议](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/data-access.html#transaction-declarative-first-example)）。上一节中的例子可以翻译成下面的例子。

<!-- tabs:end -->


```xml
<!-- the service we want to make cacheable -->
<bean id="bookService" class="x.y.service.DefaultBookService"/>

<!-- cache definitions -->
<cache:advice id="cacheAdvice" cache-manager="cacheManager">
    <cache:caching cache="books">
        <cache:cacheable method="findBook" key="#isbn"/>
        <cache:cache-evict method="loadBooks" all-entries="true"/>
    </cache:caching>
</cache:advice>

<!-- apply the cacheable behavior to all BookService interfaces -->
<aop:config>
    <aop:advisor advice-ref="cacheAdvice" pointcut="execution(* x.y.BookService.*(..))"/>
</aop:config>

<!-- cache manager definition omitted -->
```

<!-- tabs:start -->

#### ** English **

In the preceding configuration, the `bookService` is made cacheable. The caching semantics to apply are encapsulated in the `cache:advice` definition, which causes the `findBooks` method to be used for putting data into the cache and the `loadBooks` method for evicting data. Both definitions work against the `books` cache.
#### ** Chinese **

在前面的配置中，`bookService`被做为可缓存。要应用的缓存语义被封装在`cache:advice`定义中，它使`findBooks`方法被用于将数据放入缓存，而`loadBooks`方法则用于驱逐数据。这两个定义都对`books`缓存起作用。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The `aop:config` definition applies the cache advice to the appropriate points in the program by using the AspectJ pointcut expression (more information is available in [Aspect Oriented Programming with Spring](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#aop)). In the preceding example, all methods from the `BookService` are considered and the cache advice is applied to them.
#### ** Chinese **

`aop:config`定义通过使用AspectJ的点切点表达式将缓存建议应用到程序中的适当的点上（更多信息请参见[Aspect Oriented Programming with Spring](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#aop)）。在前面的例子中，所有来自`BookService`的方法都会被考虑，并将缓存建议应用到它们。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The declarative XML caching supports all of the annotation-based model, so moving between the two should be fairly easy. Furthermore, both can be used inside the same application. The XML-based approach does not touch the target code. However, it is inherently more verbose. When dealing with classes that have overloaded methods that are targeted for caching, identifying the proper methods does take an extra effort, since the `method` argument is not a good discriminator. In these cases, you can use the AspectJ pointcut to cherry pick the target methods and apply the appropriate caching functionality. However, through XML, it is easier to apply package or group or interface-wide caching (again, due to the AspectJ pointcut) and to create template-like definitions (as we did in the preceding example by defining the target cache through the `cache:definitions` `cache` attribute).
#### ** Chinese **

声明式XML缓存支持所有基于注释的模型，所以在两者之间移动应该是相当容易的。此外，这两种方法都可以在同一个应用程序内部使用。基于XML的方法不触及目标代码。但是，它本身就比较粗略。当处理有重载方法的类时，识别合适的方法确实需要花费额外的精力，因为`method`参数不是一个很好的鉴别器。在这种情况下，你可以使用AspectJ的点切方式来挑选目标方法并应用适当的缓存功能。然而，通过XML，应用包或组或接口范围内的缓存（同样，由于AspectJ点cut），以及创建类似于模板的定义（就像我们在前面的例子中通过`cache:definitions` `cache`属性定义目标缓存一样），会更容易。

<!-- tabs:end -->


### **8.5. Configuring the Cache Storage** 

<!-- tabs:start -->

#### ** English **

The cache abstraction provides several storage integration options. To use them, you need to declare an appropriate `CacheManager` (an entity that controls and manages `Cache` instances and that can be used to retrieve these for storage).
#### ** Chinese **

缓存抽象提供了几个存储集成选项。要使用它们，你需要声明一个适当的`CacheManager`（一个控制和管理`Cache`实例的实体，可以用来检索这些实例用于存储）。

<!-- tabs:end -->


### **8.5.1. JDK** **`ConcurrentMap`** **-based Cache** 

<!-- tabs:start -->

#### ** English **

The JDK-based `Cache` implementation resides under `org.springframework.cache.concurrent` package. It lets you use `ConcurrentHashMap` as a backing `Cache` store. The following example shows how to configure two caches:
#### ** Chinese **

基于JDK的`Cache`实现位于`org.springframework.cache.concurrent`包中。它允许你使用`ConcurrentHashMap`作为支持`Cache`的存储。下面的例子显示了如何配置两个缓存。

<!-- tabs:end -->


```xml
<!-- simple cache manager -->
<bean id="cacheManager" class="org.springframework.cache.support.SimpleCacheManager">
    <property name="caches">
        <set>
            <bean class="org.springframework.cache.concurrent.ConcurrentMapCacheFactoryBean" p:name="default"/>
            <bean class="org.springframework.cache.concurrent.ConcurrentMapCacheFactoryBean" p:name="books"/>
        </set>
    </property>
</bean>
```

<!-- tabs:start -->

#### ** English **

The preceding snippet uses the `SimpleCacheManager` to create a `CacheManager` for the two nested `ConcurrentMapCache` instances named `default` and `books`. Note that the names are configured directly for each cache.
#### ** Chinese **

前面的片段使用`SimpleCacheManager`为两个嵌套的`ConcurrentMapCache`实例创建了一个`CacheManager`，这两个实例的名称分别为`default`和`books`。注意，这些名称是直接为每个缓存配置的。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

As the cache is created by the application, it is bound to its lifecycle, making it suitable for basic use cases, tests, or simple applications. The cache scales well and is very fast, but it does not provide any management, persistence capabilities, or eviction contracts.
#### ** Chinese **

由于缓存是由应用创建的，所以它的生命周期是绑定的，因此适合于基本用例、测试或简单的应用。缓存的扩展性很好，速度非常快，但它不提供任何管理、持久化功能，也不提供驱逐合同。

<!-- tabs:end -->


### **8.5.2. Ehcache-based Cache** 

<!-- tabs:start -->

#### ** English **

Ehcache 3.x is fully JSR-107 compliant and no dedicated support is required for it.
#### ** Chinese **

Ehcache 3.x完全兼容JSR-107，不需要专门的支持。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The Ehcache 2.x implementation is located in the `org.springframework.cache.ehcache` package. Again, to use it, you need to declare the appropriate `CacheManager`. The following example shows how to do so:
#### ** Chinese **

Ehcache 2.x的实现位于`org.springframework.cache.ehcache`包中。同样，要使用它，你需要声明相应的`CacheManager`。下面的例子显示了如何做到这一点。

<!-- tabs:end -->


```xml
<bean id="cacheManager"
        class="org.springframework.cache.ehcache.EhCacheCacheManager" p:cache-manager-ref="ehcache"/>

<!-- EhCache library setup -->
<bean id="ehcache"
        class="org.springframework.cache.ehcache.EhCacheManagerFactoryBean" p:config-location="ehcache.xml"/>
```

<!-- tabs:start -->

#### ** English **

This setup bootstraps the ehcache library inside the Spring IoC (through the `ehcache` bean), which is then wired into the dedicated `CacheManager` implementation. Note that the entire Ehcache-specific configuration is read from `ehcache.xml`.
#### ** Chinese **

此设置将在Spring IoC中引导ehcache库（通过`ehcache` bean），然后将其连接到专用的`CacheManager`实现中。请注意，整个Ehcache专用配置是从`ehcache.xml`中读取的。

<!-- tabs:end -->


### **8.5.3. Caffeine Cache** 

<!-- tabs:start -->

#### ** English **

Caffeine is a Java 8 rewrite of Guava’s cache, and its implementation is located in the `org.springframework.cache.caffeine` package and provides access to several features of Caffeine.
#### ** Chinese **

Caffeine是Java 8对Guava的cache的重写，它的实现位于`org.springframework.cache.caffeine`包中，提供了对Caffeine的几个功能的访问。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following example configures a `CacheManager` that creates the cache on demand:
#### ** Chinese **

下面的示例配置了一个`CacheManager`，可以按需创建缓存。

<!-- tabs:end -->


```xml
<bean id="cacheManager"
        class="org.springframework.cache.caffeine.CaffeineCacheManager"/>
```

<!-- tabs:start -->

#### ** English **

You can also provide the caches to use explicitly. In that case, only those are made available by the manager. The following example shows how to do so:
#### ** Chinese **

你也可以明确提供要使用的缓存。在这种情况下，管理员只提供这些缓存。下面的例子说明了如何做到这一点。

<!-- tabs:end -->


```xml
<bean id="cacheManager" class="org.springframework.cache.caffeine.CaffeineCacheManager">
    <property name="caches">
        <set>
            <value>default</value>
            <value>books</value>
        </set>
    </property>
</bean>
```

<!-- tabs:start -->

#### ** English **

The Caffeine `CacheManager` also supports custom `Caffeine` and `CacheLoader`. See the [Caffeine documentation](https://github.com/ben-manes/caffeine/wiki) for more information about those.
#### ** Chinese **

Caffeine `CacheManager`还支持自定义`Caffeine`和`CacheLoader`。请参阅[Caffeine文档](https://github.com/ben-manes/caffeine/wiki)了解更多信息。

<!-- tabs:end -->


### **8.5.4. GemFire-based Cache** 

<!-- tabs:start -->

#### ** English **

GemFire is a memory-oriented, disk-backed, elastically scalable, continuously available, active (with built-in pattern-based subscription notifications), globally replicated database and provides fully-featured edge caching. For further information on how to use GemFire as a `CacheManager` (and more), see the [Spring Data GemFire reference documentation](https://docs.spring.io/spring-gemfire/docs/current/reference/html/).
#### ** Chinese **

GemFire是一个面向内存、磁盘备份、弹性可扩展、连续可用、活跃（内置基于模式的订阅通知）、全局复制的数据库，并提供了功能齐全的边缘缓存。有关如何将GemFire作为`CacheManager`使用的更多信息，请参阅[Spring Data GemFire参考文档](https://docs.spring.io/spring-gemfire/docs/current/reference/html/)。

<!-- tabs:end -->


### **8.5.5. JSR-107 Cache** 

<!-- tabs:start -->

#### ** English **

Spring’s caching abstraction can also use JSR-107-compliant caches. The JCache implementation is located in the `org.springframework.cache.jcache` package.
#### ** Chinese **

Spring的缓存抽象也可以使用符合JSR-107的缓存。JCache的实现位于`org.springframework.cache.jcache`包中。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Again, to use it, you need to declare the appropriate `CacheManager`. The following example shows how to do so:
#### ** Chinese **

同样，要使用它，你需要声明相应的`CacheManager`。下面的例子说明了如何做到这一点。

<!-- tabs:end -->


```xml
<bean id="cacheManager"
        class="org.springframework.cache.jcache.JCacheCacheManager"
        p:cache-manager-ref="jCacheManager"/>

<!-- JSR-107 cache manager setup  -->
<bean id="jCacheManager" .../>
```

### **8.5.6. Dealing with Caches without a Backing Store** 

<!-- tabs:start -->

#### ** English **

Sometimes, when switching environments or doing testing, you might have cache declarations without having an actual backing cache configured. As this is an invalid configuration, an exception is thrown at runtime, since the caching infrastructure is unable to find a suitable store. In situations like this, rather than removing the cache declarations (which can prove tedious), you can wire in a simple dummy cache that performs no caching — that is, it forces the cached methods to be executed every time. The following example shows how to do so:
#### ** Chinese **

有时，在切换环境或做测试时，可能会有缓存声明而没有配置实际的备份缓存。因为这是一个无效的配置，所以在运行时就会抛出一个异常，因为缓存基础设施无法找到合适的存储空间。在这样的情况下，与其移除缓存声明（这可能会很繁琐），还不如在一个简单的假缓存中加入一个简单的假缓存，它不执行任何缓存，也就是说，它每次都强制执行缓存方法。下面的例子说明了如何做到这一点。

<!-- tabs:end -->


```xml
<bean id="cacheManager" class="org.springframework.cache.support.CompositeCacheManager">
    <property name="cacheManagers">
        <list>
            <ref bean="jdkCache"/>
            <ref bean="gemfireCache"/>
        </list>
    </property>
    <property name="fallbackToNoOpCache" value="true"/>
</bean>
```

<!-- tabs:start -->

#### ** English **

The `CompositeCacheManager` in the preceding chains multiple `CacheManager` instances and, through the `fallbackToNoOpCache` flag, adds a no-op cache for all the definitions not handled by the configured cache managers. That is, every cache definition not found in either `jdkCache` or `gemfireCache` (configured earlier in the example) is handled by the no-op cache, which does not store any information, causing the target method to be executed every time.
#### ** Chinese **

前面的`CompositeCacheManager`中的`CompositeCacheManager`将多个`CacheManager`实例串联起来，并通过`fallbackToNoOpCache`标志，为所有未被配置的缓存管理器处理的定义添加一个no-op缓存。也就是说，在`jdkCache`或`gemfireCache`（在前面的例子中配置）中没有找到的每一个缓存定义都会被no-op缓存处理，而no-op缓存不存储任何信息，导致目标方法每次都会被执行。

<!-- tabs:end -->


### **8.6. Plugging-in Different Back-end Caches** 

<!-- tabs:start -->

#### ** English **

Clearly, there are plenty of caching products out there that you can use as a backing store. To plug them in, you need to provide a `CacheManager` and a `Cache` implementation, since, unfortunately, there is no available standard that we can use instead. This may sound harder than it is, since, in practice, the classes tend to be simple [adapters](https://en.wikipedia.org/wiki/Adapter_pattern) that map the caching abstraction framework on top of the storage API, as the `ehcache` classes do. Most `CacheManager` classes can use the classes in the `org.springframework.cache.support` package (such as `AbstractCacheManager` which takes care of the boiler-plate code, leaving only the actual mapping to be completed). We hope that, in time, the libraries that provide integration with Spring can fill in this small configuration gap.
#### ** Chinese **

显然，外面有很多的缓存产品可以作为后备库使用。要将它们插入，你需要提供一个`CacheManager`和`Cache`实现，因为不幸的是，没有可用的标准来代替我们使用。这听起来可能比实际情况要难，因为实际上，这些类往往是简单的[适配器](https://en.wikipedia.org/wiki/Adapter_pattern)，它们将缓存抽象框架映射到存储API之上，就像`ehcache`类一样。大多数`CacheManager`类可以使用`org.springframework.cache.support`包中的类（如`AbstractCacheManager`，它负责处理锅炉板代码，只留下实际的映射）。我们希望，假以时日，提供与Spring集成的库能够填补这个小小的配置空白。

<!-- tabs:end -->


### **8.7. How can I Set the TTL/TTI/Eviction policy/XXX feature?** 

<!-- tabs:start -->

#### ** English **

Directly through your cache provider. The cache abstraction is an abstraction, not a cache implementation. The solution you use might support various data policies and different topologies that other solutions do not support (for example, the JDK `ConcurrentHashMap` — exposing that in the cache abstraction would be useless because there would no backing support). Such functionality should be controlled directly through the backing cache (when configuring it) or through its native API.
#### ** Chinese **

直接通过你的缓存提供者来实现。缓存抽象是一个抽象，不是缓存实现。你使用的解决方案可能支持其他解决方案不支持的各种数据策略和不同的拓扑结构（例如，JDK `ConcurrentHashMap`--在缓存抽象中暴露出来是没有用的，因为没有备份支持）。这种功能应该直接通过备份缓存（配置时）或通过它的原生API来控制。

<!-- tabs:end -->



[下一章](Spring-Framework-5.2.6.RELEASE/Integration/9.%20Appendix.md)


[回目录](Spring-Framework-5.2.6.RELEASE/summary.md)

[回首页](/README)
