# 7. Task Execution and Scheduling

<!-- tabs:start -->

#### ** English **

The Spring Framework provides abstractions for the asynchronous execution and scheduling of tasks with the `TaskExecutor` and `TaskScheduler` interfaces, respectively. Spring also features implementations of those interfaces that support thread pools or delegation to CommonJ within an application server environment. Ultimately, the use of these implementations behind the common interfaces abstracts away the differences between Java SE 5, Java SE 6, and Java EE environments.
#### ** Chinese **

Spring框架分别通过`TaskExecutor`和`TaskScheduler`接口为任务的异步执行和调度提供了抽象。Spring还提供了这些接口的实现，这些接口支持线程池或在应用服务器环境中向CommonJ授权。最终，在通用接口后面使用这些实现，抽象出了Java SE 5、Java SE 6和Java EE环境之间的差异。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Spring also features integration classes to support scheduling with the `Timer` (part of the JDK since 1.3) and the Quartz Scheduler ( [https://www.quartz-scheduler.org/](https://www.quartz-scheduler.org/)). You can set up both of those schedulers by using a `FactoryBean` with optional references to `Timer` or `Trigger` instances, respectively. Furthermore, a convenience class for both the Quartz Scheduler and the `Timer` is available that lets you invoke a method of an existing target object (analogous to the normal `MethodInvokingFactoryBean` operation).
#### ** Chinese **

Spring还提供了集成类来支持与`Timer`（自1.3版本以来的JDK的一部分）和Quartz Scheduler（[[https://www.quartz-scheduler.org/](https://www.quartz-scheduler.org/)）的调度。你可以通过使用`FactoryBean`来设置这两个调度器，并分别对`Timer`或`Trigger`实例进行可选的引用。此外，Quartz Scheduler和`Timer`都有一个方便类，可以让你调用一个现有目标对象的方法（类似于普通的`MethodInvokingFactoryBean`操作）。

<!-- tabs:end -->


### **7.1. The Spring** **`TaskExecutor`** ** Abstraction** 

<!-- tabs:start -->

#### ** English **

Executors are the JDK name for the concept of thread pools. The “executor” naming is due to the fact that there is no guarantee that the underlying implementation is actually a pool. An executor may be single-threaded or even synchronous. Spring’s abstraction hides implementation details between the Java SE and Java EE environments.
#### ** Chinese **

执行者是JDK对线程池概念的命名。之所以用 执行器 命名，是因为不能保证底层实现实际上是一个池。一个执行器可能是单线程的，甚至是同步的。Spring的抽象隐藏了Java SE和Java EE环境中的实现细节。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Spring’s `TaskExecutor` interface is identical to the `java.util.concurrent.Executor` interface. In fact, originally, its primary reason for existence was to abstract away the need for Java 5 when using thread pools. The interface has a single method (`execute(Runnable task)`) that accepts a task for execution based on the semantics and configuration of the thread pool.
#### ** Chinese **

Spring的`TaskExecutor`接口与`java.util.concurrent.Executor`接口相同。事实上，最初，它存在的主要原因是为了在使用线程池时抽象出Java 5的需要。该接口有一个单一的方法(`execute(Runnable task)`)，它根据线程池的语义和配置接受一个任务执行。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The `TaskExecutor` was originally created to give other Spring components an abstraction for thread pooling where needed. Components such as the `ApplicationEventMulticaster`, JMS’s `AbstractMessageListenerContainer`, and Quartz integration all use the `TaskExecutor` abstraction to pool threads. However, if your beans need thread pooling behavior, you can also use this abstraction for your own needs.
#### ** Chinese **

`TaskExecutor`最初是为了在需要时为其他Spring组件提供线程池的抽象。诸如 `ApplicationEventMulticaster`、JMS的`AbstractMessageListenerContainer`和Quartz集成等组件都使用`TaskExecutor`抽象来池化线程。但是，如果你的Bean需要线程池行为，你也可以根据自己的需要使用这个抽象。

<!-- tabs:end -->


### **7.1.1.** **`TaskExecutor`** ** Types** 

<!-- tabs:start -->

#### ** English **

Spring includes a number of pre-built implementations of `TaskExecutor`. In all likelihood, you should never need to implement your own. The variants that Spring provides are as follows:
#### ** Chinese **

Spring包含了许多预构建的`TaskExecutor`的实现。在所有的可能性中，你应该永远不需要自己实现。Spring 提供的变体如下。

<!-- tabs:end -->


### **7.1.2. Using a** **`TaskExecutor`** 

<!-- tabs:start -->

#### ** English **

Spring’s `TaskExecutor` implementations are used as simple JavaBeans. In the following example, we define a bean that uses the `ThreadPoolTaskExecutor` to asynchronously print out a set of messages:
#### ** Chinese **

Spring的`TaskExecutor`实现作为简单的JavaBeans使用。在下面的例子中，我们定义了一个使用`ThreadPoolTaskExecutor`来异步打印出一组消息的bean。

<!-- tabs:end -->


```java
import org.springframework.core.task.TaskExecutor;

public class TaskExecutorExample {

    private class MessagePrinterTask implements Runnable {

        private String message;

        public MessagePrinterTask(String message) {
            this.message = message;
        }

        public void run() {
            System.out.println(message);
        }
    }

    private TaskExecutor taskExecutor;

    public TaskExecutorExample(TaskExecutor taskExecutor) {
        this.taskExecutor = taskExecutor;
    }

    public void printMessages() {
        for(int i = 0; i < 25; i++) {
            taskExecutor.execute(new MessagePrinterTask("Message" + i));
        }
    }
}
```

<!-- tabs:start -->

#### ** English **

As you can see, rather than retrieving a thread from the pool and executing it yourself, you add your `Runnable` to the queue. Then the `TaskExecutor` uses its internal rules to decide when the task gets executed.
#### ** Chinese **

正如你所看到的，你不是从池中检索线程并自己执行，而是将`Runnable`添加到队列中。然后`TaskExecutor`使用其内部规则来决定任务何时执行。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

To configure the rules that the `TaskExecutor` uses, we expose simple bean properties:
#### ** Chinese **

为了配置`TaskExecutor`所使用的规则，我们公开了简单的Bean属性。

<!-- tabs:end -->


```xml
<bean id="taskExecutor" class="org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor">
    <property name="corePoolSize" value="5"/>
    <property name="maxPoolSize" value="10"/>
    <property name="queueCapacity" value="25"/>
</bean>

<bean id="taskExecutorExample" class="TaskExecutorExample">
    <constructor-arg ref="taskExecutor"/>
</bean>
```

### **7.2. The Spring** **`TaskScheduler`** ** Abstraction** 

<!-- tabs:start -->

#### ** English **

In addition to the `TaskExecutor` abstraction, Spring 3.0 introduced a `TaskScheduler` with a variety of methods for scheduling tasks to run at some point in the future. The following listing shows the `TaskScheduler` interface definition:
#### ** Chinese **

除了`TaskExecutor`抽象之外，Spring 3.0还引入了一个`TaskScheduler`接口，该接口具有多种方法来调度任务在未来某个时间点运行。下面的列表显示了`TaskScheduler`接口的定义。

<!-- tabs:end -->


```java
public interface TaskScheduler {

    ScheduledFuture schedule(Runnable task, Trigger trigger);

    ScheduledFuture schedule(Runnable task, Instant startTime);

    ScheduledFuture schedule(Runnable task, Date startTime);

    ScheduledFuture scheduleAtFixedRate(Runnable task, Instant startTime, Duration period);

    ScheduledFuture scheduleAtFixedRate(Runnable task, Date startTime, long period);

    ScheduledFuture scheduleAtFixedRate(Runnable task, Duration period);

    ScheduledFuture scheduleAtFixedRate(Runnable task, long period);

    ScheduledFuture scheduleWithFixedDelay(Runnable task, Instant startTime, Duration delay);

    ScheduledFuture scheduleWithFixedDelay(Runnable task, Date startTime, long delay);

    ScheduledFuture scheduleWithFixedDelay(Runnable task, Duration delay);

    ScheduledFuture scheduleWithFixedDelay(Runnable task, long delay);
}
```

<!-- tabs:start -->

#### ** English **

The simplest method is the one named `schedule` that takes only a `Runnable` and a `Date`. That causes the task to run once after the specified time. All of the other methods are capable of scheduling tasks to run repeatedly. The fixed-rate and fixed-delay methods are for simple, periodic execution, but the method that accepts a `Trigger` is much more flexible.
#### ** Chinese **

最简单的方法是名为`schedule`的方法，它只需要一个`Runnable`和一个`Date`。这将导致任务在指定的时间后运行一次。所有其他的方法都能够安排任务重复运行。固定速率和固定延迟方法是用于简单的、周期性的执行，但接受`Trigger`的方法要灵活得多。

<!-- tabs:end -->


### **7.2.1.** **`Trigger`** ** Interface** 

<!-- tabs:start -->

#### ** English **

The `Trigger` interface is essentially inspired by JSR-236 which, as of Spring 3.0, was not yet officially implemented. The basic idea of the `Trigger` is that execution times may be determined based on past execution outcomes or even arbitrary conditions. If these determinations do take into account the outcome of the preceding execution, that information is available within a `TriggerContext`. The `Trigger` interface itself is quite simple, as the following listing shows:
#### ** Chinese **

`Trigger`接口基本上是受JSR-236的启发，截至Spring 3.0时，该接口还没有正式实现。`Trigger`的基本思想是，执行时间可以根据过去的执行结果甚至是任意条件来确定。如果这些判断确实考虑到了前一个执行结果，那么这些信息可以在`TriggerContext`中获得。`Trigger`接口本身非常简单，如下表所示。

<!-- tabs:end -->


```java
public interface Trigger {

    Date nextExecutionTime(TriggerContext triggerContext);
}
```

<!-- tabs:start -->

#### ** English **

The `TriggerContext` is the most important part. It encapsulates all of the relevant data and is open for extension in the future, if necessary. The `TriggerContext` is an interface (a `SimpleTriggerContext` implementation is used by default). The following listing shows the available methods for `Trigger` implementations.
#### ** Chinese **

`TriggerContext`是最重要的部分。它封装了所有的相关数据，如果有必要，可以在未来进行扩展。`TriggerContext`是一个接口（默认使用`SimpleTriggerContext`实现）。下面的列表显示了`Trigger`实现的可用方法。

<!-- tabs:end -->


```java
public interface TriggerContext {

    Date lastScheduledExecutionTime();

    Date lastActualExecutionTime();

    Date lastCompletionTime();
}
```

### **7.2.2.** **`Trigger`** ** Implementations** 

<!-- tabs:start -->

#### ** English **

Spring provides two implementations of the `Trigger` interface. The most interesting one is the `CronTrigger`. It enables the scheduling of tasks based on cron expressions. For example, the following task is scheduled to run 15 minutes past each hour but only during the 9-to-5 “business hours” on weekdays:
#### ** Chinese **

Spring提供了两个`Trigger`接口的实现。其中最有趣的是`CronTrigger`。它可以根据cron表达式来调度任务。例如，下面的任务被安排在每个小时过了15分钟后运行，但只在工作日的9到5 营业时间 内运行。

<!-- tabs:end -->


```java
scheduler.schedule(task, new CronTrigger("0 15 9-17 * * MON-FRI"));
```

<!-- tabs:start -->

#### ** English **

The other implementation is a `PeriodicTrigger` that accepts a fixed period, an optional initial delay value, and a boolean to indicate whether the period should be interpreted as a fixed-rate or a fixed-delay. Since the `TaskScheduler` interface already defines methods for scheduling tasks at a fixed rate or with a fixed delay, those methods should be used directly whenever possible. The value of the `PeriodicTrigger` implementation is that you can use it within components that rely on the `Trigger` abstraction. For example, it may be convenient to allow periodic triggers, cron-based triggers, and even custom trigger implementations to be used interchangeably. Such a component could take advantage of dependency injection so that you can configure such `Triggers` externally and, therefore, easily modify or extend them.
#### ** Chinese **

另一种实现是`PeriodicTrigger`，它接受一个固定的周期、一个可选的初始延迟值，以及一个布尔值来指示周期应该被解释为固定速率还是固定延迟。由于`TaskScheduler`接口已经定义了以固定速率或固定延迟来调度任务的方法，所以应该尽可能直接使用这些方法。`PeriodicTrigger`实现的价值在于，您可以在依赖`Trigger`抽象的组件中使用它。例如，允许定期触发器、基于cron的触发器，甚至是自定义触发器实现可以互换使用，这可能会很方便。这样的组件可以利用依赖注入的优势，这样你就可以从外部配置这样的`Triggers`，从而可以很容易地修改或扩展它们。

<!-- tabs:end -->


### **7.2.3.** **`TaskScheduler`** ** implementations** 

<!-- tabs:start -->

#### ** English **

As with Spring’s `TaskExecutor` abstraction, the primary benefit of the `TaskScheduler` arrangement is that an application’s scheduling needs are decoupled from the deployment environment. This abstraction level is particularly relevant when deploying to an application server environment where threads should not be created directly by the application itself. For such scenarios, Spring provides a `TimerManagerTaskScheduler` that delegates to a CommonJ `TimerManager` on WebLogic or WebSphere as well as a more recent `DefaultManagedTaskScheduler` that delegates to a JSR-236 `ManagedScheduledExecutorService` in a Java EE 7+ environment. Both are typically configured with a JNDI lookup.
#### ** Chinese **

与 Spring 的 `TaskExecutor`抽象一样，`TaskScheduler`安排的主要好处是，应用程序的调度需求与部署环境脱钩。当部署到应用程序服务器环境中，线程不应该直接由应用程序本身创建时，这种抽象层次就显得尤为重要。对于这些场景，Spring 提供了一个 `TimerManagerTaskScheduler`，它可以委托给 WebLogic 或 WebSphere 上的 CommonJ `TimerManager`，以及一个更近期的 `DefaultManagedTaskScheduler`，它可以委托给 Java EE 7+ 环境中的 JSR-236 `ManagedScheduledExecutorService`。两者通常都是通过JNDI查询来配置的。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Whenever external thread management is not a requirement, a simpler alternative is a local `ScheduledExecutorService` setup within the application, which can be adapted through Spring’s `ConcurrentTaskScheduler`. As a convenience, Spring also provides a `ThreadPoolTaskScheduler`, which internally delegates to a `ScheduledExecutorService` to provide common bean-style configuration along the lines of `ThreadPoolTaskExecutor`. These variants work perfectly fine for locally embedded thread pool setups in lenient application server environments, as well — in particular on Tomcat and Jetty.
#### ** Chinese **

当不需要外部线程管理时，一个更简单的选择是在应用程序中设置本地的 `ScheduledExecutorService`，可以通过Spring的`ConcurrentTaskScheduler`进行调整。为了方便起见，Spring还提供了一个`ThreadPoolTaskScheduler`，它在内部委托给一个`ScheduledExecutorService`来提供类似于`ThreadPoolTaskExecutor`的通用Bean风格的配置。这些变体对于在宽松的应用服务器环境中的本地嵌入式线程池设置也能很好地工作--尤其是在Tomcat和Jetty上。

<!-- tabs:end -->


### **7.3. Annotation Support for Scheduling and Asynchronous Execution** 

<!-- tabs:start -->

#### ** English **

Spring provides annotation support for both task scheduling and asynchronous method execution.
#### ** Chinese **

Spring提供了对任务调度和异步方法执行的注释支持。

<!-- tabs:end -->


### **7.3.1. Enable Scheduling Annotations** 

<!-- tabs:start -->

#### ** English **

To enable support for `@Scheduled` and `@Async` annotations, you can add `@EnableScheduling` and `@EnableAsync` to one of your `@Configuration` classes, as the following example shows:
#### ** Chinese **

要启用对 `@Scheduled` 和 `@Async` 注释的支持，您可以将 `@EnableScheduling` 和 `@EnableAsync` 添加到您的 `@Configuration` 类中，如下示例所示。

<!-- tabs:end -->


```java
@Configuration
@EnableAsync
@EnableScheduling
public class AppConfig {
}
```

<!-- tabs:start -->

#### ** English **

You can pick and choose the relevant annotations for your application. For example, if you need only support for `@Scheduled`, you can omit `@EnableAsync`. For more fine-grained control, you can additionally implement the `SchedulingConfigurer` interface, the `AsyncConfigurer` interface, or both. See the [`SchedulingConfigurer`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/scheduling/annotation/SchedulingConfigurer.html) and [`AsyncConfigurer`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/scheduling/annotation/AsyncConfigurer.html) javadoc for full details.
#### ** Chinese **

你可以为你的应用程序选择相关的注释。例如，如果你只需要支持`@Scheduled`，你可以省略`@EnableAsync`。为了实现更精细的控制，你可以另外实现`SchedulingConfigurer`接口、`AsyncConfigurer`接口，或者两者兼而有之。请参阅 [`SchedulingConfigurer`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/scheduling/annotation/SchedulingConfigurer.html)和 [`AsyncConfigurer`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/scheduling/annotation/AsyncConfigurer.html) javadoc 以了解更多详情。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

If you prefer XML configuration, you can use the `<task:annotation-driven>` element, as the following example shows:
#### ** Chinese **

如果你喜欢XML配置，可以使用`<task:annotation-driven>`元素，如下例所示。

<!-- tabs:end -->


```xml
<task:annotation-driven executor="myExecutor" scheduler="myScheduler"/>
<task:executor id="myExecutor" pool-size="5"/>
<task:scheduler id="myScheduler" pool-size="10"/>
```

<!-- tabs:start -->

#### ** English **

Note that, with the preceding XML, an executor reference is provided for handling those tasks that correspond to methods with the `@Async` annotation, and the scheduler reference is provided for managing those methods annotated with `@Scheduled`.
#### ** Chinese **

请注意，在前面的 XML 中，提供了一个执行者引用，用于处理与 `@Async` 注解的方法相对应的任务，而调度器引用则用于管理那些被 `@Scheduled` 注解的方法。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The default advice mode for processing `@Async` annotations is `proxy` which allows for interception of calls through the proxy only. Local calls within the same class cannot get intercepted that way. For a more advanced mode of interception, consider switching to `aspectj` mode in combination with compile-time or load-time weaving.
#### ** Chinese **

处理`@Async`注释的默认建议模式是`proxy`，它只允许通过代理拦截调用。同一类中的本地调用不能以这种方式被拦截。对于更高级的拦截模式，可以考虑切换到`aspectj`模式，结合编译时或加载时编织。

<!-- tabs:end -->


### **7.3.2. The** **`@Scheduled`** ** annotation** 

<!-- tabs:start -->

#### ** English **

You can add the `@Scheduled` annotation to a method, along with trigger metadata. For example, the following method is invoked every five seconds with a fixed delay, meaning that the period is measured from the completion time of each preceding invocation:
#### ** Chinese **

你可以将 `@Scheduled` 注释和触发器元数据一起添加到方法中。例如，下面的方法每隔五秒就会被调用一次，并且有一个固定的延迟，这意味着这个时间段是从之前每次调用的完成时间开始计算的。

<!-- tabs:end -->


```java
@Scheduled(fixedDelay=5000)
public void doSomething() {
    // something that should execute periodically
}
```

<!-- tabs:start -->

#### ** English **

If you need a fixed-rate execution, you can change the property name specified within the annotation. The following method is invoked every five seconds (measured between the successive start times of each invocation):
#### ** Chinese **

如果需要固定速率的执行，可以改变注释中指定的属性名称。下面的方法每隔五秒调用一次（在每次调用的连续开始时间之间测量）。

<!-- tabs:end -->


```java
@Scheduled(fixedRate=5000)
public void doSomething() {
    // something that should execute periodically
}
```

<!-- tabs:start -->

#### ** English **

For fixed-delay and fixed-rate tasks, you can specify an initial delay by indicating the number of milliseconds to wait before the first execution of the method, as the following `fixedRate` example shows:
#### ** Chinese **

对于固定延时和固定速率任务，可以通过指定在第一次执行方法之前要等待的毫秒数来指定初始延时，如下`fixedRate`示例所示。

<!-- tabs:end -->


```java
@Scheduled(initialDelay=1000, fixedRate=5000)
public void doSomething() {
    // something that should execute periodically
}
```

<!-- tabs:start -->

#### ** English **

If simple periodic scheduling is not expressive enough, you can provide a cron expression. For example, the following executes only on weekdays:
#### ** Chinese **

如果简单的周期性调度不够表达，可以提供一个cron表达式。例如，下面这个表达式只在工作日执行。

<!-- tabs:end -->


```java
@Scheduled(cron="*/5 * * * * MON-FRI")
public void doSomething() {
    // something that should execute on weekdays only
}
```

<!-- tabs:start -->

#### ** English **

You can also use the `zone` attribute to specify the time zone in which the cron expression is resolved.
#### ** Chinese **

您还可以使用`zone`属性来指定cron表达式解析的时区。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Notice that the methods to be scheduled must have void returns and must not expect any arguments. If the method needs to interact with other objects from the application context, those would typically have been provided through dependency injection.
#### ** Chinese **

注意，要预定化的方法必须有void返回，并且不能期望任何参数。如果方法需要与应用程序上下文中的其他对象交互，这些对象一般都是通过依赖注入来提供的。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

As of Spring Framework 4.3, `@Scheduled` methods are supported on beans of any scope.
#### ** Chinese **

从Spring Framework 4.3开始，`@Scheduled`方法可以在任何作用域的Bean上支持。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Make sure that you are not initializing multiple instances of the same `@Scheduled` annotation class at runtime, unless you do want to schedule callbacks to each such instance. Related to this, make sure that you do not use `@Configurable` on bean classes that are annotated with `@Scheduled` and registered as regular Spring beans with the container. Otherwise, you would get double initialization (once through the container and once through the `@Configurable` aspect), with the consequence of each `@Scheduled` method being invoked twice.
#### ** Chinese **

确保在运行时不要初始化同一个`@Scheduled`注解类的多个实例，除非你想对每个实例进行回调。与此相关的是，确保不要在用 `@Configurable` 注解了 `@Scheduled` 的 Bean 类上使用 `@Configurable`，并在容器中注册为普通的 Spring Bean。否则，你会得到两次初始化（一次通过容器，一次通过`@Configurable`方面），结果是每个`@Scheduled`方法被调用两次。

<!-- tabs:end -->


### **7.3.3. The** **`@Async`** ** annotation** 

<!-- tabs:start -->

#### ** English **

You can provide the `@Async` annotation on a method so that invocation of that method occurs asynchronously. In other words, the caller returns immediately upon invocation, while the actual execution of the method occurs in a task that has been submitted to a Spring `TaskExecutor`. In the simplest case, you can apply the annotation to a method that returns `void`, as the following example shows:
#### ** Chinese **

您可以在方法上提供 `@Async` 注解，以便异步地调用该方法。换句话说，调用者在调用时立即返回，而方法的实际执行则发生在已提交给 Spring `TaskExecutor`的任务中。在最简单的情况下，可以将注释应用到一个返回`void`的方法上，如下例所示。

<!-- tabs:end -->


```java
@Async
void doSomething() {
    // this will be executed asynchronously
}
```

<!-- tabs:start -->

#### ** English **

Unlike the methods annotated with the `@Scheduled` annotation, these methods can expect arguments, because they are invoked in the “normal” way by callers at runtime rather than from a scheduled task being managed by the container. For example, the following code is a legitimate application of the `@Async` annotation:
#### ** Chinese **

与使用 `@Scheduled` 注解的方法不同，这些方法可以期望参数，因为它们在运行时由调用者以 正常 的方式调用，而不是从容器管理的预定任务中调用。例如，下面的代码是 `@Async` 注解的合法应用。

<!-- tabs:end -->


```java
@Async
void doSomething(String s) {
    // this will be executed asynchronously
}
```

<!-- tabs:start -->

#### ** English **

Even methods that return a value can be invoked asynchronously. However, such methods are required to have a `Future`-typed return value. This still provides the benefit of asynchronous execution so that the caller can perform other tasks prior to calling `get()` on that `Future`. The following example shows how to use `@Async` on a method that returns a value:
#### ** Chinese **

即使是返回值的方法也可以异步调用。但是，这些方法必须有一个`Future`类型的返回值。这仍然提供了异步执行的好处，以便调用者在调用`get()`之前可以执行其他任务。下面的例子显示了如何在一个返回值的方法上使用 `@Async`。

<!-- tabs:end -->


```java
@Async
Future<String> returnSomething(int i) {
    // this will be executed asynchronously
}
```

<!-- tabs:start -->

#### ** English **

`@Async` methods may not only declare a regular `java.util.concurrent.Future` return type but also Spring’s `org.springframework.util.concurrent.ListenableFuture` or, as of Spring 4.2, JDK 8’s `java.util.concurrent.CompletableFuture`, for richer interaction with the asynchronous task and for immediate composition with further processing steps.
#### ** Chinese **

`@Async`方法不仅可以声明一个常规的`java.util.concurrent.Future`返回类型，还可以声明Spring的`org.springframework.util.concurrent.ListenableFuture`，或者从Spring 4.2开始，JDK 8的`java.util.concurrent.CompletableFuture`，以实现与异步任务的更丰富的交互，并与进一步的处理步骤进行即时的组合。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can not use `@Async` in conjunction with lifecycle callbacks such as `@PostConstruct`. To asynchronously initialize Spring beans, you currently have to use a separate initializing Spring bean that then invokes the `@Async` annotated method on the target, as the following example shows:
#### ** Chinese **

您不能将 `@Async`与生命周期回调（如 `@PostConstruct`）结合使用。要异步初始化Spring bean，目前必须使用一个单独的初始化Spring bean，然后在目标上调用`@Async`注释的方法，如下例所示。

<!-- tabs:end -->


```java
public class SampleBeanImpl implements SampleBean {

    @Async
    void doSomething() {
        // ...
    }

}

public class SampleBeanInitializer {

    private final SampleBean bean;

    public SampleBeanInitializer(SampleBean bean) {
        this.bean = bean;
    }

    @PostConstruct
    public void initialize() {
        bean.doSomething();
    }

}
```

<!-- tabs:start -->

#### ** English **

There is no direct XML equivalent for `@Async`, since such methods should be designed for asynchronous execution in the first place, not externally re-declared to be asynchronous. However, you can manually set up Spring’s `AsyncExecutionInterceptor` with Spring AOP, in combination with a custom pointcut.
#### ** Chinese **

`@Async`没有直接的XML等价物，因为这样的方法首先应该是为异步执行而设计的，而不是外部重新定义为异步执行。但是，你可以用Spring AOP手动设置Spring的`AsyncExecutionInterceptor`，并结合自定义的点捷径。

<!-- tabs:end -->


### **7.3.4. Executor Qualification with** **`@Async`** 

<!-- tabs:start -->

#### ** English **

By default, when specifying `@Async` on a method, the executor that is used is the one [configured when enabling async support](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#scheduling-enable-annotation-support), i.e. the “annotation-driven” element if you are using XML or your `AsyncConfigurer` implementation, if any. However, you can use the `value` attribute of the `@Async` annotation when you need to indicate that an executor other than the default should be used when executing a given method. The following example shows how to do so:
#### ** Chinese **

默认情况下，当在方法上指定 `@Async`时，所使用的执行器是[启用异步支持时配置的](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#scheduling-enable-annotation-support)，也就是说，如果你使用的是 XML 或你的 `AsyncConfigurer` 实现，则是 注解驱动的 元素。但是，当您需要指示在执行给定方法时使用默认值以外的执行器时，您可以使用 `@Async` 注释的 `value` 属性。下面的例子显示了如何做到这一点。

<!-- tabs:end -->


```java
@Async("otherExecutor")
void doSomething(String s) {
    // this will be executed asynchronously by "otherExecutor"
}
```

<!-- tabs:start -->

#### ** English **

In this case, `"otherExecutor"` can be the name of any `Executor` bean in the Spring container, or it may be the name of a qualifier associated with any `Executor` (for example, as specified with the `<qualifier>` element or Spring’s `@Qualifier` annotation).
#### ** Chinese **

在这种情况下，`"otherExecutor"`可以是Spring容器中任何`Executor` bean的名称，也可以是与任何`Executor`相关联的限定符的名称（例如，用`<qualifier>`元素或Spring的`@Qualifier`注释指定的）。

<!-- tabs:end -->


### **7.3.5. Exception Management with** **`@Async`** 

<!-- tabs:start -->

#### ** English **

When an `@Async` method has a `Future`-typed return value, it is easy to manage an exception that was thrown during the method execution, as this exception is thrown when calling `get` on the `Future` result. With a `void` return type, however, the exception is uncaught and cannot be transmitted. You can provide an `AsyncUncaughtExceptionHandler` to handle such exceptions. The following example shows how to do so:
#### ** Chinese **

当一个`@Async`方法有一个`Future`类型的返回值时，很容易管理在方法执行过程中抛出的异常，因为这个异常是在调用`Future`结果上的`get`时抛出的。但是，对于`void`返回类型，这个异常是无法捕获的，也无法传输。你可以提供一个`AsyncUncaughtExceptionHandler`来处理这样的异常。下面的例子显示了如何做到这一点。

<!-- tabs:end -->


```java
public class MyAsyncUncaughtExceptionHandler implements AsyncUncaughtExceptionHandler {

    @Override
    public void handleUncaughtException(Throwable ex, Method method, Object... params) {
        // handle exception
    }
}
```

<!-- tabs:start -->

#### ** English **

By default, the exception is merely logged. You can define a custom `AsyncUncaughtExceptionHandler` by using `AsyncConfigurer` or the `<task:annotation-driven/>` XML element.
#### ** Chinese **

默认情况下，异常只是被记录下来。您可以通过使用 `AsyncConfigurer`或 `<task:annotation-driven/>` XML 元素定义一个自定义的 `AsyncUncaughtExceptionHandler`。

<!-- tabs:end -->


### **7.4. The** **`task`** ** Namespace** 

<!-- tabs:start -->

#### ** English **

As of version 3.0, Spring includes an XML namespace for configuring `TaskExecutor` and `TaskScheduler` instances. It also provides a convenient way to configure tasks to be scheduled with a trigger.
#### ** Chinese **

从3.0版本开始，Spring包含了一个XML命名空间，用于配置`TaskExecutor`和`TaskScheduler`实例。它还提供了一种方便的方法来配置要用触发器来排程的任务。

<!-- tabs:end -->


### **7.4.1. The 'scheduler' Element** 

<!-- tabs:start -->

#### ** English **

The following element creates a `ThreadPoolTaskScheduler` instance with the specified thread pool size:
#### ** Chinese **

以下元素以指定的线程池大小创建一个`ThreadPoolTaskScheduler`实例。

<!-- tabs:end -->


```xml
<task:scheduler id="scheduler" pool-size="10"/>
```

<!-- tabs:start -->

#### ** English **

The value provided for the `id` attribute is used as the prefix for thread names within the pool. The `scheduler` element is relatively straightforward. If you do not provide a `pool-size` attribute, the default thread pool has only a single thread. There are no other configuration options for the scheduler.
#### ** Chinese **

为`id`属性提供的值被用作池内线程名的前缀。`scheduler`元素相对简单。如果不提供`pool-size`属性，默认线程池只有一个线程。对于调度器没有其他配置选项。

<!-- tabs:end -->


### **7.4.2. The** **`executor`** ** Element** 

<!-- tabs:start -->

#### ** English **

The following creates a `ThreadPoolTaskExecutor` instance:
#### ** Chinese **

下面创建一个`ThreadPoolTaskExecutor`实例。

<!-- tabs:end -->


```xml
<task:executor id="executor" pool-size="10"/>
```

<!-- tabs:start -->

#### ** English **

As with the scheduler shown in the [previous section](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#scheduling-task-namespace-scheduler), the value provided for the `id` attribute is used as the prefix for thread names within the pool. As far as the pool size is concerned, the `executor` element supports more configuration options than the `scheduler` element. For one thing, the thread pool for a `ThreadPoolTaskExecutor` is itself more configurable. Rather than only a single size, an executor’s thread pool can have different values for the core and the max size. If you provide a single value, the executor has a fixed-size thread pool (the core and max sizes are the same). However, the `executor` element’s `pool-size` attribute also accepts a range in the form of `min-max`. The following example sets a minimum value of `5` and a maximum value of `25`:
#### ** Chinese **

与[上一节](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#scheduling-task-namespace-scheduler)所示的调度器一样，为`id`属性提供的值被用作池内线程名称的前缀。至于池的大小，`executor`元素比`scheduler`元素支持更多的配置选项。首先，`ThreadPoolTaskExecutor`的线程池本身就具有更多的可配置性。一个执行器的线程池可以有不同的值，而不是只有一个单一的大小，核心和最大大小可以有不同的值。如果你提供了一个单一的值，那么执行器就有一个固定大小的线程池（core和max大小是一样的）。但是，`executor`元素的`pool-size`属性也可以接受`min-max`形式的范围。下面的示例设置了最小值`5`和最大值`25`。

<!-- tabs:end -->


```xml
<task:executor
        id="executorWithPoolSizeRange"
        pool-size="5-25"
        queue-capacity="100"/>
```

<!-- tabs:start -->

#### ** English **

In the preceding configuration, a `queue-capacity` value has also been provided. The configuration of the thread pool should also be considered in light of the executor’s queue capacity. For the full description of the relationship between pool size and queue capacity, see the documentation for [`ThreadPoolExecutor`](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ThreadPoolExecutor.html). The main idea is that, when a task is submitted, the executor first tries to use a free thread if the number of active threads is currently less than the core size. If the core size has been reached, the task is added to the queue, as long as its capacity has not yet been reached. Only then, if the queue’s capacity has been reached, does the executor create a new thread beyond the core size. If the max size has also been reached, then the executor rejects the task.
#### ** Chinese **

在前面的配置中，还提供了`queue-capacity`值。线程池的配置也应根据执行器的队列容量来考虑。关于线程池大小和队列容量之间的关系的完整描述，请参阅[`ThreadPoolExecutor`](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ThreadPoolExecutor.html)的文档。其主要思想是，当提交任务时，如果当前活动线程数小于核心大小，执行器首先尝试使用一个空闲线程。如果已经达到核心大小，只要任务的容量还没有达到核心大小，就会将任务加入队列中。只有这样，如果队列的容量已经达到了，执行器才会创建一个新的线程，超过核心大小。如果也达到了最大容量，那么执行器就会拒绝这个任务。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

By default, the queue is unbounded, but this is rarely the desired configuration, because it can lead to `OutOfMemoryErrors` if enough tasks are added to that queue while all pool threads are busy. Furthermore, if the queue is unbounded, the max size has no effect at all. Since the executor always tries the queue before creating a new thread beyond the core size, a queue must have a finite capacity for the thread pool to grow beyond the core size (this is why a fixed-size pool is the only sensible case when using an unbounded queue).
#### ** Chinese **

默认情况下，队列是无限制的，但这很少是理想的配置，因为如果在所有的池线程都忙的时候，有足够多的任务被添加到该队列中，就会导致`OutOfMemoryErrors`。此外，如果队列是无限制的，那么最大大小完全没有影响。由于执行器总是在创建一个新的线程超过核心大小之前会先尝试队列，因此队列必须有一个有限的容量，使线程池的增长超过核心大小（这就是为什么在使用无约束队列时，固定大小的线程池是唯一合理的情况）。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Consider the case, as mentioned above, when a task is rejected. By default, when a task is rejected, a thread pool executor throws a `TaskRejectedException`. However, the rejection policy is actually configurable. The exception is thrown when using the default rejection policy, which is the `AbortPolicy` implementation. For applications where some tasks can be skipped under heavy load, you can instead configure either `DiscardPolicy` or `DiscardOldestPolicy`. Another option that works well for applications that need to throttle the submitted tasks under heavy load is the `CallerRunsPolicy`. Instead of throwing an exception or discarding tasks, that policy forces the thread that is calling the submit method to run the task itself. The idea is that such a caller is busy while running that task and not able to submit other tasks immediately. Therefore, it provides a simple way to throttle the incoming load while maintaining the limits of the thread pool and queue. Typically, this allows the executor to “catch up” on the tasks it is handling and thereby frees up some capacity on the queue, in the pool, or both. You can choose any of these options from an enumeration of values available for the `rejection-policy` attribute on the `executor` element.
#### ** Chinese **

考虑一下上面提到的任务被拒绝时的情况。默认情况下，当一个任务被拒绝时，线程池执行器会抛出一个`TaskRejectedException`。但是，拒绝策略实际上是可以配置的。当使用默认的拒绝策略（即`AbortPolicy`实现）时，会抛出异常。对于某些任务可以在重负载下跳过的应用程序，可以配置 `DiscardPolicy`或 `DiscardOldestPolicy`。对于需要在重负载下节流提交任务的应用程序来说，另一个很好用的选项是`CallerRunsPolicy`。该策略不抛出异常或丢弃任务，而是迫使调用提交方法的线程本身运行任务。其想法是，这样的调用者在运行该任务的时候会很忙，无法立即提交其他任务。因此，它提供了一种简单的方法来节流传入的负载，同时保持线程池和队列的限制。通常情况下，这可以让执行器 追赶 它正在处理的任务，从而释放出队列、线程池中的一些容量，或者两者都有。您可以从`executor`元素上的`rejection-policy`属性的可用值枚举中选择这些选项。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following example shows an `executor` element with a number of attributes to specify various behaviors:
#### ** Chinese **

下面的例子显示了一个`executor`元素，该元素有许多属性来指定各种行为。

<!-- tabs:end -->


```xml
<task:executor
        id="executorWithCallerRunsPolicy"
        pool-size="5-25"
        queue-capacity="100"
        rejection-policy="CALLER_RUNS"/>
```

<!-- tabs:start -->

#### ** English **

Finally, the `keep-alive` setting determines the time limit (in seconds) for which threads may remain idle before being terminated. If there are more than the core number of threads currently in the pool, after waiting this amount of time without processing a task, excess threads get terminated. A time value of zero causes excess threads to terminate immediately after executing a task without remaining follow-up work in the task queue. The following example sets the `keep-alive` value to two minutes:
#### ** Chinese **

最后，`keep-alive`设置决定了线程在被终止之前可以保持空闲的时间限制（单位：秒）。如果当前池中的线程数量超过了核心线程的数量，那么在等待这个时间后不处理任务，多余的线程将被终止。时间值为0会导致多余的线程在执行任务后立即终止，任务队列中没有剩余的后续工作。下面的例子将`keep-alive`的值设置为两分钟。

<!-- tabs:end -->


```xml
<task:executor
        id="executorWithKeepAlive"
        pool-size="5-25"
        keep-alive="120"/>
```

### **7.4.3. The 'scheduled-tasks' Element** 

<!-- tabs:start -->

#### ** English **

The most powerful feature of Spring’s task namespace is the support for configuring tasks to be scheduled within a Spring Application Context. This follows an approach similar to other “method-invokers” in Spring, such as that provided by the JMS namespace for configuring message-driven POJOs. Basically, a `ref` attribute can point to any Spring-managed object, and the `method` attribute provides the name of a method to be invoked on that object. The following listing shows a simple example:
#### ** Chinese **

Spring的任务命名空间最强大的功能是支持在Spring应用上下文中配置任务进行调度。这遵循了类似于Spring中其他 method-invokers 的方法，例如JMS命名空间为配置消息驱动的POJO提供的方法。基本上，`ref`属性可以指向任何Spring管理的对象，而`method`属性则提供了要在该对象上调用的方法名称。下面的列表显示了一个简单的例子。

<!-- tabs:end -->


```xml
<task:scheduled-tasks scheduler="myScheduler">
    <task:scheduled ref="beanA" method="methodA" fixed-delay="5000"/>
</task:scheduled-tasks>

<task:scheduler id="myScheduler" pool-size="10"/>
```

<!-- tabs:start -->

#### ** English **

The scheduler is referenced by the outer element, and each individual task includes the configuration of its trigger metadata. In the preceding example, that metadata defines a periodic trigger with a fixed delay indicating the number of milliseconds to wait after each task execution has completed. Another option is `fixed-rate`, indicating how often the method should be executed regardless of how long any previous execution takes. Additionally, for both `fixed-delay` and `fixed-rate` tasks, you can specify an 'initial-delay' parameter, indicating the number of milliseconds to wait before the first execution of the method. For more control, you can instead provide a `cron` attribute. The following example shows these other options:
#### ** Chinese **

调度器由外部元素引用，每个单独的任务包括其触发器元数据的配置。在前面的例子中，该元数据定义了一个具有固定延迟的周期性触发器，指示每个任务执行完成后要等待的毫秒数。另一个选项是`fixed-rate`，指示方法执行的频率，而不考虑之前的执行时间。此外，对于`fixed-delay`和`fixed-rate`任务，您可以指定一个 initial-delay 参数，表示在第一次执行方法之前需要等待的毫秒数。为了获得更多控制，你可以提供一个`cron`属性。下面的例子显示了这些其他选项。

<!-- tabs:end -->


```xml
<task:scheduled-tasks scheduler="myScheduler">
    <task:scheduled ref="beanA" method="methodA" fixed-delay="5000" initial-delay="1000"/>
    <task:scheduled ref="beanB" method="methodB" fixed-rate="5000"/>
    <task:scheduled ref="beanC" method="methodC" cron="*/5 * * * * MON-FRI"/>
</task:scheduled-tasks>

<task:scheduler id="myScheduler" pool-size="10"/>
```

### **7.5. Using the Quartz Scheduler** 

<!-- tabs:start -->

#### ** English **

Quartz uses `Trigger`, `Job`, and `JobDetail` objects to realize scheduling of all kinds of jobs. For the basic concepts behind Quartz, see [https://www.quartz-scheduler.org/](https://www.quartz-scheduler.org/). For convenience purposes, Spring offers a couple of classes that simplify using Quartz within Spring-based applications.
#### ** Chinese **

Quartz使用`Trigger`、`Job`和`JobDetail`对象来实现各种作业的调度。关于Quartz背后的基本概念，请参阅[https://www.quartz-scheduler.org/](https://www.quartz-scheduler.org/)。为了方便起见，Spring提供了几个类，可以简化基于Spring的应用程序中使用Quartz。

<!-- tabs:end -->


### **7.5.1. Using the** **`JobDetailFactoryBean`** 

<!-- tabs:start -->

#### ** English **

Quartz `JobDetail` objects contain all the information needed to run a job. Spring provides a `JobDetailFactoryBean`, which provides bean-style properties for XML configuration purposes. Consider the following example:
#### ** Chinese **

Quartz `JobDetail`对象包含运行作业所需的所有信息。Spring 提供了一个 `JobDetailFactoryBean`，它为 XML 配置目的提供了 Bean 风格的属性。考虑一下下面的例子。

<!-- tabs:end -->


```xml
<bean name="exampleJob" class="org.springframework.scheduling.quartz.JobDetailFactoryBean">
    <property name="jobClass" value="example.ExampleJob"/>
    <property name="jobDataAsMap">
        <map>
            <entry key="timeout" value="5"/>
        </map>
    </property>
</bean>
```

<!-- tabs:start -->

#### ** English **

The job detail configuration has all the information it needs to run the job (`ExampleJob`). The timeout is specified in the job data map. The job data map is available through the `JobExecutionContext` (passed to you at execution time), but the `JobDetail` also gets its properties from the job data mapped to properties of the job instance. So, in the following example, the `ExampleJob` contains a bean property named `timeout`, and the `JobDetail` has it applied automatically:
#### ** Chinese **

作业细节配置中拥有运行作业所需的所有信息（`ExampleJob`）。超时在作业数据映射中指定。作业数据映射可以通过`JobExecutionContext`（在执行时传递给您），但`JobDetail`也从映射到作业实例属性的作业数据中获取其属性。因此，在下面的例子中，`ExampleJob`包含一个名为`timeout`的Bean属性，而`JobDetail`则自动应用了这个属性。

<!-- tabs:end -->


```java
package example;

public class ExampleJob extends QuartzJobBean {

    private int timeout;

    /**
     * Setter called after the ExampleJob is instantiated
     * with the value from the JobDetailFactoryBean (5)
     */
    public void setTimeout(int timeout) {
        this.timeout = timeout;
    }

    protected void executeInternal(JobExecutionContext ctx) throws JobExecutionException {
        // do the actual work
    }

}
```

<!-- tabs:start -->

#### ** English **

All additional properties from the job data map are available to you as well.
#### ** Chinese **

工作数据图中的所有附加属性也都可以为您提供。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

By using the `name` and `group` properties, you can modify the name and the group of the job, respectively. By default, the name of the job matches the bean name of the `JobDetailFactoryBean` (`exampleJob` in the preceding example above).
#### ** Chinese **

通过使用`name`和`group`属性，可以分别修改作业的名称和组。默认情况下，作业的名称与`JobDetailFactoryBean`中的Bean名称相匹配（上面的例子中的`exampleJob`）。

<!-- tabs:end -->


### **7.5.2. Using the** **`MethodInvokingJobDetailFactoryBean`** 

<!-- tabs:start -->

#### ** English **

Often you merely need to invoke a method on a specific object. By using the `MethodInvokingJobDetailFactoryBean`, you can do exactly this, as the following example shows:
#### ** Chinese **

通常情况下，你只需要在一个特定对象上调用一个方法。通过使用`MethodInvokingJobDetailFactoryBean`，你可以准确地做到这一点，如下例所示。

<!-- tabs:end -->


```xml
<bean id="jobDetail" class="org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean">
    <property name="targetObject" ref="exampleBusinessObject"/>
    <property name="targetMethod" value="doIt"/>
</bean>
```

<!-- tabs:start -->

#### ** English **

The preceding example results in the `doIt` method being called on the `exampleBusinessObject` method, as the following example shows:
#### ** Chinese **

前面的例子导致`doIt`方法在`exampleBusinessObject`方法上被调用，如下图所示。

<!-- tabs:end -->


```java
public class ExampleBusinessObject {

    // properties and collaborators

    public void doIt() {
        // do the actual work
    }
}
```

```xml
<bean id="exampleBusinessObject" class="examples.ExampleBusinessObject"/>
```

<!-- tabs:start -->

#### ** English **

By using the `MethodInvokingJobDetailFactoryBean`, you need not create one-line jobs that merely invoke a method. You need only create the actual business object and wire up the detail object.
#### ** Chinese **

通过使用`MethodInvokingJobDetailFactoryBean`，您不需要创建仅仅调用方法的单行作业。您只需要创建实际的业务对象，并为细节对象布线。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

By default, Quartz Jobs are stateless, resulting in the possibility of jobs interfering with each other. If you specify two triggers for the same `JobDetail`, it is possible that, before the first job has finished, the second one starts. If `JobDetail` classes implement the `Stateful` interface, this does not happen. The second job does not start before the first one has finished. To make jobs resulting from the `MethodInvokingJobDetailFactoryBean` be non-concurrent, set the `concurrent` flag to `false`, as the following example shows:
#### ** Chinese **

默认情况下，Quartz Jobs 是无状态的，这就导致了作业之间相互干扰的可能性。如果您为同一个`JobDetail`指定了两个触发器，那么在第一个作业完成之前，第二个作业就有可能启动。如果`JobDetail`类实现了`Stateful`接口，则不会发生这种情况。在第一个作业完成之前，第二个作业不会启动。要使由 `MethodInvokingJobDetailFactoryBean`产生的作业为非concurrent，请将`concurrent`标志设置为`false`，如下例所示。

<!-- tabs:end -->


```xml
<bean id="jobDetail" class="org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean">
    <property name="targetObject" ref="exampleBusinessObject"/>
    <property name="targetMethod" value="doIt"/>
    <property name="concurrent" value="false"/>
</bean>
```

<!-- tabs:start -->

#### ** English **

By default, jobs will run in a concurrent fashion.
#### ** Chinese **

默认情况下，作业将以并发方式运行。

<!-- tabs:end -->


### **7.5.3. Wiring up Jobs by Using Triggers and** **`SchedulerFactoryBean`** 

<!-- tabs:start -->

#### ** English **

We have created job details and jobs. We have also reviewed the convenience bean that lets you invoke a method on a specific object. Of course, we still need to schedule the jobs themselves. This is done by using triggers and a `SchedulerFactoryBean`. Several triggers are available within Quartz, and Spring offers two Quartz `FactoryBean` implementations with convenient defaults: `CronTriggerFactoryBean` and `SimpleTriggerFactoryBean`.
#### ** Chinese **

我们创建了作业详情和作业。我们还查看了方便豆，它可以让你在特定对象上调用一个方法。当然，我们仍然需要对作业本身进行调度。这可以通过使用触发器和`SchedulerFactoryBean`来完成。在Quartz内有多个触发器，Spring提供了两个Quartz `FactoryBean`实现，并提供了方便的默认值。 `CronTriggerFactoryBean`和`SimpleTriggerFactoryBean`。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Triggers need to be scheduled. Spring offers a `SchedulerFactoryBean` that exposes triggers to be set as properties. `SchedulerFactoryBean` schedules the actual jobs with those triggers.
#### ** Chinese **

触发器需要被预定化。Spring提供了一个`SchedulerFactoryBean`，可以将触发器作为属性设置。 `SchedulerFactoryBean`用这些触发器调度实际的作业。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following listing uses both a `SimpleTriggerFactoryBean` and a `CronTriggerFactoryBean`:
#### ** Chinese **

下面的列表同时使用了`SimpleTriggerFactoryBean`和`CronTriggerFactoryBean`。

<!-- tabs:end -->


```xml
<bean id="simpleTrigger" class="org.springframework.scheduling.quartz.SimpleTriggerFactoryBean">
    <!-- see the example of method invoking job above -->
    <property name="jobDetail" ref="jobDetail"/>
    <!-- 10 seconds -->
    <property name="startDelay" value="10000"/>
    <!-- repeat every 50 seconds -->
    <property name="repeatInterval" value="50000"/>
</bean>

<bean id="cronTrigger" class="org.springframework.scheduling.quartz.CronTriggerFactoryBean">
    <property name="jobDetail" ref="exampleJob"/>
    <!-- run every morning at 6 AM -->
    <property name="cronExpression" value="0 0 6 * * ?"/>
</bean>
```

<!-- tabs:start -->

#### ** English **

The preceding example sets up two triggers, one running every 50 seconds with a starting delay of 10 seconds and one running every morning at 6 AM. To finalize everything, we need to set up the `SchedulerFactoryBean`, as the following example shows:
#### ** Chinese **

在前面的例子中，我们设置了两个触发器，一个是每50秒运行一次，开始延迟10秒，另一个是每天早上6点运行一次。为了最终完成一切，我们需要设置`SchedulerFactoryBean`，如下例所示。

<!-- tabs:end -->


```xml
<bean class="org.springframework.scheduling.quartz.SchedulerFactoryBean">
    <property name="triggers">
        <list>
            <ref bean="cronTrigger"/>
            <ref bean="simpleTrigger"/>
        </list>
    </property>
</bean>
```

<!-- tabs:start -->

#### ** English **

More properties are available for the `SchedulerFactoryBean`, such as the calendars used by the job details, properties to customize Quartz with, and others. See the [`SchedulerFactoryBean`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/scheduling/quartz/SchedulerFactoryBean.html) javadoc for more information.
#### ** Chinese **

`SchedulerFactoryBean`有更多的属性，如作业详情所使用的日历、自定义Quartz的属性等。有关更多信息，请参阅 [`SchedulerFactoryBean`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/scheduling/quartz/SchedulerFactoryBean.html) javadoc。

<!-- tabs:end -->



[下一章](Spring-Framework-5.2.6.RELEASE/Integration/8.%20Cache%20Abstraction.md)


[回目录](Spring-Framework-5.2.6.RELEASE/summary.md)

[回首页](/README)
