# 4. Object Relational Mapping (ORM) Data Access

<!-- tabs:start -->

#### ** English **

This section covers data access when you use Object Relational Mapping (ORM).
#### ** Chinese **

本节涉及使用对象关系映射（ORM）时的数据访问。

<!-- tabs:end -->


### **4.1. Introduction to ORM with Spring** 

<!-- tabs:start -->

#### ** English **

The Spring Framework supports integration with the Java Persistence API (JPA) and supports native Hibernate for resource management, data access object (DAO) implementations, and transaction strategies. For example, for Hibernate, there is first-class support with several convenient IoC features that address many typical Hibernate integration issues. You can configure all of the supported features for OR (object relational) mapping tools through Dependency Injection. They can participate in Spring’s resource and transaction management, and they comply with Spring’s generic transaction and DAO exception hierarchies. The recommended integration style is to code DAOs against plain Hibernate or JPA APIs.
#### ** Chinese **

Spring框架支持与Java Persistence API（JPA）的集成，并支持原生Hibernate的资源管理、数据访问对象（DAO）实现和事务策略。例如，对于Hibernate，有一流的支持，有几个方便的IoC功能，解决了许多典型的Hibernate集成问题。你可以通过Dependency Injection来配置OR（对象关系型）映射工具所支持的所有功能。它们可以参与到Spring的资源和事务管理中，并且符合Spring的通用事务和DAO异常层次结构。推荐的集成风格是针对纯Hibernate或JPA API来编码DAO。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Spring adds significant enhancements to the ORM layer of your choice when you create data access applications. You can leverage as much of the integration support as you wish, and you should compare this integration effort with the cost and risk of building a similar infrastructure in-house. You can use much of the ORM support as you would a library, regardless of technology, because everything is designed as a set of reusable JavaBeans. ORM in a Spring IoC container facilitates configuration and deployment. Thus, most examples in this section show configuration inside a Spring container.
#### ** Chinese **

当您创建数据访问应用程序时，Spring为您选择的ORM层添加了显著的增强功能。你可以尽可能多地利用集成支持，你应该将这种集成工作与内部构建类似基础架构的成本和风险进行比较。你可以像使用库一样使用ORM支持，无论技术如何，因为所有的东西都被设计成一组可重用的JavaBeans。在Spring IoC容器中的ORM方便了配置和部署。因此，本节中的大多数示例都是在Spring容器内进行配置。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The benefits of using the Spring Framework to create your ORM DAOs include:
#### ** Chinese **

使用Spring框架来创建ORM DAO的好处包括。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

- **Easier testing.**  Spring’s IoC approach makes it easy to swap the implementations and configuration locations of Hibernate `SessionFactory` instances, JDBC `DataSource` instances, transaction managers, and mapped object implementations (if needed). This in turn makes it much easier to test each piece of persistence-related code in isolation.

- **Common data access exceptions.**  Spring can wrap exceptions from your ORM tool, converting them from proprietary (potentially checked) exceptions to a common runtime `DataAccessException` hierarchy. This feature lets you handle most persistence exceptions, which are non-recoverable, only in the appropriate layers, without annoying boilerplate catches, throws, and exception declarations. You can still trap and handle exceptions as necessary. Remember that JDBC exceptions (including DB-specific dialects) are also converted to the same hierarchy, meaning that you can perform some operations with JDBC within a consistent programming model.

- **General resource management.**  Spring application contexts can handle the location and configuration of Hibernate `SessionFactory` instances, JPA `EntityManagerFactory` instances, JDBC `DataSource` instances, and other related resources. This makes these values easy to manage and change. Spring offers efficient, easy, and safe handling of persistence resources. For example, related code that uses Hibernate generally needs to use the same Hibernate `Session` to ensure efficiency and proper transaction handling. Spring makes it easy to create and bind a `Session` to the current thread transparently, by exposing a current `Session` through the Hibernate `SessionFactory`. Thus, Spring solves many chronic problems of typical Hibernate usage, for any local or JTA transaction environment.

- **Integrated transaction management.**  You can wrap your ORM code with a declarative, aspect-oriented programming (AOP) style method interceptor either through the `@Transactional` annotation or by explicitly configuring the transaction AOP advice in an XML configuration file. In both cases, transaction semantics and exception handling (rollback and so on) are handled for you. As discussed in [Resource and Transaction Management](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/data-access.html#orm-resource-mngmnt), you can also swap various transaction managers, without affecting your ORM-related code. For example, you can swap between local transactions and JTA, with the same full services (such as declarative transactions) available in both scenarios. Additionally, JDBC-related code can fully integrate transactionally with the code you use to do ORM. This is useful for data access that is not suitable for ORM (such as batch processing and BLOB streaming) but that still needs to share common transactions with ORM operations.

#### ** Chinese **

- 更容易测试。****Spring的IoC方法可以很容易地交换Hibernate `SessionFactory`实例、JDBC `DataSource`实例、事务管理器和映射对象实现（如果需要的话）的实现和配置位置。这反过来使得测试每一段与持久化相关的代码都能更容易地独立进行。

- **常见的数据访问异常.**Spring可以从你的ORM工具中封装异常，将其从专有的（可能被检查的）异常转换为常见的运行时`DataAccessException`层次结构。这个功能可以让你只在适当的层中处理大多数不可恢复的持久化异常，而不需要烦人的模板式捕获、抛出和异常声明。你仍然可以根据需要捕获和处理异常。请记住，JDBC异常（包括DB特有的拨号）也被转换为相同的层次结构，这意味着你可以在一个一致的编程模型中使用JDBC执行一些操作。

- 一般资源管理.**Spring应用上下文可以处理Hibernate `SessionFactory`实例、JPA `EntityManagerFactory`实例、JDBC `DataSource`实例以及其他相关资源的位置和配置。这使得这些值易于管理和更改。Spring为持久化资源提供了高效、简单、安全的处理方式。例如，使用Hibernate的相关代码通常需要使用相同的Hibernate `Session`，以确保效率和正确的事务处理。Spring通过Hibernate `SessionFactory<x>SessionFactory`，通过Hibernate `SessionFactory`公开当前的`Session`，使创建和绑定到当前线程的`Session`变得非常容易。因此，对于任何本地或JTA事务环境来说，Spring解决了许多典型的Hibernate使用中的慢性问题。

- **集成的事务管理。***你可以通过`@Transactional`注释或者在XML配置文件中显式配置事务AOP建议，用声明式的、面向方面编程(AOP)风格的方法拦截器来包装你的ORM代码。在这两种情况下，事务语义和异常处理（回滚等）都会为你处理。正如[资源和事务管理](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/data-access.html#orm-resource-mngmnt)中讨论的那样，你也可以交换各种事务管理器，而不影响你的ORM相关代码。例如，你可以在本地事务和JTA之间进行交换，在这两种情况下都可以使用相同的完整服务（如声明性事务）。此外，JDBC相关的代码可以与你用来做ORM的代码完全集成事务性的事务。这对于那些不适合ORM的数据访问（如批处理和BLOB流），但仍然需要与ORM操作共享共用事务的数据访问很有用。


<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

For more comprehensive ORM support, including support for alternative database technologies such as MongoDB, you might want to check out the [Spring Data](https://projects.spring.io/spring-data/) suite of projects. If you are a JPA user, the [Getting Started Accessing Data with JPA](https://spring.io/guides/gs/accessing-data-jpa/) guide from [https://spring.io](https://spring.io/) provides a great introduction.
#### ** Chinese **

对于更全面的ORM支持，包括对MongoDB等其他数据库技术的支持，你可能想看看[Spring Data](https://projects.spring.io/spring-data/)的项目套件。如果你是JPA用户，[https://spring.io](https://spring.io/)中的[Getting Started Accessing Data with JPA](https://spring.io/guides/gs/accessing-data-jpa/)指南提供了很好的介绍。

<!-- tabs:end -->


### **4.2. General ORM Integration Considerations** 

<!-- tabs:start -->

#### ** English **

This section highlights considerations that apply to all ORM technologies. The [Hibernate](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/data-access.html#orm-hibernate) section provides more details and also show these features and configurations in a concrete context.
#### ** Chinese **

本节重点介绍了适用于所有ORM技术的注意事项。Hibernate](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/data-access.html#orm-hibernate)部分提供了更多的细节，也在具体的上下文中展示了这些功能和配置。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The major goal of Spring’s ORM integration is clear application layering (with any data access and transaction technology) and for loose coupling of application objects — no more business service dependencies on the data access or transaction strategy, no more hard-coded resource lookups, no more hard-to-replace singletons, no more custom service registries. The goal is to have one simple and consistent approach to wiring up application objects, keeping them as reusable and free from container dependencies as possible. All the individual data access features are usable on their own but integrate nicely with Spring’s application context concept, providing XML-based configuration and cross-referencing of plain JavaBean instances that need not be Spring-aware. In a typical Spring application, many important objects are JavaBeans: data access templates, data access objects, transaction managers, business services that use the data access objects and transaction managers, web view resolvers, web controllers that use the business services, and so on.
#### ** Chinese **

Spring的ORM集成的主要目标是明确的应用分层（使用任何数据访问和事务技术），并实现应用对象的松散耦合--不再有业务服务对数据访问或事务策略的依赖，不再有硬编码的资源查找，不再有难以替换的单子，不再有自定义服务注册表。我们的目标是用一种简单而一致的方法来连接应用程序对象，使其尽可能地保持可重用，并且不依赖容器。所有单独的数据访问功能都可以单独使用，但与Spring的应用程序上下文概念很好地集成在一起，提供了基于XML的配置和交叉引用的纯JavaBean实例，而这些实例不需要Spring的意识。在一个典型的Spring应用中，很多重要的对象都是JavaBean：数据访问模板、数据访问对象、事务管理器、使用数据访问对象和事务管理器的业务服务、Web视图解析器、使用业务服务的Web控制器等。

<!-- tabs:end -->


### **4.2.1. Resource and Transaction Management** 

<!-- tabs:start -->

#### ** English **

Typical business applications are cluttered with repetitive resource management code. Many projects try to invent their own solutions, sometimes sacrificing proper handling of failures for programming convenience. Spring advocates simple solutions for proper resource handling, namely IoC through templating in the case of JDBC and applying AOP interceptors for the ORM technologies.
#### ** Chinese **

典型的业务应用程序中充斥着重复性的资源管理代码。许多项目试图发明自己的解决方案，有时为了编程的方便而牺牲了正确的故障处理。Spring主张采用简单的解决方案来正确处理资源，即在JDBC的情况下通过模板化的方式进行IoC，在ORM技术中应用AOP拦截器进行ORM技术。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The infrastructure provides proper resource handling and appropriate conversion of specific API exceptions to an unchecked infrastructure exception hierarchy. Spring introduces a DAO exception hierarchy, applicable to any data access strategy. For direct JDBC, the `JdbcTemplate` class mentioned in a [previous section](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/data-access.html#jdbc-JdbcTemplate) provides connection handling and proper conversion of `SQLException` to the `DataAccessException` hierarchy, including translation of database-specific SQL error codes to meaningful exception classes. For ORM technologies, see the [next section](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/data-access.html#orm-exception-translation) for how to get the same exception translation benefits.
#### ** Chinese **

基础设施提供了适当的资源处理，并将特定的API异常适当地转换为未选中的基础设施异常层次结构。Spring引入了DAO异常层次结构，适用于任何数据访问策略。对于直接的JDBC，[上一节](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/data-access.html#jdbc-JdbcTemplate)中提到的`JdbcTemplate`类提供了连接处理，并将`SQLException`适当地转换为`DataAccessException`层次结构，包括将数据库特定的SQL错误代码转换为有意义的异常类。对于ORM技术，请参阅[下一节](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/data-access.html#orm-exception-translation)，了解如何获得同样的异常转换好处。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

When it comes to transaction management, the `JdbcTemplate` class hooks in to the Spring transaction support and supports both JTA and JDBC transactions, through respective Spring transaction managers. For the supported ORM technologies, Spring offers Hibernate and JPA support through the Hibernate and JPA transaction managers as well as JTA support. For details on transaction support, see the [Transaction Management](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/data-access.html#transaction) chapter.
#### ** Chinese **

说到事务管理，`JdbcTemplate`类通过各自的Spring事务管理器连接到Spring事务支持，并支持JTA和JDBC事务。对于所支持的ORM技术，Spring通过Hibernate和JPA事务管理器提供了Hibernate和JPA支持，以及JTA支持。有关事务支持的详细信息，请参阅[事务管理](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/data-access.html#transaction)章节。

<!-- tabs:end -->


### **4.2.2. Exception Translation** 

<!-- tabs:start -->

#### ** English **

When you use Hibernate or JPA in a DAO, you must decide how to handle the persistence technology’s native exception classes. The DAO throws a subclass of a `HibernateException` or `PersistenceException`, depending on the technology. These exceptions are all runtime exceptions and do not have to be declared or caught. You may also have to deal with `IllegalArgumentException` and `IllegalStateException`. This means that callers can only treat exceptions as being generally fatal, unless they want to depend on the persistence technology’s own exception structure. Catching specific causes (such as an optimistic locking failure) is not possible without tying the caller to the implementation strategy. This trade-off might be acceptable to applications that are strongly ORM-based or do not need any special exception treatment (or both). However, Spring lets exception translation be applied transparently through the `@Repository` annotation. The following examples (one for Java configuration and one for XML configuration) show how to do so:
#### ** Chinese **

当你在DAO中使用Hibernate或JPA时，你必须决定如何处理持久化技术的原生异常类。DAO会抛出一个`HibernateException`或`PersistenceException`的子类，这取决于该技术。这些异常都是运行时异常，不需要声明或捕获。你可能还需要处理`IllegalArgumentException`和`IllegalStateException`。这意味着调用者只能将异常视为一般致命的异常，除非他们想依赖持久化技术自身的异常结构。如果不将调用者与实现策略捆绑在一起，就无法捕捉到特定的原因（如优化锁定失败）。这样的权衡，对于那些强烈基于ORM的应用程序，或者不需要任何特殊的异常处理（或者两者兼而有之），可能是可以接受的。然而，Spring允许通过`@Repository`注释透明地应用异常转换。下面的示例（一个用于 Java 配置，一个用于 XML 配置）展示了如何实现这一功能。

<!-- tabs:end -->


```java
@Repository
public class ProductDaoImpl implements ProductDao {

    // class body here...

}
```

```xml
<beans>

    <!-- Exception translation bean post processor -->
    <bean class="org.springframework.dao.annotation.PersistenceExceptionTranslationPostProcessor"/>

    <bean id="myProductDao" class="product.ProductDaoImpl"/>

</beans>
```

<!-- tabs:start -->

#### ** English **

The postprocessor automatically looks for all exception translators (implementations of the `PersistenceExceptionTranslator` interface) and advises all beans marked with the `@Repository` annotation so that the discovered translators can intercept and apply the appropriate translation on the thrown exceptions.
#### ** Chinese **

后处理程序自动查找所有的异常翻译器（`PersistenceExceptionTranslator`接口的实现），并通知所有标记有`@Repository`注释的Bean，以便被发现的翻译器能够拦截并对抛出的异常应用适当的翻译。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

In summary, you can implement DAOs based on the plain persistence technology’s API and annotations while still benefiting from Spring-managed transactions, dependency injection, and transparent exception conversion (if desired) to Spring’s custom exception hierarchies.
#### ** Chinese **

总之，你可以基于纯持久化技术的API和注释来实现DAO，同时仍然可以从Spring管理的事务、依赖注入和透明的异常转换（如果需要的话）中受益于Spring的自定义异常层次结构。

<!-- tabs:end -->


### **4.3. Hibernate** 

<!-- tabs:start -->

#### ** English **

We start with a coverage of [Hibernate 5](https://hibernate.org/) in a Spring environment, using it to demonstrate the approach that Spring takes towards integrating OR mappers. This section covers many issues in detail and shows different variations of DAO implementations and transaction demarcation. Most of these patterns can be directly translated to all other supported ORM tools. The later sections in this chapter then cover the other ORM technologies and show brief examples.
#### ** Chinese **

我们从Spring环境中的[Hibernate 5](https://hibernate.org/)开始，用它来演示Spring在集成OR映射器方面所采取的方法。这一节详细介绍了许多问题，并展示了DAO实现和事务划分的不同变化。这些模式中的大多数可以直接转化为所有其他支持的ORM工具。然后，本章后面的章节将介绍其他的ORM技术，并展示一些简单的例子。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

As of Spring Framework 5.0, Spring requires Hibernate ORM 4.3 or later for JPA support and even Hibernate ORM 5.0+ for programming against the native Hibernate Session API. Note that the Hibernate team does not maintain any versions prior to 5.1 anymore and is likely to focus on 5.3+ exclusively soon.
#### ** Chinese **

从Spring Framework 5.0开始，Spring需要Hibernate ORM 4.3或更高版本的JPA支持，甚至需要Hibernate ORM 5.0+版本的Hibernate Session API来进行编程。注意，Hibernate团队不再维护5.1之前的任何版本，可能很快就会专门关注5.3+。

<!-- tabs:end -->


### **4.3.1.** **`SessionFactory`** ** Setup in a Spring Container** 

<!-- tabs:start -->

#### ** English **

To avoid tying application objects to hard-coded resource lookups, you can define resources (such as a JDBC `DataSource` or a Hibernate `SessionFactory`) as beans in the Spring container. Application objects that need to access resources receive references to such predefined instances through bean references, as illustrated in the DAO definition in the [next section](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/data-access.html#orm-hibernate-straight).
#### ** Chinese **

为了避免将应用程序对象与硬编码的资源查找绑定，可以将资源（例如JDBC `DataSource`或Hibernate `SessionFactory`）定义为Spring容器中的Bean。需要访问资源的应用程序对象通过bean引用来接收对这些预定义实例的引用，如[下节](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/data-access.html#orm-hibernate-straight)中的DAO定义所示。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following excerpt from an XML application context definition shows how to set up a JDBC `DataSource` and a Hibernate `SessionFactory` on top of it:
#### ** Chinese **

下面从一个XML应用程序上下文定义中摘录的内容显示了如何在上面设置一个JDBC `DataSource`和一个Hibernate `SessionFactory`。

<!-- tabs:end -->


```xml
<beans>

    <bean id="myDataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close">
        <property name="driverClassName" value="org.hsqldb.jdbcDriver"/>
        <property name="url" value="jdbc:hsqldb:hsql://localhost:9001"/>
        <property name="username" value="sa"/>
        <property name="password" value=""/>
    </bean>

    <bean id="mySessionFactory" class="org.springframework.orm.hibernate5.LocalSessionFactoryBean">
        <property name="dataSource" ref="myDataSource"/>
        <property name="mappingResources">
            <list>
                <value>product.hbm.xml</value>
            </list>
        </property>
        <property name="hibernateProperties">
            <value>
                hibernate.dialect=org.hibernate.dialect.HSQLDialect
            </value>
        </property>
    </bean>

</beans>
```

<!-- tabs:start -->

#### ** English **

Switching from a local Jakarta Commons DBCP `BasicDataSource` to a JNDI-located `DataSource` (usually managed by an application server) is only a matter of configuration, as the following example shows:
#### ** Chinese **

从本地Jakarta Commons DBCP `BasicDataSource`切换到JNDI定位的`DataSource`（通常由应用服务器管理）只是一个配置问题，如下例所示。

<!-- tabs:end -->


```xml
<beans>
    <jee:jndi-lookup id="myDataSource" jndi-name="java:comp/env/jdbc/myds"/>
</beans>
```

<!-- tabs:start -->

#### ** English **

You can also access a JNDI-located `SessionFactory`, using Spring’s `JndiObjectFactoryBean` / `<jee:jndi-lookup>` to retrieve and expose it. However, that is typically not common outside of an EJB context.
#### ** Chinese **

你也可以使用Spring的`JndiObjectFactoryBean`/`<jee:jndi-lookup>`来访问JNDI定位的`SessionFactory`，以检索和暴露它。然而，在EJB上下文之外，这通常并不常见。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Spring also provides a `LocalSessionFactoryBuilder` variant, seamlessly integrating with `@Bean` style configuration and programmatic setup (no `FactoryBean` involved).
#### ** Chinese **

Spring还提供了一个`LocalSessionFactoryBuilder`变体，与`@Bean`风格配置和程序化设置无缝集成（不涉及`FactoryBean`）。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Both `LocalSessionFactoryBean` and `LocalSessionFactoryBuilder` support background bootstrapping, with Hibernate initialization running in parallel to the application bootstrap thread on a given bootstrap executor (such as a `SimpleAsyncTaskExecutor`). On `LocalSessionFactoryBean`, this is available through the `bootstrapExecutor` property. On the programmatic `LocalSessionFactoryBuilder`, there is an overloaded `buildSessionFactory` method that takes a bootstrap executor argument.
#### ** Chinese **

`LocalSessionFactoryBean`和`LocalSessionFactoryBuilder`都支持后台引导，Hibernate初始化与给定的bootstrap执行器（如`SimpleAsyncTaskExecutor`）上的应用程序引导线程并行运行。在`LocalSessionFactoryBean上`，这可以通过`bootstrapExecutor`属性来实现。在程序化的`LocalSessionFactoryBuilder`上，有一个重载的`buildSessionFactory`方法，该方法需要一个bootstrap执行器参数。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

As of Spring Framework 5.1, such a native Hibernate setup can also expose a JPA `EntityManagerFactory` for standard JPA interaction next to native Hibernate access. See [Native Hibernate Setup for JPA](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/data-access.html#orm-jpa-hibernate) for details.
#### ** Chinese **

从Spring Framework 5.1开始，这样的原生Hibernate设置也可以暴露一个JPA `EntityManagerFactory`，用于原生Hibernate访问旁边的标准JPA交互。详情请参阅[Native Hibernate Setup for JPA](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/data-access.html#orm-jpa-hibernate)。

<!-- tabs:end -->


### **4.3.2. Implementing DAOs Based on the Plain Hibernate API** 

<!-- tabs:start -->

#### ** English **

Hibernate has a feature called contextual sessions, wherein Hibernate itself manages one current `Session` per transaction. This is roughly equivalent to Spring’s synchronization of one Hibernate `Session` per transaction. A corresponding DAO implementation resembles the following example, based on the plain Hibernate API:
#### ** Chinese **

Hibernate有一个叫做上下文会话的功能，Hibernate本身管理着每个事务中的一个当前`Session`。这大致相当于Spring对每个事务中的一个Hibernate `Session`进行同步。相应的DAO实现类似于下面的例子，基于普通的Hibernate API。

<!-- tabs:end -->


```java
public class ProductDaoImpl implements ProductDao {

    private SessionFactory sessionFactory;

    public void setSessionFactory(SessionFactory sessionFactory) {
        this.sessionFactory = sessionFactory;
    }

    public Collection loadProductsByCategory(String category) {
        return this.sessionFactory.getCurrentSession()
                .createQuery("from test.Product product where product.category=?")
                .setParameter(0, category)
                .list();
    }
}
```

<!-- tabs:start -->

#### ** English **

This style is similar to that of the Hibernate reference documentation and examples, except for holding the `SessionFactory` in an instance variable. We strongly recommend such an instance-based setup over the old-school `static` `HibernateUtil` class from Hibernate’s CaveatEmptor sample application. (In general, do not keep any resources in `static` variables unless absolutely necessary.)
#### ** Chinese **

这种风格类似于Hibernate参考文档和示例中的风格，只是将`SessionFactory`保存在一个实例变量中。我们强烈推荐这种基于实例的设置，而不是Hibernate的CaveatEmptor示例应用程序中的老式的`static` `HibernateUtil`类。(一般来说，除非绝对必要，否则不要在`static`变量中保留任何资源。)

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The preceding DAO example follows the dependency injection pattern. It fits nicely into a Spring IoC container, as it would if coded against Spring’s `HibernateTemplate`. You can also set up such a DAO in plain Java (for example, in unit tests). To do so, instantiate it and call `setSessionFactory(..)` with the desired factory reference. As a Spring bean definition, the DAO would resemble the following:
#### ** Chinese **

上面的DAO示例遵循了依赖注入模式。它很适合于Spring的IoC容器，就像在Spring的`HibernateTemplate`中编码一样。你也可以在纯Java中设置这样一个DAO（例如，在单元测试中）。要做到这一点，请实例化它，然后调用`setSessionFactory(..)`，并使用所需的工厂引用。作为一个Spring Bean的定义，DAO将类似于下面的内容。

<!-- tabs:end -->


```xml
<beans>

    <bean id="myProductDao" class="product.ProductDaoImpl">
        <property name="sessionFactory" ref="mySessionFactory"/>
    </bean>

</beans>
```

<!-- tabs:start -->

#### ** English **

The main advantage of this DAO style is that it depends on Hibernate API only. No import of any Spring class is required. This is appealing from a non-invasiveness perspective and may feel more natural to Hibernate developers.
#### ** Chinese **

这种DAO风格的主要优点是它只依赖于Hibernate API。不需要任何Spring类的导入。从非侵入性的角度来看，这一点很吸引人，对于Hibernate开发者来说，可能会觉得比较自然。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

However, the DAO throws plain `HibernateException` (which is unchecked, so it does not have to be declared or caught), which means that callers can treat exceptions only as being generally fatal — unless they want to depend on Hibernate’s own exception hierarchy. Catching specific causes (such as an optimistic locking failure) is not possible without tying the caller to the implementation strategy. This trade off might be acceptable to applications that are strongly Hibernate-based, do not need any special exception treatment, or both.
#### ** Chinese **

然而，DAO会抛出普通的`HibernateException`（它是未选中的，所以不需要声明或捕获），这意味着调用者只能将异常视为一般致命的异常--除非他们想依赖Hibernate自己的异常层次结构。如果不将调用者与实现策略捆绑在一起，那么捕获特定的原因（如优化锁定失败）是不可能的。这种权衡，对于那些强烈依赖Hibernate、不需要任何特殊异常处理，或者两者兼而有之的应用来说，可能是可以接受的。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Fortunately, Spring’s `LocalSessionFactoryBean` supports Hibernate’s `SessionFactory.getCurrentSession()` method for any Spring transaction strategy, returning the current Spring-managed transactional `Session`, even with `HibernateTransactionManager`. The standard behavior of that method remains to return the current `Session` associated with the ongoing JTA transaction, if any. This behavior applies regardless of whether you use Spring’s `JtaTransactionManager`, EJB container managed transactions (CMTs), or JTA.
#### ** Chinese **

幸运的是，Spring的`LocalSessionFactoryBean`支持Hibernate的`SessionFactory.getCurrentSession()`方法，用于任何Spring事务策略，返回当前由Spring管理的事务性`Session`，即使是使用`HibernateTransactionManager`也是如此。该方法的标准行为仍然是返回与正在进行的JTA事务相关联的当前`Session`，如果有的话。无论您是使用Spring的`JtaTransactionManager`、EJB容器管理的事务(CTT)还是JTA，这个行为都适用。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

In summary, you can implement DAOs based on the plain Hibernate API, while still being able to participate in Spring-managed transactions.
#### ** Chinese **

总之，你可以基于纯Hibernate API实现DAO，同时还能参与Spring管理的事务。

<!-- tabs:end -->


### **4.3.3. Declarative Transaction Demarcation** 

<!-- tabs:start -->

#### ** English **

We recommend that you use Spring’s declarative transaction support, which lets you replace explicit transaction demarcation API calls in your Java code with an AOP transaction interceptor. You can configure this transaction interceptor in a Spring container by using either Java annotations or XML. This declarative transaction capability lets you keep business services free of repetitive transaction demarcation code and focus on adding business logic, which is the real value of your application.
#### ** Chinese **

我们建议你使用Spring的声明式事务支持，它可以让你在Java代码中用AOP事务拦截器代替显式事务划分API调用。你可以通过使用Java注释或XML在Spring容器中配置这个事务拦截器。这种声明性事务功能可以让你保持业务服务不需要重复的事务划界代码，而专注于添加业务逻辑，这才是你的应用程序的真正价值所在。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Before you continue, we are strongly encourage you to read [Declarative transaction management](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/data-access.html#transaction-declarative) if you have not already done so.
#### ** Chinese **

在您继续说下去之前，我们强烈鼓励您阅读【声明性交易管理】(https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/data-access.html#transaction-declarative)，如果您还没有这样做的话，请阅读【声明性交易管理】。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can annotate the service layer with `@Transactional` annotations and instruct the Spring container to find these annotations and provide transactional semantics for these annotated methods. The following example shows how to do so:
#### ** Chinese **

你可以用`@Transactional`注释来注释服务层，并指示Spring容器找到这些注释，为这些注释的方法提供事务性语义。下面的示例显示了如何做到这一点。

<!-- tabs:end -->


```java
public class ProductServiceImpl implements ProductService {

    private ProductDao productDao;

    public void setProductDao(ProductDao productDao) {
        this.productDao = productDao;
    }

    @Transactional
    public void increasePriceOfAllProductsInCategory(final String category) {
        List productsToChange = this.productDao.loadProductsByCategory(category);
        // ...
    }

    @Transactional(readOnly = true)
    public List<Product> findAllProducts() {
        return this.productDao.findAllProducts();
    }
}
```

<!-- tabs:start -->

#### ** English **

In the container, you need to set up the `PlatformTransactionManager` implementation (as a bean) and a `<tx:annotation-driven/>` entry, opting into `@Transactional` processing at runtime. The following example shows how to do so:
#### ** Chinese **

在容器中，你需要设置`PlatformTransactionManager`实现（作为一个Bean）和`<tx:annotation-driven/>`条目，在运行时选择`@Transactional`处理。下面的例子显示了如何做到这一点。

<!-- tabs:end -->


```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:aop="http://www.springframework.org/schema/aop"
    xmlns:tx="http://www.springframework.org/schema/tx"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/tx
        https://www.springframework.org/schema/tx/spring-tx.xsd
        http://www.springframework.org/schema/aop
        https://www.springframework.org/schema/aop/spring-aop.xsd">

    <!-- SessionFactory, DataSource, etc. omitted -->

    <bean id="transactionManager"
            class="org.springframework.orm.hibernate5.HibernateTransactionManager">
        <property name="sessionFactory" ref="sessionFactory"/>
    </bean>

    <tx:annotation-driven/>

    <bean id="myProductService" class="product.SimpleProductService">
        <property name="productDao" ref="myProductDao"/>
    </bean>

</beans>
```

### **4.3.4. Programmatic Transaction Demarcation** 

<!-- tabs:start -->

#### ** English **

You can demarcate transactions in a higher level of the application, on top of lower-level data access services that span any number of operations. Nor do restrictions exist on the implementation of the surrounding business service. It needs only a Spring `PlatformTransactionManager`. Again, the latter can come from anywhere, but preferably as a bean reference through a `setTransactionManager(..)` method. Also, the `productDAO` should be set by a `setProductDao(..)` method. The following pair of snippets show a transaction manager and a business service definition in a Spring application context and an example for a business method implementation:
#### ** Chinese **

你可以在应用的更高层次的事务中划定事务，在较低层次的数据访问服务之上，跨越任何数量的操作。对周围的业务服务的实现也不存在限制。它只需要一个Spring `PlatformTransactionManager`。同样，后者可以来自任何地方，但最好是通过`setTransactionManager(..)`方法作为Bean引用。另外，`productDAO`应该通过`setProductDao(..)`方法来设置。下面的一对片段展示了Spring应用上下文中的事务管理器和业务服务定义，以及一个业务方法实现的例子。

<!-- tabs:end -->


```xml
<beans>

    <bean id="myTxManager" class="org.springframework.orm.hibernate5.HibernateTransactionManager">
        <property name="sessionFactory" ref="mySessionFactory"/>
    </bean>

    <bean id="myProductService" class="product.ProductServiceImpl">
        <property name="transactionManager" ref="myTxManager"/>
        <property name="productDao" ref="myProductDao"/>
    </bean>

</beans>
```

```java
public class ProductServiceImpl implements ProductService {

    private TransactionTemplate transactionTemplate;
    private ProductDao productDao;

    public void setTransactionManager(PlatformTransactionManager transactionManager) {
        this.transactionTemplate = new TransactionTemplate(transactionManager);
    }

    public void setProductDao(ProductDao productDao) {
        this.productDao = productDao;
    }

    public void increasePriceOfAllProductsInCategory(final String category) {
        this.transactionTemplate.execute(new TransactionCallbackWithoutResult() {
            public void doInTransactionWithoutResult(TransactionStatus status) {
                List productsToChange = this.productDao.loadProductsByCategory(category);
                // do the price increase...
            }
        });
    }
}
```

<!-- tabs:start -->

#### ** English **

Spring’s `TransactionInterceptor` lets any checked application exception be thrown with the callback code, while `TransactionTemplate` is restricted to unchecked exceptions within the callback. `TransactionTemplate` triggers a rollback in case of an unchecked application exception or if the transaction is marked rollback-only by the application (by setting `TransactionStatus`). By default, `TransactionInterceptor` behaves the same way but allows configurable rollback policies per method.
#### ** Chinese **

Spring的`TransactionInterceptor`允许在回调代码中抛出任何检查过的应用程序异常，而`TransactionTemplate`仅限于回调中的未检查异常。 `TransactionTemplate`在发生未检查的应用程序异常或事务被应用程序标记为只回滚的情况下触发回调（通过设置`TransactionStatus`）。默认情况下，`TransactionInterceptor`的行为方式与之相同，但允许对每个方法进行可配置的回滚策略。

<!-- tabs:end -->


### **4.3.5. Transaction Management Strategies** 

<!-- tabs:start -->

#### ** English **

Both `TransactionTemplate` and `TransactionInterceptor` delegate the actual transaction handling to a `PlatformTransactionManager` instance (which can be a `HibernateTransactionManager` (for a single Hibernate `SessionFactory`) by using a `ThreadLocal` `Session` under the hood) or a `JtaTransactionManager` (delegating to the JTA subsystem of the container) for Hibernate applications. You can even use a custom `PlatformTransactionManager` implementation. Switching from native Hibernate transaction management to JTA (such as when facing distributed transaction requirements for certain deployments of your application) is only a matter of configuration. You can replace the Hibernate transaction manager with Spring’s JTA transaction implementation. Both transaction demarcation and data access code work without changes, because they use the generic transaction management APIs.
#### ** Chinese **

`TransactionTemplate`和`TransactionInterceptor`都将实际事务处理委托给一个`PlatformTransactionManager`实例（可以是`HibernateTransactionManager`（对于一个 单个Hibernate `SessionFactory`），通过在引擎盖下使用`ThreadLocal` `Session`）或`JtaTransactionManager`（委托给容器的JTA子系统）来实现Hibernate应用程序。你甚至可以使用自定义的`PlatformTransactionManager`实现。从原生的Hibernate事务管理切换到JTA（例如当你的应用程序的某些部署面临分布式事务需求时）只是一个配置问题。你可以用Spring的JTA事务实现取代Hibernate事务管理器。事务划分和数据访问代码都可以正常工作，无需改动，因为它们都使用了通用的事务管理API。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

For distributed transactions across multiple Hibernate session factories, you can combine `JtaTransactionManager` as a transaction strategy with multiple `LocalSessionFactoryBean` definitions. Each DAO then gets one specific `SessionFactory` reference passed into its corresponding bean property. If all underlying JDBC data sources are transactional container ones, a business service can demarcate transactions across any number of DAOs and any number of session factories without special regard, as long as it uses `JtaTransactionManager` as the strategy.
#### ** Chinese **

对于跨多个Hibernate会话工厂的分布式事务，你可以将`JtaTransactionManager`作为事务策略与多个`LocalSessionFactoryBean`定义结合起来。然后，每个DAO会得到一个特定的`SessionFactory`引用传入其相应的Bean属性。如果所有底层的JDBC数据源都是事务型容器，那么业务服务可以在任意数量的DAO和任意数量的会话工厂之间划分事务，而无需特别考虑，只要它使用`JtaTransactionManager`作为策略。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Both `HibernateTransactionManager` and `JtaTransactionManager` allow for proper JVM-level cache handling with Hibernate, without container-specific transaction manager lookup or a JCA connector (if you do not use EJB to initiate transactions).
#### ** Chinese **

`HibernateTransactionManager`和`JtaTransactionManager`都允许使用Hibernate进行适当的JVM级别的缓存处理，而不需要容器特定的事务管理器查找或JCA连接器（如果你不使用EJB来启动事务）。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

`HibernateTransactionManager` can export the Hibernate JDBC `Connection` to plain JDBC access code for a specific `DataSource`. This ability allows for high-level transaction demarcation with mixed Hibernate and JDBC data access completely without JTA, provided you access only one database. `HibernateTransactionManager` automatically exposes the Hibernate transaction as a JDBC transaction if you have set up the passed-in `SessionFactory` with a `DataSource` through the `dataSource` property of the `LocalSessionFactoryBean` class. Alternatively, you can specify explicitly the `DataSource` for which the transactions are supposed to be exposed through the `dataSource` property of the `HibernateTransactionManager` class.
#### ** Chinese **

`HibernateTransactionManager`可以将Hibernate JDBC `Connection`导出为特定`DataSource`的纯JDBC访问代码。这种能力允许使用混合Hibernate和JDBC数据访问的高级事务划分，完全不需要JTA，只要你只访问一个数据库。 `HibernateTransactionManager`如果你通过`LocalSessionFactoryBean`类的`dataSource`属性设置了传入的`SessionFactory`，那么Hibernate事务就会自动作为JDBC事务公开。或者，您可以通过`HibernateTransactionManager`类的`dataSource`属性明确指定要暴露事务的`DataSource`。

<!-- tabs:end -->


### **4.3.6. Comparing Container-managed and Locally Defined Resources** 

<!-- tabs:start -->

#### ** English **

You can switch between a container-managed JNDI `SessionFactory` and a locally defined one without having to change a single line of application code. Whether to keep resource definitions in the container or locally within the application is mainly a matter of the transaction strategy that you use. Compared to a Spring-defined local `SessionFactory`, a manually registered JNDI `SessionFactory` does not provide any benefits. Deploying a `SessionFactory` through Hibernate’s JCA connector provides the added value of participating in the Java EE server’s management infrastructure, but does not add actual value beyond that.
#### ** Chinese **

你可以在容器管理的JNDI `SessionFactory`和本地定义的JNDI `SessionFactory`之间切换，而不需要改变一行应用程序代码。是将资源定义保留在容器中还是在应用程序中本地定义，主要取决于你使用的事务策略。与Spring定义的本地`SessionFactory`相比，手动注册的JNDI `SessionFactory`并没有提供任何好处。通过 Hibernate 的 JCA 连接器部署 `SessionFactory`，可以提供参与 Java EE 服务器管理基础架构的附加值，但并不能增加实际价值。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Spring’s transaction support is not bound to a container. When configured with any strategy other than JTA, transaction support also works in a stand-alone or test environment. Especially in the typical case of single-database transactions, Spring’s single-resource local transaction support is a lightweight and powerful alternative to JTA. When you use local EJB stateless session beans to drive transactions, you depend both on an EJB container and on JTA, even if you access only a single database and use only stateless session beans to provide declarative transactions through container-managed transactions. Direct use of JTA programmatically also requires a Java EE environment. JTA does not involve only container dependencies in terms of JTA itself and of JNDI `DataSource` instances. For non-Spring, JTA-driven Hibernate transactions, you have to use the Hibernate JCA connector or extra Hibernate transaction code with the `TransactionManagerLookup` configured for proper JVM-level caching.
#### ** Chinese **

Spring的事务支持不绑定在容器中。当使用JTA以外的任何策略进行配置时，事务支持也可以在独立或测试环境中工作。特别是在单数据库事务的典型案例中，Spring的单资源本地事务支持是JTA的轻量级和强大的替代方案。当你使用本地的EJB无状态会话Bean来驱动事务时，你既依赖EJB容器，又依赖JTA，即使你只访问一个单一的数据库，并且只使用无状态会话Bean通过容器管理的事务来提供声明性事务。在程序上直接使用JTA也需要一个Java EE环境。JTA不只涉及到JTA本身和JNDI `DataSource`实例的容器依赖性。对于非Spring，JTA驱动的Hibernate事务，你必须使用Hibernate JCA连接器或额外的Hibernate事务代码，并配置了`TransactionManagerLookup`，以实现适当的JVM级缓存。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Spring-driven transactions can work as well with a locally defined Hibernate `SessionFactory` as they do with a local JDBC `DataSource`, provided they access a single database. Thus, you need only use Spring’s JTA transaction strategy when you have distributed transaction requirements. A JCA connector requires container-specific deployment steps, and (obviously) JCA support in the first place. This configuration requires more work than deploying a simple web application with local resource definitions and Spring-driven transactions. Also, you often need the Enterprise Edition of your container if you use, for example, WebLogic Express, which does not provide JCA. A Spring application with local resources and transactions that span one single database works in any Java EE web container (without JTA, JCA, or EJB), such as Tomcat, Resin, or even plain Jetty. Additionally, you can easily reuse such a middle tier in desktop applications or test suites.
#### ** Chinese **

Spring驱动的事务可以与本地定义的Hibernate `SessionFactory`一起工作，就像在本地的JDBC `DataSource`中一样，只要它们访问单个数据库，就能很好地工作。因此，当你有分布式事务需求时，你只需要使用Spring的JTA事务策略。JCA连接器需要特定于容器的部署步骤，并且（显然）首先需要JCA支持。这种配置需要比部署一个简单的web应用程序，使用本地资源定义和Spring驱动的事务来部署更多的工作。另外，如果你使用的是不提供JCA的WebLogic Express等不提供JCA的容器，你往往需要容器的企业版。一个具有本地资源和事务的Spring应用程序可以在任何Java EE Web容器（没有JTA、JCA或EJB）中工作，例如Tomcat、Resin、甚至是普通的Jetty等，这些容器中都可以使用本地资源和事务，并跨越一个数据库。此外，您可以轻松地在桌面应用程序或测试套件中重用这样一个中间层。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

All things considered, if you do not use EJBs, stick with local `SessionFactory` setup and Spring’s `HibernateTransactionManager` or `JtaTransactionManager`. You get all of the benefits, including proper transactional JVM-level caching and distributed transactions, without the inconvenience of container deployment. JNDI registration of a Hibernate `SessionFactory` through the JCA connector adds value only when used in conjunction with EJBs.
#### ** Chinese **

综合考虑，如果你不使用EJB，请坚持使用本地`SessionFactory`设置和Spring的`HibernateTransactionManager`或`JtaTransactionManager`。你可以获得所有的好处，包括适当的事务性 JVM 级缓存和分布式事务，而没有容器部署的不便。通过 JCA 连接器注册 Hibernate `SessionFactory` 的 JNDI 注册，只有在与 EJB 配合使用时才会增加价值。

<!-- tabs:end -->


### **4.3.7. Spurious Application Server Warnings with Hibernate** 

<!-- tabs:start -->

#### ** English **

In some JTA environments with very strict `XADataSource` implementations (currently only some WebLogic Server and WebSphere versions), when Hibernate is configured without regard to the JTA `PlatformTransactionManager` object for that environment, spurious warning or exceptions can show up in the application server log. These warnings or exceptions indicate that the connection being accessed is no longer valid or JDBC access is no longer valid, possibly because the transaction is no longer active. As an example, here is an actual exception from WebLogic:
#### ** Chinese **

在某些具有非常严格的 `XADataSource`实现的 JTA 环境中（目前只有某些 WebLogic Server 和 WebSphere 版本），当配置 Hibernate 时，如果不考虑该环境的 JTA `PlatformTransactionManager` 对象，则可能会在应用服务器日志中显示虚假警告或异常。这些警告或异常表明被访问的连接不再有效或JDBC访问不再有效，可能是因为事务不再活动。作为一个例子，这里是一个来自WebLogic的实际异常。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

java.sql.SQLException: The transaction is no longer active - status: 'Committed'. No
#### ** Chinese **

java.Sql.SQLException: 事务已不再活动 - 状态：'已提交'。没有

<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

further JDBC access is allowed within this transaction.
#### ** Chinese **

该事务中允许进一步的JDBC访问。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can resolve this warning by making Hibernate aware of the JTA `PlatformTransactionManager` instance, to which it synchronizes (along with Spring). You have two options for doing this:
#### ** Chinese **

您可以通过让 Hibernate 知晓 JTA `PlatformTransactionManager` 实例来解决这个警告，而 Hibernate 会与 Spring 同步（与 Spring 一起）。你有两个选项可以做到这一点。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

- If, in your application context, you already directly obtain the JTA `PlatformTransactionManager` object (presumably from JNDI through `JndiObjectFactoryBean` or `<jee:jndi-lookup>`) and feed it, for example, to Spring’s `JtaTransactionManager`, the easiest way is to specify a reference to the bean that defines this JTA `PlatformTransactionManager` instance as the value of the `jtaTransactionManager` property for `LocalSessionFactoryBean`. Spring then makes the object available to Hibernate.

- More likely, you do not already have the JTA `PlatformTransactionManager` instance, because Spring’s `JtaTransactionManager` can find it itself. Thus, you need to configure Hibernate to look up JTA `PlatformTransactionManager` directly. You do this by configuring an application server-specific `TransactionManagerLookup` class in the Hibernate configuration, as described in the Hibernate manual.

#### ** Chinese **

- 如果在你的应用上下文中，你已经直接获得了JTA `PlatformTransactionManager`对象（可能是通过`JndiObjectFactoryBean`或`<jee: jndi-lookup>`）并将其反馈给Spring的`JtaTransactionManager`，最简单的方法是指定一个对定义这个JTA`PlatformTransactionManager`实例的Bean的引用，作为`LocalSessionFactoryBean`的`jtaTransactionManager`属性的值。 `Spring然后将该对象提供给Hibernate。

- 更有可能的是，你还没有JTA `PlatformTransactionManager`实例，因为Spring的`JtaTransactionManager`可以自己找到它。因此，你需要配置Hibernate来直接查找JTA `PlatformTransactionManager`。您可以通过在Hibernate配置中配置一个应用程序服务器专用的`TransactionManagerLookup`类来实现，具体操作方法见Hibernate手册。


<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

The remainder of this section describes the sequence of events that occur with and without Hibernate’s awareness of the JTA `PlatformTransactionManager`.
#### ** Chinese **

本节的其余部分描述了在Hibernate意识到JTA `PlatformTransactionManager`的情况下和不意识到JTA `PlatformTransactionManager`的情况下发生的事件序列。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

When Hibernate is not configured with any awareness of the JTA `PlatformTransactionManager`, the following events occur when a JTA transaction commits:
#### ** Chinese **

当Hibernate没有配置任何意识到JTA `PlatformTransactionManager`时，当JTA事务提交时，会发生以下事件。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

- The JTA transaction commits.

- Spring’s `JtaTransactionManager` is synchronized to the JTA transaction, so it is called back through an `afterCompletion` callback by the JTA transaction manager.

- Among other activities, this synchronization can trigger a callback by Spring to Hibernate, through Hibernate’s `afterTransactionCompletion` callback (used to clear the Hibernate cache), followed by an explicit `close()` call on the Hibernate session, which causes Hibernate to attempt to `close()` the JDBC Connection.

- In some environments, this `Connection.close()` call then triggers the warning or error, as the application server no longer considers the `Connection` to be usable, because the transaction has already been committed.

#### ** Chinese **

- JTA事务提交。

- Spring的`JtaTransactionManager`被同步到JTA事务，所以它通过JTA事务管理器的`afterCompletion`回调来回调。

- 在其他活动中，这种同步可以通过Hibernate的`afterTransactionCompletion`回调（用于清除Hibernate缓存），然后在Hibernate会话上进行显式`close()`调用，从而使Hibernate尝试`close()`JDBC连接。

- 在某些环境中，这个`Connection.close()`调用会触发警告或错误，因为应用程序服务器不再认为`Connection`可用，因为事务已经提交了。


<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

When Hibernate is configured with awareness of the JTA `PlatformTransactionManager`, the following events occur when a JTA transaction commits:
#### ** Chinese **

当Hibernate配置了JTA `PlatformTransactionManager`的意识时，当JTA事务提交时，会发生以下事件。

<!-- tabs:end -->


### **4.4. JPA** 

<!-- tabs:start -->

#### ** English **

The Spring JPA, available under the `org.springframework.orm.jpa` package, offers comprehensive support for the [Java Persistence API](https://www.oracle.com/technetwork/articles/javaee/jpa-137156.html) in a manner similar to the integration with Hibernate while being aware of the underlying implementation in order to provide additional features.
#### ** Chinese **

Spring JPA在`org.springframework.orm.jpa`包下提供的Spring JPA，以类似于与Hibernate集成的方式提供对[Java Persistence API](https://www.oracle.com/technetwork/articles/javaee/jpa-137156.html)的全面支持，同时注意到底层实现，以提供额外的功能。

<!-- tabs:end -->


### **4.4.1. Three Options for JPA Setup in a Spring Environment** 

<!-- tabs:start -->

#### ** English **

The Spring JPA support offers three ways of setting up the JPA `EntityManagerFactory` that is used by the application to obtain an entity manager.
#### ** Chinese **

Spring JPA支持提供了三种设置JPA `EntityManagerFactory`的方法，应用程序用于获取实体管理器。

<!-- tabs:end -->


### **Using** **`LocalEntityManagerFactoryBean`** 

<!-- tabs:start -->

#### ** English **

You can use this option only in simple deployment environments such as stand-alone applications and integration tests.
#### ** Chinese **

您只能在简单的部署环境中使用此选项，例如独立的应用程序和集成测试。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The `LocalEntityManagerFactoryBean` creates an `EntityManagerFactory` suitable for simple deployment environments where the application uses only JPA for data access. The factory bean uses the JPA `PersistenceProvider` auto-detection mechanism (according to JPA’s Java SE bootstrapping) and, in most cases, requires you to specify only the persistence unit name. The following XML example configures such a bean:
#### ** Chinese **

`LocalEntityManagerFactoryBean`创建了一个`EntityManagerFactory`，适用于简单的部署环境，在这些环境中，应用程序只使用JPA进行数据访问。该工厂Bean使用JPA `PersistenceProvider`自动检测机制（根据JPA的Java SE引导机制），在大多数情况下，只需要指定持久化单元名称即可。下面的XML示例配置了这样一个Bean。

<!-- tabs:end -->


```xml
<beans>
    <bean id="myEmf" class="org.springframework.orm.jpa.LocalEntityManagerFactoryBean">
        <property name="persistenceUnitName" value="myPersistenceUnit"/>
    </bean>
</beans>
```

<!-- tabs:start -->

#### ** English **

This form of JPA deployment is the simplest and the most limited. You cannot refer to an existing JDBC `DataSource` bean definition, and no support for global transactions exists. Furthermore, weaving (byte-code transformation) of persistent classes is provider-specific, often requiring a specific JVM agent to specified on startup. This option is sufficient only for stand-alone applications and test environments, for which the JPA specification is designed.
#### ** Chinese **

这种形式的JPA部署是最简单也是最有限的。你不能引用现有的JDBC `DataSource` bean定义，也不支持全局事务。此外，持久化类的编织（字节码转换）是特定于提供者的，通常需要在启动时指定一个特定的JVM代理。这个选项只适用于独立的应用程序和测试环境，而JPA规范就是为此而设计的。

<!-- tabs:end -->


### **Obtaining an EntityManagerFactory from JNDI** 

<!-- tabs:start -->

#### ** English **

You can use this option when deploying to a Java EE server. Check your server’s documentation on how to deploy a custom JPA provider into your server, allowing for a different provider than the server’s default.
#### ** Chinese **

在部署到Java EE服务器时，可以使用这个选项。请查看服务器的文档，了解如何在服务器中部署自定义JPA提供者，允许使用与服务器默认的不同的提供者。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Obtaining an `EntityManagerFactory` from JNDI (for example in a Java EE environment), is a matter of changing the XML configuration, as the following example shows:
#### ** Chinese **

从JNDI中获取`EntityManagerFactory`（例如在Java EE环境中），只需改变XML配置即可，如下例所示。

<!-- tabs:end -->


```xml
<beans>
    <jee:jndi-lookup id="myEmf" jndi-name="persistence/myPersistenceUnit"/>
</beans>
```

<!-- tabs:start -->

#### ** English **

This action assumes standard Java EE bootstrapping. The Java EE server auto-detects persistence units (in effect, `META-INF/persistence.xml` files in application jars) and `persistence-unit-ref` entries in the Java EE deployment descriptor (for example, `web.xml`) and defines environment naming context locations for those persistence units.
#### ** Chinese **

这个操作假设了标准的Java EE引导。Java EE 服务器会自动检测应用程序 jars 中的持久化单元（实际上，`META-INF/persistence.xml`文件）和 `persistence-unit-ref`条目（例如，`web.xml`），并为这些持久化单元定义环境命名上下文位置。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

In such a scenario, the entire persistence unit deployment, including the weaving (byte-code transformation) of persistent classes, is up to the Java EE server. The JDBC `DataSource` is defined through a JNDI location in the `META-INF/persistence.xml` file. `EntityManager` transactions are integrated with the server’s JTA subsystem. Spring merely uses the obtained `EntityManagerFactory`, passing it on to application objects through dependency injection and managing transactions for the persistence unit (typically through `JtaTransactionManager`).
#### ** Chinese **

在这种情况下，整个持久化单元的部署，包括持久化类的编织（字节码转换），都是由Java EE服务器决定的。JDBC `DataSource`通过`META-INF/persistence.xml`文件中的JNDI位置来定义。 `EntityManager`事务与服务器的JTA子系统集成。Spring仅仅使用获得的`EntityManagerFactory`，通过依赖注入将其传递给应用程序对象，并为持久化单元管理事务（通常通过`JtaTransactionManager`）。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

If you use multiple persistence units in the same application, the bean names of such JNDI-retrieved persistence units should match the persistence unit names that the application uses to refer to them (for example, in `@PersistenceUnit` and `@PersistenceContext` annotations).
#### ** Chinese **

如果在同一个应用程序中使用多个持久化单元，那么这些 JNDI 检索到的持久化单元的 bean 名称应该与应用程序用来引用它们的持久化单元名称相匹配（例如，在 `@PersistenceUnit` 和 `@PersistenceContext` 注解中）。

<!-- tabs:end -->


### **Using** **`LocalContainerEntityManagerFactoryBean`** 

<!-- tabs:start -->

#### ** English **

You can use this option for full JPA capabilities in a Spring-based application environment. This includes web containers such as Tomcat, stand-alone applications, and integration tests with sophisticated persistence requirements.
#### ** Chinese **
您可以在基于Spring的应用程序环境中使用此选项来实现完全的JPA功能。这包括像Tomcat这样的Web容器、独立的应用程序和具有复杂的持久性要求的集成测试。


<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

If you want to specifically configure a Hibernate setup, an immediate alternative is to go with Hibernate 5.2 or 5.3 and set up a native Hibernate `LocalSessionFactoryBean` instead of a plain JPA `LocalContainerEntityManagerFactoryBean`, letting it interact with JPA access code as well as native Hibernate access code. See [Native Hibernate setup for JPA interaction](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/data-access.html#orm-jpa-hibernate) for details.
#### ** Chinese **

如果你想专门配置一个Hibernate设置，一个直接的选择是使用Hibernate 5.2或5.3，并设置一个原生的Hibernate `LocalSessionFactoryBean`，而不是普通的JPA `LocalContainerEntityManagerFactoryBean`，让它与JPA访问代码以及原生的Hibernate访问代码交互。详情请参见[Native Hibernate设置为JPA交互](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/data-access.html#orm-jpa-hibernate)。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The `LocalContainerEntityManagerFactoryBean` gives full control over `EntityManagerFactory` configuration and is appropriate for environments where fine-grained customization is required. The `LocalContainerEntityManagerFactoryBean` creates a `PersistenceUnitInfo` instance based on the `persistence.xml` file, the supplied `dataSourceLookup` strategy, and the specified `loadTimeWeaver`. It is, thus, possible to work with custom data sources outside of JNDI and to control the weaving process. The following example shows a typical bean definition for a `LocalContainerEntityManagerFactoryBean`:
#### ** Chinese **

`LocalContainerEntityManagerFactoryBean`提供了对`EntityManagerFactory`配置的全面控制，适合于需要精细化定制的环境。`LocalContainerEntityManagerFactoryBean`根据`persistence.xml`文件、提供的`dataSourceLookup`策略和指定的`loadTimeWeaver`创建一个`PersistenceUnitInfo`实例。因此，可以在JNDI之外使用自定义数据源，并控制编织过程。下面的例子显示了一个典型的 `LocalContainerEntityManagerFactoryBean` 的bean定义。
<!-- tabs:end -->


```xml
<beans>
    <bean id="myEmf" class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean">
        <property name="dataSource" ref="someDataSource"/>
        <property name="loadTimeWeaver">
            <bean class="org.springframework.instrument.classloading.InstrumentationLoadTimeWeaver"/>
        </property>
    </bean>
</beans>
```

<!-- tabs:start -->

#### ** English **

The following example shows a typical `persistence.xml` file:
#### ** Chinese **

下面的例子显示了一个典型的 `persistence.xml`文件。

<!-- tabs:end -->


```xml
<persistence xmlns="http://java.sun.com/xml/ns/persistence" version="1.0">
    <persistence-unit name="myUnit" transaction-type="RESOURCE_LOCAL">
        <mapping-file>META-INF/orm.xml</mapping-file>
        <exclude-unlisted-classes/>
    </persistence-unit>
</persistence>
```

<!-- tabs:start -->

#### ** English **

The `<exclude-unlisted-classes/>` shortcut indicates that no scanning for annotated entity classes is supposed to occur. An explicit 'true' value (`<exclude-unlisted-classes>true</exclude-unlisted-classes/>`) also means no scan. `<exclude-unlisted-classes>false</exclude-unlisted-classes/>` does trigger a scan. However, we recommend omitting the `exclude-unlisted-classes` element if you want entity class scanning to occur.
#### ** Chinese **

`<exclude-unlisted-classes/>`快捷方式表示不扫描注释的实体类。一个显式的 "true "值(`<exclude-unlisted-classes>true</exclude-unlisted-classes/>`)也意味着没有扫描。 `<exclude-unlisted-classes>false</exclude-unlisted-classes/>`确实会触发扫描。但是，如果你想让实体类扫描发生，我们建议省略`exclude-unlisted-classes`元素。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Using the `LocalContainerEntityManagerFactoryBean` is the most powerful JPA setup option, allowing for flexible local configuration within the application. It supports links to an existing JDBC `DataSource`, supports both local and global transactions, and so on. However, it also imposes requirements on the runtime environment, such as the availability of a weaving-capable class loader if the persistence provider demands byte-code transformation.
#### ** Chinese **

使用 `LocalContainerEntityManagerFactoryBean` 是最强大的JPA设置选项，可以在应用程序中灵活地进行本地配置。它支持链接到现有的JDBC `DataSource`，支持本地和全局事务等。但是，它也对运行时环境提出了一些要求，例如，如果持久化提供者要求字节码转换，则需要有一个能够编织的类加载器。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

This option may conflict with the built-in JPA capabilities of a Java EE server. In a full Java EE environment, consider obtaining your `EntityManagerFactory` from JNDI. Alternatively, specify a custom `persistenceXmlLocation` on your `LocalContainerEntityManagerFactoryBean` definition (for example, META-INF/my-persistence.xml) and include only a descriptor with that name in your application jar files. Because the Java EE server looks only for default `META-INF/persistence.xml` files, it ignores such custom persistence units and, hence, avoids conflicts with a Spring-driven JPA setup upfront. (This applies to Resin 3.1, for example.)
#### ** Chinese **

这个选项可能会与Java EE服务器的内置JPA功能冲突。在一个完整的Java EE环境中，考虑从JNDI中获取你的 "`EntityManagerFactory`"。或者，在你的`LocalContainerEntityManagerFactoryBean`定义中指定一个自定义的`persistenceXmlLocation`（例如，META-INF/my-persistence.xml），并在你的应用程序jar文件中只包含一个带有该名称的描述符。因为Java EE服务器只查找默认的  `META-INF/persistence.xml` 文件，所以它忽略了这些自定义的持久化单元，因此，可以避免与Spring驱动的JPA设置冲突。例如，这适用于Resin 3.1）。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

When is load-time weaving required?
#### ** Chinese **

什么时候需要进行负载时间的织入？

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Not all JPA providers require a JVM agent. Hibernate is an example of one that does not. If your provider does not require an agent or you have other alternatives, such as applying enhancements at build time through a custom compiler or an Ant task, you should not use the load-time weaver.
#### ** Chinese **

不是所有的JPA提供商都需要JVM代理。Hibernate就是一个不需要代理的例子。如果你的提供者不需要代理，或者你有其他选择，比如在构建时通过自定义编译器或Ant任务应用增强，那么你就不应该使用加载时间织机。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The `LoadTimeWeaver` interface is a Spring-provided class that lets JPA `ClassTransformer` instances be plugged in a specific manner, depending on whether the environment is a web container or application server. Hooking `ClassTransformers` through an [agent](https://docs.oracle.com/javase/6/docs/api/java/lang/instrument/package-summary.html) is typically not efficient. The agents work against the entire virtual machine and inspect every class that is loaded, which is usually undesirable in a production server environment.
#### ** Chinese **

`LoadTimeWeaver`接口是一个Spring提供的类，它可以让JPA`ClassTransformer`实例以特定的方式插入，这取决于环境是web容器还是应用服务器。通过[agent](https://docs.oracle.com/javase/6/docs/api/java/lang/instrument/package-summary.html)挂接`ClassTransformers`通常效率不高。这些代理对整个虚拟机进行工作，并检查每个加载的类，这在生产服务器环境中通常是不可取的。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Spring provides a number of `LoadTimeWeaver` implementations for various environments, letting `ClassTransformer` instances be applied only for each class loader and not for each VM.
#### ** Chinese **

Spring为各种环境提供了许多 `LoadTimeWeaver` 实现，让 `ClassTransformer` 实例只适用于每个类加载器而不是每个VM。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

See the [Spring configuration](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#aop-aj-ltw-spring) in the AOP chapter for more insight regarding the `LoadTimeWeaver` implementations and their setup, either generic or customized to various platforms (such as Tomcat, JBoss and WebSphere).
#### ** Chinese **

有关`LoadTimeWeaver`实现及其设置的更多信息，请参见AOP章节中的[Spring配置](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#aop-aj-ltw-spring)，可以是通用的，也可以是针对不同平台（如Tomcat、JBoss和WebSphere）定制的。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

As described in [Spring configuration](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#aop-aj-ltw-spring), you can configure a context-wide `LoadTimeWeaver` by using the `@EnableLoadTimeWeaving` annotation of the `context:load-time-weaver` XML element. Such a global weaver is automatically picked up by all JPA `LocalContainerEntityManagerFactoryBean` instances. The following example shows the preferred way of setting up a load-time weaver, delivering auto-detection of the platform (e.g. Tomcat’s weaving-capable class loader or Spring’s JVM agent) and automatic propagation of the weaver to all weaver-aware beans:
#### ** Chinese **

正如[Spring configuration](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#aop-aj-ltw-spring)中描述的那样，你可以通过使用`context:load-time-weaver` XML元素的`@EnableLoadTimeWeaving`注释来配置一个全局的`LoadTimeWeaver`。这样的全局编织器会被所有的JPA `LocalContainerEntityManagerFactoryBean`实例自动拾取。下面的例子显示了设置加载时织机的首选方式，提供了平台的自动检测（例如Tomcat的织机类加载器或Spring的JVM代理），并将织机自动传播到所有有织机意识的Bean。

<!-- tabs:end -->


```xml
<context:load-time-weaver/>
<bean id="emf" class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean">
    ...
</bean>
```

<!-- tabs:start -->

#### ** English **

However, you can, if needed, manually specify a dedicated weaver through the `loadTimeWeaver` property, as the following example shows:
#### ** Chinese **

但是，如果需要，您可以通过`loadTimeWeaver`属性手动指定一个专用的织机，如下图所示。

<!-- tabs:end -->


```xml
<bean id="emf" class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean">
    <property name="loadTimeWeaver">
        <bean class="org.springframework.instrument.classloading.ReflectiveLoadTimeWeaver"/>
    </property>
</bean>
```

<!-- tabs:start -->

#### ** English **

No matter how the LTW is configured, by using this technique, JPA applications relying on instrumentation can run in the target platform (for example, Tomcat) without needing an agent. This is especially important when the hosting applications rely on different JPA implementations, because the JPA transformers are applied only at the class-loader level and are, thus, isolated from each other.
#### ** Chinese **

无论LTW是如何配置的，通过使用这种技术，依赖仪表的JPA应用可以在目标平台（例如Tomcat）上运行，而不需要代理。当托管应用依赖不同的JPA实现时，这一点尤其重要，因为JPA变换器只在类加载器级别上应用，因此彼此之间是隔离的。

<!-- tabs:end -->


### **Dealing with Multiple Persistence Units** 

<!-- tabs:start -->

#### ** English **

For applications that rely on multiple persistence units locations (stored in various JARS in the classpath, for example), Spring offers the `PersistenceUnitManager` to act as a central repository and to avoid the persistence units discovery process, which can be expensive. The default implementation lets multiple locations be specified. These locations are parsed and later retrieved through the persistence unit name. (By default, the classpath is searched for `META-INF/persistence.xml` files.) The following example configures multiple locations:
#### ** Chinese **

对于依赖多个持久化单元位置的应用程序（例如，存储在classpath中的各种JARS中），Spring提供了`PersistenceUnitManager`作为中央存储库，避免了持久化单元的发现过程，而这个过程可能会很昂贵。默认的实现允许指定多个位置。这些位置被解析，然后通过持久化单元名称来检索。(默认情况下，classpath会搜索`META-INF/persistence.xml`文件)。下面的例子配置了多个位置。

<!-- tabs:end -->


```xml
<bean id="pum" class="org.springframework.orm.jpa.persistenceunit.DefaultPersistenceUnitManager">
    <property name="persistenceXmlLocations">
        <list>
            <value>org/springframework/orm/jpa/domain/persistence-multi.xml</value>
            <value>classpath:/my/package/**/custom-persistence.xml</value>
            <value>classpath*:META-INF/persistence.xml</value>
        </list>
    </property>
    <property name="dataSources">
        <map>
            <entry key="localDataSource" value-ref="local-db"/>
            <entry key="remoteDataSource" value-ref="remote-db"/>
        </map>
    </property>
    <!-- if no datasource is specified, use this one -->
    <property name="defaultDataSource" ref="remoteDataSource"/>
</bean>

<bean id="emf" class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean">
    <property name="persistenceUnitManager" ref="pum"/>
    <property name="persistenceUnitName" value="myCustomUnit"/>
</bean>
```

<!-- tabs:start -->

#### ** English **

The default implementation allows customization of the `PersistenceUnitInfo` instances (before they are fed to the JPA provider) either declaratively (through its properties, which affect all hosted units) or programmatically (through the `PersistenceUnitPostProcessor`, which allows persistence unit selection). If no `PersistenceUnitManager` is specified, one is created and used internally by `LocalContainerEntityManagerFactoryBean`.
#### ** Chinese **

默认的实现允许自定义 `PersistenceUnitInfo`实例（在将其送入JPA提供者之前），可以通过声明方式（通过其属性，影响所有托管单元）或程序化方式（通过`PersistenceUnitPostProcessor`，允许持久化单元选择）。如果没有指定`PersistenceUnitManager`，则会创建一个并由`LocalContainerEntityManagerFactoryBean`内部使用。

<!-- tabs:end -->


### **Background Bootstrapping** 

<!-- tabs:start -->

#### ** English **

`LocalContainerEntityManagerFactoryBean` supports background bootstrapping through the `bootstrapExecutor` property, as the following example shows:
#### ** Chinese **

`LocalContainerEntityManagerFactoryBean`通过`bootstrapExecutor`属性支持后台引导，如下图所示。

<!-- tabs:end -->


```xml
<bean id="emf" class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean">
    <property name="bootstrapExecutor">
        <bean class="org.springframework.core.task.SimpleAsyncTaskExecutor"/>
    </property>
</bean>
```

<!-- tabs:start -->

#### ** English **

The actual JPA provider bootstrapping is handed off to the specified executor and then, running in parallel, to the application bootstrap thread. The exposed `EntityManagerFactory` proxy can be injected into other application components and is even able to respond to `EntityManagerFactoryInfo` configuration inspection. However, once the actual JPA provider is being accessed by other components (for example, calling `createEntityManager`), those calls block until the background bootstrapping has completed. In particular, when you use Spring Data JPA, make sure to set up deferred bootstrapping for its repositories as well.
#### ** Chinese **

实际的JPA提供者引导被交给指定的执行器，然后，并行运行的应用程序引导线程。公开的`EntityManagerFactory`代理可以被注入到其他应用程序组件中，甚至能够响应`EntityManagerFactoryInfo`配置检查。然而，一旦实际的JPA提供者被其他组件访问（例如，调用`createEntityManager`），这些调用就会被阻止，直到后台引导完成。特别是，当您使用Spring Data JPA时，请确保为其存储库也设置了延迟引导。

<!-- tabs:end -->


### **4.4.2. Implementing DAOs Based on JPA:** **`EntityManagerFactory`** ** and** **`EntityManager`** 

<!-- tabs:start -->

#### ** English **

Although `EntityManagerFactory` instances are thread-safe, `EntityManager` instances are not. The injected JPA `EntityManager` behaves like an `EntityManager` fetched from an application server’s JNDI environment, as defined by the JPA specification. It delegates all calls to the current transactional `EntityManager`, if any. Otherwise, it falls back to a newly created `EntityManager` per operation, in effect making its usage thread-safe.
#### ** Chinese **

虽然`EntityManagerFactory`实例是线程安全的，但`EntityManager`实例不是。注入的JPA `EntityManager`的行为就像从应用服务器的JNDI环境中提取的`EntityManager`一样，由JPA规范定义。它将所有调用委托给当前事务性的 `EntityManager`（如果有的话）。否则，它将回落到新创建的 `EntityManager`的每一次操作中，实际上是使其使用线程安全。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

It is possible to write code against the plain JPA without any Spring dependencies, by using an injected `EntityManagerFactory` or `EntityManager`. Spring can understand the `@PersistenceUnit` and `@PersistenceContext` annotations both at the field and the method level if a `PersistenceAnnotationBeanPostProcessor` is enabled. The following example shows a plain JPA DAO implementation that uses the `@PersistenceUnit` annotation:
#### ** Chinese **

通过使用注入的`EntityManagerFactory`或`EntityManager`，可以在没有任何Spring依赖关系的情况下编写针对纯JPA的代码。如果启用了`PersistenceAnnotationBeanPostProcessor`，Spring可以在字段和方法级理解`@PersistenceUnit`和`@PersistenceContext`注释。下面的示例显示了一个使用 `@PersistenceUnit`注释的纯JPA DAO实现。

<!-- tabs:end -->


```java
public class ProductDaoImpl implements ProductDao {

    private EntityManagerFactory emf;

    @PersistenceUnit
    public void setEntityManagerFactory(EntityManagerFactory emf) {
        this.emf = emf;
    }

    public Collection loadProductsByCategory(String category) {
        try (EntityManager em = this.emf.createEntityManager()) {
            Query query = em.createQuery("from Product as p where p.category = ?1");
            query.setParameter(1, category);
            return query.getResultList();
        }
    }
}
```

<!-- tabs:start -->

#### ** English **

The preceding DAO has no dependency on Spring and still fits nicely into a Spring application context. Moreover, the DAO takes advantage of annotations to require the injection of the default `EntityManagerFactory`, as the following example bean definition shows:
#### ** Chinese **

前面的DAO没有对Spring的依赖性，仍然很适合Spring应用上下文。此外，DAO利用了注释的优势，要求注入默认的`EntityManagerFactory`，正如下面的示例Bean定义所示。

<!-- tabs:end -->


```xml
<beans>

    <!-- bean post-processor for JPA annotations -->
    <bean class="org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor"/>

    <bean id="myProductDao" class="product.ProductDaoImpl"/>

</beans>
```

<!-- tabs:start -->

#### ** English **

As an alternative to explicitly defining a `PersistenceAnnotationBeanPostProcessor`, consider using the Spring `context:annotation-config` XML element in your application context configuration. Doing so automatically registers all Spring standard post-processors for annotation-based configuration, including `CommonAnnotationBeanPostProcessor` and so on.
#### ** Chinese **

作为显式定义`PersistenceAnnotationBeanPostProcessor`的替代方案，可以考虑在应用程序上下文配置中使用Spring `context:annotation-config` XML元素。这样做会自动注册所有Spring标准的后处理程序，用于基于注释的配置，包括`CommonAnnotationBeanPostProcessor`等。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Consider the following example:
#### ** Chinese **

请看下面的例子：

<!-- tabs:end -->


```xml
<beans>

    <!-- post-processors for all standard config annotations -->
    <context:annotation-config/>

    <bean id="myProductDao" class="product.ProductDaoImpl"/>

</beans>
```

<!-- tabs:start -->

#### ** English **

The main problem with such a DAO is that it always creates a new `EntityManager` through the factory. You can avoid this by requesting a transactional `EntityManager` (also called a “shared EntityManager” because it is a shared, thread-safe proxy for the actual transactional EntityManager) to be injected instead of the factory. The following example shows how to do so:
#### ** Chinese **

这种DAO的主要问题是，它总是通过工厂创建一个新的`EntityManager`。您可以通过请求注入一个事务性的 `EntityManager`（也称为 共享 EntityManager，因为它是实际事务性 EntityManager 的共享、线程安全的代理）来代替工厂来避免这个问题。下面的例子显示了如何做到这一点。

<!-- tabs:end -->


```java
public class ProductDaoImpl implements ProductDao {

    @PersistenceContext
    private EntityManager em;

    public Collection loadProductsByCategory(String category) {
        Query query = em.createQuery("from Product as p where p.category = :category");
        query.setParameter("category", category);
        return query.getResultList();
    }
}
```

<!-- tabs:start -->

#### ** English **

The `@PersistenceContext` annotation has an optional attribute called `type`, which defaults to `PersistenceContextType.TRANSACTION`. You can use this default to receive a shared `EntityManager` proxy. The alternative, `PersistenceContextType.EXTENDED`, is a completely different affair. This results in a so-called extended `EntityManager`, which is not thread-safe and, hence, must not be used in a concurrently accessed component, such as a Spring-managed singleton bean. Extended `EntityManager` instances are only supposed to be used in stateful components that, for example, reside in a session, with the lifecycle of the `EntityManager` not tied to a current transaction but rather being completely up to the application.
#### ** Chinese **

`@PersistenceContext`注解有一个可选属性，名为`type`，默认为`PersistenceContextType.TRANSACTION`。您可以使用这个默认值来接收共享`EntityManager`代理。另一种选择是 `PersistenceContextType.EXTENDED`，这是完全不同的事情。这导致了一个所谓的扩展`EntityManager`，它不是线程安全的，因此，不能在并发访问的组件中使用，例如Spring管理的单子bean。扩展的`EntityManager`实例只应该在有状态的组件中使用，例如，驻留在一个会话中，而`EntityManager`的生命周期不与当前事务绑定，而是完全由应用程序决定。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Method- and field-level Injection
#### ** Chinese **

方法级和现场级注入

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can apply annotations that indicate dependency injections (such as `@PersistenceUnit` and `@PersistenceContext`) on field or methods inside a class — hence the expressions “method-level injection” and “field-level injection”. Field-level annotations are concise and easier to use while method-level annotations allow for further processing of the injected dependency. In both cases, the member visibility (public, protected, or private) does not matter.
#### ** Chinese **

您可以在类内的字段或方法上应用表示依赖注入的注释（如`@PersistenceUnit`和`@PersistenceContext`）--因此，方法级注入 和 字段级注入 的表达式。字段级注解比较简洁，而且更容易使用，而方法级注解则允许进一步处理注入的依赖关系。在这两种情况下，成员的可见性（public、protected或private）并不重要。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

What about class-level annotations?
#### ** Chinese **

类级注解呢？

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

On the Java EE platform, they are used for dependency declaration and not for resource injection.
#### ** Chinese **

在Java EE平台上，它们被用于依赖声明，而不是用于资源注入。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The injected `EntityManager` is Spring-managed (aware of the ongoing transaction). Even though the new DAO implementation uses method-level injection of an `EntityManager` instead of an `EntityManagerFactory`, no change is required in the application context XML, due to annotation usage.
#### ** Chinese **

注入的`EntityManager`是由Spring管理的（意识到正在进行的事务）。尽管新的DAO实现使用了方法级注入的`EntityManager`而不是`EntityManagerFactory`，但由于注解的使用，在应用上下文XML中不需要改变。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The main advantage of this DAO style is that it depends only on the Java Persistence API. No import of any Spring class is required. Moreover, as the JPA annotations are understood, the injections are applied automatically by the Spring container. This is appealing from a non-invasiveness perspective and can feel more natural to JPA developers.
#### ** Chinese **

这种DAO风格的主要优点是它只依赖于Java Persistence API。不需要任何Spring类的导入。此外，由于理解了JPA的注解，注入是由Spring容器自动应用的。从非侵入性的角度来看，这一点很吸引人，对于JPA开发者来说，可以感觉到更自然。

<!-- tabs:end -->


### **4.4.3. Spring-driven JPA transactions** 

<!-- tabs:start -->

#### ** English **

We strongly encourage you to read [Declarative transaction management](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/data-access.html#transaction-declarative), if you have not already done so, to get more detailed coverage of Spring’s declarative transaction support.
#### ** Chinese **

我们强烈鼓励您阅读[声明式事务管理](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/data-access.html#transaction-declarative)，如果您还没有这样做的话，请阅读[声明式事务管理](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/data-access.html#transaction-declarative)，以获得关于Spring的声明式事务支持的更详细的内容。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The recommended strategy for JPA is local transactions through JPA’s native transaction support. Spring’s `JpaTransactionManager` provides many capabilities known from local JDBC transactions (such as transaction-specific isolation levels and resource-level read-only optimizations) against any regular JDBC connection pool (no XA requirement).
#### ** Chinese **

推荐的JPA策略是通过JPA的本地事务支持来实现本地事务。Spring的`JpaTransactionManager`提供了许多从本地JDBC事务中了解到的功能（如事务特定的隔离级别和资源级只读优化），可以对抗任何常规的JDBC连接池（没有XA要求）。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Spring JPA also lets a configured `JpaTransactionManager` expose a JPA transaction to JDBC access code that accesses the same `DataSource`, provided that the registered `JpaDialect` supports retrieval of the underlying JDBC `Connection`. Spring provides dialects for the EclipseLink and Hibernate JPA implementations. See the [next section](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/data-access.html#orm-jpa-dialect) for details on the `JpaDialect` mechanism.
#### ** Chinese **

Spring JPA还允许配置的`JpaTransactionManager`将JPA事务暴露给JDBC访问代码，该代码可以访问相同的`DataSource`，前提是注册的`JpaDialect`支持检索底层JDBC `Connection`。Spring为EclipseLink和Hibernate JPA实现提供了方言。有关`JpaDialect`机制的详细信息，请参阅[下一节](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/data-access.html#orm-jpa-dialect)。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

As an immediate alternative, Spring’s native `HibernateTransactionManager` is capable of interacting with JPA access code as of Spring Framework 5.1 and Hibernate 5.2/5.3, adapting to several Hibernate specifics and providing JDBC interaction. This makes particular sense in combination with `LocalSessionFactoryBean` setup. See [Native Hibernate Setup for JPA Interaction](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/data-access.html#orm-jpa-hibernate) for details.
#### ** Chinese **

作为一个直接的替代方案，Spring的原生`HibernateTransactionManager`能够与Spring Framework 5.1和Hibernate 5.2/5.3中的JPA访问代码进行交互，能够适应一些Hibernate的特殊性，并提供JDBC交互。这与`LocalSessionFactoryBean`设置结合起来特别有意义。详情请参阅[Native Hibernate Setup for JPA Interaction](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/data-access.html#orm-jpa-hibernate)。

<!-- tabs:end -->


### **4.4.4. Understanding** **`JpaDialect`** ** and** **`JpaVendorAdapter`** 

<!-- tabs:start -->

#### ** English **

As an advanced feature, `JpaTransactionManager` and subclasses of `AbstractEntityManagerFactoryBean` allow a custom `JpaDialect` to be passed into the `jpaDialect` bean property. A `JpaDialect` implementation can enable the following advanced features supported by Spring, usually in a vendor-specific manner:
#### ** Chinese **

作为一项高级功能，`JpaTransactionManager`和`AbstractEntityManagerFactoryBean`的子类允许将自定义的`JpaDialect`传递到`jpaDialect` bean属性中。`JpaDialect`实现可以启用Spring所支持的以下高级特性，通常是以厂商指定的方式。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

- The JTA transaction is ready to commit.

- Spring’s `JtaTransactionManager` is synchronized to the JTA transaction, so the transaction is called back through a `beforeCompletion` callback by the JTA transaction manager.

- Spring is aware that Hibernate itself is synchronized to the JTA transaction and behaves differently than in the previous scenario. Assuming the Hibernate `Session` needs to be closed at all, Spring closes it now.

- The JTA transaction commits.

- Hibernate is synchronized to the JTA transaction, so the transaction is called back through an `afterCompletion` callback by the JTA transaction manager and can properly clear its cache.

- [Using ](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/data-access.html#orm-jpa-setup-lemfb)[`LocalEntityManagerFactoryBean`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/data-access.html#orm-jpa-setup-lemfb)

- [Obtaining an EntityManagerFactory from JNDI](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/data-access.html#orm-jpa-setup-jndi)

- [Using ](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/data-access.html#orm-jpa-setup-lcemfb)[`LocalContainerEntityManagerFactoryBean`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/data-access.html#orm-jpa-setup-lcemfb)

- Applying specific transaction semantics (such as custom isolation level or transaction timeout)

- Retrieving the transactional JDBC `Connection` (for exposure to JDBC-based DAOs)

- Advanced translation of `PersistenceExceptions` to Spring `DataAccessExceptions`

#### ** Chinese **

- JTA事务已经准备好提交了。

- Spring的`JtaTransactionManager`与JTA事务同步，因此JTA事务管理器通过`beforeCompletion`回调来回调该事务。

- Spring意识到Hibernate本身是同步到JTA事务的，其行为方式与上一个场景不同。假设Hibernate `Session`完全需要关闭，Spring现在就关闭它。

- JTA事务提交。

- Hibernate与JTA事务是同步的，所以该事务会被JTA事务管理器通过`afterCompletion`回调，可以适当地清除它的缓存。

- 使用】(https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/data-access.html#orm-jpa-setup-lemfb)[`LocalEntityManagerFactoryBean`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/data-access.html#orm-jpa-setup-lemfb)

- 从JNDI中获取EntityManagerFactory](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/data-access.html#orm-jpa-setup-jndi)

- 使用](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/data-access.html#orm-jpa-setup-lcemfb)[`LocalContainerEntityManagerFactoryBean`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/data-access.html#orm-jpa-setup-lcemfb)

- 应用特定的事务语义（如自定义隔离级别或事务超时）。

- 检索事务性的JDBC `Connection`（用于暴露于基于JDBC的DAO）。

- `PersistenceExceptions`到Spring `DataAccessExceptions`的高级翻译


<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

This is particularly valuable for special transaction semantics and for advanced translation of exception. The default implementation (`DefaultJpaDialect`) does not provide any special abilities and, if the features listed earlier are required, you have to specify the appropriate dialect.
#### ** Chinese **

这对于特殊的事务语义和异常的高级翻译特别有价值。默认的实现(`DefaultJpaDialect`)没有提供任何特殊的能力，如果需要前面列出的功能，你必须指定适当的方言。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

As an even broader provider adaptation facility primarily for Spring’s full-featured `LocalContainerEntityManagerFactoryBean` setup, `JpaVendorAdapter` combines the capabilities of `JpaDialect` with other provider-specific defaults. Specifying a `HibernateJpaVendorAdapter` or `EclipseLinkJpaVendorAdapter` is the most convenient way of auto-configuring an `EntityManagerFactory` setup for Hibernate or EclipseLink, respectively. Note that those provider adapters are primarily designed for use with Spring-driven transaction management (that is, for use with `JpaTransactionManager`).
#### ** Chinese **

作为一个更广泛的提供者适应工具，主要针对Spring的全功能`LocalContainerEntityManagerFactoryBean`设置，`JpaVendorAdapter`结合了`JpaDialect`和其他特定于提供者的默认设置。指定一个 `HibernateJpaVendorAdapter`或`EclipseLinkJpaVendorAdapter`是分别为Hibernate或EclipseLink自动配置`EntityManagerFactory`设置的最方便的方法。请注意，这些提供者适配器主要是为Spring驱动的事务管理而设计的（即与`JpaTransactionManager`一起使用）。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

See the [`JpaDialect`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/orm/jpa/JpaDialect.html) and [`JpaVendorAdapter`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/orm/jpa/JpaVendorAdapter.html) javadoc for more details of its operations and how they are used within Spring’s JPA support.
#### ** Chinese **

请参阅 [`JpaDialect`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/orm/jpa/JpaDialect.html)和 [`JpaVendorAdapter`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/orm/jpa/JpaVendorAdapter.html) javadoc，了解更多关于其操作的详细信息，以及如何在Spring的JPA支持中使用。

<!-- tabs:end -->


### **4.4.5. Setting up JPA with JTA Transaction Management** 

<!-- tabs:start -->

#### ** English **

As an alternative to `JpaTransactionManager`, Spring also allows for multi-resource transaction coordination through JTA, either in a Java EE environment or with a stand-alone transaction coordinator, such as Atomikos. Aside from choosing Spring’s `JtaTransactionManager` instead of `JpaTransactionManager`, you need to take few further steps:
#### ** Chinese **

作为`JpaTransactionManager`的替代方案，Spring还允许通过JTA实现多资源事务协调，无论是在Java EE环境中，还是与独立的事务协调器（如Atomikos）一起使用。除了选择Spring的`JtaTransactionManager`而不是`JpaTransactionManager`之外，你还需要采取一些进一步的步骤。

<!-- tabs:end -->


### **4.4.6. Native Hibernate Setup and Native Hibernate Transactions for JPA Interaction** 

<!-- tabs:start -->

#### ** English **

As of Spring Framework 5.1 and Hibernate 5.2/5.3, a native `LocalSessionFactoryBean` setup in combination with `HibernateTransactionManager` allows for interaction with `@PersistenceContext` and other JPA access code. A Hibernate `SessionFactory` natively implements JPA’s `EntityManagerFactory` interface now and a Hibernate `Session` handle natively is a JPA `EntityManager`. Spring’s JPA support facilities automatically detect native Hibernate sessions.
#### ** Chinese **

从Spring Framework 5.1和Hibernate 5.2/5.3开始，原生的`LocalSessionFactoryBean`设置与`HibernateTransactionManager`结合使用，可以与`@PersistenceContext`和其他JPA访问代码进行交互。一个Hibernate `SessionFactory`原生地实现了JPA的`EntityManagerFactory`接口，而一个Hibernate `Session`句柄原生地就是一个JPA `EntityManager`。Spring的JPA支持设施可以自动检测到原生Hibernate会话。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Such native Hibernate setup can, therefore, serve as a replacement for a standard JPA `LocalContainerEntityManagerFactoryBean` and `JpaTransactionManager` combination in many scenarios, allowing for interaction with `SessionFactory.getCurrentSession()` (and also `HibernateTemplate`) next to `@PersistenceContext EntityManager` within the same local transaction. Such a setup also provides stronger Hibernate integration and more configuration flexibility, because it is not constrained by JPA bootstrap contracts.
#### ** Chinese **

因此，这样的原生Hibernate设置可以在许多场景中作为标准JPA`LocalContainerEntityManagerFactoryBean`和`JpaTransactionManager`组合的替代品，允许在同一本地事务中与`@PersistenceContext EntityManager`旁边的`SessionFactory.getCurrentSession()`（以及`HibernateTemplate`）交互。这样的设置还提供了更强的Hibernate集成和更多的配置灵活性，因为它不受JPA引导合同的约束。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You do not need `HibernateJpaVendorAdapter` configuration in such a scenario, since Spring’s native Hibernate setup provides even more features (for example, custom Hibernate Integrator setup, Hibernate 5.3 bean container integration, and stronger optimizations for read-only transactions). Last but not least, you can also express native Hibernate setup through `LocalSessionFactoryBuilder`, seamlessly integrating with `@Bean` style configuration (no `FactoryBean` involved).
#### ** Chinese **

在这种情况下，你不需要`HibernateJpaVendorAdapter`配置，因为Spring的原生Hibernate设置提供了更多的功能（例如，自定义Hibernate Integrator设置、Hibernate 5.3 bean容器集成，以及对只读事务的更强优化）。最后，你还可以通过`LocalSessionFactoryBuilder`表达原生Hibernate设置，与`@Bean`风格配置无缝集成（不涉及`FactoryBean`）。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

`LocalSessionFactoryBean` and `LocalSessionFactoryBuilder` support background bootstrapping, just as the JPA `LocalContainerEntityManagerFactoryBean` does. See [Background Bootstrapping](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/data-access.html#orm-jpa-setup-background) for an introduction.
#### ** Chinese **

`LocalSessionFactoryBean`和`LocalSessionFactoryBuilder`支持后台引导，就像JPA `LocalContainerEntityManagerFactoryBean`一样。有关介绍，请参阅 [Background Bootstrapping](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/data-access.html#orm-jpa-setup-background)。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

On `LocalSessionFactoryBean`, this is available through the `bootstrapExecutor` property. On the programmatic `LocalSessionFactoryBuilder`, an overloaded `buildSessionFactory` method takes a bootstrap executor argument.
#### ** Chinese **

在`LocalSessionFactoryBean上`，这可以通过`bootstrapExecutor`属性获得。在程序化的`LocalSessionFactoryBuilder`上，一个重载的`buildSessionFactory`方法需要一个bootstrap执行器参数。

<!-- tabs:end -->


## 


[下一章](Spring-Framework-5.2.6.RELEASE/Data%20Access/5.%20Marshalling%20XML%20by%20Using%20Object-XML%20Mappers.md)


[回目录](Spring-Framework-5.2.6.RELEASE/summary.md)

[回首页](/README)
