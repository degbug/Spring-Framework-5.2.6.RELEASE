# 1.10. View Technologies

<!-- tabs:start -->

#### ** English **

[WebFlux](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-view)
#### ** Chinese **

[WebFlux](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-view)

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The use of view technologies in Spring MVC is pluggable, whether you decide to use Thymeleaf, Groovy Markup Templates, JSPs, or other technologies, is primarily a matter of a configuration change. This chapter covers view technologies integrated with Spring MVC. We assume you are already familiar with [View Resolution](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-viewresolver).
#### ** Chinese **

视图技术在Spring MVC中的使用是可插拔的，无论你决定使用Thymeleaf、Groovy Markup Templates、JSPs，还是其他技术，主要是改变配置的问题。本章涵盖了与Spring MVC集成的视图技术。我们假设你已经熟悉了[视图解析](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-viewresolver)。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The views of a Spring MVC application live within the internal trust boundaries of that application. Views have access to all the beans of your application context. As such, it is not recommended to use Spring MVC’s template support in applications where the templates are editable by external sources, since this can have security implications.
#### ** Chinese **

Spring MVC 应用程序的视图位于该应用程序的内部信任边界内。视图可以访问应用程序上下文中的所有Bean。因此，不建议在模板可由外部来源编辑的应用程序中使用Spring MVC的模板支持，因为这可能会产生安全问题。

<!-- tabs:end -->


### **1.10.1. Thymeleaf** 

<!-- tabs:start -->

#### ** English **

[WebFlux](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-view-thymeleaf)
#### ** Chinese **

[WebFlux](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-view-thymeleaf)

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Thymeleaf is a modern server-side Java template engine that emphasizes natural HTML templates that can be previewed in a browser by double-clicking, which is very helpful for independent work on UI templates (for example, by a designer) without the need for a running server. If you want to replace JSPs, Thymeleaf offers one of the most extensive set of features to make such a transition easier. Thymeleaf is actively developed and maintained. For a more complete introduction, see the [Thymeleaf](https://www.thymeleaf.org/) project home page.
#### ** Chinese **

Thymeleaf是一个现代的服务器端Java模板引擎，它强调的是自然的HTML模板，通过双击可以在浏览器中预览，这对于不需要运行服务器的情况下独立完成UI模板的工作（例如由设计人员完成）非常有帮助。如果你想取代JSP，Thymeleaf提供了一套最丰富的功能，让这样的过渡更容易。Thymeleaf正在积极开发和维护。更完整的介绍，请参阅[Thymeleaf](https://www.thymeleaf.org/)项目主页。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The Thymeleaf integration with Spring MVC is managed by the Thymeleaf project. The configuration involves a few bean declarations, such as `ServletContextTemplateResolver`, `SpringTemplateEngine`, and `ThymeleafViewResolver`. See [Thymeleaf+Spring](https://www.thymeleaf.org/documentation.html) for more details.
#### ** Chinese **

Thymeleaf与Spring MVC的集成由Thymeleaf项目管理。配置涉及一些Bean声明，例如`ServletContextTemplateResolver`、`SpringTemplateEngine`和`ThymeleafViewResolver`。更多详情请参见[Thymeleaf+Spring](https://www.thymeleaf.org/documentation.html)。

<!-- tabs:end -->


### **1.10.2. FreeMarker** 

<!-- tabs:start -->

#### ** English **

[WebFlux](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-view-freemarker)
#### ** Chinese **

[WebFlux](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-view-freemarker)

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

[Apache FreeMarker](https://freemarker.apache.org/) is a template engine for generating any kind of text output from HTML to email and others. The Spring Framework has built-in integration for using Spring MVC with FreeMarker templates.
#### ** Chinese **

[Apache FreeMarker](https://freemarker.apache.org/)是一个模板引擎，用于生成从HTML到电子邮件等任何类型的文本输出。Spring框架内置了Spring MVC与FreeMarker模板的集成。

<!-- tabs:end -->


### **View Configuration** 

<!-- tabs:start -->

#### ** English **

[WebFlux](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-view-freemarker-contextconfig)
#### ** Chinese **

[WebFlux](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-view-freemarker-contextconfig)

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following example shows how to configure FreeMarker as a view technology:
#### ** Chinese **

下面的例子显示了如何将FreeMarker配置为视图技术。

<!-- tabs:end -->


```java
@Configuration
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {

    @Override
    public void configureViewResolvers(ViewResolverRegistry registry) {
        registry.freeMarker();
    }

    // Configure FreeMarker...

    @Bean
    public FreeMarkerConfigurer freeMarkerConfigurer() {
        FreeMarkerConfigurer configurer = new FreeMarkerConfigurer();
        configurer.setTemplateLoaderPath("/WEB-INF/freemarker");
        return configurer;
    }
}
```

<!-- tabs:start -->

#### ** English **

The following example shows how to configure the same in XML:
#### ** Chinese **

下面的例子显示了如何在XML中进行相同的配置。

<!-- tabs:end -->


```xml
<mvc:annotation-driven/>

<mvc:view-resolvers>
    <mvc:freemarker/>
</mvc:view-resolvers>

<!-- Configure FreeMarker... -->
<mvc:freemarker-configurer>
    <mvc:template-loader-path location="/WEB-INF/freemarker"/>
</mvc:freemarker-configurer>
```

<!-- tabs:start -->

#### ** English **

Alternatively, you can also declare the `FreeMarkerConfigurer` bean for full control over all properties, as the following example shows:
#### ** Chinese **

或者，你也可以声明`FreeMarkerConfigurer` bean来完全控制所有属性，如下例所示。

<!-- tabs:end -->


```xml
<bean id="freemarkerConfig" class="org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer">
    <property name="templateLoaderPath" value="/WEB-INF/freemarker/"/>
</bean>
```

<!-- tabs:start -->

#### ** English **

Your templates need to be stored in the directory specified by the `FreeMarkerConfigurer` shown in the preceding example. Given the preceding configuration, if your controller returns a view name of `welcome`, the resolver looks for the `/WEB-INF/freemarker/welcome.ftl` template.
#### ** Chinese **

您的模板需要存储在前面示例中的 `FreeMarkerConfigurer`所指定的目录中。根据前面的配置，如果您的控制器返回的视图名称为 `welcome`，解析器将查找 `/WEB-INF/freemarker/welcome.ftl`模板。

<!-- tabs:end -->


### **FreeMarker Configuration** 

<!-- tabs:start -->

#### ** English **

[WebFlux](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-views-freemarker)
#### ** Chinese **

[WebFlux](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-views-freemarker)

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can pass FreeMarker 'Settings' and 'SharedVariables' directly to the FreeMarker `Configuration` object (which is managed by Spring) by setting the appropriate bean properties on the `FreeMarkerConfigurer` bean. The `freemarkerSettings` property requires a `java.util.Properties` object, and the `freemarkerVariables` property requires a `java.util.Map`. The following example shows how to use a `FreeMarkerConfigurer`:
#### ** Chinese **

你可以通过在`FreeMarkerConfiguration` bean上设置适当的bean属性，将FreeMarker'Settings'和'SharedVariables'直接传递给FreeMarker`Configuration`对象（由Spring管理）。`freemarkerSettings`属性需要一个`java.util.Properties`对象，而`freemarkerVariables`属性需要一个`java.util.Map`对象。下面的例子显示了如何使用`FreeMarkerConfigurer`。

<!-- tabs:end -->


```xml
<bean id="freemarkerConfig" class="org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer">
    <property name="templateLoaderPath" value="/WEB-INF/freemarker/"/>
    <property name="freemarkerVariables">
        <map>
            <entry key="xml_escape" value-ref="fmXmlEscape"/>
        </map>
    </property>
</bean>

<bean id="fmXmlEscape" class="freemarker.template.utility.XmlEscape"/>
```

<!-- tabs:start -->

#### ** English **

See the FreeMarker documentation for details of settings and variables as they apply to the `Configuration` object.
#### ** Chinese **

有关适用于`Configuration`对象的设置和变量的详细信息，请参阅FreeMarker文档。

<!-- tabs:end -->


### **Form Handling** 

<!-- tabs:start -->

#### ** English **

Spring provides a tag library for use in JSPs that contains, among others, a `<spring:bind/>` element. This element primarily lets forms display values from form-backing objects and show the results of failed validations from a `Validator` in the web or business tier. Spring also has support for the same functionality in FreeMarker, with additional convenience macros for generating form input elements themselves.
#### ** Chinese **

Spring 提供了一个用于 JSP 中的标记库，其中包含一个 `<spring:bind/>`元素。这个元素主要让表单显示来自表单支持对象的值，并显示来自web或业务层中的`Validator`验证失败的结果。在FreeMarker中，Spring也支持同样的功能，并为生成表单输入元素本身提供了额外的方便宏。

<!-- tabs:end -->


### **The Bind Macros** 

<!-- tabs:start -->

#### ** English **

[WebFlux](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-view-bind-macros)
#### ** Chinese **

[WebFlux](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-view-bind-macros)

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

A standard set of macros are maintained within the `spring-webmvc.jar` file for FreeMarker, so they are always available to a suitably configured application.
#### ** Chinese **

在FreeMarker的`spring-webmvc.jar`文件中维护了一组标准的宏，因此它们总是可以被适当配置的应用程序使用。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Some of the macros defined in the Spring templating libraries are considered internal (private), but no such scoping exists in the macro definitions, making all macros visible to calling code and user templates. The following sections concentrate only on the macros you need to directly call from within your templates. If you wish to view the macro code directly, the file is called `spring.ftl` and is in the `org.springframework.web.servlet.view.freemarker` package.
#### ** Chinese **

在Spring模板库中定义的一些宏被认为是内部的（私有的），但在宏定义中不存在这样的范围，使得所有的宏对调用代码和用户模板都是可见的。下面的章节只集中在您需要在模板中直接调用的宏。如果您希望直接查看宏代码，该文件名为 `spring.ftl`，位于 `org.springframework.web.servlet.view.freemarker`包中。

<!-- tabs:end -->


### **Simple Binding** 

<!-- tabs:start -->

#### ** English **

In your HTML forms based on FreeMarker templates that act as a form view for a Spring MVC controller, you can use code similar to the next example to bind to field values and display error messages for each input field in similar fashion to the JSP equivalent. The following example shows a `personForm` view:
#### ** Chinese **

在你的基于 FreeMarker 模板的 HTML 表单中，作为 Spring MVC 控制器的表单视图，你可以使用类似于下一个示例的代码来绑定字段值，并以类似于 JSP 的方式为每个输入字段显示错误信息。下面的示例显示了一个`personForm`视图。

<!-- tabs:end -->


```xml
<!-- FreeMarker macros have to be imported into a namespace.
    We strongly recommend sticking to 'spring'. -->
<#import "/spring.ftl" as spring/>
<html>
    ...
    <form action="" method="POST">
        Name:
        <@spring.bind "personForm.name"/>
        <input type="text"
            name="${spring.status.expression}"
            value="${spring.status.value?html}"/><br />
        <#list spring.status.errorMessages as error> <b>${error}</b> <br /> </#list>
        <br />
        ...
        <input type="submit" value="submit"/>
    </form>
    ...
</html>
```

<!-- tabs:start -->

#### ** English **

`<@spring.bind>` requires a 'path' argument, which consists of the name of your command object (it is 'command', unless you changed it in your controller configuration) followed by a period and the name of the field on the command object to which you wish to bind. You can also use nested fields, such as `command.address.street`. The `bind` macro assumes the default HTML escaping behavior specified by the `ServletContext` parameter `defaultHtmlEscape` in `web.xml`.
#### ** Chinese **

`<@spring.bind>`需要一个 "path "参数，它由命令对象的名称（除非您在控制器配置中更改了 "command"，否则就是 "command"）组成，后面是句号和命令对象上的字段名称，您希望与之绑定。您也可以使用嵌套字段，例如`command.address.street`。`bind`宏假定默认的HTML转义行为由`web.xml`中的`ServletContext`参数`defaultHtmlEscape`指定。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

An alternative form of the macro called `<@spring.bindEscaped>` takes a second argument that explicitly specifies whether HTML escaping should be used in the status error messages or values. You can set it to `true` or `false` as required. Additional form handling macros simplify the use of HTML escaping, and you should use these macros wherever possible. They are explained in the next section.
#### ** Chinese **

一个名为`<@spring.bindEscaped>`的宏的另一种形式，它需要第二个参数，明确地指定在状态错误信息或值中是否应该使用HTML转义。您可以根据需要将其设置为`true`或`false`。附加的表单处理宏简化了HTML转义的使用，您应该尽可能使用这些宏。它们将在下一节中解释。

<!-- tabs:end -->


### **Input Macros** 

<!-- tabs:start -->

#### ** English **

Additional convenience macros for FreeMarker simplify both binding and form generation (including validation error display). It is never necessary to use these macros to generate form input fields, and you can mix and match them with simple HTML or direct calls to the Spring bind macros that we highlighted previously.
#### ** Chinese **

FreeMarker的附加方便宏简化了绑定和表单生成（包括验证错误显示）。从来没有必要使用这些宏来生成表单输入字段，您可以将其与简单的HTML或直接调用我们之前强调的Spring绑定宏混合搭配。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following table of available macros shows the FreeMarker Template (FTL) definitions and the parameter list that each takes:
#### ** Chinese **

下面的可用宏表显示了FreeMarker Template (FTL)的定义以及每个宏的参数列表。

<!-- tabs:end -->


macro | FTL definition 
-|-
message (output a string from a resource bundle based on the code parameter) | <@spring.message code/> 
messageText (output a string from a resource bundle based on the code parameter, falling back to the value of the default parameter) | <@spring.messageText code, text/> 
url (prefix a relative URL with the application’s context root) | <@spring.url relativeUrl/> 
formInput (standard input field for gathering user input) | <@spring.formInput path, attributes, fieldType/> 
formHiddenInput (hidden input field for submitting non-user input) | <@spring.formHiddenInput path, attributes/> 
formPasswordInput (standard input field for gathering passwords. Note that no value is ever populated in fields of this type.) | <@spring.formPasswordInput path, attributes/> 
formTextarea (large text field for gathering long, freeform text input) | <@spring.formTextarea path, attributes/> 
formSingleSelect (drop down box of options that let a single required value be selected) | <@spring.formSingleSelect path, options, attributes/> 
formMultiSelect (a list box of options that let the user select 0 or more values) | <@spring.formMultiSelect path, options, attributes/> 
formRadioButtons (a set of radio buttons that let a single selection be made from the available choices) | <@spring.formRadioButtons path, options separator, attributes/> 
formCheckboxes (a set of checkboxes that let 0 or more values be selected) | <@spring.formCheckboxes path, options, separator, attributes/> 
formCheckbox (a single checkbox) | <@spring.formCheckbox path, attributes/> 
showErrors (simplify display of validation errors for the bound field) | <@spring.showErrors separator, classOrStyle/> 


<!-- tabs:start -->

#### ** English **

In FreeMarker templates, `formHiddenInput` and `formPasswordInput` are not actually required, as you can use the normal `formInput` macro, specifying `hidden` or `password` as the value for the `fieldType` parameter.
#### ** Chinese **

在FreeMarker模板中，`formHiddenInput`和`formPasswordInput`实际上并不是必需的，因为你可以使用普通的`formInput`宏，指定`hidden`或`password`作为`fieldType`参数的值。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The parameters to any of the above macros have consistent meanings:
#### ** Chinese **

上述任何一个宏的参数都有一致的含义。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

- `path`: The name of the field to bind to (ie "command.name")

- `options`: A `Map` of all the available values that can be selected from in the input field. The keys to the map represent the values that are POSTed back from the form and bound to the command object. Map objects stored against the keys are the labels displayed on the form to the user and may be different from the corresponding values posted back by the form. Usually, such a map is supplied as reference data by the controller. You can use any `Map` implementation, depending on required behavior. For strictly sorted maps, you can use a `SortedMap` (such as a `TreeMap`) with a suitable `Comparator` and, for arbitrary Maps that should return values in insertion order, use a `LinkedHashMap` or a `LinkedMap` from `commons-collections`.

- `separator`: Where multiple options are available as discreet elements (radio buttons or checkboxes), the sequence of characters used to separate each one in the list (such as `<br>`).

- `attributes`: An additional string of arbitrary tags or text to be included within the HTML tag itself. This string is echoed literally by the macro. For example, in a `textarea` field, you may supply attributes (such as 'rows="5" cols="60"'), or you could pass style information such as 'style="border:1px solid silver"'.

- `classOrStyle`: For the `showErrors` macro, the name of the CSS class that the `span` element that wraps each error uses. If no information is supplied (or the value is empty), the errors are wrapped in `<b></b>` tags.

#### ** Chinese **

- `path`：要绑定的字段名称（即 "command.name"）。

- `options`。`Map`：一个`Map`的所有可用值，可以从输入字段中选择。地图的键代表从表单中传回并绑定到命令对象的值。与按键相对应存储的贴图对象是在表单上显示给用户的标签，它可能与表单发回的相应值不同。通常情况下，这样的贴图是由控制器作为参考数据提供的。您可以使用任何`Map`实现，这取决于所需的行为。对于严格排序的映射，可以使用`SortedMap`（如`TreeMap`），并使用合适的`Comparator`；对于应该按插入顺序返回值的任意映射，可以使用`LinkedHashMap`或`commons-collections`中的`LinkedMap`。

- `separator`。当多个选项作为离散元素（单选按钮或复选框）可用时，用于分隔列表中每个选项的字符序列（如`<br>`）。

- `attributes`。在HTML标记本身中包含的任意标记或文本的附加字符串。这个字符串会被宏按字面意思呼应。例如，在`textarea`字段中，可以提供属性（如'rws="5" cols="60"），也可以传递样式信息，如'style="border:1px solid silver"'。

- `classOrStyle`。对于`showErrors`宏，是指包裹每个错误的`span`元素所使用的CSS类的名称。如果没有提供任何信息（或值为空），错误将被封装在`<b></b>`标记中。


<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

The following sections outline examples of the macros.
#### ** Chinese **

以下各节概述了宏的例子。

<!-- tabs:end -->


### Input Fields

<!-- tabs:start -->

#### ** English **

The `formInput` macro takes the `path` parameter (`command.name`) and an additional `attributes` parameter (which is empty in the upcoming example). The macro, along with all other form generation macros, performs an implicit Spring bind on the path parameter. The binding remains valid until a new bind occurs, so the `showErrors` macro does not need to pass the path parameter again — it operates on the field for which a binding was last created.
#### ** Chinese **

`formInput`宏使用了`path`参数（`command.name`）和一个额外的`attributes`参数（在接下来的示例中是空的）。这个宏和其他所有的表单生成宏一样，都会对路径参数执行一个隐式的Spring绑定。在新的绑定发生之前，该绑定仍然有效，所以`showErrors`宏不需要再次传递路径参数--它对上次创建绑定的字段进行操作。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The `showErrors` macro takes a separator parameter (the characters that are used to separate multiple errors on a given field) and also accepts a second parameter — this time, a class name or style attribute. Note that FreeMarker can specify default values for the attributes parameter. The following example shows how to use the `formInput` and `showWErrors` macros:
#### ** Chinese **

`showErrors`宏接受一个分隔符参数（用于分隔给定字段上的多个错误的字符），同时也接受第二个参数--这一次是类名或样式属性。注意，FreeMarker可以为属性参数指定默认值。下面的例子显示了如何使用`formInput`和`showWErrors`宏。

<!-- tabs:end -->


```xml
<@spring.formInput "command.name"/>
<@spring.showErrors "<br>"/>
```

<!-- tabs:start -->

#### ** English **

The next example shows the output of the form fragment, generating the name field and displaying a validation error after the form was submitted with no value in the field. Validation occurs through Spring’s Validation framework.
#### ** Chinese **

接下来的示例显示了表单片段的输出，生成名称字段，并在表单提交后显示了一个验证错误，而该字段中没有值。验证是通过Spring的验证框架进行的。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The generated HTML resembles the following example:
#### ** Chinese **

生成的HTML类似于下面的例子。

<!-- tabs:end -->


```html
Name:
<input type="text" name="name" value="">
<br>
    <b>required</b>
<br>
<br>
```

<!-- tabs:start -->

#### ** English **

The `formTextarea` macro works the same way as the `formInput` macro and accepts the same parameter list. Commonly, the second parameter (`attributes`) is used to pass style information or `rows` and `cols` attributes for the `textarea`.
#### ** Chinese **

`formTextarea`宏的工作方式与`formInput`宏相同，并且接受相同的参数列表。通常，第二个参数(`attributes`)用于为`textarea`传递样式信息或`rows`和`cols`属性。

<!-- tabs:end -->


### Selection Fields

<!-- tabs:start -->

#### ** English **

You can use four selection field macros to generate common UI value selection inputs in your HTML forms:
#### ** Chinese **

你可以使用四个选择字段宏来生成HTML表单中常见的UI值选择输入。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

- `formSingleSelect`

- `formMultiSelect`

- `formRadioButtons`

- `formCheckboxes`

#### ** Chinese **

- `表单单选`

- `表格多选`

- `formRadioButtonons`

- `表格检查框`


<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

Each of the four macros accepts a `Map` of options that contains the value for the form field and the label that corresponds to that value. The value and the label can be the same.
#### ** Chinese **

四个宏中的每个宏都接受一个`Map`选项，其中包含表单字段的值和对应于该值的标签。该值和标签可以是相同的。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The next example is for radio buttons in FTL. The form-backing object specifies a default value of 'London' for this field, so no validation is necessary. When the form is rendered, the entire list of cities to choose from is supplied as reference data in the model under the name 'cityMap'. The following listing shows the example:
#### ** Chinese **

接下来的例子是针对FTL中的单选按钮。表单支持对象为这个字段指定了一个默认值'London'，所以不需要验证。当表单被渲染时，整个城市列表作为参考数据在模型中以'cityMap'的名称提供给用户。下面的列表显示了这个例子。

<!-- tabs:end -->


```html
...
Town:
<@spring.formRadioButtons "command.address.town", cityMap, ""/><br><br>
```

<!-- tabs:start -->

#### ** English **

The preceding listing renders a line of radio buttons, one for each value in `cityMap`, and uses a separator of `""`. No additional attributes are supplied (the last parameter to the macro is missing). The `cityMap` uses the same `String` for each key-value pair in the map. The map’s keys are what the form actually submits as `POST` request parameters. The map values are the labels that the user sees. In the preceding example, given a list of three well known cities and a default value in the form backing object, the HTML resembles the following:
#### ** Chinese **

上面的列表显示了一行单选按钮，`cityMap`中的每个值都有一个，并使用了`""`的分隔符。没有提供额外的属性（宏的最后一个参数缺失）。`cityMap`为地图中的每个键值对使用相同的`String`。地图的键值是表单实际提交的`POST`请求参数。地图的值是用户看到的标签。在前面的例子中，给定一个三个知名城市的列表和表单支持对象中的默认值，HTML类似于下面的内容。

<!-- tabs:end -->


```html
Town:
<input type="radio" name="address.town" value="London">London</input>
<input type="radio" name="address.town" value="Paris" checked="checked">Paris</input>
<input type="radio" name="address.town" value="New York">New York</input>
```

<!-- tabs:start -->

#### ** English **

If your application expects to handle cities by internal codes (for example), you can create the map of codes with suitable keys, as the following example shows:
#### ** Chinese **

如果你的应用程序希望通过内部代码来处理城市（例如），你可以用合适的键来创建代码地图，如下例所示。

<!-- tabs:end -->


```java
protected Map<String, ?> referenceData(HttpServletRequest request) throws Exception {
    Map<String, String> cityMap = new LinkedHashMap<>();
    cityMap.put("LDN", "London");
    cityMap.put("PRS", "Paris");
    cityMap.put("NYC", "New York");

    Map<String, Object> model = new HashMap<>();
    model.put("cityMap", cityMap);
    return model;
}
```

<!-- tabs:start -->

#### ** English **

The code now produces output where the radio values are the relevant codes, but the user still sees the more user-friendly city names, as follows:
#### ** Chinese **

现在该代码产生的输出中，单选值是相关的代码，但用户仍然可以看到更友好的城市名称，如下所示。

<!-- tabs:end -->


```html
Town:
<input type="radio" name="address.town" value="LDN">London</input>
<input type="radio" name="address.town" value="PRS" checked="checked">Paris</input>
<input type="radio" name="address.town" value="NYC">New York</input>
```

### **HTML Escaping** 

<!-- tabs:start -->

#### ** English **

Default usage of the form macros described earlier results in HTML elements that are HTML 4.01 compliant and that use the default value for HTML escaping defined in your `web.xml` file, as used by Spring’s bind support. To make the elements be XHTML compliant or to override the default HTML escaping value, you can specify two variables in your template (or in your model, where they are visible to your templates). The advantage of specifying them in the templates is that they can be changed to different values later in the template processing to provide different behavior for different fields in your form.
#### ** Chinese **
默认使用前面描述的表单宏的结果是，HTML元素符合HTML 4.01标准，并且使用Spring的绑定支持中定义的 "`web.xml` "文件中的HTML转义默认值。为了使元素符合XHTML，或者覆盖默认的HTML转义值，你可以在你的模板中指定两个变量（或者在你的模型中，在你的模板中可以看到它们）。在模板中指定它们的好处是，在模板处理中可以在以后的模板处理中将它们改为不同的值，以便为表单中的不同字段提供不同的行为。


<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

To switch to XHTML compliance for your tags, specify a value of `true` for a model or context variable named `xhtmlCompliant`, as the following example shows:
#### ** Chinese **

要为您的标记切换到XHTML合规性，请为命名为`xhtmlCompliant`的模型或上下文变量指定一个`true`的值，如下例所示。

<!-- tabs:end -->


```xml
<#-- for FreeMarker -->
<#assign xhtmlCompliant = true>
```

<!-- tabs:start -->

#### ** English **

After processing this directive, any elements generated by the Spring macros are now XHTML compliant.
#### ** Chinese **

处理此指令后，由Spring宏生成的任何元素现在都符合XHTML标准。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

In similar fashion, you can specify HTML escaping per field, as the following example shows:
#### ** Chinese **

以类似的方式，你可以为每个字段指定HTML转义，如下例所示。

<!-- tabs:end -->


```xml
<#-- until this point, default HTML escaping is used -->

<#assign htmlEscape = true>
<#-- next field will use HTML escaping -->
<@spring.formInput "command.name"/>

<#assign htmlEscape = false in spring>
<#-- all future fields will be bound with HTML escaping off -->
```

### **1.10.3. Groovy Markup** 

<!-- tabs:start -->

#### ** English **

The [Groovy Markup Template Engine](http://groovy-lang.org/templating.html#_the_markuptemplateengine) is primarily aimed at generating XML-like markup (XML, XHTML, HTML5, and others), but you can use it to generate any text-based content. The Spring Framework has a built-in integration for using Spring MVC with Groovy Markup.
#### ** Chinese **

Groovy Markup模板引擎](http://groovy-lang.org/templating.html#_the_markuptemplateengine)主要是为了生成类似XML的标记（XML、XHTML、HTML5等），但你也可以用它来生成任何基于文本的内容。Spring框架有一个内置的集成，用于使用Spring MVC与Groovy Markup。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The Groovy Markup Template engine requires Groovy 2.3.1+.
#### ** Chinese **

Groovy Markup模板引擎需要Groovy 2.3.1以上。

<!-- tabs:end -->


### **Configuration** 

<!-- tabs:start -->

#### ** English **

The following example shows how to configure the Groovy Markup Template Engine:
#### ** Chinese **

下面的例子说明了如何配置Groovy Markup模板引擎。

<!-- tabs:end -->


```java
@Configuration
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {

    @Override
    public void configureViewResolvers(ViewResolverRegistry registry) {
        registry.groovy();
    }

    // Configure the Groovy Markup Template Engine...

    @Bean
    public GroovyMarkupConfigurer groovyMarkupConfigurer() {
        GroovyMarkupConfigurer configurer = new GroovyMarkupConfigurer();
        configurer.setResourceLoaderPath("/WEB-INF/");
        return configurer;
    }
}
```

<!-- tabs:start -->

#### ** English **

The following example shows how to configure the same in XML:
#### ** Chinese **

下面的例子显示了如何在XML中进行相同的配置。

<!-- tabs:end -->


```xml
<mvc:annotation-driven/>

<mvc:view-resolvers>
    <mvc:groovy/>
</mvc:view-resolvers>

<!-- Configure the Groovy Markup Template Engine... -->
<mvc:groovy-configurer resource-loader-path="/WEB-INF/"/>
```

### **Example** 

<!-- tabs:start -->

#### ** English **

Unlike traditional template engines, Groovy Markup relies on a DSL that uses a builder syntax. The following example shows a sample template for an HTML page:
#### ** Chinese **

与传统的模板引擎不同，Groovy Markup依赖于使用构建器语法的DSL。下面的例子显示了一个HTML页面的模板示例。

<!-- tabs:end -->


```html
yieldUnescaped '<!DOCTYPE html>'
html(lang:'en') {
    head {
        meta('http-equiv':'"Content-Type" content="text/html; charset=utf-8"')
        title('My page')
    }
    body {
        p('This is an example of HTML contents')
    }
}
```

### **1.10.4. Script Views** 

<!-- tabs:start -->

#### ** English **

[WebFlux](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-view-script)
#### ** Chinese **

[WebFlux](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-view-script)

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The Spring Framework has a built-in integration for using Spring MVC with any templating library that can run on top of the [JSR-223](https://www.jcp.org/en/jsr/detail?id=223) Java scripting engine. We have tested the following templating libraries on different script engines:
#### ** Chinese **

Spring框架有一个内置的集成，可以将Spring MVC与任何可以在[JSR-223](https://www.jcp.org/en/jsr/detail?id=223)Java脚本引擎之上运行的模板化库集成使用。我们在不同的脚本引擎上测试了以下的模板库。

<!-- tabs:end -->


Scripting Library | Scripting Engine 
-|-
Handlebars | Nashorn 
Mustache | Nashorn 
React | Nashorn 
EJS | Nashorn 
ERB | JRuby 
String templates | Jython 
Kotlin Script templating | Kotlin 


<!-- tabs:start -->

#### ** English **

The basic rule for integrating any other script engine is that it must implement the `ScriptEngine` and `Invocable` interfaces.
#### ** Chinese **

集成任何其他脚本引擎的基本规则是，它必须实现`ScriptEngine`和`Invocable`接口。

<!-- tabs:end -->


### **Requirements** 

<!-- tabs:start -->

#### ** English **

[WebFlux](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-view-script-dependencies)
#### ** Chinese **

[WebFlux](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-view-script-dependencies)

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You need to have the script engine on your classpath, the details of which vary by script engine:
#### ** Chinese **

你需要在你的classpath上安装脚本引擎，具体细节因脚本引擎而异。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

- The [Nashorn](https://openjdk.java.net/projects/nashorn/) JavaScript engine is provided with Java 8+. Using the latest update release available is highly recommended.

- [JRuby](https://www.jruby.org/) should be added as a dependency for Ruby support.

- [Jython](https://www.jython.org/) should be added as a dependency for Python support.

- `org.jetbrains.kotlin:kotlin-script-util` dependency and a `META-INF/services/javax.script.ScriptEngineFactory` file containing a `org.jetbrains.kotlin.script.jsr223.KotlinJsr223JvmLocalScriptEngineFactory` line should be added for Kotlin script support. See [this example](https://github.com/sdeleuze/kotlin-script-templating) for more details.

#### ** Chinese **

- Nashorn](https://openjdk.java.net/projects/nashorn/)的JavaScript引擎提供了Java 8+。强烈建议使用最新的更新版本。

- [JRuby](https://www.jruby.org/)应该被添加为支持Ruby的依赖项。

- 应该添加[Jython](https://www.jython.org/)作为Python支持的依赖。

- `org.jetbrains.kotlin:kotlin-script-util`依赖和一个`META-INF/services/javax.script.ScriptEngineFactory`文件，其中包含一个`org.jetbrains.kotlin.script.jsr223.KotlinJsr223JvmLocalScriptEngineFactory`行，应该添加为Kotlin脚本支持。更多细节请参见[这个例子](https://github.com/sdeleuze/kotlin-script-templating)。


<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

You need to have the script templating library. One way to do that for Javascript is through [WebJars](https://www.webjars.org/).
#### ** Chinese **

你需要有脚本模板化库。对Javascript来说，一种方法是通过[WebJars](https://www.webjars.org/)。

<!-- tabs:end -->


### **Script Templates** 

<!-- tabs:start -->

#### ** English **

[WebFlux](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-script-integrate)
#### ** Chinese **

[WebFlux](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-script-integrate)

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can declare a `ScriptTemplateConfigurer` bean to specify the script engine to use, the script files to load, what function to call to render templates, and so on. The following example uses Mustache templates and the Nashorn JavaScript engine:
#### ** Chinese **

你可以声明一个`ScriptTemplateConfigurer` bean来指定要使用的脚本引擎、加载的脚本文件、调用什么函数来渲染模板等等。下面的例子使用了Mustache模板和Nashorn JavaScript引擎。

<!-- tabs:end -->


```java
@Configuration
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {

    @Override
    public void configureViewResolvers(ViewResolverRegistry registry) {
        registry.scriptTemplate();
    }

    @Bean
    public ScriptTemplateConfigurer configurer() {
        ScriptTemplateConfigurer configurer = new ScriptTemplateConfigurer();
        configurer.setEngineName("nashorn");
        configurer.setScripts("mustache.js");
        configurer.setRenderObject("Mustache");
        configurer.setRenderFunction("render");
        return configurer;
    }
}
```

<!-- tabs:start -->

#### ** English **

The following example shows the same arrangement in XML:
#### ** Chinese **

下面的例子显示的是XML中的相同安排。

<!-- tabs:end -->


```xml
<mvc:annotation-driven/>

<mvc:view-resolvers>
    <mvc:script-template/>
</mvc:view-resolvers>

<mvc:script-template-configurer engine-name="nashorn" render-object="Mustache" render-function="render">
    <mvc:script location="mustache.js"/>
</mvc:script-template-configurer>
```

<!-- tabs:start -->

#### ** English **

The controller would look no different for the Java and XML configurations, as the following example shows:
#### ** Chinese **

对于Java和XML配置，控制器看起来没有什么不同，如下图所示。

<!-- tabs:end -->


```java
@Controller
public class SampleController {

    @GetMapping("/sample")
    public String test(Model model) {
        model.addAttribute("title", "Sample title");
        model.addAttribute("body", "Sample body");
        return "template";
    }
}
```

<!-- tabs:start -->

#### ** English **

The following example shows the Mustache template:
#### ** Chinese **

下面的例子是小胡子模板。

<!-- tabs:end -->


```html
<html>
    <head>
        <title>{{title}}</title>
    </head>
    <body>
        <p>{{body}}</p>
    </body>
</html>
```

<!-- tabs:start -->

#### ** English **

The render function is called with the following parameters:
#### ** Chinese **

渲染函数的调用参数如下。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

- `String template`: The template content

- `Map model`: The view model

- `RenderingContext renderingContext`: The [`RenderingContext`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/web/servlet/view/script/RenderingContext.html) that gives access to the application context, the locale, the template loader, and the URL (since 5.0)

#### ** Chinese **

- `字符串模板`：模板内容

- `地图模型`：视图模型

- `RenderingContext renderingContext`：[`RenderingContext`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/web/servlet/view/script/RenderingContext.html)，它提供了对应用程序上下文、locale、模板加载器和URL的访问（自5.0以来）。


<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

`Mustache.render()` is natively compatible with this signature, so you can call it directly.
#### ** Chinese **

`Mustache.render()`原生地与此签名兼容，所以你可以直接调用它。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

If your templating technology requires some customization, you can provide a script that implements a custom render function. For example, [Handlerbars](https://handlebarsjs.com/) needs to compile templates before using them and requires a [polyfill](https://en.wikipedia.org/wiki/Polyfill) to emulate some browser facilities that are not available in the server-side script engine.
#### ** Chinese **

如果你的模板化技术需要一些定制，可以提供一个脚本，实现自定义的渲染函数。例如，[Handlerbars](https://handlebarsjs.com/)在使用模板之前需要编译模板，并且需要[polyfill](https://en.wikipedia.org/wiki/Polyfill)来模拟一些服务器端脚本引擎中没有的浏览器设施。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following example shows how to do so:
#### ** Chinese **

下面的例子说明了如何做到这一点。

<!-- tabs:end -->


```java
@Configuration
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {

    @Override
    public void configureViewResolvers(ViewResolverRegistry registry) {
        registry.scriptTemplate();
    }

    @Bean
    public ScriptTemplateConfigurer configurer() {
        ScriptTemplateConfigurer configurer = new ScriptTemplateConfigurer();
        configurer.setEngineName("nashorn");
        configurer.setScripts("polyfill.js", "handlebars.js", "render.js");
        configurer.setRenderFunction("render");
        configurer.setSharedEngine(false);
        return configurer;
    }
}
```

<!-- tabs:start -->

#### ** English **

Setting the `sharedEngine` property to `false` is required when using non-thread-safe script engines with templating libraries not designed for concurrency, such as Handlebars or React running on Nashorn. In that case, Java SE 8 update 60 is required, due to [this bug](https://bugs.openjdk.java.net/browse/JDK-8076099), but it is generally recommended to use a recent Java SE patch release in any case.
#### ** Chinese **

当使用非线程安全的脚本引擎和不为并发设计的模板库（如Handlebars或运行在Nashorn上的React）时，需要将`sharedEngine`属性设置为`false`。在这种情况下，由于[这个bug](https://bugs.openjdk.java.net/browse/JDK-8076099)，需要Java SE 8更新60，但一般建议使用最近的Java SE补丁版本。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

`polyfill.js` defines only the `window` object needed by Handlebars to run properly, as follows:
#### ** Chinese **

`polyfill.js`只定义了Handlebars所需的`window`对象，以便正常运行，如下所示。

<!-- tabs:end -->


```javascript
var window = {};
```

<!-- tabs:start -->

#### ** English **

This basic `render.js` implementation compiles the template before using it. A production-ready implementation should also store any reused cached templates or pre-compiled templates. You can do so on the script side (and handle any customization you need — managing template engine configuration, for example). The following example shows how to do so:
#### ** Chinese **

这个基本的`render.js`实现在使用模板之前会对模板进行编译。一个生产就绪的实现还应该存储任何重复使用的缓存模板或预编译模板。你可以在脚本端这样做（并处理你需要的任何定制 - 例如管理模板引擎配置）。下面的例子显示了如何做到这一点。

<!-- tabs:end -->


```javascript
function render(template, model) {
    var compiledTemplate = Handlebars.compile(template);
    return compiledTemplate(model);
}
```

<!-- tabs:start -->

#### ** English **

Check out the Spring Framework unit tests, [Java](https://github.com/spring-projects/spring-framework/tree/master/spring-webmvc/src/test/java/org/springframework/web/servlet/view/script), and [resources](https://github.com/spring-projects/spring-framework/tree/master/spring-webmvc/src/test/resources/org/springframework/web/servlet/view/script), for more configuration examples.
#### ** Chinese **

查看Spring框架的单元测试，[Java](https://github.com/spring-projects/spring-framework/tree/master/spring-webmvc/src/test/java/org/springframework/web/servlet/view/script)和[资源](https://github.com/spring-projects/spring-framework/tree/master/spring-webmvc/src/test/resources/org/springframework/web/servlet/view/script)，了解更多的配置示例。

<!-- tabs:end -->


### **1.10.5. JSP and JSTL** 

<!-- tabs:start -->

#### ** English **

The Spring Framework has a built-in integration for using Spring MVC with JSP and JSTL.
#### ** Chinese **

Spring框架有一个内置的Spring MVC与JSP和JSTL的集成。

<!-- tabs:end -->


### **View Resolvers** 

<!-- tabs:start -->

#### ** English **

When developing with JSPs, you can declare a `InternalResourceViewResolver` or a `ResourceBundleViewResolver` bean.
#### ** Chinese **

当使用JSP开发时，可以声明一个`InternalResourceViewResolver`或`ResourceBundleViewResolver` bean。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

`ResourceBundleViewResolver` relies on a properties file to define the view names mapped to a class and a URL. With a `ResourceBundleViewResolver`, you can mix different types of views by using only one resolver, as the following example shows:
#### ** Chinese **

`ResourceBundleViewResolver`依赖于一个属性文件来定义映射到类和URL的视图名称。使用 `ResourceBundleViewResolver`，您可以通过只使用一个解析器来混合不同类型的视图，如下例所示。

<!-- tabs:end -->


```xml
<!-- the ResourceBundleViewResolver -->
<bean id="viewResolver" class="org.springframework.web.servlet.view.ResourceBundleViewResolver">
    <property name="basename" value="views"/>
</bean>

# And a sample properties file is used (views.properties in WEB-INF/classes):
<!-- tabs:start -->

#### ** English **

welcome.(class)=org.springframework.web.servlet.view.JstlView
#### ** Chinese **

welcome.(class)=org.springframework.web.servlet.view.JstlView

<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

welcome.url=/WEB-INF/jsp/welcome.jsp
#### ** Chinese **

welcome.url=/WEB-INF/jsp/welcome.jsp

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

productList.(class)=org.springframework.web.servlet.view.JstlView
#### ** Chinese **

productList.(class)=org.springframework.web.servlet.view.JstlView

<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

productList.url=/WEB-INF/jsp/productlist.jsp
#### ** Chinese **

productList.url=/WEB-INF/jsp/productlist.jsp

<!-- tabs:end -->

```

`InternalResourceViewResolver` can also be used for JSPs. As a best practice, we strongly encourage placing your JSP files in a directory under the `'WEB-INF'` directory so there can be no direct access by clients.

```xml
<!-- tabs:start -->

#### ** English **

<bean id="viewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver">
#### ** Chinese **

<bean id="viewResolver "class="org.springframework.web.servlet.view.InternalResourceViewResolver">

<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

    <property name="viewClass" value="org.springframework.web.servlet.view.JstlView"/>
#### ** Chinese **

    <property name="viewClass "value="org.springframework.web.servlet.view.JstlView"/><property name="viewClass" value="org.springframework.web.servlet.view.JstlView"/></></>

<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

    <property name="prefix" value="/WEB-INF/jsp/"/>
#### ** Chinese **

    <property name="prefix" value="/WEB-INF/jsp/"/><property name="prefix" value="/WEB-INF/jsp/"/>

<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

    <property name="suffix" value=".jsp"/>
#### ** Chinese **

    <property name="supix" value=".jsp"/><property name="supix" value=".jsp"/>

<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

</bean>
#### ** Chinese **

</豆>

<!-- tabs:end -->

```

### **JSPs versus JSTL** 

<!-- tabs:start -->

#### ** English **

When using the JSP Standard Tag Library (JSTL) you must use a special view class, the `JstlView`, as JSTL needs some preparation before things such as the I18N features can work.
#### ** Chinese **

当使用JSP标准标签库（JSTL）时，你必须使用一个特殊的视图类`JstlView`，因为JSTL需要一些准备工作，然后才可以使用I18N等功能。

<!-- tabs:end -->


### **Spring’s JSP Tag Library** 

<!-- tabs:start -->

#### ** English **

Spring provides data binding of request parameters to command objects, as described in earlier chapters. To facilitate the development of JSP pages in combination with those data binding features, Spring provides a few tags that make things even easier. All Spring tags have HTML escaping features to enable or disable escaping of characters.
#### ** Chinese **

Spring提供了请求参数与命令对象的数据绑定功能，正如前面几章所描述的那样。为了方便结合这些数据绑定功能开发JSP页面，Spring提供了一些标记，使事情变得更加简单。所有的Spring标记都有HTML转义功能，可以启用或禁用字符转义。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The `spring.tld` tag library descriptor (TLD) is included in the `spring-webmvc.jar`. For a comprehensive reference on individual tags, browse the [API reference](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/web/servlet/tags/package-summary.html#package.description) or see the tag library description.
#### ** Chinese **

`spring.tld`标签库描述符（TLD）包含在`spring-webmvc.jar`中。关于单个标签的全面参考，请浏览[API参考](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/web/servlet/tags/package-summary.html#package.description)或查看标签库描述。

<!-- tabs:end -->


### **Spring’s form tag library** 

<!-- tabs:start -->

#### ** English **

As of version 2.0, Spring provides a comprehensive set of data binding-aware tags for handling form elements when using JSP and Spring Web MVC. Each tag provides support for the set of attributes of its corresponding HTML tag counterpart, making the tags familiar and intuitive to use. The tag-generated HTML is HTML 4.01/XHTML 1.0 compliant.
#### ** Chinese **

从2.0版本开始，Spring提供了一组全面的数据绑定感知标签，用于在使用JSP和Spring Web MVC时处理表单元素。每个标签都提供了对其对应的HTML标签对应的属性集的支持，这使得这些标签的使用变得非常熟悉和直观。标签生成的HTML符合HTML 4.01/XHTML 1.0标准。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Unlike other form/input tag libraries, Spring’s form tag library is integrated with Spring Web MVC, giving the tags access to the command object and reference data your controller deals with. As we show in the following examples, the form tags make JSPs easier to develop, read, and maintain.
#### ** Chinese **

与其他窗体/输入标签库不同，Spring的窗体标签库与Spring Web MVC集成在一起，可以让标签访问命令对象和控制器处理的引用数据。正如我们在下面的示例中所展示的那样，表单标记使JSP更容易开发、读取和维护。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

We go through the form tags and look at an example of how each tag is used. We have included generated HTML snippets where certain tags require further commentary.
#### ** Chinese **

我们通过表单标签，看看每个标签的使用实例。我们已经包含了生成的HTML片段，其中某些标签需要进一步注释。

<!-- tabs:end -->


### **Configuration** 

<!-- tabs:start -->

#### ** English **

The form tag library comes bundled in `spring-webmvc.jar`. The library descriptor is called `spring-form.tld`.
#### ** Chinese **

表单标签库绑定在`spring-webmvc.jar`中。库的描述符叫做`spring-form.tld`。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

To use the tags from this library, add the following directive to the top of your JSP page:
#### ** Chinese **

要使用这个库中的标签，请在JSP页面的顶部添加以下指令。

<!-- tabs:end -->


```html
<%@ taglib prefix="form" uri="http://www.springframework.org/tags/form" %>
```

<!-- tabs:start -->

#### ** English **

where `form` is the tag name prefix you want to use for the tags from this library.
#### ** Chinese **

其中`form`是您要为这个库中的标签使用的标签名前缀。

<!-- tabs:end -->


### **The Form Tag** 

<!-- tabs:start -->

#### ** English **

This tag renders an HTML 'form' element and exposes a binding path to inner tags for binding. It puts the command object in the `PageContext` so that the command object can be accessed by inner tags. All the other tags in this library are nested tags of the `form` tag.
#### ** Chinese **

这个标记渲染了一个HTML "表单 "元素，并暴露了一个绑定路径到内部标签的绑定路径。它将命令对象放在`PageContext`中，以便内部标记可以访问命令对象。这个库中的所有其他标签都是`form`标签的嵌套标签。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Assume that we have a domain object called `User`. It is a JavaBean with properties such as `firstName` and `lastName`. We can use it as the form-backing object of our form controller, which returns `form.jsp`. The following example shows what `form.jsp` could look like:
#### ** Chinese **

假设我们有一个名为`User`的域对象。它是一个JavaBean，具有`firstName`和`lastName`等属性。我们可以用它作为表单控制器的表单支持对象，返回`form.jsp`。下面的例子显示了`form.jsp`的样子。

<!-- tabs:end -->


```html
<form:form>
    <table>
        <tr>
            <td>First Name:</td>
            <td><form:input path="firstName"/></td>
        </tr>
        <tr>
            <td>Last Name:</td>
            <td><form:input path="lastName"/></td>
        </tr>
        <tr>
            <td colspan="2">
                <input type="submit" value="Save Changes"/>
            </td>
        </tr>
    </table>
</form:form>
```

<!-- tabs:start -->

#### ** English **

The `firstName` and `lastName` values are retrieved from the command object placed in the `PageContext` by the page controller. Keep reading to see more complex examples of how inner tags are used with the `form` tag.
#### ** Chinese **

`firstName`和`lastName`的值由页面控制器从放置在`PageContext`中的命令对象中获取。继续阅读，查看更多关于内部标签如何与`form`标签一起使用的复杂例子。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following listing shows the generated HTML, which looks like a standard form:
#### ** Chinese **

下面的列表显示的是生成的HTML，看起来像一个标准表格。

<!-- tabs:end -->


```html
<form method="POST">
    <table>
        <tr>
            <td>First Name:</td>
            <td><input name="firstName" type="text" value="Harry"/></td>
        </tr>
        <tr>
            <td>Last Name:</td>
            <td><input name="lastName" type="text" value="Potter"/></td>
        </tr>
        <tr>
            <td colspan="2">
                <input type="submit" value="Save Changes"/>
            </td>
        </tr>
    </table>
</form>
```

<!-- tabs:start -->

#### ** English **

The preceding JSP assumes that the variable name of the form-backing object is `command`. If you have put the form-backing object into the model under another name (definitely a best practice), you can bind the form to the named variable, as the following example shows:
#### ** Chinese **

前面的JSP假设表单支持对象的变量名是`command`。如果你把表单支持对象以另一个名称放入模型中（肯定是最好的做法），你可以把表单绑定到命名的变量上，如下例所示。

<!-- tabs:end -->


```html
<form:form modelAttribute="user">
    <table>
        <tr>
            <td>First Name:</td>
            <td><form:input path="firstName"/></td>
        </tr>
        <tr>
            <td>Last Name:</td>
            <td><form:input path="lastName"/></td>
        </tr>
        <tr>
            <td colspan="2">
                <input type="submit" value="Save Changes"/>
            </td>
        </tr>
    </table>
</form:form>
```

### **The** **`input`** ** Tag** 

<!-- tabs:start -->

#### ** English **

This tag renders an HTML `input` element with the bound value and `type='text'` by default. For an example of this tag, see [The Form Tag](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-view-jsp-formtaglib-formtag). You can also use HTML5-specific types, such as `email`, `tel`, `date`, and others.
#### ** Chinese **

此标记显示一个HTML `input`元素，默认为绑定值和`type='text'`。有关此标记的示例，请参阅 [The Form Tag](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-view-jsp-formtaglib-formtag)。您也可以使用 HTML5 特定的类型，例如 `email`、`tel`、`date`等。

<!-- tabs:end -->


### **The** **`checkbox`** ** Tag** 

<!-- tabs:start -->

#### ** English **

This tag renders an HTML `input` tag with the `type` set to `checkbox`.
#### ** Chinese **

此标记显示一个HTML `input`标记，将`type`设置为`checkbox`。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Assume that our `User` has preferences such as newsletter subscription and a list of hobbies. The following example shows the `Preferences` class:
#### ** Chinese **

假设我们的`User`有一些偏好，比如订阅电子报和兴趣爱好列表。下面的例子显示了`Preferences`类。

<!-- tabs:end -->


```java
public class Preferences {

    private boolean receiveNewsletter;
    private String[] interests;
    private String favouriteWord;

    public boolean isReceiveNewsletter() {
        return receiveNewsletter;
    }

    public void setReceiveNewsletter(boolean receiveNewsletter) {
        this.receiveNewsletter = receiveNewsletter;
    }

    public String[] getInterests() {
        return interests;
    }

    public void setInterests(String[] interests) {
        this.interests = interests;
    }

    public String getFavouriteWord() {
        return favouriteWord;
    }

    public void setFavouriteWord(String favouriteWord) {
        this.favouriteWord = favouriteWord;
    }
}
```

<!-- tabs:start -->

#### ** English **

The corresponding `form.jsp` could then resemble the following:
#### ** Chinese **

相应的`form.jsp`可以像下面这样。

<!-- tabs:end -->


```html
<form:form>
    <table>
        <tr>
            <td>Subscribe to newsletter?:</td>
            <%-- Approach 1: Property is of type java.lang.Boolean --%>
            <td><form:checkbox path="preferences.receiveNewsletter"/></td>
        </tr>

        <tr>
            <td>Interests:</td>
            <%-- Approach 2: Property is of an array or of type java.util.Collection --%>
            <td>
                Quidditch: <form:checkbox path="preferences.interests" value="Quidditch"/>
                Herbology: <form:checkbox path="preferences.interests" value="Herbology"/>
                Defence Against the Dark Arts: <form:checkbox path="preferences.interests" value="Defence Against the Dark Arts"/>
            </td>
        </tr>

        <tr>
            <td>Favourite Word:</td>
            <%-- Approach 3: Property is of type java.lang.Object --%>
            <td>
                Magic: <form:checkbox path="preferences.favouriteWord" value="Magic"/>
            </td>
        </tr>
    </table>
</form:form>
```

<!-- tabs:start -->

#### ** English **

There are three approaches to the `checkbox` tag, which should meet all your checkbox needs.
#### ** Chinese **

`checkbox`标签有三种方法，应该可以满足你所有的复选框需求。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

- Approach One: When the bound value is of type `java.lang.Boolean`, the `input(checkbox)` is marked as `checked` if the bound value is `true`. The `value` attribute corresponds to the resolved value of the `setValue(Object)` value property.

- Approach Two: When the bound value is of type `array` or `java.util.Collection`, the `input(checkbox)` is marked as `checked` if the configured `setValue(Object)` value is present in the bound `Collection`.

- Approach Three: For any other bound value type, the `input(checkbox)` is marked as `checked` if the configured `setValue(Object)` is equal to the bound value.

#### ** Chinese **

- 方法一：当绑定的值类型为`java.lang.Boolean`时，如果绑定的值为`true`，则`input(checkbox)`被标记为`checked`。`value`属性对应于`setValue(Object)`值属性的解析值。

- 方法二：当绑定的值是类型为`array`或`java.util.Collection`时，如果配置的`setValue(Object)`值存在于绑定的`Collection`中，则将`input(checkbox)`标记为`checked`。

- 方法三。对于任何其他绑定的值类型，如果配置的`setValue(Object)`值等于绑定的值，则将`input(复选框)`标记为`checked`。


<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

Note that, regardless of the approach, the same HTML structure is generated. The following HTML snippet defines some checkboxes:
#### ** Chinese **

注意，无论采用哪种方法，都会生成相同的HTML结构。下面的HTML片段定义了一些复选框。

<!-- tabs:end -->


```html
<tr>
    <td>Interests:</td>
    <td>
        Quidditch: <input name="preferences.interests" type="checkbox" value="Quidditch"/>
        <input type="hidden" value="1" name="_preferences.interests"/>
        Herbology: <input name="preferences.interests" type="checkbox" value="Herbology"/>
        <input type="hidden" value="1" name="_preferences.interests"/>
        Defence Against the Dark Arts: <input name="preferences.interests" type="checkbox" value="Defence Against the Dark Arts"/>
        <input type="hidden" value="1" name="_preferences.interests"/>
    </td>
</tr>
```

<!-- tabs:start -->

#### ** English **

You might not expect to see the additional hidden field after each checkbox. When a checkbox in an HTML page is not checked, its value is not sent to the server as part of the HTTP request parameters once the form is submitted, so we need a workaround for this quirk in HTML for Spring form data binding to work. The `checkbox` tag follows the existing Spring convention of including a hidden parameter prefixed by an underscore (`_`) for each checkbox. By doing this, you are effectively telling Spring that “the checkbox was visible in the form, and I want my object to which the form data binds to reflect the state of the checkbox, no matter what.”
#### ** Chinese **

你可能不会想到在每个复选框之后会看到额外的隐藏字段。当HTML页面中的复选框没有被选中时，一旦表单提交后，它的值不会作为HTTP请求参数的一部分被发送到服务器，因此我们需要在HTML中为Spring表单数据绑定提供一个变通的方法。`checkbox`标签遵循了现有的Spring惯例，即为每个复选框包含一个由下划线(`_`)前缀的隐藏参数。通过这样做，你实际上是在告诉Spring "复选框在表单中是可见的，我希望我的表单数据绑定的对象能够反映出复选框的状态，无论如何都是如此。"

<!-- tabs:end -->


### **The** **`checkboxes`** ** Tag** 

<!-- tabs:start -->

#### ** English **

This tag renders multiple HTML `input` tags with the `type` set to `checkbox`.
#### ** Chinese **

此标记显示多个HTML `input`标记，并将`type`设置为`checkbox`。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

This section build on the example from the previous `checkbox` tag section. Sometimes, you prefer not to have to list all the possible hobbies in your JSP page. You would rather provide a list at runtime of the available options and pass that in to the tag. That is the purpose of the `checkboxes` tag. You can pass in an `Array`, a `List`, or a `Map` that contains the available options in the `items` property. Typically, the bound property is a collection so that it can hold multiple values selected by the user. The following example shows a JSP that uses this tag:
#### ** Chinese **

本节是在前面`checkbox`标签部分的例子基础上建立的。有时，你不希望在JSP页面中列出所有可能的爱好。你宁愿在运行时提供一个可用选项的列表，然后将其传递到标记中。这就是`checkboxes`标记的目的。您可以传入 `Array`、`List`或`Map`，其中包含`items`属性中的可用选项。通常情况下，绑定的属性是一个集合，这样它可以容纳用户选择的多个值。下面的例子显示了一个使用该标记的JSP。

<!-- tabs:end -->


```html
<form:form>
    <table>
        <tr>
            <td>Interests:</td>
            <td>
                <%-- Property is of an array or of type java.util.Collection --%>
                <form:checkboxes path="preferences.interests" items="${interestList}"/>
            </td>
        </tr>
    </table>
</form:form>
```

<!-- tabs:start -->

#### ** English **

This example assumes that the `interestList` is a `List` available as a model attribute that contains strings of the values to be selected from. If you use a `Map`, the map entry key is used as the value, and the map entry’s value is used as the label to be displayed. You can also use a custom object where you can provide the property names for the value by using `itemValue` and the label by using `itemLabel`.
#### ** Chinese **

这个例子假设`interestList`是一个`List`，作为一个模型属性可用，其中包含要选择的值的字符串。如果使用`Map`，则使用地图条目键作为值，地图条目的值作为要显示的标签。您也可以使用自定义对象，其中您可以使用`itemValue`为值提供属性名，并使用`itemLabel`提供标签。

<!-- tabs:end -->


### **The** **`radiobutton`** ** Tag** 

<!-- tabs:start -->

#### ** English **

This tag renders an HTML `input` element with the `type` set to `radio`.
#### ** Chinese **

此标记显示一个HTML `input`元素，将`type`设置为`radio`。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

A typical usage pattern involves multiple tag instances bound to the same property but with different values, as the following example shows:
#### ** Chinese **

一个典型的使用模式是将多个标记实例绑定到同一个属性，但值不同，如下例所示。

<!-- tabs:end -->


```html
<tr>
    <td>Sex:</td>
    <td>
        Male: <form:radiobutton path="sex" value="M"/> <br/>
        Female: <form:radiobutton path="sex" value="F"/>
    </td>
</tr>
```

### **The** **`radiobuttons`** ** Tag** 

<!-- tabs:start -->

#### ** English **

This tag renders multiple HTML `input` elements with the `type` set to `radio`.
#### ** Chinese **

此标记显示多个HTML `input`元素，并将`type`设置为`radio`。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

As with the [`checkboxes`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-view-jsp-formtaglib-checkboxestag)[ tag](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-view-jsp-formtaglib-checkboxestag), you might want to pass in the available options as a runtime variable. For this usage, you can use the `radiobuttons` tag. You pass in an `Array`, a `List`, or a `Map` that contains the available options in the `items` property. If you use a `Map`, the map entry key is used as the value and the map entry’s value are used as the label to be displayed. You can also use a custom object where you can provide the property names for the value by using `itemValue` and the label by using `itemLabel`, as the following example shows:
#### ** Chinese **

与 [`checkboxes`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-view-jsp-formtaglib-checkboxestag)[标签](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-view-jsp-formtaglib-checkboxestag)一样，您可能希望将可用的选项作为运行时变量传递给用户。对于这种用法，您可以使用`radiobuttons`标签。您可以传递一个`Array`、`List`或`Map`，其中包含`items`属性中的可用选项。如果使用`Map`，则使用地图条目键作为值，地图条目的值作为要显示的标签。您也可以使用自定义对象，其中您可以使用`itemValue`为值提供属性名，使用`itemLabel`为标签提供属性名，如下例所示。

<!-- tabs:end -->


```html
<tr>
    <td>Sex:</td>
    <td><form:radiobuttons path="sex" items="${sexOptions}"/></td>
</tr>
```

### **The** **`password`** ** Tag** 

<!-- tabs:start -->

#### ** English **

This tag renders an HTML `input` tag with the type set to `password` with the bound value.
#### ** Chinese **

此标记显示一个HTML `input`标记，类型设置为`password`，绑定值为`password`。

<!-- tabs:end -->


```html
<tr>
    <td>Password:</td>
    <td>
        <form:password path="password"/>
    </td>
</tr>
```

<!-- tabs:start -->

#### ** English **

Note that, by default, the password value is not shown. If you do want the password value to be shown, you can set the value of the `showPassword` attribute to `true`, as the following example shows:
#### ** Chinese **

注意，默认情况下，密码值不会显示。如果您希望显示密码值，可以将`showPassword`属性的值设置为`true`，如下例所示。

<!-- tabs:end -->


```html
<tr>
    <td>Password:</td>
    <td>
        <form:password path="password" value="^76525bvHGq" showPassword="true"/>
    </td>
</tr>
```

### **The** **`select`** ** Tag** 

<!-- tabs:start -->

#### ** English **

This tag renders an HTML 'select' element. It supports data binding to the selected option as well as the use of nested `option` and `options` tags.
#### ** Chinese **

这个标记渲染了一个HTML "select "元素。它支持与所选选项的数据绑定，以及使用嵌套的`option`和`options`标签。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Assume that a `User` has a list of skills. The corresponding HTML could be as follows:
#### ** Chinese **

假设一个`User`有一个技能列表。相应的HTML可能如下：

<!-- tabs:end -->


```html
<tr>
    <td>Skills:</td>
    <td><form:select path="skills" items="${skills}"/></td>
</tr>
```

<!-- tabs:start -->

#### ** English **

If the `User’s` skill are in Herbology, the HTML source of the 'Skills' row could be as follows:
#### ** Chinese **

如果`User’s`技能是在草药学中，那么 "技能 "行的HTML来源可以如下。

<!-- tabs:end -->


```html
<tr>
    <td>Skills:</td>
    <td>
        <select name="skills" multiple="true">
            <option value="Potions">Potions</option>
            <option value="Herbology" selected="selected">Herbology</option>
            <option value="Quidditch">Quidditch</option>
        </select>
    </td>
</tr>
```

### **The** **`option`** ** Tag** 

<!-- tabs:start -->

#### ** English **

This tag renders an HTML `option` element. It sets `selected`, based on the bound value. The following HTML shows typical output for it:
#### ** Chinese **

这个标记渲染一个HTML `option`元素。它根据绑定值设置`selected`。下面的HTML显示了它的典型输出。

<!-- tabs:end -->


```html
<tr>
    <td>House:</td>
    <td>
        <form:select path="house">
            <form:option value="Gryffindor"/>
            <form:option value="Hufflepuff"/>
            <form:option value="Ravenclaw"/>
            <form:option value="Slytherin"/>
        </form:select>
    </td>
</tr>
```

<!-- tabs:start -->

#### ** English **

If the `User’s` house was in Gryffindor, the HTML source of the 'House' row would be as follows:
#### ** Chinese **

如果`User’s`房子在Gryffindor，那么 "房子 "行的HTML源将如下。

<!-- tabs:end -->


```html
<tr>
    <td>House:</td>
    <td>
        <select name="house">
            <option value="Gryffindor" selected="selected">Gryffindor</option> (1)
            <option value="Hufflepuff">Hufflepuff</option>
            <option value="Ravenclaw">Ravenclaw</option>
            <option value="Slytherin">Slytherin</option>
        </select>
    </td>
</tr>
```

<!-- tabs:start -->

#### ** English **

(1)Note the addition of a `selected` attribute.
#### ** Chinese **

(1)注意增加一个`selected`属性。

<!-- tabs:end -->


### **The** **`options`** ** Tag** 

<!-- tabs:start -->

#### ** English **

This tag renders a list of HTML `option` elements. It sets the `selected` attribute, based on the bound value. The following HTML shows typical output for it:
#### ** Chinese **

这个标记渲染了一个HTML `option`元素的列表。它根据绑定的值设置了`selected`属性。下面的HTML显示了它的典型输出。

<!-- tabs:end -->


```html
<tr>
    <td>Country:</td>
    <td>
        <form:select path="country">
            <form:option value="-" label="--Please Select"/>
            <form:options items="${countryList}" itemValue="code" itemLabel="name"/>
        </form:select>
    </td>
</tr>
```

<!-- tabs:start -->

#### ** English **

If the `User` lived in the UK, the HTML source of the 'Country' row would be as follows:
#### ** Chinese **

如果`User`住在英国，"国家 "行的HTML源将如下所示。

<!-- tabs:end -->


```html
<tr>
    <td>Country:</td>
    <td>
        <select name="country">
            <option value="-">--Please Select</option>
            <option value="AT">Austria</option>
            <option value="UK" selected="selected">United Kingdom</option> (1)
            <option value="US">United States</option>
        </select>
    </td>
</tr>
```

<!-- tabs:start -->

#### ** English **

(1)Note the addition of a `selected` attribute.
#### ** Chinese **

(1)注意增加一个`selected`属性。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

As the preceding example shows, the combined usage of an `option` tag with the `options` tag generates the same standard HTML but lets you explicitly specify a value in the JSP that is for display only (where it belongs), such as the default string in the example: "-- Please Select".
#### ** Chinese **

正如前面的例子所示，将`option`标签与`options`标签结合使用，可以生成相同的标准HTML，但可以在JSP中明确指定一个只用于显示的值（它的位置），例如例子中的默认字符串。"--请选择"。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The `items` attribute is typically populated with a collection or array of item objects. `itemValue` and `itemLabel` refer to bean properties of those item objects, if specified. Otherwise, the item objects themselves are turned into strings. Alternatively, you can specify a `Map` of items, in which case the map keys are interpreted as option values and the map values correspond to option labels. If `itemValue` or `itemLabel` (or both) happen to be specified as well, the item value property applies to the map key, and the item label property applies to the map value.
#### ** Chinese **

`items`属性通常由一个集合或数组的项对象填充。 `itemValue`和`itemLabel`如果指定的话，则指的是这些项对象的Bean属性。否则，项目对象本身就会变成字符串。或者，你可以指定一个`Map`项，在这种情况下，映射键被解释为选项值，而映射值对应于选项标签。如果同时指定了`itemValue`或`itemLabel`(或两者都有)，则项值属性适用于映射键，而项标签属性适用于映射值。

<!-- tabs:end -->


### **The** **`textarea`** ** Tag** 

<!-- tabs:start -->

#### ** English **

This tag renders an HTML `textarea` element. The following HTML shows typical output for it:
#### ** Chinese **

这个标记显示了一个HTML `textarea`元素。下面的HTML显示了该标记的典型输出。

<!-- tabs:end -->


```html
<tr>
    <td>Notes:</td>
    <td><form:textarea path="notes" rows="3" cols="20"/></td>
    <td><form:errors path="notes"/></td>
</tr>
```

### **The** **`hidden`** ** Tag** 

<!-- tabs:start -->

#### ** English **

This tag renders an HTML `input` tag with the `type` set to `hidden` with the bound value. To submit an unbound hidden value, use the HTML `input` tag with the `type` set to `hidden`. The following HTML shows typical output for it:
#### ** Chinese **

此标记渲染一个HTML `input`标记，并将`type`设置为`hidden`的HTML `input`标记与绑定的值。要提交一个未绑定的隐藏值，请使用HTML `input`标签，并将`type`设置为`hidden`。下面的HTML显示了它的典型输出。

<!-- tabs:end -->


```html
<form:hidden path="house"/>
```

<!-- tabs:start -->

#### ** English **

If we choose to submit the `house` value as a hidden one, the HTML would be as follows:
#### ** Chinese **

如果我们选择将`house`的值作为隐藏值提交，那么HTML将如下所示。

<!-- tabs:end -->


```html
<input name="house" type="hidden" value="Gryffindor"/>
```

### **The** **`errors`** ** Tag** 

<!-- tabs:start -->

#### ** English **

This tag renders field errors in an HTML `span` element. It provides access to the errors created in your controller or those that were created by any validators associated with your controller.
#### ** Chinese **

此标记显示HTML `span`元素中的字段错误。它提供了对控制器中创建的错误或与控制器关联的任何验证器创建的错误的访问。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Assume that we want to display all error messages for the `firstName` and `lastName` fields once we submit the form. We have a validator for instances of the `User` class called `UserValidator`, as the following example shows:
#### ** Chinese **

假设我们想在提交表单后显示所有的`firstName`和`lastName`字段的错误信息。我们为`User`类的实例设置了一个验证器，名为`UserValidator`，如下图所示。

<!-- tabs:end -->


```java
public class UserValidator implements Validator {

    public boolean supports(Class candidate) {
        return User.class.isAssignableFrom(candidate);
    }

    public void validate(Object obj, Errors errors) {
        ValidationUtils.rejectIfEmptyOrWhitespace(errors, "firstName", "required", "Field is required.");
        ValidationUtils.rejectIfEmptyOrWhitespace(errors, "lastName", "required", "Field is required.");
    }
}
```

<!-- tabs:start -->

#### ** English **

The `form.jsp` could be as follows:
#### ** Chinese **

`form.jsp`可以如下所示。

<!-- tabs:end -->


```html
<form:form>
    <table>
        <tr>
            <td>First Name:</td>
            <td><form:input path="firstName"/></td>
            <%-- Show errors for firstName field --%>
            <td><form:errors path="firstName"/></td>
        </tr>

        <tr>
            <td>Last Name:</td>
            <td><form:input path="lastName"/></td>
            <%-- Show errors for lastName field --%>
            <td><form:errors path="lastName"/></td>
        </tr>
        <tr>
            <td colspan="3">
                <input type="submit" value="Save Changes"/>
            </td>
        </tr>
    </table>
</form:form>
```

<!-- tabs:start -->

#### ** English **

If we submit a form with empty values in the `firstName` and `lastName` fields, the HTML would be as follows:
#### ** Chinese **

如果我们在`firstName`和`lastName`字段中的值为空，那么HTML将如下所示。

<!-- tabs:end -->


```html
<form method="POST">
    <table>
        <tr>
            <td>First Name:</td>
            <td><input name="firstName" type="text" value=""/></td>
            <%-- Associated errors to firstName field displayed --%>
            <td><span name="firstName.errors">Field is required.</span></td>
        </tr>

        <tr>
            <td>Last Name:</td>
            <td><input name="lastName" type="text" value=""/></td>
            <%-- Associated errors to lastName field displayed --%>
            <td><span name="lastName.errors">Field is required.</span></td>
        </tr>
        <tr>
            <td colspan="3">
                <input type="submit" value="Save Changes"/>
            </td>
        </tr>
    </table>
</form>
```

<!-- tabs:start -->

#### ** English **

What if we want to display the entire list of errors for a given page? The next example shows that the `errors` tag also supports some basic wildcarding functionality.
#### ** Chinese **

如果我们想显示一个指定页面的整个错误列表呢？下面的例子显示，`errors`标签也支持一些基本的通配功能。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

- `path="*"`: Displays all errors.

- `path="lastName"`: Displays all errors associated with the `lastName` field.

- If `path` is omitted, only object errors are displayed.

#### ** Chinese **

- `path="*"`。显示所有错误。

- `path="lastName"`：显示所有与`lastName`字段相关的错误。显示与 `lastName`字段相关联的所有错误。

- 如果省略了 `path`，则只显示对象错误。


<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

The following example displays a list of errors at the top of the page, followed by field-specific errors next to the fields:
#### ** Chinese **

下面的示例在页面顶部显示了一个错误列表，在字段旁边显示了特定字段的错误。

<!-- tabs:end -->


```html
<form:form>
    <form:errors path="*" cssClass="errorBox"/>
    <table>
        <tr>
            <td>First Name:</td>
            <td><form:input path="firstName"/></td>
            <td><form:errors path="firstName"/></td>
        </tr>
        <tr>
            <td>Last Name:</td>
            <td><form:input path="lastName"/></td>
            <td><form:errors path="lastName"/></td>
        </tr>
        <tr>
            <td colspan="3">
                <input type="submit" value="Save Changes"/>
            </td>
        </tr>
    </table>
</form:form>
```

<!-- tabs:start -->

#### ** English **

The HTML would be as follows:
#### ** Chinese **

HTML的内容如下：

<!-- tabs:end -->


```html
<form method="POST">
    <span name="*.errors" class="errorBox">Field is required.<br/>Field is required.</span>
    <table>
        <tr>
            <td>First Name:</td>
            <td><input name="firstName" type="text" value=""/></td>
            <td><span name="firstName.errors">Field is required.</span></td>
        </tr>

        <tr>
            <td>Last Name:</td>
            <td><input name="lastName" type="text" value=""/></td>
            <td><span name="lastName.errors">Field is required.</span></td>
        </tr>
        <tr>
            <td colspan="3">
                <input type="submit" value="Save Changes"/>
            </td>
        </tr>
    </table>
</form>
```

<!-- tabs:start -->

#### ** English **

The `spring-form.tld` tag library descriptor (TLD) is included in the `spring-webmvc.jar`. For a comprehensive reference on individual tags, browse the [API reference](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/web/servlet/tags/form/package-summary.html#package.description) or see the tag library description.
#### ** Chinese **

`spring-form.tld`标签库描述符（TLD）包含在`spring-webmvc.jar`中。关于单个标签的全面参考，请浏览[API参考](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/web/servlet/tags/form/package-summary.html#package.description)或查看标签库描述。

<!-- tabs:end -->


### **HTTP Method Conversion** 

<!-- tabs:start -->

#### ** English **

A key principle of REST is the use of the “Uniform Interface”. This means that all resources (URLs) can be manipulated by using the same four HTTP methods: GET, PUT, POST, and DELETE. For each method, the HTTP specification defines the exact semantics. For instance, a GET should always be a safe operation, meaning that it has no side effects, and a PUT or DELETE should be idempotent, meaning that you can repeat these operations over and over again, but the end result should be the same. While HTTP defines these four methods, HTML only supports two: GET and POST. Fortunately, there are two possible workarounds: you can either use JavaScript to do your PUT or DELETE, or you can do a POST with the “real” method as an additional parameter (modeled as a hidden input field in an HTML form). Spring’s `HiddenHttpMethodFilter` uses this latter trick. This filter is a plain Servlet filter and, therefore, it can be used in combination with any web framework (not just Spring MVC). Add this filter to your web.xml, and a POST with a hidden `method` parameter is converted into the corresponding HTTP method request.
#### ** Chinese **

REST的一个关键原则是使用 "统一接口"。这意味着所有的资源（URL）都可以通过使用相同的四种HTTP方法进行操作。GET、PUT、POST和DELETE。对于每一种方法，HTTP规范都定义了确切的语义。例如，GET应该永远是安全的操作，这意味着它没有任何副作用，而PUT或DELETE应该是同义词，这意味着你可以反复地重复这些操作，但最终的结果应该是一样的。虽然HTTP定义了这四种方法，但HTML只支持两种。GET和POST。幸运的是，有两种可能的变通方法：你可以使用JavaScript来完成PUT或DELETE，或者用 "真正的 "方法作为额外的参数来完成POST（在HTML表单中作为一个隐藏的输入字段来建模）。Spring的`HiddenHttpMethodFilter`使用了后一种方法。这个过滤器是一个普通的Servlet过滤器，因此，它可以与任何web框架（不只是Spring MVC）结合使用。将这个过滤器添加到你的web.xml中，一个带有隐藏的`method`参数的POST就会被转换为相应的HTTP方法请求。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

To support HTTP method conversion, the Spring MVC form tag was updated to support setting the HTTP method. For example, the following snippet comes from the Pet Clinic sample:
#### ** Chinese **

为了支持HTTP方法转换，更新了Spring MVC表单标签，支持设置HTTP方法。例如，下面的片段来自于宠物诊所的示例。

<!-- tabs:end -->


```html
<form:form method="delete">
    <p class="submit"><input type="submit" value="Delete Pet"/></p>
</form:form>
```

<!-- tabs:start -->

#### ** English **

The preceding example performs an HTTP POST, with the “real” DELETE method hidden behind a request parameter. It is picked up by the `HiddenHttpMethodFilter`, which is defined in web.xml, as the following example shows:
#### ** Chinese **

上面的例子执行了一个HTTP POST，"真正的 "DELETE方法隐藏在一个请求参数后面。它被定义在web.xml中的`HiddenHttpMethodFilter`所接收，如下例所示。

<!-- tabs:end -->


```html
<filter>
    <filter-name>httpMethodFilter</filter-name>
    <filter-class>org.springframework.web.filter.HiddenHttpMethodFilter</filter-class>
</filter>

<filter-mapping>
    <filter-name>httpMethodFilter</filter-name>
    <servlet-name>petclinic</servlet-name>
</filter-mapping>
```

<!-- tabs:start -->

#### ** English **

The following example shows the corresponding `@Controller` method:
#### ** Chinese **

下面的示例显示了相应的`@Controller`方法。

<!-- tabs:end -->


```java
@RequestMapping(method = RequestMethod.DELETE)
public String deletePet(@PathVariable int ownerId, @PathVariable int petId) {
    this.clinic.deletePet(petId);
    return "redirect:/owners/" + ownerId;
}
```

### **HTML5 Tags** 

<!-- tabs:start -->

#### ** English **

The Spring form tag library allows entering dynamic attributes, which means you can enter any HTML5 specific attributes.
#### ** Chinese **

Spring表单标签库允许输入动态属性，这意味着你可以输入任何HTML5的特定属性。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The form `input` tag supports entering a type attribute other than `text`. This is intended to allow rendering new HTML5 specific input types, such as `email`, `date`, `range`, and others. Note that entering `type='text'` is not required, since `text` is the default type.
#### ** Chinese **

表单 `input`标签支持输入`text`以外的类型属性。这是为了允许渲染新的 HTML5 特定输入类型，如 `email`、`date`、`range`等。请注意，输入 `type='text'`并不是必须的，因为`text`是默认类型。

<!-- tabs:end -->


### **1.10.6. Tiles** 

<!-- tabs:start -->

#### ** English **

You can integrate Tiles - just as any other view technology - in web applications that use Spring. This section describes, in a broad way, how to do so.
#### ** Chinese **

您可以像其他视图技术一样，将Tiles集成到使用Spring的Web应用程序中。本节大致介绍了如何做到这一点。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

This section focuses on Spring’s support for Tiles version 3 in the `org.springframework.web.servlet.view.tiles3` package.
#### ** Chinese **

本节主要介绍Spring在`org.springframework.web.servlet.view.tiles3`包中对Tiles 3版本的支持。

<!-- tabs:end -->


### **Dependencies** 

<!-- tabs:start -->

#### ** English **

To be able to use Tiles, you have to add a dependency on Tiles version 3.0.1 or higher and [its transitive dependencies](https://tiles.apache.org/framework/dependency-management.html) to your project.
#### ** Chinese **

为了能够使用Tiles，你必须在你的项目中添加一个Tiles 3.0.1或更高版本的依赖关系，以及[它的反式依赖关系](https://tiles.apache.org/framework/dependency-management.html)。

<!-- tabs:end -->


### **Configuration** 

<!-- tabs:start -->

#### ** English **

To be able to use Tiles, you have to configure it by using files that contain definitions (for basic information on definitions and other Tiles concepts, see [https://tiles.apache.org](https://tiles.apache.org/)). In Spring, this is done by using the `TilesConfigurer`. The following example `ApplicationContext` configuration shows how to do so:
#### ** Chinese **

为了能够使用Tiles，你必须通过使用包含定义的文件来配置它（关于定义和其他Tiles概念的基本信息，请参阅[https://tiles.apache.org](https://tiles.apache.org/)）。在Spring中，这可以通过使用`TilesConfigurer`来实现。下面的`ApplicationContext`配置的例子说明了如何做到这一点。

<!-- tabs:end -->


```xml
<bean id="tilesConfigurer" class="org.springframework.web.servlet.view.tiles3.TilesConfigurer">
    <property name="definitions">
        <list>
            <value>/WEB-INF/defs/general.xml</value>
            <value>/WEB-INF/defs/widgets.xml</value>
            <value>/WEB-INF/defs/administrator.xml</value>
            <value>/WEB-INF/defs/customer.xml</value>
            <value>/WEB-INF/defs/templates.xml</value>
        </list>
    </property>
</bean>
```

<!-- tabs:start -->

#### ** English **

The preceding example defines five files that contain definitions. The files are all located in the `WEB-INF/defs` directory. At initialization of the `WebApplicationContext`, the files are loaded, and the definitions factory are initialized. After that has been done, the Tiles included in the definition files can be used as views within your Spring web application. To be able to use the views, you have to have a `ViewResolver` as with any other view technology used with Spring. You can use either of two implementations, the `UrlBasedViewResolver` and the `ResourceBundleViewResolver`.
#### ** Chinese **

上面的例子定义了五个包含定义的文件。这些文件都位于`WEB-INF/defs`目录下。在初始化`WebApplicationContext`时，这些文件被加载，定义工厂被初始化。完成后，定义文件中包含的Tiles可以在Spring Web应用程序中作为视图使用。要使用视图，您必须拥有一个`ViewResolver`，就像使用Spring的其他视图技术一样。您可以使用两种实现中的任何一种，即基于`UrlBasedViewResolver`和`ResourceBundleViewResolver`。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can specify locale-specific Tiles definitions by adding an underscore and then the locale, as the following example shows:
#### ** Chinese **

你可以通过添加下划线然后再添加locale来指定特定于本地的瓷砖定义，如下例所示。

<!-- tabs:end -->


```xml
<bean id="tilesConfigurer" class="org.springframework.web.servlet.view.tiles3.TilesConfigurer">
    <property name="definitions">
        <list>
            <value>/WEB-INF/defs/tiles.xml</value>
            <value>/WEB-INF/defs/tiles_fr_FR.xml</value>
        </list>
    </property>
</bean>
```

<!-- tabs:start -->

#### ** English **

With the preceding configuration, `tiles_fr_FR.xml` is used for requests with the `fr_FR` locale, and `tiles.xml` is used by default.
#### ** Chinese **

通过前面的配置，`tiles_fr_FR.xm`用于具有`fr_FR` locale的请求，而`tiles.xml`则默认使用。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Since underscores are used to indicate locales, we recommended not using them otherwise in the file names for Tiles definitions.
#### ** Chinese **

由于下划线是用来表示地域，我们建议不要在瓷砖定义的文件名中使用下划线。

<!-- tabs:end -->


### **`UrlBasedViewResolver`** 

<!-- tabs:start -->

#### ** English **

The `UrlBasedViewResolver` instantiates the given `viewClass` for each view it has to resolve. The following bean defines a `UrlBasedViewResolver`:
#### ** Chinese **

`UrlBasedViewResolver`为它要解析的每个视图实例化给定的`viewClass`。下面的Bean定义了一个`UrlBasedViewResolver`。

<!-- tabs:end -->


```xml
<bean id="viewResolver" class="org.springframework.web.servlet.view.UrlBasedViewResolver">
    <property name="viewClass" value="org.springframework.web.servlet.view.tiles3.TilesView"/>
</bean>
```

### **`ResourceBundleViewResolver`** 

<!-- tabs:start -->

#### ** English **

The `ResourceBundleViewResolver` has to be provided with a property file that contains view names and view classes that the resolver can use. The following example shows a bean definition for a `ResourceBundleViewResolver` and the corresponding view names and view classes (taken from the Pet Clinic sample):
#### ** Chinese **

`ResourceBundleViewResolver`必须提供一个属性文件，其中包含解析器可以使用的视图名称和视图类。下面的示例显示了 `ResourceBundleViewResolver`的 Bean 定义以及相应的视图名称和视图类（取自 Pet Clinic 示例）。

<!-- tabs:end -->


```xml
<bean id="viewResolver" class="org.springframework.web.servlet.view.ResourceBundleViewResolver">
    <property name="basename" value="views"/>
</bean>
```

<!-- tabs:start -->

#### ** English **

... welcomeView.(class)=org.springframework.web.servlet.view.tiles3.TilesView welcomeView.url=welcome (this is the name of a Tiles definition) vetsView.(class)=org.springframework.web.servlet.view.tiles3.TilesView vetsView.url=vetsView (again, this is the name of a Tiles definition) findOwnersForm.(class)=org.springframework.web.servlet.view.JstlView findOwnersForm.url=/WEB-INF/jsp/findOwners.jsp ...
#### ** Chinese **

....(class)=org.springframework.web.servlet.view.tiles3.TilesView welcomeView.url=welcome(这是一个Tiles定义的名称) vetsView.(class)=org.springframework.web.servlet.view.tiles3.TilesView vetsView.url=vetsView(同样，这是一个Tiles定义的名称) TilesView vetsView.(类)=org.springframework.web.servlet.view.JstlView findOwnersForm.(类)=org.springframework.web.servlet.view.JstlView findOwnersForm.url=/WEB-INF/jsp/findOwners.jsp ...

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

When you use the `ResourceBundleViewResolver`, you can easily mix different view technologies.
#### ** Chinese **

当你使用`ResourceBundleViewResolver`时，你可以轻松地混合不同的视图技术。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Note that the `TilesView` class supports JSTL (the JSP Standard Tag Library).
#### ** Chinese **

注意，`TilesView`类支持JSTL（JSP标准标签库）。

<!-- tabs:end -->


### **`SimpleSpringPreparerFactory`** ** and** **`SpringBeanPreparerFactory`** 

<!-- tabs:start -->

#### ** English **

As an advanced feature, Spring also supports two special Tiles `PreparerFactory` implementations. See the Tiles documentation for details on how to use `ViewPreparer` references in your Tiles definition files.
#### ** Chinese **

作为一项高级功能，Spring还支持两个特殊的Tiles `PreparerFactory`实现。有关如何在您的Tiles定义文件中使用`ViewPreparer`引用的详细信息，请参阅Tiles文档。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can specify `SimpleSpringPreparerFactory` to autowire `ViewPreparer` instances based on specified preparer classes, applying Spring’s container callbacks as well as applying configured Spring BeanPostProcessors. If Spring’s context-wide annotation configuration has been activated, annotations in `ViewPreparer` classes are automatically detected and applied. Note that this expects preparer classes in the Tiles definition files, as the default `PreparerFactory` does.
#### ** Chinese **

您可以指定`SimpleSpringPreparerFactory`，以根据指定的preparer类自动触发`ViewPreparer`实例，应用Spring的容器回调以及应用配置的Spring BeanPostProcessors。如果已经激活了Spring的上下文注释配置，`ViewPreparer`类中的注释将被自动检测并应用。请注意，这需要在Tiles定义文件中的preparer类，就像默认的`PreparerFactory`那样。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can specify `SpringBeanPreparerFactory` to operate on specified preparer names (instead of classes), obtaining the corresponding Spring bean from the DispatcherServlet’s application context. The full bean creation process is in the control of the Spring application context in this case, allowing for the use of explicit dependency injection configuration, scoped beans, and so on. Note that you need to define one Spring bean definition for each preparer name (as used in your Tiles definitions). The following example shows how to define a `SpringBeanPreparerFactory` property on a `TilesConfigurer` bean:
#### ** Chinese **

你可以指定`SpringBeanPreparerFactory`来操作指定的准备者名称（而不是类），从DispatcherServlet的应用上下文中获取相应的Spring Bean。在这种情况下，整个Bean的创建过程是在Spring应用上下文的控制下进行的，允许使用显式依赖注入配置、Scoped bean等。注意，你需要为每个准备者名称定义一个Spring Bean定义（正如你的Tiles定义中使用的那样）。下面的示例显示了如何在`TilesConfigurer` bean上定义一个`SpringBeanPreparerFactory`属性。

<!-- tabs:end -->


```xml
<bean id="tilesConfigurer" class="org.springframework.web.servlet.view.tiles3.TilesConfigurer">
    <property name="definitions">
        <list>
            <value>/WEB-INF/defs/general.xml</value>
            <value>/WEB-INF/defs/widgets.xml</value>
            <value>/WEB-INF/defs/administrator.xml</value>
            <value>/WEB-INF/defs/customer.xml</value>
            <value>/WEB-INF/defs/templates.xml</value>
        </list>
    </property>

    <!-- resolving preparer names as Spring bean definition names -->
    <property name="preparerFactoryClass"
            value="org.springframework.web.servlet.view.tiles3.SpringBeanPreparerFactory"/>

</bean>
```

### **1.10.7. RSS and Atom** 

<!-- tabs:start -->

#### ** English **

Both `AbstractAtomFeedView` and `AbstractRssFeedView` inherit from the `AbstractFeedView` base class and are used to provide Atom and RSS Feed views, respectively. They are based on [ROME](https://rometools.github.io/rome/) project and are located in the package `org.springframework.web.servlet.view.feed`.
#### ** Chinese **

`AbstractAtomFeedView`和`AbstractRssFeedView`都继承自`AbstractFeedView`基类，分别用于提供Atom和RSS Feed视图。它们基于[ROME](https://rometools.github.io/rome/)项目，位于包`org.springframework.web.servlet.view.feed`中。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

`AbstractAtomFeedView` requires you to implement the `buildFeedEntries()` method and optionally override the `buildFeedMetadata()` method (the default implementation is empty). The following example shows how to do so:
#### ** Chinese **

`AbstractAtomFeedView`要求您实现`buildFeedEntries()`方法，并可选择覆盖`buildFeedMetadata()`方法（默认实现为空）。下面的示例显示了如何实现。

<!-- tabs:end -->


```java
public class SampleContentAtomView extends AbstractAtomFeedView {

    @Override
    protected void buildFeedMetadata(Map<String, Object> model,
            Feed feed, HttpServletRequest request) {
        // implementation omitted
    }

    @Override
    protected List<Entry> buildFeedEntries(Map<String, Object> model,
            HttpServletRequest request, HttpServletResponse response) throws Exception {
        // implementation omitted
    }
}
```

<!-- tabs:start -->

#### ** English **

Similar requirements apply for implementing `AbstractRssFeedView`, as the following example shows:
#### ** Chinese **

类似的要求也适用于实现`AbstractRssFeedView`，如下例所示。

<!-- tabs:end -->


```java
public class SampleContentRssView extends AbstractRssFeedView {

    @Override
    protected void buildFeedMetadata(Map<String, Object> model,
            Channel feed, HttpServletRequest request) {
        // implementation omitted
    }

    @Override
    protected List<Item> buildFeedItems(Map<String, Object> model,
            HttpServletRequest request, HttpServletResponse response) throws Exception {
        // implementation omitted
    }
}
```

<!-- tabs:start -->

#### ** English **

The `buildFeedItems()` and `buildFeedEntries()` methods pass in the HTTP request, in case you need to access the Locale. The HTTP response is passed in only for the setting of cookies or other HTTP headers. The feed is automatically written to the response object after the method returns.
#### ** Chinese **

`buildFeedItems()`和`buildFeedEntries()`方法传入了HTTP请求，以备您需要访问Locale。传入的HTTP响应仅用于设置cookie或其他HTTP头文件的设置。该方法返回后，feed会自动写入响应对象。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

For an example of creating an Atom view, see Alef Arendsen’s Spring Team Blog [entry](https://spring.io/blog/2009/03/16/adding-an-atom-view-to-an-application-using-spring-s-rest-support).
#### ** Chinese **

关于创建Atom视图的例子，请看Alef Arendsen的Spring团队博客[条目](https://spring.io/blog/2009/03/16/adding-an-atom-view-to-an-application-using-spring-s-rest-support)。

<!-- tabs:end -->


### **1.10.8. PDF and Excel** 

<!-- tabs:start -->

#### ** English **

Spring offers ways to return output other than HTML, including PDF and Excel spreadsheets. This section describes how to use those features.
#### ** Chinese **

Spring提供了HTML以外的其他输出方式，包括PDF和Excel电子表格。本节介绍如何使用这些功能。

<!-- tabs:end -->


### **Introduction to Document Views** 

<!-- tabs:start -->

#### ** English **

An HTML page is not always the best way for the user to view the model output, and Spring makes it simple to generate a PDF document or an Excel spreadsheet dynamically from the model data. The document is the view and is streamed from the server with the correct content type, to (hopefully) enable the client PC to run their spreadsheet or PDF viewer application in response.
#### ** Chinese **

一个HTML页面并不总是用户查看模型输出的最佳方式，而Spring可以让用户从模型数据中动态生成PDF文档或Excel电子表格。文档就是视图，并从服务器上以正确的内容类型进行流式传输，以便（希望）使客户端PC能够运行电子表格或PDF查看器应用程序来响应。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

In order to use Excel views, you need to add the Apache POI library to your classpath. For PDF generation, you need to add (preferably) the OpenPDF library.
#### ** Chinese **

为了使用Excel视图，你需要在classpath中添加Apache POI库。对于PDF的生成，你需要添加（最好是）OpenPDF库。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You should use the latest versions of the underlying document-generation libraries, if possible. In particular, we strongly recommend OpenPDF (for example, OpenPDF 1.2.12) instead of the outdated original iText 2.1.7, since OpenPDF is actively maintained and fixes an important vulnerability for untrusted PDF content.
#### ** Chinese **

如果可能的话，你应该使用最新版本的底层文档生成库。特别是，我们强烈推荐使用OpenPDF（例如，OpenPDF 1.2.12），而不是过时的iText 2.1.7，因为OpenPDF是积极维护的，并修复了一个重要的漏洞，对未受信任的PDF内容进行了修复。

<!-- tabs:end -->


### **PDF Views** 

<!-- tabs:start -->

#### ** English **

A simple PDF view for a word list could extend `org.springframework.web.servlet.view.document.AbstractPdfView` and implement the `buildPdfDocument()` method, as the following example shows:
#### ** Chinese **

一个简单的word列表的PDF视图可以扩展`org.springframework.web.servlet.view.document.AbstractPdfView`，并实现`buildPdfDocument()`方法，如下例所示。

<!-- tabs:end -->


```java
public class PdfWordList extends AbstractPdfView {

    protected void buildPdfDocument(Map<String, Object> model, Document doc, PdfWriter writer,
            HttpServletRequest request, HttpServletResponse response) throws Exception {

        List<String> words = (List<String>) model.get("wordList");
        for (String word : words) {
            doc.add(new Paragraph(word));
        }
    }
}
```

<!-- tabs:start -->

#### ** English **

A controller can return such a view either from an external view definition (referencing it by name) or as a `View` instance from the handler method.
#### ** Chinese **

控制器可以从外部视图定义中返回这样一个视图（通过名称引用），或者从处理程序方法中返回一个`View`实例。

<!-- tabs:end -->


### **Excel Views** 

<!-- tabs:start -->

#### ** English **

Since Spring Framework 4.2, `org.springframework.web.servlet.view.document.AbstractXlsView` is provided as a base class for Excel views. It is based on Apache POI, with specialized subclasses (`AbstractXlsxView` and `AbstractXlsxStreamingView`) that supersede the outdated `AbstractExcelView` class.
#### ** Chinese **

自Spring Framework 4.2以来，`org.springframework.web.servlet.view.document.AbstractXlsView`作为Excel视图的基类提供了。它基于Apache POI，有专门的子类(`AbstractXlsxView`和`AbstractXlsxStreamingView`)，取代了过时的`AbstractExcelView`类。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The programming model is similar to `AbstractPdfView`, with `buildExcelDocument()` as the central template method and controllers being able to return such a view from an external definition (by name) or as a `View` instance from the handler method.
#### ** Chinese **

编程模型类似于`AbstractPdfView`，以`buildExcelDocument()`为中心模板方法，控制器能够从外部定义（通过名称）或从处理程序方法中返回这样的视图`View`实例。

<!-- tabs:end -->


### **1.10.9. Jackson** 

<!-- tabs:start -->

#### ** English **

[WebFlux](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-view-httpmessagewriter)
#### ** Chinese **

[WebFlux](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-view-httpmessagewriter)

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Spring offers support for the Jackson JSON library.
#### ** Chinese **

Spring提供了对JSON JSON库的支持。

<!-- tabs:end -->


### **Jackson-based JSON MVC Views** 

<!-- tabs:start -->

#### ** English **

[WebFlux](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-view-httpmessagewriter)
#### ** Chinese **

[WebFlux](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-view-httpmessagewriter)

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The `MappingJackson2JsonView` uses the Jackson library’s `ObjectMapper` to render the response content as JSON. By default, the entire contents of the model map (with the exception of framework-specific classes) are encoded as JSON. For cases where the contents of the map need to be filtered, you can specify a specific set of model attributes to encode by using the `modelKeys` property. You can also use the `extractValueFromSingleKeyModel` property to have the value in single-key models extracted and serialized directly rather than as a map of model attributes.
#### ** Chinese **

`MappingJackson2JsonView`使用Jackson库的`ObjectMapper`将响应内容渲染成JSON。默认情况下，模型映射的整个内容（框架特定类除外）被编码为JSON。对于需要过滤映射内容的情况，可以通过使用`modelKeys`属性指定一组特定的模型属性进行编码。你也可以使用`extractValueFromSingleKeyModel`属性来直接提取和序列化单键模型中的值，而不是作为模型属性的映射。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can customize JSON mapping as needed by using Jackson’s provided annotations. When you need further control, you can inject a custom `ObjectMapper` through the `ObjectMapper` property, for cases where you need to provide custom JSON serializers and deserializers for specific types.
#### ** Chinese **

你可以根据需要使用Jackson提供的注释来定制JSON映射。当您需要进一步控制时，您可以通过`ObjectMapper`属性注入一个自定义的`ObjectMapper`，用于需要为特定类型提供自定义JSON序列化器和解序列化器的情况。

<!-- tabs:end -->


### **Jackson-based XML Views** 

<!-- tabs:start -->

#### ** English **

[WebFlux](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-view-httpmessagewriter)
#### ** Chinese **

[WebFlux](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-view-httpmessagewriter)

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

`MappingJackson2XmlView` uses the [Jackson XML extension’s](https://github.com/FasterXML/jackson-dataformat-xml) `XmlMapper` to render the response content as XML. If the model contains multiple entries, you should explicitly set the object to be serialized by using the `modelKey` bean property. If the model contains a single entry, it is serialized automatically.
#### ** Chinese **

`MappingJackson2XmlView`使用[Jackson XML扩展的](https://github.com/FasterXML/jackson-dataformat-xml) `XmlMapper`将响应内容渲染成XML。如果模型包含多个条目，应该通过使用`modelKey` bean属性显式设置要序列化的对象。如果模型包含单个条目，则会自动进行序列化。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can customized XML mapping as needed by using JAXB or Jackson’s provided annotations. When you need further control, you can inject a custom `XmlMapper` through the `ObjectMapper` property, for cases where custom XML you need to provide serializers and deserializers for specific types.
#### ** Chinese **

你可以根据需要使用JAXB或Jackson提供的注释来定制XML映射。当你需要进一步控制时，你可以通过`ObjectMapper`属性注入一个自定义的`XmlMapper`，用于自定义XML需要为特定类型提供序列化器和解序列化器的情况。

<!-- tabs:end -->


### **1.10.10. XML Marshalling** 

<!-- tabs:start -->

#### ** English **

The `MarshallingView` uses an XML `Marshaller` (defined in the `org.springframework.oxm` package) to render the response content as XML. You can explicitly set the object to be marshalled by using a `MarshallingView` instance’s `modelKey` bean property. Alternatively, the view iterates over all model properties and marshals the first type that is supported by the `Marshaller`. For more information on the functionality in the `org.springframework.oxm` package, see [Marshalling XML using O/X Mappers](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/data-access.html#oxm).
#### ** Chinese **

`MarshallingView`使用一个XML `Marshaller`（在`org.springframework.oxm`包中定义）来将响应内容渲染成XML。您可以通过使用 `MarshallingView`实例的 `modelKey` bean 属性来显式地设置要被管理的对象。或者，视图会迭代所有的模型属性，并对`Marshaller`所支持的第一个类型进行调度。有关 `org.springframework.oxm`包中的功能的更多信息，请参见[使用O/X Mappers对XML进行元帅化](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/data-access.html#oxm)。

<!-- tabs:end -->


### **1.10.11. XSLT Views** 

<!-- tabs:start -->

#### ** English **

XSLT is a transformation language for XML and is popular as a view technology within web applications. XSLT can be a good choice as a view technology if your application naturally deals with XML or if your model can easily be converted to XML. The following section shows how to produce an XML document as model data and have it transformed with XSLT in a Spring Web MVC application.
#### ** Chinese **

XSLT是一种针对XML的转换语言，在Web应用程序中作为视图技术很受欢迎。如果你的应用程序自然而然地处理XML，或者你的模型可以很容易地转换为XML，那么XSLT作为视图技术是一个不错的选择。下面的章节展示了如何在Spring Web MVC应用程序中生成一个XML文档作为模型数据，并使用XSLT对其进行转换。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

This example is a trivial Spring application that creates a list of words in the `Controller` and adds them to the model map. The map is returned, along with the view name of our XSLT view. See [Annotated Controllers](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-controller) for details of Spring Web MVC’s `Controller` interface. The XSLT controller turns the list of words into a simple XML document ready for transformation.
#### ** Chinese **

这个例子是一个琐碎的Spring应用程序，它在`Controller`中创建了一个单词列表，并将其添加到模型映射中。该映射与我们的XSLT视图名称一起返回。有关Spring Web MVC的`Controller`接口的详细信息，请参阅[Annotated Controllers](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-controller)。XSLT 控制器将单词列表转化为一个简单的 XML 文档，并准备好进行转换。

<!-- tabs:end -->


### **Beans** 

<!-- tabs:start -->

#### ** English **

Configuration is standard for a simple Spring web application: The MVC configuration has to define an `XsltViewResolver` bean and regular MVC annotation configuration. The following example shows how to do so:
#### ** Chinese **

配置是一个简单的Spring Web应用程序的标准配置。MVC配置必须定义一个`XsltViewResolver` bean和常规MVC注释配置。下面的例子显示了如何做到这一点。

<!-- tabs:end -->


```java
@EnableWebMvc
@ComponentScan
@Configuration
public class WebConfig implements WebMvcConfigurer {

    @Bean
    public XsltViewResolver xsltViewResolver() {
        XsltViewResolver viewResolver = new XsltViewResolver();
        viewResolver.setPrefix("/WEB-INF/xsl/");
        viewResolver.setSuffix(".xslt");
        return viewResolver;
    }
}
```

### **Controller** 

<!-- tabs:start -->

#### ** English **

We also need a Controller that encapsulates our word-generation logic.
#### ** Chinese **

我们还需要一个控制器来封装我们的文字生成逻辑。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The controller logic is encapsulated in a `@Controller` class, with the handler method being defined as follows:
#### ** Chinese **

控制器逻辑被封装在一个`@Controller`类中，处理程序方法定义如下。

<!-- tabs:end -->


```java
@Controller
public class XsltController {

    @RequestMapping("/")
    public String home(Model model) throws Exception {
        Document document = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();
        Element root = document.createElement("wordList");

        List<String> words = Arrays.asList("Hello", "Spring", "Framework");
        for (String word : words) {
            Element wordNode = document.createElement("word");
            Text textNode = document.createTextNode(word);
            wordNode.appendChild(textNode);
            root.appendChild(wordNode);
        }

        model.addAttribute("wordList", root);
        return "home";
    }
}
```

<!-- tabs:start -->

#### ** English **

So far, we have only created a DOM document and added it to the Model map. Note that you can also load an XML file as a `Resource` and use it instead of a custom DOM document.
#### ** Chinese **

到目前为止，我们只创建了一个DOM文档，并将其添加到Model地图中。注意，你也可以将一个XML文件加载为`Resource`，并使用它来代替自定义DOM文档。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

There are software packages available that automatically 'domify' an object graph, but, within Spring, you have complete flexibility to create the DOM from your model in any way you choose. This prevents the transformation of XML playing too great a part in the structure of your model data, which is a danger when using tools to manage the DOMification process.
#### ** Chinese **

有一些软件包可以自动 "支配 "对象图，但在Spring中，你可以完全灵活地从你的模型中以你选择的任何方式创建DOM。这可以防止XML的转换在你的模型数据结构中发挥太大作用，这在使用工具来管理DOM化过程时是一个危险。

<!-- tabs:end -->


### **Transformation** 

<!-- tabs:start -->

#### ** English **

Finally, the `XsltViewResolver` resolves the “home” XSLT template file and merges the DOM document into it to generate our view. As shown in the `XsltViewResolver` configuration, XSLT templates live in the `war` file in the `WEB-INF/xsl` directory and end with an `xslt` file extension.
#### ** Chinese **

最后，`XsltViewResolver`解析 "home "XSLT模板文件，并将DOM文档合并到其中，生成我们的视图。如`XsltViewResolver`配置中所示，XSLT模板住在`WEB-INF/xsl`目录下的`war`文件中，并以`xslt`文件扩展名结束。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following example shows an XSLT transform:
#### ** Chinese **

下面的例子显示了一个XSLT变换。

<!-- tabs:end -->


```xml
<?xml version="1.0" encoding="utf-8"?>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">

    <xsl:output method="html" omit-xml-declaration="yes"/>

    <xsl:template match="/">
        <html>
            <head><title>Hello!</title></head>
            <body>
                <h1>My First Words</h1>
                <ul>
                    <xsl:apply-templates/>
                </ul>
            </body>
        </html>
    </xsl:template>

    <xsl:template match="word">
        <li><xsl:value-of select="."/></li>
    </xsl:template>

</xsl:stylesheet>
```

<!-- tabs:start -->

#### ** English **

The preceding transform is rendered as the following HTML:
#### ** Chinese **

前面的转换被渲染成下面的HTML。

<!-- tabs:end -->


```html
<html>
    <head>
        <META http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <title>Hello!</title>
    </head>
    <body>
        <h1>My First Words</h1>
        <ul>
            <li>Hello</li>
            <li>Spring</li>
            <li>Framework</li>
        </ul>
    </body>
</html>
```


[下一章](Spring-Framework-5.2.6.RELEASE/Web%20on%20Servlet%20Stack/1.11.%20MVC%20Config.md)


[回目录](Spring-Framework-5.2.6.RELEASE/summary.md)

[回首页](/README)
