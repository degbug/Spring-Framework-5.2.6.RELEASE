

See [REST Endpoints](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#rest-client-access) for details.
#### ** English **

The main difference between the two preceding diagrams is the use of the “broker relay” for passing messages up to the external STOMP broker over TCP and for passing messages down from the broker to subscribed clients.
#### ** Chinese **

前面两张图的主要区别在于使用了 "经纪人中继"，通过TCP向外部STOMP经纪人向上传递报文，并将报文从经纪人向下传递给订阅客户端。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

When messages are received from a WebSocket connection, they are decoded to STOMP frames, turned into a Spring `Message` representation, and sent to the `clientInboundChannel` for further processing. For example, STOMP messages whose destination headers start with `/app` may be routed to `@MessageMapping` methods in annotated controllers, while `/topic` and `/queue` messages may be routed directly to the message broker.
#### ** Chinese **

当从 WebSocket 连接接收到消息时，它们会被解码为 STOMP 帧，转化为 Spring `Message` 表示，并发送至 `clientInboundChannel` 进行进一步处理。例如，目标头以 `/app`开头的 STOMP 消息可以被路由到注释控制器中的 `@MessageMapping` 方法，而 `/topic` 和 `/queue` 消息可以直接路由到消息代理。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

An annotated `@Controller` that handles a STOMP message from a client may send a message to the message broker through the `brokerChannel`, and the broker broadcasts the message to matching subscribers through the `clientOutboundChannel`. The same controller can also do the same in response to HTTP requests, so a client can perform an HTTP POST, and then a `@PostMapping` method can send a message to the message broker to broadcast to subscribed clients.
#### ** Chinese **

一个处理来自客户端的STOMP消息的注释`@Controller`可以通过`brokerChannel`向消息代理发送消息，而代理通过`clientOutboundChannel`向匹配的订阅者广播消息。同样的控制器也可以对HTTP请求进行同样的响应，所以客户端可以执行一个HTTP POST，然后通过`@PostMapping`方法向消息代理发送消息，将消息广播给订阅的客户端。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

We can trace the flow through a simple example. Consider the following example, which sets up a server:
#### ** Chinese **

我们可以通过一个简单的例子来追溯这个流程。考虑一下下面的例子，设置一个服务器。

<!-- tabs:end -->


```java
@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

    @Override
    public void registerStompEndpoints(StompEndpointRegistry registry) {
        registry.addEndpoint("/portfolio");
    }

    @Override
    public void configureMessageBroker(MessageBrokerRegistry registry) {
        registry.setApplicationDestinationPrefixes("/app");
        registry.enableSimpleBroker("/topic");
    }
}

@Controller
public class GreetingController {

    @MessageMapping("/greeting") {
    public String handle(String greeting) {
        return "[" + getTimestamp() + ": " + greeting;
    }
}
```

<!-- tabs:start -->

#### ** English **

The preceding example supports the following flow:
#### ** Chinese **

前面的例子支持以下流程：

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The client connects to [`http://localhost:8080/portfolio`](http://localhost:8080/portfolio) and, once a WebSocket connection is established, STOMP frames begin to flow on it.The client sends a SUBSCRIBE frame with a destination header of `/topic/greeting`. Once received and decoded, the message is sent to the `clientInboundChannel` and is then routed to the message broker, which stores the client subscription.The client sends a aSEND frame to `/app/greeting`. The `/app` prefix helps to route it to annotated controllers. After the `/app` prefix is stripped, the remaining `/greeting` part of the destination is mapped to the `@MessageMapping` method in `GreetingController`.The value returned from `GreetingController` is turned into a Spring `Message` with a payload based on the return value and a default destination header of `/topic/greeting` (derived from the input destination with `/app` replaced by `/topic`). The resulting message is sent to the `brokerChannel` and handled by the message broker.The message broker finds all matching subscribers and sends a MESSAGE frame to each one through the `clientOutboundChannel`, from where messages are encoded as STOMP frames and sent on the WebSocket connection.
#### ** Chinese **

客户端连接到[`http://localhost:8080/portfolio`](http://localhost:8080/portfolio)，一旦建立了WebSocket连接，STOMP帧就开始在上面流动。一旦接收到并解码，消息被发送到`clientInboundChannel`，然后被路由到消息代理，由消息代理存储客户端订阅。`/app`前缀有助于将其路由到注释控制器。在`/app`前缀被剥离后，剩余的`/greeting`部分被映射到`GreetingController`中的`@MessageMapping`方法。 从`GreetingController`返回的值被转化为一个Spring `Message`，其有效载荷基于返回值和默认的目标头为`/topic/greeting`（从输入目标中派生出来的`/app`，用`/topic`替换为`/topic`）。由此产生的消息被发送到`brokerChannel`，并由消息代理处理。消息代理找到所有匹配的用户，并通过`clientOutboundChannel`向每个用户发送一个MESSAGE帧，从这里，消息被编码为STOMP帧，并通过WebSocket连接发送。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The next section provides more details on annotated methods, including the kinds of arguments and return values that are supported.
#### ** Chinese **

下一节将提供更多关于注释方法的细节，包括支持的参数和返回值的种类。

<!-- tabs:end -->


### **4.4.6. Annotated Controllers** 

<!-- tabs:start -->

#### ** English **

Applications can use annotated `@Controller` classes to handle messages from clients. Such classes can declare `@MessageMapping`, `@SubscribeMapping`, and `@ExceptionHandler` methods, as described in the following topics:
#### ** Chinese **

应用程序可以使用注释的 `@Controller`类来处理来自客户端的消息。这些类可以声明 `@MessageMapping`、`@SubscribeMapping`和`@ExceptionHandler`方法，如下面的主题所述。

<!-- tabs:end -->


### **`@MessageMapping`** 

<!-- tabs:start -->

#### ** English **

You can use `@MessageMapping` to annotate methods that route messages based on their destination. It is supported at the method level as well as at the type level. At the type level, `@MessageMapping` is used to express shared mappings across all methods in a controller.
#### ** Chinese **

你可以使用 `@MessageMapping`来注释根据目的地路由消息的方法。它在方法级和类型级都支持。在类型级，`@MessageMapping`用于表达控制器中所有方法之间的共享映射。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

By default, the mapping values are Ant-style path patterns (for example `/thing*`, `/thing/**`), including support for template variables (for example, `/thing/{id}`). The values can be referenced through `@DestinationVariable` method arguments. Applications can also switch to a dot-separated destination convention for mappings, as explained in [Dots as Separators](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#websocket-stomp-destination-separator).
#### ** Chinese **

默认情况下，映射值是Ant风格的路径模式（例如`/thing*`，`/thing/**`），包括对模板变量的支持（例如`/thing/{id}`）。这些值可以通过`@DestinationVariable`方法参数来引用。应用程序也可以切换到点分隔的目的地约定，正如[点分隔符](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#websocket-stomp-destination-separator)中所解释的那样。

<!-- tabs:end -->


### **Supported Method Arguments** 

<!-- tabs:start -->

#### ** English **

The following table describes the method arguments:
#### ** Chinese **

下面的表格描述了方法参数。

<!-- tabs:end -->


Method argument | Description 
-|-
Message | For access to the complete message. 
MessageHeaders | For access to the headers within the Message. 
MessageHeaderAccessor, SimpMessageHeaderAccessor, and StompHeaderAccessor | For access to the headers through typed accessor methods. 
@Payload | For access to the payload of the message, converted (for example, from JSON) by a configured MessageConverter.The presence of this annotation is not required since it is, by default, assumed if no other argument is matched.You can annotate payload arguments with @javax.validation.Valid or Spring’s @Validated, to have the payload arguments be automatically validated. 
@Header | For access to a specific header value — along with type conversion using an org.springframework.core.convert.converter.Converter, if necessary. 
@Headers | For access to all headers in the message. This argument must be assignable to java.util.Map. 
@DestinationVariable | For access to template variables extracted from the message destination. Values are converted to the declared method argument type as necessary. 
java.security.Principal | Reflects the user logged in at the time of the WebSocket HTTP handshake. 


### **Return Values** 

<!-- tabs:start -->

#### ** English **

By default, the return value from a `@MessageMapping` method is serialized to a payload through a matching `MessageConverter` and sent as a `Message` to the `brokerChannel`, from where it is broadcast to subscribers. The destination of the outbound message is the same as that of the inbound message but prefixed with `/topic`.
#### ** Chinese **

默认情况下，来自`@MessageMapping`方法的返回值通过匹配的`MessageConverter`序列化为有效载荷，并作为`Message`发送到`brokerChannel`，并从那里向用户广播。出站消息的目的地与入站消息相同，但前缀为`/topic`。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can use the `@SendTo` and `@SendToUser` annotations to customize the destination of the output message. `@SendTo` is used to customize the target destination or to specify multiple destinations. `@SendToUser` is used to direct the output message to only the user associated with the input message. See [User Destinations](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#websocket-stomp-user-destination).
#### ** Chinese **

您可以使用 `@SendTo` 和 `@SendToUser` 注释来自定义输出消息的目的地。 `@SendTo`用于自定义目标目的地或指定多个目的地。 `@SendToUser`用于将输出消息仅指向与输入消息相关联的用户。参见[用户目的地](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#websocket-stomp-user-destination)。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can use both `@SendTo` and `@SendToUser` at the same time on the same method, and both are supported at the class level, in which case they act as a default for methods in the class. However, keep in mind that any method-level `@SendTo` or `@SendToUser` annotations override any such annotations at the class level.
#### ** Chinese **

您可以在同一个方法上同时使用 `@SendTo` 和 `@SendToUser`，而且这两个注释都在类级支持，在这种情况下，它们将作为类中的方法的默认注释。但是，请记住，任何方法级的 `@SendTo` 或 `@SendToUser` 注解会覆盖类级的任何此类注解。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Messages can be handled asynchronously and a `@MessageMapping` method can return `ListenableFuture`, `CompletableFuture`, or `CompletionStage`.
#### ** Chinese **

消息可以异步处理，`@MessageMapping`方法可以返回`ListenableFuture`、`CompletableFuture`或`CompletionStage`。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Note that `@SendTo` and `@SendToUser` are merely a convenience that amounts to using the `SimpMessagingTemplate` to send messages. If necessary, for more advanced scenarios, `@MessageMapping` methods can fall back on using the `SimpMessagingTemplate` directly. This can be done instead of, or possibly in addition to, returning a value. See [Sending Messages](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#websocket-stomp-handle-send).
#### ** Chinese **

请注意，`@SendTo`和`@SendToUser`只是一种方便，相当于使用`SimpMessagingTemplate`来发送消息。如果有必要，对于更高级的场景，`@MessageMapping`方法可以直接使用`SimpMessagingTemplate`。这可以代替或者可能是在返回一个值的基础上进行。参见[发送消息](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#websocket-stomp-handle-send)。

<!-- tabs:end -->


### **`@SubscribeMapping`** 

<!-- tabs:start -->

#### ** English **

`@SubscribeMapping` is similar to `@MessageMapping` but narrows the mapping to subscription messages only. It supports the same [method arguments](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#websocket-stomp-message-mapping) as `@MessageMapping`. However for the return value, by default, a message is sent directly to the client (through `clientOutboundChannel`, in response to the subscription) and not to the broker (through `brokerChannel`, as a broadcast to matching subscriptions). Adding `@SendTo` or `@SendToUser` overrides this behavior and sends to the broker instead.
#### ** Chinese **

`@SubscribeMapping`类似于`@MessageMapping`，但仅将映射范围缩小到订阅消息。它支持与`@MessageMapping`相同的[方法参数](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#websocket-stomp-message-mapping)。但是，对于返回值，默认情况下，消息会直接发送到客户端（通过`clientOutboundChannel`，作为对订阅的响应），而不是发送给代理（通过`brokerChannel`，作为广播给匹配的订阅）。添加`@SendTo`或`@SendToUser`会覆盖这个行为，而不是发送给代理。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

When is this useful? Assume that the broker is mapped to `/topic` and `/queue`, while application controllers are mapped to `/app`. In this setup, the broker stores all subscriptions to `/topic` and `/queue` that are intended for repeated broadcasts, and there is no need for the application to get involved. A client could also subscribe to some `/app` destination, and a controller could return a value in response to that subscription without involving the broker without storing or using the subscription again (effectively a one-time request-reply exchange). One use case for this is populating a UI with initial data on startup.
#### ** Chinese **

什么时候有用？假设代理被映射到`/topic`和`/queue`，而应用控制器被映射到`/app`。在这种设置中，代理存储了所有订阅的`/topic`和`/queue`，这些订阅都是为了重复广播，应用程序不需要介入。客户端也可以订阅一些`/app`目的地，控制器可以返回一个值作为对该订阅的响应，而不需要涉及到代理，也不需要存储或再次使用该订阅（实际上是一次性的请求-回复交换）。这方面的一个用例是在启动时用初始数据填充UI。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

When is this not useful? Do not try to map broker and controllers to the same destination prefix unless you want both to independently process messages, including subscriptions, for some reason. Inbound messages are handled in parallel. There are no guarantees whether a broker or a controller processes a given message first. If the goal is to be notified when a subscription is stored and ready for broadcasts, a client should ask for a receipt if the server supports it (simple broker does not). For example, with the Java [STOMP client](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#websocket-stomp-client), you could do the following to add a receipt:
#### ** Chinese **

什么时候这样做没用？不要尝试将代理和控制器映射到同一个目标前缀，除非你想让两者都独立处理报文，包括订阅，因为某些原因。入站消息是并行处理的。不能保证是代理还是控制器先处理一个给定的消息。如果目标是在订阅被存储并准备好广播的时候被通知，如果服务器支持的话，客户端应该要求收据（简单的broker不支持）。例如，用Java[STOMP客户端](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#websocket-stomp-client)，你可以做以下操作来增加一个收据。

<!-- tabs:end -->


```java
@Autowired
private TaskScheduler messageBrokerTaskScheduler;

// During initialization..
stompClient.setTaskScheduler(this.messageBrokerTaskScheduler);

// When subscribing..
StompHeaders headers = new StompHeaders();
headers.setDestination("/topic/...");
headers.setReceipt("r1");
FrameHandler handler = ...;
stompSession.subscribe(headers, handler).addReceiptTask(() -> {
    // Subscription ready...
});
```

<!-- tabs:start -->

#### ** English **

A server side option is [to register](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#websocket-stomp-interceptors) an `ExecutorChannelInterceptor` on the `brokerChannel` and implement the `afterMessageHandled` method that is invoked after messages, including subscriptions, have been handled.
#### ** Chinese **

服务器端选项是[注册](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#websocket-stomp-interceptors)在`brokerChannel`上注册一个`ExecutorChannelInterceptor`，并实现`afterMessageHandled`方法，该方法在消息（包括订阅）被处理后被调用。

<!-- tabs:end -->


### **`@MessageExceptionHandler`** 

<!-- tabs:start -->

#### ** English **

An application can use `@MessageExceptionHandler` methods to handle exceptions from `@MessageMapping` methods. You can declare exceptions in the annotation itself or through a method argument if you want to get access to the exception instance. The following example declares an exception through a method argument:
#### ** Chinese **

应用程序可以使用`@MessageExceptionHandler`方法来处理来自`@MessageMapping`方法的异常。如果想获得对异常实例的访问权，可以在注释本身中声明异常，也可以通过方法参数声明异常。下面的例子是通过方法参数声明异常。

<!-- tabs:end -->


```java
@Controller
public class MyController {

    // ...

    @MessageExceptionHandler
    public ApplicationError handleException(MyException exception) {
        // ...
        return appError;
    }
}
```

<!-- tabs:start -->

#### ** English **

`@MessageExceptionHandler` methods support flexible method signatures and support the same method argument types and return values as [`@MessageMapping`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#websocket-stomp-message-mapping) methods.
#### ** Chinese **

`@MessageExceptionHandler`方法支持灵活的方法签名，并支持与[`@MessageMapping`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#websocket-stomp-message-mapping)方法相同的方法参数类型和返回值。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Typically, `@MessageExceptionHandler` methods apply within the `@Controller` class (or class hierarchy) in which they are declared. If you want such methods to apply more globally (across controllers), you can declare them in a class marked with `@ControllerAdvice`. This is comparable to the [similar support](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-controller-advice) available in Spring MVC.
#### ** Chinese **

通常情况下，`@MessageExceptionHandler`方法会在`@Controller`类（或类层次结构）中应用。如果你想让这些方法在全局范围内应用（跨控制器），你可以在类中声明这些方法，并标注`@ControllerAdvice`。这类似于Spring MVC中的[类似支持](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-controller-advice)。

<!-- tabs:end -->


### **4.4.7. Sending Messages** 

<!-- tabs:start -->

#### ** English **

What if you want to send messages to connected clients from any part of the application? Any application component can send messages to the `brokerChannel`. The easiest way to do so is to inject a `SimpMessagingTemplate` and use it to send messages. Typically, you would inject it by type, as the following example shows:
#### ** Chinese **

如果您想从应用程序的任何部分向连接的客户端发送消息怎么办？任何应用程序组件都可以向`brokerChannel`发送消息。最简单的方法是注入一个`SimpMessagingTemplate`并使用它来发送消息。通常情况下，你会按类型注入，如下图所示。

<!-- tabs:end -->


```java
@Controller
public class GreetingController {

    private SimpMessagingTemplate template;

    @Autowired
    public GreetingController(SimpMessagingTemplate template) {
        this.template = template;
    }

    @RequestMapping(path="/greetings", method=POST)
    public void greet(String greeting) {
        String text = "[" + getTimestamp() + "]:" + greeting;
        this.template.convertAndSend("/topic/greetings", text);
    }

}
```

<!-- tabs:start -->

#### ** English **

However, you can also qualify it by its name (`brokerMessagingTemplate`), if another bean of the same type exists.
#### ** Chinese **

但是，如果存在另一个相同类型的Bean，你也可以通过它的名字来限定它（`brokerMessagingTemplate`）。

<!-- tabs:end -->


### **4.4.8. Simple Broker** 

<!-- tabs:start -->

#### ** English **

The built-in simple message broker handles subscription requests from clients, stores them in memory, and broadcasts messages to connected clients that have matching destinations. The broker supports path-like destinations, including subscriptions to Ant-style destination patterns.
#### ** Chinese **

内置的简单消息代理处理来自客户端的订阅请求，将其存储在内存中，并将消息广播给有匹配目的地的连接客户端。该代理支持类似路径的目的地，包括订阅Ant式的目的地模式。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Applications can also use dot-separated (rather than slash-separated) destinations. See [Dots as Separators](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#websocket-stomp-destination-separator).
#### ** Chinese **

应用程序也可以使用点分隔（而不是斜线分隔）目的地。参见[点分隔符](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#websocket-stomp-destination-separator)。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

If configured with a task scheduler, the simple broker supports [STOMP heartbeats](https://stomp.github.io/stomp-specification-1.2.html#Heart-beating). For that, you can declare your own scheduler or use the one that is automatically declared and used internally. The following example shows how to declare your own scheduler:
#### ** Chinese **

如果配置了任务调度器，简单的代理支持[STOMP心跳](https://stomp.github.io/stomp-specification-1.2.html#Heart-beating)。为此，你可以声明自己的调度器，或者使用内部自动声明和使用的调度器。下面的例子说明了如何声明自己的调度器。

<!-- tabs:end -->


```java
@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

    private TaskScheduler messageBrokerTaskScheduler;

    @Autowired
    public void setMessageBrokerTaskScheduler(TaskScheduler taskScheduler) {
        this.messageBrokerTaskScheduler = taskScheduler;
    }

    @Override
    public void configureMessageBroker(MessageBrokerRegistry registry) {

        registry.enableSimpleBroker("/queue/", "/topic/")
                .setHeartbeatValue(new long[] {10000, 20000})
                .setTaskScheduler(this.messageBrokerTaskScheduler);

        // ...
    }
}
```

### **4.4.9. External Broker** 

<!-- tabs:start -->

#### ** English **

The simple broker is great for getting started but supports only a subset of STOMP commands (it does not support acks, receipts, and some other features), relies on a simple message-sending loop, and is not suitable for clustering. As an alternative, you can upgrade your applications to use a full-featured message broker.
#### ** Chinese **

这种简单的消息代理很适合入门，但只支持STOMP命令的一个子集（它不支持acks、receiptts和其他一些功能），依赖于一个简单的消息发送循环，并且不适合集群。作为替代方案，你可以升级你的应用程序，使用功能齐全的消息代理。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

See the STOMP documentation for your message broker of choice (such as [RabbitMQ](https://www.rabbitmq.com/stomp.html), [ActiveMQ](https://activemq.apache.org/stomp.html), and others), install the broker, and run it with STOMP support enabled. Then you can enable the STOMP broker relay (instead of the simple broker) in the Spring configuration.
#### ** Chinese **

请参阅您所选择的消息代理的STOMP文档（如[RabbitMQ](https://www.rabbitmq.com/stomp.html)、[ActiveMQ](https://activemq.apache.org/stomp.html)等），安装代理，并在启用STOMP支持的情况下运行。然后，您可以在Spring配置中启用STOMP代理中继（而不是简单的代理）。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following example configuration enables a full-featured broker:
#### ** Chinese **

下面的示例配置实现了一个全功能代理。

<!-- tabs:end -->


```java
@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

    @Override
    public void registerStompEndpoints(StompEndpointRegistry registry) {
        registry.addEndpoint("/portfolio").withSockJS();
    }

    @Override
    public void configureMessageBroker(MessageBrokerRegistry registry) {
        registry.enableStompBrokerRelay("/topic", "/queue");
        registry.setApplicationDestinationPrefixes("/app");
    }

}
```

<!-- tabs:start -->

#### ** English **

The following example shows the XML configuration equivalent of the preceding example:
#### ** Chinese **

下面的例子显示了XML配置与前一个例子的等价物。

<!-- tabs:end -->


```xml
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:websocket="http://www.springframework.org/schema/websocket"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/websocket
        https://www.springframework.org/schema/websocket/spring-websocket.xsd">

    <websocket:message-broker application-destination-prefix="/app">
        <websocket:stomp-endpoint path="/portfolio" />
            <websocket:sockjs/>
        </websocket:stomp-endpoint>
        <websocket:stomp-broker-relay prefix="/topic,/queue" />
    </websocket:message-broker>

</beans>
```

<!-- tabs:start -->

#### ** English **

The STOMP broker relay in the preceding configuration is a Spring [`MessageHandler`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/messaging/MessageHandler.html) that handles messages by forwarding them to an external message broker. To do so, it establishes TCP connections to the broker, forwards all messages to it, and then forwards all messages received from the broker to clients through their WebSocket sessions. Essentially, it acts as a “relay” that forwards messages in both directions.
#### ** Chinese **

前面配置的STOMP代理中继是一个Spring [`MessageHandler`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/messaging/MessageHandler.html)，它通过将消息转发到外部消息代理来处理消息。为此，它与代理建立TCP连接，将所有消息转发到代理，然后将从代理接收到的所有消息通过WebSocket会话转发到客户端。从本质上说，它就像一个 中继，将消息双向转发。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Add `io.projectreactor.netty:reactor-netty` and `io.netty:netty-all` dependencies to your project for TCP connection management.
#### ** Chinese **

将 `io.projectreactor.netty:reactor-netty` 和 `io.netty:netty-all` 依赖关系添加到你的项目中，用于 TCP 连接管理。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Furthermore, application components (such as HTTP request handling methods, business services, and others) can also send messages to the broker relay, as described in [Sending Messages](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#websocket-stomp-handle-send), to broadcast messages to subscribed WebSocket clients.
#### ** Chinese **

此外，应用程序组件（如HTTP请求处理方法、业务服务等）也可以像[发送消息](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#websocket-stomp-handle-send)中描述的那样，向代理中继发送消息，向订阅的WebSocket客户端广播消息。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

In effect, the broker relay enables robust and scalable message broadcasting.
#### ** Chinese **

实际上，经纪人中继实现了稳健的、可扩展的消息广播。

<!-- tabs:end -->


### **4.4.10. Connecting to a Broker** 

<!-- tabs:start -->

#### ** English **

A STOMP broker relay maintains a single “system” TCP connection to the broker. This connection is used for messages originating from the server-side application only, not for receiving messages. You can configure the STOMP credentials (that is, the STOMP frame `login` and `passcode` headers) for this connection. This is exposed in both the XML namespace and Java configuration as the `systemLogin` and `systemPasscode` properties with default values of `guest` and `guest`.
#### ** Chinese **

STOMP代理中继器保持一个单一的 系统 TCP连接到代理。该连接仅用于发自服务器端应用程序的消息，不用于接收消息。您可以为这个连接配置 STOMP 凭据（即 STOMP 帧 `login` 和 `passcode` 头文件）。这在 XML 命名空间和 Java 配置中都以 `systemLogin` 和 `systemPasscode` 属性的默认值为 `guest` 和 `guest` 的形式公开。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The STOMP broker relay also creates a separate TCP connection for every connected WebSocket client. You can configure the STOMP credentials that are used for all TCP connections created on behalf of clients. This is exposed in both the XML namespace and Java configuration as the `clientLogin` and `clientPasscode` properties with default values of `guest` and `guest`.
#### ** Chinese **

STOMP 代理中继也为每个连接的 WebSocket 客户端创建一个单独的 TCP 连接。您可以配置STOMP凭证，这些凭证用于代表客户端创建的所有TCP连接。这在 XML 命名空间和 Java 配置中都以 `clientLogin` 和 `clientPasscode` 属性的默认值 `guest` 和 `guest` 的形式公开。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The STOMP broker relay always sets the `login` and `passcode` headers on every `CONNECT` frame that it forwards to the broker on behalf of clients. Therefore, WebSocket clients need not set those headers. They are ignored. As the [Authentication](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#websocket-stomp-authentication) section explains, WebSocket clients should instead rely on HTTP authentication to protect the WebSocket endpoint and establish the client identity.
#### ** Chinese **

STOMP代理中继总是在它代表客户转发给代理的每个`CONNECT`帧上设置`login`和`passcode`头。因此，WebSocket 客户端不需要设置这些报头。它们会被忽略。正如[身份验证](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#websocket-stomp-authentication)部分所解释的那样，WebSocket 客户端应该依靠 HTTP 身份验证来保护 WebSocket 端点并建立客户机身份。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The STOMP broker relay also sends and receives heartbeats to and from the message broker over the “system” TCP connection. You can configure the intervals for sending and receiving heartbeats (10 seconds each by default). If connectivity to the broker is lost, the broker relay continues to try to reconnect, every 5 seconds, until it succeeds.
#### ** Chinese **

STOMP代理中继也通过 系统 TCP连接向消息代理发送和接收心跳。您可以配置发送和接收心跳的时间间隔（默认为10秒）。如果失去了与代理的连接，代理中继会继续尝试重新连接，每隔5秒一次，直到成功为止。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Any Spring bean can implement `ApplicationListener<BrokerAvailabilityEvent>` to receive notifications when the “system” connection to the broker is lost and re-established. For example, a Stock Quote service that broadcasts stock quotes can stop trying to send messages when there is no active “system” connection.
#### ** Chinese **

任何Spring bean都可以实现`ApplicationListener<BrokerAvailabilityEvent>`，以便在 系统 连接到经纪商的 系统 连接丢失并重新建立时接收通知。例如，当没有活动的 系统 连接时，广播股票报价服务可以停止尝试发送消息。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

By default, the STOMP broker relay always connects, and reconnects as needed if connectivity is lost, to the same host and port. If you wish to supply multiple addresses, on each attempt to connect, you can configure a supplier of addresses, instead of a fixed host and port. The following example shows how to do that:
#### ** Chinese **

默认情况下，STOMP代理中继总是连接，如果失去连接，则根据需要重新连接到同一主机和端口。如果您希望在每次尝试连接时提供多个地址，您可以配置一个地址供应商，而不是固定的主机和端口。下面的例子说明了如何做到这一点。

<!-- tabs:end -->


```java
@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig extends AbstractWebSocketMessageBrokerConfigurer {

    // ...

    @Override
    public void configureMessageBroker(MessageBrokerRegistry registry) {
        registry.enableStompBrokerRelay("/queue/", "/topic/").setTcpClient(createTcpClient());
        registry.setApplicationDestinationPrefixes("/app");
    }

    private ReactorNettyTcpClient<byte[]> createTcpClient() {
        return new ReactorNettyTcpClient<>(
                client -> client.addressSupplier(() -> ... ),
                new StompReactorNettyCodec());
    }
}
```

<!-- tabs:start -->

#### ** English **

You can also configure the STOMP broker relay with a `virtualHost` property. The value of this property is set as the `host` header of every `CONNECT` frame and can be useful (for example, in a cloud environment where the actual host to which the TCP connection is established differs from the host that provides the cloud-based STOMP service).
#### ** Chinese **

您还可以用`virtualHost`属性配置STOMP代理中继。此属性的值被设置为每个 `CONNECT` 帧的 `host` 头，该属性的值可能很有用（例如，在云环境中，建立 TCP 连接的实际主机与提供基于云的 STOMP 服务的主机不同）。

<!-- tabs:end -->


### **4.4.11. Dots as Separators** 

<!-- tabs:start -->

#### ** English **

When messages are routed to `@MessageMapping` methods, they are matched with `AntPathMatcher`. By default, patterns are expected to use slash (`/`) as the separator. This is a good convention in web applications and similar to HTTP URLs. However, if you are more used to messaging conventions, you can switch to using dot (`.`) as the separator.
#### ** Chinese **

当消息被路由到`@MessageMapping`方法时，它们将与`AntPathMatcher`匹配。默认情况下，模式会使用斜线（`/`）作为分隔符。这在web应用中是一个很好的惯例，类似于HTTP URL。但是，如果您更习惯于使用消息传递协议，您可以改用点(`.`.</x>)作为分隔符。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following example shows how to do so in Java configuration:
#### ** Chinese **

下面的例子显示了在Java配置中如何做到这一点。

<!-- tabs:end -->


```java
@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

    // ...

    @Override
    public void configureMessageBroker(MessageBrokerRegistry registry) {
        registry.setPathMatcher(new AntPathMatcher("."));
        registry.enableStompBrokerRelay("/queue", "/topic");
        registry.setApplicationDestinationPrefixes("/app");
    }
}
```

<!-- tabs:start -->

#### ** English **

The following example shows the XML configuration equivalent of the preceding example:
#### ** Chinese **

下面的例子显示了XML配置与前一个例子的等价物。

<!-- tabs:end -->


```xml
<beans xmlns="http://www.springframework.org/schema/beans"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xmlns:websocket="http://www.springframework.org/schema/websocket"
        xsi:schemaLocation="
                http://www.springframework.org/schema/beans
                https://www.springframework.org/schema/beans/spring-beans.xsd
                http://www.springframework.org/schema/websocket
                https://www.springframework.org/schema/websocket/spring-websocket.xsd">

    <websocket:message-broker application-destination-prefix="/app" path-matcher="pathMatcher">
        <websocket:stomp-endpoint path="/stomp"/>
        <websocket:stomp-broker-relay prefix="/topic,/queue" />
    </websocket:message-broker>

    <bean id="pathMatcher" class="org.springframework.util.AntPathMatcher">
        <constructor-arg index="0" value="."/>
    </bean>

</beans>
```

<!-- tabs:start -->

#### ** English **

After that, a controller can use a dot (`.`) as the separator in `@MessageMapping` methods, as the following example shows:
#### ** Chinese **

之后，控制器可以在`@MessageMapping`方法中使用点(`.`)作为分隔符，如下例所示。

<!-- tabs:end -->


```java
@Controller
@MessageMapping("red")
public class RedController {

    @MessageMapping("blue.{green}")
    public void handleGreen(@DestinationVariable String green) {
        // ...
    }
}
```

<!-- tabs:start -->

#### ** English **

The client can now send a message to `/app/red.blue.green123`.
#### ** Chinese **

客户端现在可以发送消息到`/app/red.blue.green123`。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

In the preceding example, we did not change the prefixes on the “broker relay”, because those depend entirely on the external message broker. See the STOMP documentation pages for the broker you use to see what conventions it supports for the destination header.
#### ** Chinese **

在前面的例子中，我们没有改变 代理中继 的前缀，因为这些完全取决于外部消息代理。请查看你所使用的代理的STOMP文档页面，看看它支持的目标头有哪些约定。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The “simple broker”, on the other hand, does rely on the configured `PathMatcher`, so, if you switch the separator, that change also applies to the broker and the way the broker matches destinations from a message to patterns in subscriptions.
#### ** Chinese **

另一方面，简单代理 确实依赖于配置的`PathMatcher`，因此，如果你切换了分隔符，这一变化也适用于代理和代理从消息到订阅中的模式匹配目的地的方式。

<!-- tabs:end -->


### **4.4.12. Authentication** 

<!-- tabs:start -->

#### ** English **

Every STOMP over WebSocket messaging session begins with an HTTP request. That can be a request to upgrade to WebSockets (that is, a WebSocket handshake) or, in the case of SockJS fallbacks, a series of SockJS HTTP transport requests.
#### ** Chinese **

每个 STOMP over WebSocket 消息传递会话都以 HTTP 请求开始。这可以是一个升级到WebSocket的请求（也就是WebSocket握手），或者在SockJS回退的情况下，是一系列SockJS HTTP传输请求。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Many web applications already have authentication and authorization in place to secure HTTP requests. Typically, a user is authenticated through Spring Security by using some mechanism such as a login page, HTTP basic authentication, or another way. The security context for the authenticated user is saved in the HTTP session and is associated with subsequent requests in the same cookie-based session.
#### ** Chinese **

许多Web应用程序已经有了身份验证和授权来保障HTTP请求的安全。通常情况下，用户通过Spring Security通过一些机制（如登录页面、HTTP基本认证或其他方式）进行身份验证。经过认证的用户的安全上下文保存在HTTP会话中，并与同一个基于cookie的会话中的后续请求相关联。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Therefore, for a WebSocket handshake or for SockJS HTTP transport requests, typically, there is already an authenticated user accessible through `HttpServletRequest#getUserPrincipal()`. Spring automatically associates that user with a WebSocket or SockJS session created for them and, subsequently, with all STOMP messages transported over that session through a user header.
#### ** Chinese **

因此，对于 WebSocket 握手或 SockJS HTTP 传输请求，通常情况下，已经有一个通过 `HttpServletRequest#getUserPrincipal()`访问的认证用户。Spring会自动将该用户与为其创建的WebSocket或SockJS会话关联，随后，通过用户头将该用户与通过该会话传输的所有STOMP消息关联。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

In short, a typical web application needs to do nothing beyond what it already does for security. The user is authenticated at the HTTP request level with a security context that is maintained through a cookie-based HTTP session (which is then associated with WebSocket or SockJS sessions created for that user) and results in a user header being stamped on every `Message` flowing through the application.
#### ** Chinese **

简而言之，一个典型的Web应用在安全方面不需要做任何其他事情。用户在HTTP请求层通过基于cookie的HTTP会话（然后与为该用户创建的WebSocket或SockJS会话相关联）维护的安全上下文对用户进行身份验证，并在每个流经应用程序的`Message`上加盖用户头。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Note that the STOMP protocol does have `login` and `passcode` headers on the `CONNECT` frame. Those were originally designed for and are still needed, for example, for STOMP over TCP. However, for STOMP over WebSocket, by default, Spring ignores authorization headers at the STOMP protocol level, assumes that the user is already authenticated at the HTTP transport level, and expects that the WebSocket or SockJS session contain the authenticated user.
#### ** Chinese **

请注意，STOMP协议在`CONNECT`帧上确实有`login`和`passcode`头。这些是最初设计的，现在仍然需要，例如，对于TCP上的STOMP来说。然而，对于 WebSocket 上的 STOMP，Spring 默认情况下会忽略 STOMP 协议层的授权头，假定用户已经在 HTTP 传输层进行了身份验证，并期望 WebSocket 或 SockJS 会话包含已验证的用户。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Spring Security provides [WebSocket sub-protocol authorization](https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#websocket) that uses a `ChannelInterceptor` to authorize messages based on the user header in them. Also, Spring Session provides a [WebSocket integration](https://docs.spring.io/spring-session/docs/current/reference/html5/#websocket) that ensures the user HTTP session does not expire when the WebSocket session is still active.
#### ** Chinese **

Spring Security提供了[WebSocket子协议授权](https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#websocket)，它使用一个`ChannelInterceptor`来根据用户报文中的用户头进行授权。另外，Spring Session提供了一个[WebSocket集成](https://docs.spring.io/spring-session/docs/current/reference/html5/#websocket)，可以确保用户的HTTP会话在WebSocket会话仍处于活动状态时不会过期。

<!-- tabs:end -->


### **4.4.13. Token Authentication** 

<!-- tabs:start -->

#### ** English **

[Spring Security OAuth](https://github.com/spring-projects/spring-security-oauth) provides support for token based security, including JSON Web Token (JWT). You can use this as the authentication mechanism in Web applications, including STOMP over WebSocket interactions, as described in the previous section (that is, to maintain identity through a cookie-based session).
#### ** Chinese **

Spring Security OAuth](https://github.com/spring-projects/spring-security-oauth)提供了对基于令牌安全的支持，包括JSON Web Token (JWT)。你可以在Web应用中使用它作为身份验证机制，包括通过WebSocket交互的STOMP（即通过基于cookie的会话来维护身份）。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

At the same time, cookie-based sessions are not always the best fit (for example, in applications that do not maintain a server-side session or in mobile applications where it is common to use headers for authentication).
#### ** Chinese **

同时，基于cookie的会话并不总是最适合（例如，在不维护服务器端会话的应用中，或者在移动应用中，使用头文件进行身份验证是很常见的）。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The [WebSocket protocol, RFC 6455](https://tools.ietf.org/html/rfc6455#section-10.5) "doesn’t prescribe any particular way that servers can authenticate clients during the WebSocket handshake." In practice, however, browser clients can use only standard authentication headers (that is, basic HTTP authentication) or cookies and cannot (for example) provide custom headers. Likewise, the SockJS JavaScript client does not provide a way to send HTTP headers with SockJS transport requests. See [sockjs-client issue 196](https://github.com/sockjs/sockjs-client/issues/196). Instead, it does allow sending query parameters that you can use to send a token, but that has its own drawbacks (for example, the token may be inadvertently logged with the URL in server logs).
#### ** Chinese **

[WebSocket协议，RFC 6455](https://tools.ietf.org/html/rfc6455#section-10.5) "没有规定服务器在WebSocket握手过程中对客户进行身份验证的任何特定方式。但实际上，浏览器客户端只能使用标准的认证头（即基本的HTTP认证）或cookies，不能（例如）提供自定义的头。同样，SockJS JavaScript客户端也没有提供一种方法来发送带有SockJS传输请求的HTTP头文件。参见[sockjs-client issue 196](https://github.com/sockjs/sockjs-client/issues/196)。相反，它确实允许发送查询参数，你可以用它来发送令牌，但这有其自身的缺点（例如，令牌可能会在服务器日志中无意中与URL一起被记录下来）。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The preceding limitations are for browser-based clients and do not apply to the Spring Java-based STOMP client, which does support sending headers with both WebSocket and SockJS requests.
#### ** Chinese **

前面的限制是针对基于浏览器的客户端，不适用于基于Spring Java的STOMP客户端，而STOMP客户端确实支持通过WebSocket和SockJS请求发送头文件。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Therefore, applications that wish to avoid the use of cookies may not have any good alternatives for authentication at the HTTP protocol level. Instead of using cookies, they may prefer to authenticate with headers at the STOMP messaging protocol level Doing so requires two simple steps:
#### ** Chinese **

因此，希望避免使用cookie的应用程序可能没有任何好的替代方案来在HTTP协议层面进行身份验证。与其使用cookie，他们可能更愿意使用STOMP消息协议级别的头文件进行身份验证。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Use the STOMP client to pass authentication headers at connect time.Process the authentication headers with a `ChannelInterceptor`.
#### ** Chinese **

使用STOMP客户端在连接时传递认证头，用`ChannelInterceptor`处理认证头。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The next example uses server-side configuration to register a custom authentication interceptor. Note that an interceptor needs only to authenticate and set the user header on the CONNECT `Message`. Spring notes and saves the authenticated user and associate it with subsequent STOMP messages on the same session. The following example shows how register a custom authentication interceptor:
#### ** Chinese **

下一个示例使用服务器端配置来注册一个自定义验证拦截器。注意，拦截器只需要在CONNECT `Message`上进行身份验证并设置用户头。Spring 注释并保存已认证的用户，并将其与同一会话上的后续 STOMP 消息关联。下面的例子显示了如何注册一个自定义验证拦截器。

<!-- tabs:end -->


```java
@Configuration
@EnableWebSocketMessageBroker
public class MyConfig implements WebSocketMessageBrokerConfigurer {

    @Override
    public void configureClientInboundChannel(ChannelRegistration registration) {
        registration.interceptors(new ChannelInterceptor() {
            @Override
            public Message<?> preSend(Message<?> message, MessageChannel channel) {
                StompHeaderAccessor accessor =
                        MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class);
                if (StompCommand.CONNECT.equals(accessor.getCommand())) {
                    Authentication user = ... ; // access authentication header(s)
                    accessor.setUser(user);
                }
                return message;
            }
        });
    }
}
```

<!-- tabs:start -->

#### ** English **

Also, note that, when you use Spring Security’s authorization for messages, at present, you need to ensure that the authentication `ChannelInterceptor` config is ordered ahead of Spring Security’s. This is best done by declaring the custom interceptor in its own implementation of `WebSocketMessageBrokerConfigurer` that is marked with `@Order(Ordered.HIGHEST_PRECEDENCE + 99)`.
#### ** Chinese **

另外，需要注意的是，当你使用Spring Security的消息授权时，目前需要确保认证`ChannelInterceptor`配置先于Spring Security的配置排序。这最好通过在其自身实现的`WebSocketMessageBrokerConfigurer`中声明自定义拦截器来实现，该自定义拦截器被标记为`@Order(Ordered.HIGHEST_PRECEDENCE + 99)`。

<!-- tabs:end -->


### **4.4.14. User Destinations** 

<!-- tabs:start -->

#### ** English **

An application can send messages that target a specific user, and Spring’s STOMP support recognizes destinations prefixed with `/user/` for this purpose. For example, a client might subscribe to the `/user/queue/position-updates` destination. This destination is handled by the `UserDestinationMessageHandler` and transformed into a destination unique to the user session (such as `/queue/position-updates-user123`). This provides the convenience of subscribing to a generically named destination while, at the same time, ensuring no collisions with other users who subscribe to the same destination so that each user can receive unique stock position updates.
#### ** Chinese **

应用程序可以发送针对特定用户的消息，而Spring的STOMP支持为此目的识别以`/user/`为前缀的目的地。例如，客户端可能会订阅`/user/queue/position-updates`目的地。这个目的地由`UserDestinationMessageHandler`处理，并转换为用户会话中唯一的目的地（如`/queue/position-updates-user123`）。这提供了订阅一个通用命名的目的地的便利，同时，确保不会与订阅同一目的地的其他用户发生碰撞，从而使每个用户都能收到唯一的股票位置更新。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

On the sending side, messages can be sent to a destination such as `/user/{username}/queue/position-updates`, which in turn is translated by the `UserDestinationMessageHandler` into one or more destinations, one for each session associated with the user. This lets any component within the application send messages that target a specific user without necessarily knowing anything more than their name and the generic destination. This is also supported through an annotation and a messaging template.
#### ** Chinese **

在发送端，消息可以被发送到一个目的地，例如 `/user/{username}/queue/position-updates`，而这个目的地又被`UserDestinationMessageHandler`翻译成一个或多个目的地，每个与用户相关联的会话都有一个。这使得应用程序中的任何组件都可以发送针对特定用户的消息，而不需要知道他们的名字和通用目的地。这也可以通过一个注释和消息模板来支持。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

A message-handling method can send messages to the user associated with the message being handled through the `@SendToUser` annotation (also supported on the class-level to share a common destination), as the following example shows:
#### ** Chinese **

一个消息处理方法可以通过`@SendToUser`注解（也支持在类级上共享一个共同的目的地），向与被处理的消息相关联的用户发送消息，如下例所示。

<!-- tabs:end -->


```java
@Controller
public class PortfolioController {

    @MessageMapping("/trade")
    @SendToUser("/queue/position-updates")
    public TradeResult executeTrade(Trade trade, Principal principal) {
        // ...
        return tradeResult;
    }
}
```

<!-- tabs:start -->

#### ** English **

If the user has more than one session, by default, all of the sessions subscribed to the given destination are targeted. However, sometimes, it may be necessary to target only the session that sent the message being handled. You can do so by setting the `broadcast` attribute to false, as the following example shows:
#### ** Chinese **

如果用户有一个以上的会话，默认情况下，所有订阅到给定目标的会话都会成为目标。但是，有时可能需要只针对发送消息处理的会话。您可以通过将 `broadcast` 属性设置为 false 来做到这一点，如下例所示。

<!-- tabs:end -->


```java
@Controller
public class MyController {

    @MessageMapping("/action")
    public void handleAction() throws Exception{
        // raise MyBusinessException here
    }

    @MessageExceptionHandler
    @SendToUser(destinations="/queue/errors", broadcast=false)
    public ApplicationError handleException(MyBusinessException exception) {
        // ...
        return appError;
    }
}
```

<!-- tabs:start -->

#### ** English **

While user destinations generally imply an authenticated user, it is not strictly required. A WebSocket session that is not associated with an authenticated user can subscribe to a user destination. In such cases, the `@SendToUser` annotation behaves exactly the same as with `broadcast=false` (that is, targeting only the session that sent the message being handled).
#### ** Chinese **

虽然用户目的地通常意味着经过身份验证的用户，但这并不是严格要求。一个没有与认证用户关联的WebSocket会话可以订阅用户目的地。在这种情况下，`@SendToUser`注释的行为与`broadcast=false`完全相同（也就是说，只针对发送正在处理的消息的会话）。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can send a message to user destinations from any application component by, for example, injecting the `SimpMessagingTemplate` created by the Java configuration or the XML namespace. (The bean name is `brokerMessagingTemplate` if required for qualification with `@Qualifier`.) The following example shows how to do so:
#### ** Chinese **

你可以从任何应用程序组件中向用户目的地发送消息，例如，通过注入由Java配置或XML命名空间创建的`SimpMessagingTemplate`，就可以向用户目的地发送消息。(如果需要用`@Qualifier`进行限定，则Bean名为`brokerMessagingTemplate`)。下面的例子显示了如何做到这一点。

<!-- tabs:end -->


```java
@Service
public class TradeServiceImpl implements TradeService {

    private final SimpMessagingTemplate messagingTemplate;

    @Autowired
    public TradeServiceImpl(SimpMessagingTemplate messagingTemplate) {
        this.messagingTemplate = messagingTemplate;
    }

    // ...

    public void afterTradeExecuted(Trade trade) {
        this.messagingTemplate.convertAndSendToUser(
                trade.getUserName(), "/queue/position-updates", trade.getResult());
    }
}
```

<!-- tabs:start -->

#### ** English **

When you use user destinations with an external message broker, you should check the broker documentation on how to manage inactive queues, so that, when the user session is over, all unique user queues are removed. For example, RabbitMQ creates auto-delete queues when you use destinations such as `/exchange/amq.direct/position-updates`. So, in that case, the client could subscribe to `/user/exchange/amq.direct/position-updates`. Similarly, ActiveMQ has [configuration options](https://activemq.apache.org/delete-inactive-destinations.html) for purging inactive destinations.
#### ** Chinese **

当您使用外部消息代理的用户目的地时，应该检查代理文档中关于如何管理非活动队列的内容，这样当用户会话结束时，所有唯一的用户队列都会被删除。例如，当您使用`/exchange/amq.direct/position-updates`等目的地时，RabbitMQ会创建自动删除队列。因此，在这种情况下，客户端可以订阅`/user/exchange/amq.direct/position-updates`。同样，ActiveMQ有[配置选项](https://activemq.apache.org/delete-inactive-destinations.html)用于清除非活动目的地。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

In a multi-application server scenario, a user destination may remain unresolved because the user is connected to a different server. In such cases, you can configure a destination to broadcast unresolved messages so that other servers have a chance to try. This can be done through the `userDestinationBroadcast` property of the `MessageBrokerRegistry` in Java configuration and the `user-destination-broadcast` attribute of the `message-broker` element in XML.
#### ** Chinese **

在多应用服务器的场景中，由于用户连接到不同的服务器，用户的目的地可能仍然无法解决。在这种情况下，你可以配置一个目的地来广播未解决的消息，以便其他服务器有机会尝试。这可以通过Java配置中的`MessageBrokerRegistry`中的`userDestinationBroadcast`属性和XML中的`message-broker`元素的`user-destination-broadcast`属性来实现。

<!-- tabs:end -->


### **4.4.15. Order of Messages** 

<!-- tabs:start -->

#### ** English **

Messages from the broker are published to the `clientOutboundChannel`, from where they are written to WebSocket sessions. As the channel is backed by a `ThreadPoolExecutor`, messages are processed in different threads, and the resulting sequence received by the client may not match the exact order of publication.
#### ** Chinese **

来自代理的消息被发布到`clientOutboundChannel`，从那里将消息写入WebSocket会话。由于该通道由 `ThreadPoolExecutor`支持，因此消息在不同的线程中处理，客户机接收到的结果序列可能与发布的准确顺序不一致。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

If this is an issue, enable the `setPreservePublishOrder` flag, as the following example shows:
#### ** Chinese **

如果这是一个问题，请启用`setPreservePublishOrder`标志，如下例所示。

<!-- tabs:end -->


```java
@Configuration
@EnableWebSocketMessageBroker
public class MyConfig implements WebSocketMessageBrokerConfigurer {

    @Override
    protected void configureMessageBroker(MessageBrokerRegistry registry) {
        // ...
        registry.setPreservePublishOrder(true);
    }

}
```

<!-- tabs:start -->

#### ** English **

The following example shows the XML configuration equivalent of the preceding example:
#### ** Chinese **

下面的例子显示了XML配置与前一个例子的等价物。

<!-- tabs:end -->


```xml
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:websocket="http://www.springframework.org/schema/websocket"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/websocket
        https://www.springframework.org/schema/websocket/spring-websocket.xsd">

    <websocket:message-broker preserve-publish-order="true">
        <!-- ... -->
    </websocket:message-broker>

</beans>
```

<!-- tabs:start -->

#### ** English **

When the flag is set, messages within the same client session are published to the `clientOutboundChannel` one at a time, so that the order of publication is guaranteed. Note that this incurs a small performance overhead, so you should enable it only if it is required.
#### ** Chinese **

当该标志被设置时，同一客户端会话内的消息会一次一个一个地发布到`clientOutboundChannel`，这样发布的顺序就会得到保证。注意，这样做会产生少量的性能开销，所以只有在需要时才启用。

<!-- tabs:end -->


### **4.4.16. Events** 

<!-- tabs:start -->

#### ** English **

Several `ApplicationContext` events are published and can be received by implementing Spring’s `ApplicationListener` interface:
#### ** Chinese **

多个`ApplicationContext`事件被发布，可以通过实现Spring的`ApplicationListener`接口来接收。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

- [`@MessageMapping`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#websocket-stomp-message-mapping)

- [`@SubscribeMapping`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#websocket-stomp-subscribe-mapping)

- [`@MessageExceptionHandler`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#websocket-stomp-exception-handler)

- `BrokerAvailabilityEvent`: Indicates when the broker becomes available or unavailable. While the “simple” broker becomes available immediately on startup and remains so while the application is running, the STOMP “broker relay” can lose its connection to the full featured broker (for example, if the broker is restarted). The broker relay has reconnect logic and re-establishes the “system” connection to the broker when it comes back. As a result, this event is published whenever the state changes from connected to disconnected and vice-versa. Components that use the `SimpMessagingTemplate` should subscribe to this event and avoid sending messages at times when the broker is not available. In any case, they should be prepared to handle `MessageDeliveryException` when sending a message.

- `SessionConnectEvent`: Published when a new STOMP CONNECT is received to indicate the start of a new client session. The event contains the message that represents the connect, including the session ID, user information (if any), and any custom headers the client sent. This is useful for tracking client sessions. Components subscribed to this event can wrap the contained message with `SimpMessageHeaderAccessor` or `StompMessageHeaderAccessor`.

- `SessionConnectedEvent`: Published shortly after a `SessionConnectEvent` when the broker has sent a STOMP CONNECTED frame in response to the CONNECT. At this point, the STOMP session can be considered fully established.

- `SessionSubscribeEvent`: Published when a new STOMP SUBSCRIBE is received.

- `SessionUnsubscribeEvent`: Published when a new STOMP UNSUBSCRIBE is received.

- `SessionDisconnectEvent`: Published when a STOMP session ends. The DISCONNECT may have been sent from the client or it may be automatically generated when the WebSocket session is closed. In some cases, this event is published more than once per session. Components should be idempotent with regard to multiple disconnect events.

#### ** Chinese **

- [`@MessageMapping`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#websocket-stomp-message-mapping)

- [`@SubscribeMapping`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#websocket-stomp-subscribe-mapping)

- [`@MessageExceptionHandler`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#websocket-stomp-exception-handler)

- `BrokerAvailabilityEvent`：指示经纪商何时变得可用或不可用。虽然 "简单 "代理在启动时立即变得可用，并在应用程序运行时保持可用，但STOMP的 "代理中继 "可能会失去与全功能代理的连接（例如，如果代理被重新启动）。经纪人中继有重新连接逻辑，当它回来时，会重新建立与经纪商的 "系统 "连接。因此，每当状态从连接到断开时，这个事件就会被发布，反之亦然。使用`SimpMessagingTemplate`的组件应该订阅此事件，并避免在代理不可用时发送消息。在任何情况下，它们应该准备好在发送消息时处理`MessageDeliveryException`。

- `SessionConnectEvent`。当收到一个新的STOMP CONNECT时发布，表示新的客户端会话的开始。该事件包含代表连接的消息，包括会话ID、用户信息（如果有的话）和客户端发送的任何自定义头。这对于跟踪客户机会话很有用。订阅此事件的组件可以用`SimpMessageHeaderAccessor`或`StompMessageHeaderAccessor`来封装包含的消息。

- `SessionConnectedEvent`。在`SessionConnectEvent`之后不久，当代理发送了一个响应CONNECT的STOMP CONNECTED帧后不久发布。此时，STOMP会话可以被视为完全建立。

- `SessionSubscribeEvent`。当收到一个新的STOMP SUBSCRIBE 时发布。

- `SessionUnsubscribeEvent`：当收到新的STOMP SUBSCRIBE 时发布。当收到一个新的 STOMP UNSubscribeEvent 时发布。

- `SessionDisconnectEvent`: 当STOMP会话结束时发布。当一个STOMP会话结束时发布。DISCONNECT可能是由客户端发送的，也可能是在WebSocket会话关闭时自动生成的。在某些情况下，这个事件在每个会话中发布一次以上。组件对于多个disconnect事件应该是idempotent的。


<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

When you use a full-featured broker, the STOMP “broker relay” automatically reconnects the “system” connection if broker becomes temporarily unavailable. Client connections, however, are not automatically reconnected. Assuming heartbeats are enabled, the client typically notices the broker is not responding within 10 seconds. Clients need to implement their own reconnecting logic.
#### ** Chinese **

当您使用全功能代理时，如果代理暂时不可用，STOMP "代理中继 "会自动重新连接 "系统 "连接。但是，客户端连接不会自动重新连接。假设启用了心跳，客户端通常会在10秒内注意到经纪商没有响应。客户端需要实现自己的重新连接逻辑。

<!-- tabs:end -->


### **4.4.17. Interception** 

<!-- tabs:start -->

#### ** English **

[Events](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#websocket-stomp-appplication-context-events) provide notifications for the lifecycle of a STOMP connection but not for every client message. Applications can also register a `ChannelInterceptor` to intercept any message and in any part of the processing chain. The following example shows how to intercept inbound messages from clients:
#### ** Chinese **

[Events](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#websocket-stomp-appplication-context-events)为STOMP连接的生命周期提供通知，但不是为每个客户端消息提供通知。应用程序也可以注册一个`ChannelInterceptor`来拦截任何消息，并在处理链的任何部分拦截。下面的例子显示了如何拦截来自客户端的入站消息。

<!-- tabs:end -->


```java
@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

    @Override
    public void configureClientInboundChannel(ChannelRegistration registration) {
        registration.interceptors(new MyChannelInterceptor());
    }
}
```

<!-- tabs:start -->

#### ** English **

A custom `ChannelInterceptor` can use `StompHeaderAccessor` or `SimpMessageHeaderAccessor` to access information about the message, as the following example shows:
#### ** Chinese **

一个自定义的`ChannelInterceptor`可以使用`StompHeaderAccessor`或`SimpMessageHeaderAccessor`来访问有关消息的信息，如下图所示。

<!-- tabs:end -->


```java
public class MyChannelInterceptor implements ChannelInterceptor {

    @Override
    public Message<?> preSend(Message<?> message, MessageChannel channel) {
        StompHeaderAccessor accessor = StompHeaderAccessor.wrap(message);
        StompCommand command = accessor.getStompCommand();
        // ...
        return message;
    }
}
```

<!-- tabs:start -->

#### ** English **

Applications can also implement `ExecutorChannelInterceptor`, which is a sub-interface of `ChannelInterceptor` with callbacks in the thread in which the messages are handled. While a `ChannelInterceptor` is invoked once for each message sent to a channel, the `ExecutorChannelInterceptor` provides hooks in the thread of each `MessageHandler` subscribed to messages from the channel.
#### ** Chinese **

应用程序也可以实现`ExecutorChannelInterceptor`，它是`ChannelInterceptor`的一个子接口，在处理消息的线程中提供回调。`ChannelInterceptor`会对每一条发送到通道的消息都调用一次，而`ExecutorChannelInterceptor`则在每个`MessageHandler`的线程中提供了钩子，用于处理来自通道的消息。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Note that, as with the `SesionDisconnectEvent` described earlier, a DISCONNECT message can be from the client or it can also be automatically generated when the WebSocket session is closed. In some cases, an interceptor may intercept this message more than once for each session. Components should be idempotent with regard to multiple disconnect events.
#### ** Chinese **

注意，与前面描述的`SesionDisconnectEvent`一样，DISCONNECT消息可以来自客户端，也可以在WebSocket会话关闭时自动生成。在某些情况下，拦截器可以为每个会话拦截此消息不止一次。组件对于多个断开连接事件应该是idempotent的。

<!-- tabs:end -->


### **4.4.18. STOMP Client** 

<!-- tabs:start -->

#### ** English **

Spring provides a STOMP over WebSocket client and a STOMP over TCP client.
#### ** Chinese **

Spring提供了STOMP over WebSocket客户端和STOMP over TCP客户端。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

To begin, you can create and configure `WebSocketStompClient`, as the following example shows:
#### ** Chinese **

首先，你可以创建和配置`WebSocketStompClient`，如下例所示。

<!-- tabs:end -->


```java
WebSocketClient webSocketClient = new StandardWebSocketClient();
WebSocketStompClient stompClient = new WebSocketStompClient(webSocketClient);
stompClient.setMessageConverter(new StringMessageConverter());
stompClient.setTaskScheduler(taskScheduler); // for heartbeats
```

<!-- tabs:start -->

#### ** English **

In the preceding example, you could replace `StandardWebSocketClient` with `SockJsClient`, since that is also an implementation of `WebSocketClient`. The `SockJsClient` can use WebSocket or HTTP-based transport as a fallback. For more details, see [`SockJsClient`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#websocket-fallback-sockjs-client).
#### ** Chinese **

在前面的例子中，你可以用`StandardWebSocketClient`替换为`SockJsClient`，因为这也是`WebSocketClient`的实现。`SockJsClient`可以使用WebSocket或基于HTTP的传输方式作为回退。更多详情，请参阅 [`SockJsClient`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#websocket-fallback-sockjs-client)。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Next, you can establish a connection and provide a handler for the STOMP session, as the following example shows:
#### ** Chinese **

接下来，你可以建立一个连接并为STOMP会话提供一个处理程序，如下例所示。

<!-- tabs:end -->


```java
String url = "ws://127.0.0.1:8080/endpoint";
StompSessionHandler sessionHandler = new MyStompSessionHandler();
stompClient.connect(url, sessionHandler);
```

<!-- tabs:start -->

#### ** English **

When the session is ready for use, the handler is notified, as the following example shows:
#### ** Chinese **

当会话可以使用时，就会通知处理程序，如下例所示。

<!-- tabs:end -->


```java
public class MyStompSessionHandler extends StompSessionHandlerAdapter {

    @Override
    public void afterConnected(StompSession session, StompHeaders connectedHeaders) {
        // ...
    }
}
```

<!-- tabs:start -->

#### ** English **

Once the session is established, any payload can be sent and is serialized with the configured `MessageConverter`, as the following example shows:
#### ** Chinese **

一旦建立了会话，就可以发送任何有效载荷，并通过配置的`MessageConverter`进行序列化，如下例所示。

<!-- tabs:end -->


```java
session.send("/topic/something", "payload");
```

<!-- tabs:start -->

#### ** English **

You can also subscribe to destinations. The `subscribe` methods require a handler for messages on the subscription and returns a `Subscription` handle that you can use to unsubscribe. For each received message, the handler can specify the target `Object` type to which the payload should be deserialized, as the following example shows:
#### ** Chinese **

你也可以订阅目的地。`subscribe`方法需要一个订阅上的消息处理程序，并返回一个`Subscription`句柄，可以用来取消订阅。对于每个接收到的消息，处理程序可以指定目标`Object`类型，如下面的例子所示，有效载荷应该被反序列化。

<!-- tabs:end -->


```java
session.subscribe("/topic/something", new StompFrameHandler() {

    @Override
    public Type getPayloadType(StompHeaders headers) {
        return String.class;
    }

    @Override
    public void handleFrame(StompHeaders headers, Object payload) {
        // ...
    }

});
```

<!-- tabs:start -->

#### ** English **

To enable STOMP heartbeat, you can configure `WebSocketStompClient` with a `TaskScheduler` and optionally customize the heartbeat intervals (10 seconds for write inactivity, which causes a heartbeat to be sent, and 10 seconds for read inactivity, which closes the connection).
#### ** Chinese **

要启用STOMP心跳，可以用`WebSocketStompClient`配置`TaskScheduler`，并可选择自定义心跳时间间隔（10秒为写不活动，会导致发送心跳，10秒为读不活动，会关闭连接）。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

When you use `WebSocketStompClient` for performance tests to simulate thousands of clients from the same machine, consider turning off heartbeats, since each connection schedules its own heartbeat tasks and that is not optimized for a large number of clients running on the same machine.
#### ** Chinese **

当您使用`WebSocketStompClient`进行性能测试以模拟来自同一台机器的数千个客户端时，请考虑关闭心跳任务，因为每个连接都会安排自己的心跳任务，这对于在同一台机器上运行的大量客户端来说并不是最优化的。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The STOMP protocol also supports receipts, where the client must add a `receipt` header to which the server responds with a RECEIPT frame after the send or subscribe are processed. To support this, the `StompSession` offers `setAutoReceipt(boolean)` that causes a `receipt` header to be added on every subsequent send or subscribe event. Alternatively, you can also manually add a receipt header to the `StompHeaders`. Both send and subscribe return an instance of `Receiptable` that you can use to register for receipt success and failure callbacks. For this feature, you must configure the client with a `TaskScheduler` and the amount of time before a receipt expires (15 seconds by default).
#### ** Chinese **

STOMP协议还支持接收，客户端必须添加一个`receipt`头，服务器在处理发送或订阅后用一个RECEIPT帧来响应。为了支持这一点，`StompSession`提供了`setAutoReceipt(boolean)`，它可以在每一个后续的发送或订阅事件中添加一个`receipt`头。或者，你也可以手动添加一个收据头到`StompHeaders`中。发送和订阅都会返回一个`Receiptable`实例，您可以用它来注册收件成功和失败回调。对于此功能，您必须为客户端配置一个`TaskScheduler`和收据过期前的时间（默认为15秒）。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Note that `StompSessionHandler` itself is a `StompFrameHandler`, which lets it handle ERROR frames in addition to the `handleException` callback for exceptions from the handling of messages and `handleTransportError` for transport-level errors including `ConnectionLostException`.
#### ** Chinese **

请注意，`StompSessionHandler`本身就是一个`StompFrameHandler`，除了`handleException`回调用于处理报文的异常和`handleTransportError`用于处理传输级错误（包括`ConnectionLostException`）之外，它还可以处理ERROR帧。

<!-- tabs:end -->


### **4.4.19. WebSocket Scope** 

<!-- tabs:start -->

#### ** English **

Each WebSocket session has a map of attributes. The map is attached as a header to inbound client messages and may be accessed from a controller method, as the following example shows:
#### ** Chinese **

每个WebSocket会话都有一个属性映射。该映射作为头连接到入站客户端消息中，可以通过控制器方法访问，如下例所示。

<!-- tabs:end -->


```java
@Controller
public class MyController {

    @MessageMapping("/action")
    public void handle(SimpMessageHeaderAccessor headerAccessor) {
        Map<String, Object> attrs = headerAccessor.getSessionAttributes();
        // ...
    }
}
```

<!-- tabs:start -->

#### ** English **

You can declare a Spring-managed bean in the `websocket` scope. You can inject WebSocket-scoped beans into controllers and any channel interceptors registered on the `clientInboundChannel`. Those are typically singletons and live longer than any individual WebSocket session. Therefore, you need to use a scope proxy mode for WebSocket-scoped beans, as the following example shows:
#### ** Chinese **

您可以在`websocket`作用域中声明一个Spring管理的Bean。您可以将 WebSocket 范围内的 bean 注入控制器和任何在 `clientInboundChannel` 上注册的通道拦截器中。那些通常是单子，并且比任何单独的 WebSocket 会话活得更长。因此，您需要为 WebSocket-scoped Bean 使用范围代理模式，如下例所示。

<!-- tabs:end -->


```java
@Component
@Scope(scopeName = "websocket", proxyMode = ScopedProxyMode.TARGET_CLASS)
public class MyBean {

    @PostConstruct
    public void init() {
        // Invoked after dependencies injected
    }

    // ...

    @PreDestroy
    public void destroy() {
        // Invoked when the WebSocket session ends
    }
}

@Controller
public class MyController {

    private final MyBean myBean;

    @Autowired
    public MyController(MyBean myBean) {
        this.myBean = myBean;
    }

    @MessageMapping("/action")
    public void handle() {
        // this.myBean from the current WebSocket session
    }
}
```

<!-- tabs:start -->

#### ** English **

As with any custom scope, Spring initializes a new `MyBean` instance the first time it is accessed from the controller and stores the instance in the WebSocket session attributes. The same instance is subsequently returned until the session ends. WebSocket-scoped beans have all Spring lifecycle methods invoked, as shown in the preceding examples.
#### ** Chinese **

与任何自定义作用域一样，Spring在第一次从控制器中访问MyBean</x>时初始化一个新的`MyBean`实例，并将该实例存储在WebSocket会话属性中。此后会返回相同的实例，直到会话结束。正如前面的例子所示，WebSocket-scoped Bean 的所有 Spring 生命周期方法都会被调用。

<!-- tabs:end -->


### **4.4.20. Performance** 

<!-- tabs:start -->

#### ** English **

There is no silver bullet when it comes to performance. Many factors affect it, including the size and volume of messages, whether application methods perform work that requires blocking, and external factors (such as network speed and other issues). The goal of this section is to provide an overview of the available configuration options along with some thoughts on how to reason about scaling.
#### ** Chinese **

当谈到性能时，没有什么灵丹妙药。许多因素都会影响它，包括消息的大小和数量，应用程序方法是否执行需要阻止的工作，以及外部因素（如网络速度和其他问题）。本节的目的是对可用的配置选项进行概述，同时也是对如何合理地进行扩展的一些思考。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

In a messaging application, messages are passed through channels for asynchronous executions that are backed by thread pools. Configuring such an application requires good knowledge of the channels and the flow of messages. Therefore, it is recommended to review [Flow of Messages](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#websocket-stomp-message-flow).
#### ** Chinese **

在消息传递应用中，消息通过通道进行异步执行，这些通道是由线程池支持的。配置这样一个应用程序需要对通道和消息流有很好的了解。因此，建议查阅【消息流】(https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#websocket-stomp-message-flow)。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The obvious place to start is to configure the thread pools that back the `clientInboundChannel` and the `clientOutboundChannel`. By default, both are configured at twice the number of available processors.
#### ** Chinese **

最明显的地方是配置支持`clientInboundChannel`和`clientOutboundChannel`的线程池。默认情况下，这两个线程池的配置是可用处理器数量的两倍。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

If the handling of messages in annotated methods is mainly CPU-bound, the number of threads for the `clientInboundChannel` should remain close to the number of processors. If the work they do is more IO-bound and requires blocking or waiting on a database or other external system, the thread pool size probably needs to be increased.
#### ** Chinese **

如果注解方法中的消息处理主要是CPU绑定的，那么`clientInboundChannel`的线程数应该保持在处理器数量附近。如果它们所做的工作更多的是IO-bound，需要在数据库或其他外部系统上进行阻塞或等待，那么线程池的大小可能需要增加。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

`ThreadPoolExecutor` has three important properties: the core thread pool size, the max thread pool size, and the capacity for the queue to store tasks for which there are no available threads.
#### ** Chinese **

`ThreadPoolExecutor`有三个重要的属性：核心线程池的大小、最大线程池的大小，以及队列的容量，用于存储没有可用线程的任务。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

A common point of confusion is that configuring the core pool size (for example, 10) and max pool size (for example, 20) results in a thread pool with 10 to 20 threads. In fact, if the capacity is left at its default value of Integer.MAX_VALUE, the thread pool never increases beyond the core pool size, since all additional tasks are queued.
#### ** Chinese **

一个常见的混淆点是，配置核心池大小（例如10）和最大池大小（例如20）会导致线程池有10到20个线程。事实上，如果将容量保持在其默认值Integer.MAX_VALUE，线程池的容量永远不会增加到超过核心池大小，因为所有额外的任务都会被队列化。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

See the javadoc of `ThreadPoolExecutor` to learn how these properties work and understand the various queuing strategies.
#### ** Chinese **

查看`ThreadPoolExecutor`的javadoc，学习这些属性的工作原理，了解各种队列策略。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

On the `clientOutboundChannel` side, it is all about sending messages to WebSocket clients. If clients are on a fast network, the number of threads should remain close to the number of available processors. If they are slow or on low bandwidth, they take longer to consume messages and put a burden on the thread pool. Therefore, increasing the thread pool size becomes necessary.
#### ** Chinese **

在`clientOutboundChannel`方面，都是向WebSocket客户端发送消息。如果客户端在快速网络上，线程的数量应该保持与可用的处理器数量接近。如果它们的速度较慢或者带宽较低，那么它们消耗消息的时间就会比较长，给线程池带来负担。因此，增加线程池的大小就变得很有必要。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

While the workload for the `clientInboundChannel` is possible to predict — after all, it is based on what the application does — how to configure the "clientOutboundChannel" is harder, as it is based on factors beyond the control of the application. For this reason, two additional properties relate to the sending of messages: `sendTimeLimit` and `sendBufferSizeLimit`. You can use those methods to configure how long a send is allowed to take and how much data can be buffered when sending messages to a client.
#### ** Chinese **

虽然`clientInboundChannel`的工作量是可以预测的--毕竟它是基于应用程序所做的事情--但如何配置 "clientOutboundChannel "就比较难了，因为它是基于应用程序无法控制的因素。基于这个原因，有两个额外的属性与消息的发送有关。 `sendTimeLimit`和`sendBufferSizeLimit`。你可以使用这些方法来配置发送消息到客户端时，允许发送的时间有多长，以及可以缓冲多少数据。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The general idea is that, at any given time, only a single thread can be used to send to a client. All additional messages, meanwhile, get buffered, and you can use these properties to decide how long sending a message is allowed to take and how much data can be buffered in the meantime. See the javadoc and documentation of the XML schema for important additional details.
#### ** Chinese **

一般的想法是，在任何时候，只能用一个线程来向客户端发送消息。与此同时，所有额外的消息都会被缓冲，你可以使用这些属性来决定发送消息的时间，以及在此期间可以缓冲多少数据。关于重要的附加细节，请参阅javadoc和XML模式的文档。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following example shows a possible configuration:
#### ** Chinese **

下面的例子显示了一个可能的配置。

<!-- tabs:end -->


```java
@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

    @Override
    public void configureWebSocketTransport(WebSocketTransportRegistration registration) {
        registration.setSendTimeLimit(15 * 1000).setSendBufferSizeLimit(512 * 1024);
    }

    // ...

}
```

<!-- tabs:start -->

#### ** English **

The following example shows the XML configuration equivalent of the preceding example:
#### ** Chinese **

下面的例子显示了XML配置与前一个例子的等价物。

<!-- tabs:end -->


```xml
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:websocket="http://www.springframework.org/schema/websocket"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/websocket
        https://www.springframework.org/schema/websocket/spring-websocket.xsd">

    <websocket:message-broker>
        <websocket:transport send-timeout="15000" send-buffer-size="524288" />
        <!-- ... -->
    </websocket:message-broker>

</beans>
```

<!-- tabs:start -->

#### ** English **

You can also use the WebSocket transport configuration shown earlier to configure the maximum allowed size for incoming STOMP messages. In theory, a WebSocket message can be almost unlimited in size. In practice, WebSocket servers impose limits — for example, 8K on Tomcat and 64K on Jetty. For this reason, STOMP clients (such as the JavaScript [webstomp-client](https://github.com/JSteunou/webstomp-client) and others) split larger STOMP messages at 16K boundaries and send them as multiple WebSocket messages, which requires the server to buffer and re-assemble.
#### ** Chinese **

您还可以使用前面所示的 WebSocket 传输配置来配置传入的 STOMP 报文的最大允许大小。理论上，一个WebSocket消息的大小几乎可以是无限的。在实践中，WebSocket服务器都有限制--例如，Tomcat上的8K和Jetty上的64K。基于这个原因，STOMP客户端（如JavaScript[webstomp-client](https://github.com/JSteunou/webstomp-client)等）将较大的STOMP报文以16K的边界拆分，并将其作为多个WebSocket报文发送，这就需要服务器进行缓冲和重新组装。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Spring’s STOMP-over-WebSocket support does this ,so applications can configure the maximum size for STOMP messages irrespective of WebSocket server-specific message sizes. Keep in mind that the WebSocket message size is automatically adjusted, if necessary, to ensure they can carry 16K WebSocket messages at a minimum.
#### ** Chinese **

Spring 的 STOMP-over-WebSocket 支持可以做到这一点，因此应用程序可以配置 STOMP 消息的最大大小，而不考虑 WebSocket 服务器特定的消息大小。请记住，如果有必要，WebSocket消息的大小会自动调整，以确保它们至少可以携带16K的WebSocket消息。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following example shows one possible configuration:
#### ** Chinese **

下面的例子显示了一个可能的配置。

<!-- tabs:end -->


```java
@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

    @Override
    public void configureWebSocketTransport(WebSocketTransportRegistration registration) {
        registration.setMessageSizeLimit(128 * 1024);
    }

    // ...

}
```

<!-- tabs:start -->

#### ** English **

The following example shows the XML configuration equivalent of the preceding example:
#### ** Chinese **

下面的例子显示了XML配置与前一个例子的等价物。

<!-- tabs:end -->


```xml
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:websocket="http://www.springframework.org/schema/websocket"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/websocket
        https://www.springframework.org/schema/websocket/spring-websocket.xsd">

    <websocket:message-broker>
        <websocket:transport message-size="131072" />
        <!-- ... -->
    </websocket:message-broker>

</beans>
```

<!-- tabs:start -->

#### ** English **

An important point about scaling involves using multiple application instances. Currently, you cannot do that with the simple broker. However, when you use a full-featured broker (such as RabbitMQ), each application instance connects to the broker, and messages broadcast from one application instance can be broadcast through the broker to WebSocket clients connected through any other application instances.
#### ** Chinese **

关于缩放的一个重要的点涉及到使用多个应用实例。目前，使用简单的代理无法做到这一点。但是，当您使用全功能代理（如RabbitMQ）时，每个应用实例都会连接到代理，而从一个应用实例广播的消息可以通过代理广播到通过任何其他应用实例连接的WebSocket客户端。

<!-- tabs:end -->


### **4.4.21. Monitoring** 

<!-- tabs:start -->

#### ** English **

When you use `@EnableWebSocketMessageBroker` or `<websocket:message-broker>`, key infrastructure components automatically gather statisticss and counters that provide important insight into the internal state of the application. The configuration also declares a bean of type `WebSocketMessageBrokerStats` that gathers all available information in one place and by default logs it at the `INFO` level once every 30 minutes. This bean can be exported to JMX through Spring’s `MBeanExporter` for viewing at runtime (for example, through JDK’s `jconsole`). The following list summarizes the available information:
#### ** Chinese **

当您使用`@EnableWebSocketMessageBroker`或`<websocket:message-broker>`时，关键的基础架构组件会自动收集统计数字和计数器，这些统计数字和计数器可以提供对应用程序内部状态的重要洞察力。配置还声明了一个类型为`WebSocketMessageBrokerStats`的Bean，它可以在一个地方收集所有可用的信息，默认情况下，每隔30分钟在`INFO`级别记录一次。这个 bean 可以通过 Spring 的 `MBeanExporter`导出到 JMX，以便在运行时查看（例如，通过 JDK 的 `jconsole`）。下面的列表总结了可用的信息。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

**Client WebSocket SessionsCurrent** Indicates how many client sessions there are currently, with the count further broken down by WebSocket versus HTTP streaming and polling SockJS sessions.**Total** Indicates how many total sessions have been established.**Abnormally ClosedConnect Failures** Sessions that got established but were closed after not having received any messages within 60 seconds. This is usually an indication of proxy or network issues.**Send Limit Exceeded** Sessions closed after exceeding the configured send timeout or the send buffer limits, which can occur with slow clients (see previous section).**Transport Errors** Sessions closed after a transport error, such as failure to read or write to a WebSocket connection or HTTP request or response.**STOMP Frames** The total number of CONNECT, CONNECTED, and DISCONNECT frames processed, indicating how many clients connected on the STOMP level. Note that the DISCONNECT count may be lower when sessions get closed abnormally or when clients close without sending a DISCONNECT frame.**STOMP Broker RelayTCP Connections** Indicates how many TCP connections on behalf of client WebSocket sessions are established to the broker. This should be equal to the number of client WebSocket sessions + 1 additional shared “system” connection for sending messages from within the application.**STOMP Frames** The total number of CONNECT, CONNECTED, and DISCONNECT frames forwarded to or received from the broker on behalf of clients. Note that a DISCONNECT frame is sent to the broker regardless of how the client WebSocket session was closed. Therefore, a lower DISCONNECT frame count is an indication that the broker is pro-actively closing connections (maybe because of a heartbeat that did not arrive in time, an invalid input frame, or other issue).**Client Inbound Channel** Statistics from the thread pool that backs the `clientInboundChannel` that provide insight into the health of incoming message processing. Tasks queueing up here is an indication that the application may be too slow to handle messages. If there I/O bound tasks (for example, slow database queries, HTTP requests to third party REST API, and so on), consider increasing the thread pool size.**Client Outbound Channel** Statistics from the thread pool that backs the `clientOutboundChannel` that provides insight into the health of broadcasting messages to clients. Tasks queueing up here is an indication clients are too slow to consume messages. One way to address this is to increase the thread pool size to accommodate the expected number of concurrent slow clients. Another option is to reduce the send timeout and send buffer size limits (see the previous section).**SockJS Task Scheduler** Statistics from the thread pool of the SockJS task scheduler that is used to send heartbeats. Note that, when heartbeats are negotiated on the STOMP level, the SockJS heartbeats are disabled.
#### ** Chinese **

**客户端 WebSocket 会话Current**表示目前有多少个客户端会话，并根据 WebSocket 与 HTTP 流和轮询 SockJS 会话进一步细分。这通常表示代理或网络问题。 ***Send Limit Exceeded**在超过了配置的发送超时或发送缓冲区限制后关闭的会话，这可能发生在慢的客户端上（见上一节）。注意，当会话被异常关闭或客户机在没有发送DISCONNECT帧的情况下关闭时，DISCONNECT的数量可能会更少。这应该等于客户端WebSocket会话的数量+1个额外的共享 "系统 "连接，用于从应用程序内部发送消息。请注意，无论客户端WebSocket会话是如何关闭的，DISCONNECT帧都会被发送至代理。因此，较低的DISCONNECT帧计数表明代理正在主动关闭连接（可能是因为心跳没有及时到达，输入帧无效或其他问题）。这里的任务排队是应用程序可能太慢，无法处理消息的迹象。如果有I/O绑定的任务（例如，缓慢的数据库查询、向第三方REST API的HTTP请求等等），请考虑增加线程池的大小。在这里排队的任务是客户机消耗消息太慢的一个迹象。解决这个问题的一个方法是增加线程池的大小，以适应预期的并发慢客户端的数量。另一个方法是减少发送超时和发送缓冲区大小的限制（见上一节）。**SockJS任务调度器**SockJS任务调度器的线程池中用于发送心跳的统计。注意，当心跳是在STOMP级别上协商的时候，SockJS的心跳被禁用。

<!-- tabs:end -->


### **4.4.22. Testing** 

<!-- tabs:start -->

#### ** English **

There are two main approaches to testing applications when you use Spring’s STOMP-over-WebSocket support. The first is to write server-side tests to verify the functionality of controllers and their annotated message-handling methods. The second is to write full end-to-end tests that involve running a client and a server.
#### ** Chinese **

当你使用Spring的STOMP-over-WebSocket支持时，有两种主要方法来测试应用程序。第一种是编写服务器端测试来验证控制器的功能及其注释的消息处理方法。第二种是编写完整的端到端测试，包括运行一个客户端和一个服务器。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The two approaches are not mutually exclusive. On the contrary, each has a place in an overall test strategy. Server-side tests are more focused and easier to write and maintain. End-to-end integration tests, on the other hand, are more complete and test much more, but they are also more involved to write and maintain.
#### ** Chinese **

这两种方法不是相互排斥的。恰恰相反，两者在整个测试策略中都有其一席之地。服务器端测试更有针对性，更容易编写和维护。而端到端集成测试则更完整，测试的内容也更多，但编写和维护的工作量也更大。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The simplest form of server-side tests is to write controller unit tests. However, this is not useful enough, since much of what a controller does depends on its annotations. Pure unit tests simply cannot test that.
#### ** Chinese **

服务器端测试的最简单形式是编写控制器单元测试。然而，这样做是不够用的，因为控制器的很多工作都依赖于它的注释。纯粹的单元测试根本无法测试这些。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Ideally, controllers under test should be invoked as they are at runtime, much like the approach to testing controllers that handle HTTP requests by using the Spring MVC Test framework — that is, without running a Servlet container but relying on the Spring Framework to invoke the annotated controllers. As with Spring MVC Test, you have two possible alternatives here, either use a “context-based” or use a “standalone” setup:
#### ** Chinese **

理想情况下，被测试的控制器应该在运行时调用，就像使用Spring MVC测试框架来测试处理HTTP请求的控制器的方法一样--也就是说，不运行Servlet容器，而是依靠Spring框架来调用注释的控制器。和Spring MVC测试一样，你有两种可能的选择，要么使用 "基于上下文"，要么使用 "独立 "设置。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

- Load the actual Spring configuration with the help of the Spring TestContext framework, inject `clientInboundChannel` as a test field, and use it to send messages to be handled by controller methods.

- Manually set up the minimum Spring framework infrastructure required to invoke controllers (namely the `SimpAnnotationMethodMessageHandler`) and pass messages for controllers directly to it.

#### ** Chinese **

- 在Spring TestContext框架的帮助下加载实际的Spring配置，注入`clientInboundChannel`作为测试字段，并使用它来发送控制器方法要处理的消息。

- 手动设置调用控制器所需的最低限度的Spring框架基础架构（即`SimpAnnotationMethodMessageHandler`），并将控制器的消息直接传递给它。


<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

Both of these setup scenarios are demonstrated in the [tests for the stock portfolio](https://github.com/rstoyanchev/spring-websocket-portfolio/tree/master/src/test/java/org/springframework/samples/portfolio/web) sample application.
#### ** Chinese **

这两种设置方案都在【股票组合的测试】(https://github.com/rstoyanchev/spring-websocket-portfolio/tree/master/src/test/java/org/springframework/samples/portfolio/web)示例应用中进行了演示。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The second approach is to create end-to-end integration tests. For that, you need to run a WebSocket server in embedded mode and connect to it as a WebSocket client that sends WebSocket messages containing STOMP frames. The [tests for the stock portfolio](https://github.com/rstoyanchev/spring-websocket-portfolio/tree/master/src/test/java/org/springframework/samples/portfolio/web) sample application also demonstrate this approach by using Tomcat as the embedded WebSocket server and a simple STOMP client for test purposes.
#### ** Chinese **

第二种方法是创建端到端的集成测试。为此，你需要在嵌入式模式下运行一个WebSocket服务器，并作为一个WebSocket客户端连接到它，发送包含STOMP帧的WebSocket消息。股票投资组合的测试](https://github.com/rstoyanchev/spring-websocket-portfolio/tree/master/src/test/java/org/springframework/samples/portfolio/web)示例应用程序也演示了这种方法，使用Tomcat作为嵌入式WebSocket服务器和一个简单的STOMP客户端进行测试。

<!-- tabs:end -->



[下一章](Spring-Framework-5.2.6.RELEASE/Web%20on%20Servlet%20Stack/5.%20Other%20Web%20Frameworks.md)


[回目录](Spring-Framework-5.2.6.RELEASE/summary.md)

[回首页](/README)
