# 1.3. Annotated Controllers

<!-- tabs:start -->

#### ** English **

[WebFlux](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-controller)
#### ** Chinese **

[WebFlux](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-controller)

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Spring MVC provides an annotation-based programming model where `@Controller` and `@RestController` components use annotations to express request mappings, request input, exception handling, and more. Annotated controllers have flexible method signatures and do not have to extend base classes nor implement specific interfaces. The following example shows a controller defined by annotations:
#### ** Chinese **

Spring MVC提供了一个基于注释的编程模型，其中`@Controller`和`@RestController`组件使用注释来表达请求映射、请求输入、异常处理等。注释的控制器具有灵活的方法签名，不需要扩展基类，也不需要实现特定的接口。下面的例子显示了一个由注释定义的控制器。

<!-- tabs:end -->


```java
@Controller
public class HelloController {

    @GetMapping("/hello")
    public String handle(Model model) {
        model.addAttribute("message", "Hello World!");
        return "index";
    }
}
```

<!-- tabs:start -->

#### ** English **

In the preceding example, the method accepts a `Model` and returns a view name as a `String`, but many other options exist and are explained later in this chapter.
#### ** Chinese **

在前面的例子中，该方法接受一个`Model`，并返回一个视图名称为`String`，但也有许多其他的选项，将在本章后面解释。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Guides and tutorials on [spring.io](https://spring.io/guides) use the annotation-based programming model described in this section.
#### ** Chinese **

在[spring.io](https://spring.io/guides)上的指南和教程使用本节中描述的基于注释的编程模型。

<!-- tabs:end -->


### **1.3.1. Declaration** 

<!-- tabs:start -->

#### ** English **

[WebFlux](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-controller)
#### ** Chinese **

[WebFlux](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-controller)

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can define controller beans by using a standard Spring bean definition in the Servlet’s `WebApplicationContext`. The `@Controller` stereotype allows for auto-detection, aligned with Spring general support for detecting `@Component` classes in the classpath and auto-registering bean definitions for them. It also acts as a stereotype for the annotated class, indicating its role as a web component.
#### ** Chinese **

你可以在Servlet的`WebApplicationContext`中使用标准的Spring Bean定义来定义控制器Bean。`@Controller` stereotype允许自动检测，与Spring对检测classpath中的`@Component`类的一般支持一致，并为它们自动注册Bean定义。它还可以作为注释类的立体型，表示其作为web组件的角色。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

To enable auto-detection of such `@Controller` beans, you can add component scanning to your Java configuration, as the following example shows:
#### ** Chinese **

要启用这种`@Controller` Bean的自动检测，可以在Java配置中添加组件扫描，如下例所示。

<!-- tabs:end -->


```java
@Configuration
@ComponentScan("org.example.web")
public class WebConfig {

    // ...
}
```

<!-- tabs:start -->

#### ** English **

The following example shows the XML configuration equivalent of the preceding example:
#### ** Chinese **

下面的例子显示了XML配置与前一个例子的等价物。

<!-- tabs:end -->


```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:p="http://www.springframework.org/schema/p"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd">

    <context:component-scan base-package="org.example.web"/>

    <!-- ... -->

</beans>
```

<!-- tabs:start -->

#### ** English **

`@RestController` is a [composed annotation](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-meta-annotations) that is itself meta-annotated with `@Controller` and `@ResponseBody` to indicate a controller whose every method inherits the type-level `@ResponseBody` annotation and, therefore, writes directly to the response body versus view resolution and rendering with an HTML template.
#### ** Chinese **

`@RestController`是一个[组成注解](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-meta-annotations)，它本身带有`@Controller`和`@ResponseBody`的元注解，以表示一个控制器，其每个方法都继承了类型级的`@ResponseBody`注解，因此，与视图解析和HTML模板渲染相比，直接写入响应体。

<!-- tabs:end -->


### **AOP Proxies** 

<!-- tabs:start -->

#### ** English **

In some cases, you may need to decorate a controller with an AOP proxy at runtime. One example is if you choose to have `@Transactional` annotations directly on the controller. When this is the case, for controllers specifically, we recommend using class-based proxying. This is typically the default choice with controllers. However, if a controller must implement an interface that is not a Spring Context callback (such as `InitializingBean`, `*Aware`, and others), you may need to explicitly configure class-based proxying. For example, with `<tx:annotation-driven/>` you can change to `<tx:annotation-driven proxy-target-class="true"/>`, and with `@EnableTransactionManagement` you can change to `@EnableTransactionManagement(proxyTargetClass = true)`.
#### ** Chinese **

在某些情况下，你可能需要在运行时用AOP代理来装饰一个控制器。一个例子是，如果你选择在控制器上直接使用`@Transactional`注释。在这种情况下，对于控制器，我们建议使用基于类的代理。这通常是控制器的默认选择。但是，如果控制器必须实现一个非Spring Context回调的接口（如`InitializingBean`、`*Aware`等），可能需要显式配置基于类的代理。例如，对于 `<tx:annotation-driven/>`，您可以将其改为 `<tx:annotation-driven proxy-target-class="true"/>`，而对于 `@EnableTransactionManagement`，您可以将其改为 `@EnableTransactionManagement(proxyTargetClass = true)`。

<!-- tabs:end -->


### **1.3.2. Request Mapping** 

<!-- tabs:start -->

#### ** English **

[WebFlux](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-requestmapping)
#### ** Chinese **

[WebFlux](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-requestmapping)

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can use the `@RequestMapping` annotation to map requests to controllers methods. It has various attributes to match by URL, HTTP method, request parameters, headers, and media types. You can use it at the class level to express shared mappings or at the method level to narrow down to a specific endpoint mapping.
#### ** Chinese **

你可以使用`@RequestMapping`注释将请求映射到控制器方法。它有各种属性，可以根据URL、HTTP方法、请求参数、头文件和媒体类型进行匹配。你可以在类级使用它来表达共享映射，或者在方法级使用它来缩小到特定的端点映射。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

There are also HTTP method specific shortcut variants of `@RequestMapping`:
#### ** Chinese **

`@RequestMapping`也有HTTP方法的特定快捷方式变体。

<!-- tabs:end -->


- `@GetMapping`

- `@PostMapping`

- `@PutMapping`

- `@DeleteMapping`

- `@PatchMapping`


<!-- tabs:start -->

#### ** English **

The shortcuts are [Custom Annotations](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-requestmapping-composed) that are provided because, arguably, most controller methods should be mapped to a specific HTTP method versus using `@RequestMapping`, which, by default, matches to all HTTP methods. At the same, a `@RequestMapping` is still needed at the class level to express shared mappings.
#### ** Chinese **

这些捷径是[自定义注释](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-requestmapping-composed)提供的，因为可以说，与使用`@RequestMapping`相比，大多数控制器方法应该被映射到一个特定的HTTP方法，而默认情况下，它匹配到所有的HTTP方法。同时，在类级仍然需要一个`@RequestMapping`来表达共享映射。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following example has type and method level mappings:
#### ** Chinese **

下面的例子有类型和方法级的映射。

<!-- tabs:end -->


```java
@RestController
@RequestMapping("/persons")
class PersonController {

    @GetMapping("/{id}")
    public Person getPerson(@PathVariable Long id) {
        // ...
    }

    @PostMapping
    @ResponseStatus(HttpStatus.CREATED)
    public void add(@RequestBody Person person) {
        // ...
    }
}
```

### **URI patterns** 

<!-- tabs:start -->

#### ** English **

[WebFlux](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-requestmapping-uri-templates)
#### ** Chinese **

[WebFlux](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-requestmapping-uri-templates)

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can map requests by using glob patterns and wildcards:
#### ** Chinese **

你可以通过使用 glob 模式和通配符来映射请求。

<!-- tabs:end -->


Pattern | Description | Example 
-|-|-
? | Matches one character | "/pages/t?st.html"matches "/pages/test.html" and "/pages/t3st.html" 
* | Matches zero or more characters within a path segment | "/resources/*.png" matches "/resources/file.png""/projects/*/versions" matches "/projects/spring/versions" but does not match "/projects/spring/boot/versions" 
** | Matches zero or more path segments until the end of the path | "/resources/**" matches "/resources/file.png" and "/resources/images/file.png" 
{name} | Matches a path segment and captures it as a variable named "name" | "/projects/{project}/versions" matches "/projects/spring/versions" and captures project=spring 
{name:[a-z]+} | Matches the regexp "[a-z]+" as a path variable named "name" | "/projects/{project:[a-z]+}/versions" matches "/projects/spring/versions" but not "/projects/spring1/versions" 


<!-- tabs:start -->

#### ** English **

Captured URI variables can be accessed with `@PathVariable`, as the following example shows:
#### ** Chinese **

可以用`@PathVariable`访问捕获的URI变量，如下例所示。

<!-- tabs:end -->


```java
@GetMapping("/owners/{ownerId}/pets/{petId}")
public Pet findPet(@PathVariable Long ownerId, @PathVariable Long petId) {
    // ...
}
```

<!-- tabs:start -->

#### ** English **

You can declare URI variables at the class and method levels, as the following example shows:
#### ** Chinese **

你可以在类和方法级声明URI变量，如下例所示。

<!-- tabs:end -->


```java
@Controller
@RequestMapping("/owners/{ownerId}")
public class OwnerController {

    @GetMapping("/pets/{petId}")
    public Pet findPet(@PathVariable Long ownerId, @PathVariable Long petId) {
        // ...
    }
}
```

<!-- tabs:start -->

#### ** English **

URI variables are automatically converted to the appropriate type, or `TypeMismatchException` is raised. Simple types (`int`, `long`, `Date`, and so on) are supported by default and you can register support for any other data type. See [Type Conversion](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-typeconversion) and [`DataBinder`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-initbinder).
#### ** Chinese **

URI变量会自动转换为相应的类型，否则会产生`TypeMismatchException`。默认支持简单类型（`int`、`long`、`Date`等），你可以注册支持任何其他数据类型。请参见[类型转换](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-typeconversion)和[`DataBinder`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-initbinder)。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can explicitly name URI variables (for example, `@PathVariable("customId")`), but you can leave that detail out if the names are the same and your code is compiled with debugging information or with the `-parameters` compiler flag on Java 8.
#### ** Chinese **

你可以显式命名URI变量（例如，`@PathVariable("customId")`），但如果名称相同，并且你的代码在编译时使用调试信息或在Java 8上使用`-parameters`编译器标志，你可以不写这个细节。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The syntax `{varName:regex}` declares a URI variable with a regular expression that has syntax of `{varName:regex}`. For example, given URL `"/spring-web-3.0.5 .jar"`, the following method extracts the name, version, and file extension:
#### ** Chinese **

语法 `{varName:regex}`声明一个带有正则表达式的URI变量，其语法为`{varName:regex}`。例如，给定 URL `"/spring-web-3.0.5 .jar"`，下面的方法可以提取名称、版本和文件扩展名。

<!-- tabs:end -->


```java
@GetMapping("/{name:[a-z-]+}-{version:\\d\\.\\d\\.\\d}{ext:\\.[a-z]+}")
public void handle(@PathVariable String version, @PathVariable String ext) {
    // ...
}
```

<!-- tabs:start -->

#### ** English **

URI path patterns can also have embedded `${…​}` placeholders that are resolved on startup by using `PropertyPlaceHolderConfigurer` against local, system, environment, and other property sources. You can use this, for example, to parameterize a base URL based on some external configuration.
#### ** Chinese **
<!-- tabs:end -->

URI路径模式也可以有嵌入式的`${…​}`占位符，这些占位符在启动时通过使用`PropertyPlaceHolderConfigurer`对本地、系统、环境和其他属性源进行解析。例如，你可以用它来根据一些外部配置对基础 URL 进行参数化。

<!-- tabs:start -->

#### ** English **

Spring MVC uses the `PathMatcher` contract and the `AntPathMatcher` implementation from `spring-core` for URI path matching.
#### ** Chinese **
Spring MVC使用 `PathMatcher` 合约和 `spring-core` 中的 `AntPathMatcher` 实现来进行URI路径匹配。

<!-- tabs:end -->


### **Pattern Comparison** 

<!-- tabs:start -->

#### ** English **

[WebFlux](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-requestmapping-pattern-comparison)
#### ** Chinese **

[WebFlux](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-requestmapping-pattern-comparison)

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

When multiple patterns match a URL, they must be compared to find the best match. This is done by using `AntPathMatcher.getPatternComparator(String path)`, which looks for patterns that are more specific.
#### ** Chinese **

当多个模式匹配一个URL时，必须对它们进行比较以找到最佳匹配。这是通过使用`AntPathMatcher.getPatternComparator(String path)`来实现的，它可以寻找更具体的模式。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

A pattern is less specific if it has a lower count of URI variables (counted as 1), single wildcards (counted as 1), and double wildcards (counted as 2). Given an equal score, the longer pattern is chosen. Given the same score and length, the pattern with more URI variables than wildcards is chosen.
#### ** Chinese **

如果一个模式的URI变量数量较少（计为1），单通配符（计为1），双通配符（计为2），则该模式的特殊性较差。给出相同的分数，则选择较长的模式。在相同分数和长度的情况下，选择URI变量多于通配符的模式。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The default mapping pattern (`/**`) is excluded from scoring and always sorted last. Also, prefix patterns (such as `/public/**`) are considered less specific than other pattern that do not have double wildcards.
#### ** Chinese **

默认的映射模式（`/**`）被排除在评分之外，并且总是最后排序。另外，前缀模式（如`/public/**`）与其他没有双通配符的模式相比，前缀模式被认为不那么具体。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

For the full details, see [`AntPatternComparator`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/util/AntPathMatcher.AntPatternComparator.html) in [`AntPathMatcher`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/util/AntPathMatcher.html) and also keep in mind that you can customize the [`PathMatcher`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/util/PathMatcher.html) implementation. See [Path Matching](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-config-path-matching) in the configuration section.
#### ** Chinese **

关于完整的细节，请参阅[`AntPatternComparator`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/util/AntPathMatcher.AntPatternComparator.html)中的[`AntPathMatcher`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/util/AntPathMatcher.html)，同时也请记住，你可以自定义[`PathMatcher`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/util/PathMatcher.html)的实现。参见配置部分中的[路径匹配](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-config-path-matching)。

<!-- tabs:end -->


### **Suffix Match** 

<!-- tabs:start -->

#### ** English **

By default, Spring MVC performs `.*` suffix pattern matching so that a controller mapped to `/person` is also implicitly mapped to `/person.*`. The file extension is then used to interpret the requested content type to use for the response (that is, instead of the `Accept` header) — for example, `/person.pdf`, `/person.xml`, and others.
#### ** Chinese **

默认情况下，Spring MVC会执行`.*`后缀模式匹配，这样映射到`/person`的控制器也会隐式地映射到`/person.*`。然后，文件扩展名被用来解释请求的内容类型以用于响应（即代替`Accept`头）--例如，`/person.pdf`、`/person.xml`等。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Using file extensions in this way was necessary when browsers used to send `Accept` headers that were hard to interpret consistently. At present, that is no longer a necessity and using the `Accept` header should be the preferred choice.
#### ** Chinese **

当浏览器发送`Accept`头难以统一解释的时候，以这种方式使用文件扩展名是必要的。现在，这已不再是必要的，使用`Accept`头应该是首选。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Over time, the use of file name extensions has proven problematic in a variety of ways. It can cause ambiguity when overlain with the use of URI variables, path parameters, and URI encoding. Reasoning about URL-based authorization and security (see next section for more details) also become more difficult.
#### ** Chinese **

随着时间的推移，文件名扩展名的使用被证明是有很多问题的。当它与URI变量、路径参数和URI编码的使用相重叠时，会造成模糊不清。基于URL的授权和安全推理也变得更加困难（详见下节）。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

To completely disable the use of file extensions, you must set both of the following:
#### ** Chinese **

要完全禁止使用文件扩展名，必须设置以下两项。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

- `useSuffixPatternMatching(false)`, see [PathMatchConfigurer](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-config-path-matching)

- `favorPathExtension(false)`, see [ContentNegotiationConfigurer](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-config-content-negotiation)

#### ** Chinese **

- `useSuffixPatternMatching(false)`，见[PathMatchConfigurer](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-config-path-matching)

- `favorPathExtension(false)`，见[ContentNegotiationConfigurer](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-config-content-negotiation)


<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

URL-based content negotiation can still be useful (for example, when typing a URL in a browser). To enable that, we recommend a query parameter-based strategy to avoid most of the issues that come with file extensions. Alternatively, if you must use file extensions, consider restricting them to a list of explicitly registered extensions through the `mediaTypes` property of [ContentNegotiationConfigurer](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-config-content-negotiation).
#### ** Chinese **

基于URL的内容协商仍然有用（例如，在浏览器中输入URL时）。为了实现这一点，我们建议使用基于查询参数的策略来避免文件扩展名带来的大部分问题。另外，如果您必须使用文件扩展名，可以考虑通过[ContentNegotiationConfigurer](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-config-content-negotiation)的`mediaTypes`属性将其限制为显式注册的扩展名列表。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Starting in 5.2.4, path extension related options for request mapping in [RequestMappingHandlerMapping](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/org/springframework/web/servlet/mvc/method/annotation/RequestMappingHandlerMapping.java) and for content negotiation in [ContentNegotiationManagerFactoryBean](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/org.springframework.web.accept/ContentNegotiationManagerFactoryBean.java) are deprecated. See Spring Framework issue [#24179](https://github.com/spring-projects/spring-framework/issues/24179) and related issues for further plans.
#### ** Chinese **

从5.2.4开始，在[RequestMappingHandlerMapping](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/org/springframework/web/servlet/mvc/method/annotation/RequestMappingHandlerMapping.java)中的请求映射和[ContentNegotiationManagerFactoryBean](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/org.springframework.web.accept/ContentNegotiationManagerFactoryBean.java)中的内容协商的路径扩展相关选项已被取消。关于进一步的计划，请参阅Spring Framework问题[#24179](https://github.com/spring-projects/spring-framework/issues/24179)和相关问题。

<!-- tabs:end -->


### **Suffix Match and RFD** 

<!-- tabs:start -->

#### ** English **

A reflected file download (RFD) attack is similar to XSS in that it relies on request input (for example, a query parameter and a URI variable) being reflected in the response. However, instead of inserting JavaScript into HTML, an RFD attack relies on the browser switching to perform a download and treating the response as an executable script when double-clicked later.
#### ** Chinese **

反映式文件下载(RFD)攻击与XSS类似，它依赖于请求输入(例如，查询参数和URI变量)在响应中得到反映。然而，RFD攻击不是将JavaScript插入到HTML中，而是依靠浏览器切换执行下载，并在双击后将响应视为可执行脚本。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

In Spring MVC, `@ResponseBody` and `ResponseEntity` methods are at risk, because they can render different content types, which clients can request through URL path extensions. Disabling suffix pattern matching and using path extensions for content negotiation lower the risk but are not sufficient to prevent RFD attacks.
#### ** Chinese **

在Spring MVC中，`@ResponseBody`和`ResponseEntity`方法存在风险，因为它们可以渲染不同的内容类型，而客户端可以通过URL路径扩展来请求这些类型。禁用后缀模式匹配和使用路径扩展进行内容协商可以降低风险，但不足以防止RFD攻击。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

To prevent RFD attacks, prior to rendering the response body, Spring MVC adds a `Content-Disposition:inline;filename=f.txt` header to suggest a fixed and safe download file. This is done only if the URL path contains a file extension that is neither whitelisted nor explicitly registered for content negotiation. However, it can potentially have side effects when URLs are typed directly into a browser.
#### ** Chinese **

为了防止RFD攻击，在渲染响应体之前，Spring MVC会添加一个`Content-Disposition:inline;filename=f.txt`头来建议一个固定安全的下载文件。只有当URL路径包含一个既没有白名单也没有显式注册内容协商的文件扩展名时，才会这样做。然而，当直接在浏览器中输入URL时，它可能会产生潜在的副作用。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Many common path extensions are whitelisted by default. Applications with custom `HttpMessageConverter` implementations can explicitly register file extensions for content negotiation to avoid having a `Content-Disposition` header added for those extensions. See [Content Types](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-config-content-negotiation).
#### ** Chinese **

许多常见的路径扩展名默认都是白名单。具有自定义`HttpMessageConverter`实现的应用程序可以显式地注册文件扩展名，以避免为这些扩展名添加`Content-Disposition`头。参见[内容类型](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-config-content-negotiation)。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

See [CVE-2015-5211](https://pivotal.io/security/cve-2015-5211) for additional recommendations related to RFD.
#### ** Chinese **

有关RFD的其他建议，请参阅[CVE-2015-5211](https://pivotal.io/security/cve-2015-5211)。

<!-- tabs:end -->


### **Consumable Media Types** 

<!-- tabs:start -->

#### ** English **

[WebFlux](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-requestmapping-consumes)
#### ** Chinese **

[WebFlux](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-requestmapping-consumes)

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can narrow the request mapping based on the `Content-Type` of the request, as the following example shows:
#### ** Chinese **

您可以根据请求的`Content-Type`来缩小请求映射范围，如下图所示。

<!-- tabs:end -->


```java
@PostMapping(path = "/pets", consumes = "application/json") (1)
public void addPet(@RequestBody Pet pet) {
    // ...
}

//(1) Using a consumes attribute to narrow the mapping by the content type.
```

<!-- tabs:start -->

#### ** English **

The `consumes` attribute also supports negation expressions — for example, `!text/plain` means any content type other than `text/plain`.
#### ** Chinese **

`consumes`属性也支持否定表达式 - 例如，`!text/plain`表示除`text/plain`以外的任何内容类型。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can declare a shared `consumes` attribute at the class level. Unlike most other request-mapping attributes, however, when used at the class level, a method-level `consumes` attribute overrides rather than extends the class-level declaration.
#### ** Chinese **

你可以在类级声明一个共享的`consumes`属性。但是，与大多数其他请求映射属性不同，当在类级使用时，方法级的`consumes`属性会覆盖而不是扩展类级声明。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

`MediaType` provides constants for commonly used media types, such as `APPLICATION_JSON_VALUE` and `APPLICATION_XML_VALUE`.
#### ** Chinese **

`MediaType`提供了常用媒体类型的常量，如`APPLICATION_JSON_VALUE`和`APPLICATION_XML_VALUE`。

<!-- tabs:end -->


### **Producible Media Types** 

<!-- tabs:start -->

#### ** English **

[WebFlux](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-requestmapping-produces)
#### ** Chinese **

[WebFlux](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-requestmapping-produces)

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can narrow the request mapping based on the `Accept` request header and the list of content types that a controller method produces, as the following example shows:
#### ** Chinese **

您可以根据`Accept`请求头和控制器方法产生的内容类型列表来缩小请求映射范围，如下例所示。

<!-- tabs:end -->


```java
@GetMapping(path = "/pets/{petId}", produces = "application/json") (1)
@ResponseBody
public Pet getPet(@PathVariable String petId) {
    // ...
}

//(1) Using a produces attribute to narrow the mapping by the content type.
```

<!-- tabs:start -->

#### ** English **

The media type can specify a character set. Negated expressions are supported — for example, `!text/plain` means any content type other than "text/plain".
#### ** Chinese **

媒体类型可以指定一个字符集。支持否定的表达式 - 例如，`!text/plain`表示除 text/plain 以外的任何内容类型。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can declare a shared `produces` attribute at the class level. Unlike most other request-mapping attributes, however, when used at the class level, a method-level `produces` attribute overrides rather than extends the class-level declaration.
#### ** Chinese **

你可以在类级声明一个共享的`produces`属性。但是，与大多数其他请求映射属性不同，当在类级使用时，方法级的`produces`属性会覆盖而不是扩展类级声明。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

`MediaType` provides constants for commonly used media types, such as `APPLICATION_JSON_VALUE` and `APPLICATION_XML_VALUE`.
#### ** Chinese **

`MediaType`提供了常用媒体类型的常量，如`APPLICATION_JSON_VALUE`和`APPLICATION_XML_VALUE`。

<!-- tabs:end -->


### **Parameters, headers** 

<!-- tabs:start -->

#### ** English **

[WebFlux](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-requestmapping-params-and-headers)
#### ** Chinese **

[WebFlux](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-requestmapping-params-and-headers)

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can narrow request mappings based on request parameter conditions. You can test for the presence of a request parameter (`myParam`), for the absence of one (`!myParam`), or for a specific value (`myParam=myValue`). The following example shows how to test for a specific value:
#### ** Chinese **

你可以根据请求参数条件来缩小请求映射范围。您可以测试是否存在一个请求参数(`myParam`)，是否存在一个请求参数(`!myParam`)，或者测试一个特定的值(`myParam=myValue`)。下面的例子显示了如何测试一个特定值。

<!-- tabs:end -->


```java
@GetMapping(path = "/pets/{petId}", params = "myParam=myValue") (1)
public void findPet(@PathVariable String petId) {
    // ...
}

//(1) Testing whether myParam equals myValue.
```

<!-- tabs:start -->

#### ** English **

You can also use the same with request header conditions, as the following example shows:
#### ** Chinese **

你也可以在请求头条件中使用同样的方法，如下例所示。

<!-- tabs:end -->


```java
@GetMapping(path = "/pets", headers = "myHeader=myValue") (1)
public void findPet(@PathVariable String petId) {
    // ...
}

//(1) Testing whether myHeader equals myValue.
```

<!-- tabs:start -->

#### ** English **

You can match `Content-Type` and `Accept` with the headers condition, but it is better to use [consumes](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-requestmapping-consumes) and [produces](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-requestmapping-produces) instead.
#### ** Chinese **

你可以将`Content-Type`和`Accept`与headers条件相匹配，但最好用[ consumes](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-requestmapping-consumes)和[prosince](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-requestmapping-produces)代替。

<!-- tabs:end -->


### **HTTP HEAD, OPTIONS** 

<!-- tabs:start -->

#### ** English **

[WebFlux](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-requestmapping-head-options)
#### ** Chinese **

[WebFlux](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-requestmapping-head-options)

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

`@GetMapping` (and `@RequestMapping(method=HttpMethod.GET)`) support HTTP HEAD transparently for request mapping. Controller methods do not need to change. A response wrapper, applied in `javax.servlet.http.HttpServlet`, ensures a `Content-Length` header is set to the number of bytes written (without actually writing to the response).
#### ** Chinese **

`@GetMapping`(和`@RequestMapping(method=HttpMethod.GET)`)支持HTTP HEAD透明地进行请求映射。控制器方法不需要改变。在`javax.servlet.http.HttpServlet`中应用了一个响应包装器，确保`Content-Length`头被设置为写入的字节数（而不是实际写入响应）。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

`@GetMapping` (and `@RequestMapping(method=HttpMethod.GET)`) are implicitly mapped to and support HTTP HEAD. An HTTP HEAD request is processed as if it were HTTP GET except that, instead of writing the body, the number of bytes are counted and the `Content-Length` header is set.
#### ** Chinese **

`@GetMapping`(和`@RequestMapping(method=HttpMethod.GET)`)隐式映射到并支持HTTP HEAD。一个HTTP HEAD请求的处理方式就像HTTP GET一样，只是不写正文，而是计算字节数，并且设置了`Content-Length`头。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

By default, HTTP OPTIONS is handled by setting the `Allow` response header to the list of HTTP methods listed in all `@RequestMapping` methods that have matching URL patterns.
#### ** Chinese **

默认情况下，通过将`Allow`响应头设置为所有`@RequestMapping`方法中列出的具有匹配的URL模式的HTTP方法列表来处理HTTP OPTIONS。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

For a `@RequestMapping` without HTTP method declarations, the `Allow` header is set to `GET,HEAD,POST,PUT,PATCH,DELETE,OPTIONS`. Controller methods should always declare the supported HTTP methods (for example, by using the HTTP method specific variants: `@GetMapping`, `@PostMapping`, and others).
#### ** Chinese **

对于没有HTTP方法声明的`@RequestMapping`，`Allow`头被设置为`GET,HEAD,POST,PUT,PATCH,DELETE,OPTIONS`。控制器方法应该始终声明支持的HTTP方法（例如，通过使用HTTP方法的特定变体。 `@GetMapping`、`@PostMapping`等）。)

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can explicitly map the `@RequestMapping` method to HTTP HEAD and HTTP OPTIONS, but that is not necessary in the common case.
#### ** Chinese **

你可以将`@RequestMapping`方法显式地映射到HTTP HEAD和HTTP OPTIONS，但在常见的情况下，这不是必须的。

<!-- tabs:end -->


### **Custom Annotations** 

<!-- tabs:start -->

#### ** English **

[WebFlux](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#mvc-ann-requestmapping-head-options)
#### ** Chinese **

[WebFlux](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#mvc-ann-requestmapping-head-options)

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Spring MVC supports the use of [composed annotations](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-meta-annotations) for request mapping. Those are annotations that are themselves meta-annotated with `@RequestMapping` and composed to redeclare a subset (or all) of the `@RequestMapping` attributes with a narrower, more specific purpose.
#### ** Chinese **

Spring MVC支持使用[composition annotations](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-meta-annotations)进行请求映射。这些注释本身就是用`@RequestMapping`进行元注释的注释，这些注释的组成是为了重新定义`@RequestMapping`属性的一个子集（或全部），其目的更窄、更具体。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

`@GetMapping`, `@PostMapping`, `@PutMapping`, `@DeleteMapping`, and `@PatchMapping` are examples of composed annotations. They are provided because, arguably, most controller methods should be mapped to a specific HTTP method versus using `@RequestMapping`, which, by default, matches to all HTTP methods. If you need an example of composed annotations, look at how those are declared.
#### ** Chinese **

`@GetMapping`、`@PostMapping`、`@PutMapping`、`@DeleteMapping`和`@PatchMapping`是组成注释的例子。提供这些注释是因为，可以说，大多数控制器方法应该被映射到特定的HTTP方法，而不是使用`@RequestMapping`，默认情况下，它匹配到所有的HTTP方法。如果你需要一个组成注释的例子，可以看看这些注释是如何声明的。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Spring MVC also supports custom request-mapping attributes with custom request-matching logic. This is a more advanced option that requires subclassing `RequestMappingHandlerMapping` and overriding the `getCustomMethodCondition` method, where you can check the custom attribute and return your own `RequestCondition`.
#### ** Chinese **

Spring MVC还支持自定义请求映射属性与自定义请求匹配逻辑。这是一个更高级的选项，需要子classing `RequestMappingHandlerMapping`，并重写`getCustomMethodCondition`方法，在这里你可以检查自定义属性并返回自己的`RequestCondition`。

<!-- tabs:end -->


### **Explicit Registrations** 

<!-- tabs:start -->

#### ** English **

[WebFlux](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-requestmapping-registration)
#### ** Chinese **

[WebFlux](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-requestmapping-registration)

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can programmatically register handler methods, which you can use for dynamic registrations or for advanced cases, such as different instances of the same handler under different URLs. The following example registers a handler method:
#### ** Chinese **

你可以用程序化的方式注册处理程序方法，可以用于动态注册或高级情况，例如在不同的URL下注册同一处理程序的不同实例。下面的例子注册了一个处理程序方法。

<!-- tabs:end -->


```java
@Configuration
public class MyConfig {

    @Autowired
    public void setHandlerMapping(RequestMappingHandlerMapping mapping, UserHandler handler) (1)
            throws NoSuchMethodException {

        RequestMappingInfo info = RequestMappingInfo
                .paths("/user/{id}").methods(RequestMethod.GET).build(); (2)

        Method method = UserHandler.class.getMethod("getUser", Long.class); (3)

        mapping.registerMapping(info, handler, method); (4)
    }
}

//(1) Inject the target handler and the handler mapping for controllers.
(2) Prepare the request mapping meta data.
(3) Get the handler method.
(4) Add the registration.
```

### **1.3.3. Handler Methods** 

<!-- tabs:start -->

#### ** English **

[WebFlux](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-methods)
#### ** Chinese **

[WebFlux](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-methods)

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

`@RequestMapping` handler methods have a flexible signature and can choose from a range of supported controller method arguments and return values.
#### ** Chinese **

`@RequestMapping`处理程序方法具有灵活的签名，可以从一系列支持的控制器方法参数和返回值中选择。

<!-- tabs:end -->


### **Method Arguments** 

<!-- tabs:start -->

#### ** English **

[WebFlux](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-arguments)
#### ** Chinese **

[WebFlux](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-arguments)

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The next table describes the supported controller method arguments. Reactive types are not supported for any arguments.
#### ** Chinese **

下表描述了支持的控制器方法参数。不支持任何参数的反应式类型。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

JDK 8’s `java.util.Optional` is supported as a method argument in combination with annotations that have a `required` attribute (for example, `@RequestParam`, `@RequestHeader`, and others) and is equivalent to `required=false`.
#### ** Chinese **

JDK 8的`java.util.Optional`支持作为方法参数与具有`required`属性的注释（例如，`@RequestParam`、`@RequestHeader`等）结合在一起，相当于`required=false`。

<!-- tabs:end -->


Controller method argument | Description 
-|-
WebRequest, NativeWebRequest | Generic access to request parameters and request and session attributes, without direct use of the Servlet API. 
javax.servlet.ServletRequest, javax.servlet.ServletResponse | Choose any specific request or response type — for example, ServletRequest, HttpServletRequest, or Spring’s MultipartRequest, MultipartHttpServletRequest. 
javax.servlet.http.HttpSession | Enforces the presence of a session. As a consequence, such an argument is never null. Note that session access is not thread-safe. Consider setting the RequestMappingHandlerAdapter instance’s synchronizeOnSession flag to true if multiple requests are allowed to concurrently access a session. 
javax.servlet.http.PushBuilder | Servlet 4.0 push builder API for programmatic HTTP/2 resource pushes. Note that, per the Servlet specification, the injected PushBuilder instance can be null if the client does not support that HTTP/2 feature. 
java.security.Principal | Currently authenticated user — possibly a specific Principal implementation class if known. 
HttpMethod | The HTTP method of the request. 
java.util.Locale | The current request locale, determined by the most specific LocaleResolver available (in effect, the configured LocaleResolver or LocaleContextResolver). 
java.util.TimeZone + java.time.ZoneId | The time zone associated with the current request, as determined by a LocaleContextResolver. 
java.io.InputStream, java.io.Reader | For access to the raw request body as exposed by the Servlet API. 
java.io.OutputStream, java.io.Writer | For access to the raw response body as exposed by the Servlet API. 
@PathVariable | For access to URI template variables. See URI patterns. 
@MatrixVariable | For access to name-value pairs in URI path segments. See Matrix Variables. 
@RequestParam | For access to the Servlet request parameters, including multipart files. Parameter values are converted to the declared method argument type. See @RequestParam as well as Multipart.Note that use of @RequestParam is optional for simple parameter values. See “Any other argument”, at the end of this table. 
@RequestHeader | For access to request headers. Header values are converted to the declared method argument type. See @RequestHeader. 
@CookieValue | For access to cookies. Cookies values are converted to the declared method argument type. See @CookieValue. 
@RequestBody | For access to the HTTP request body. Body content is converted to the declared method argument type by using HttpMessageConverter implementations. See @RequestBody. 
HttpEntity<B> | For access to request headers and body. The body is converted with an HttpMessageConverter. See HttpEntity. 
@RequestPart | For access to a part in a multipart/form-data request, converting the part’s body with an HttpMessageConverter. See Multipart. 
java.util.Map, org.springframework.ui.Model, org.springframework.ui.ModelMap | For access to the model that is used in HTML controllers and exposed to templates as part of view rendering. 
RedirectAttributes | Specify attributes to use in case of a redirect (that is, to be appended to the query string) and flash attributes to be stored temporarily until the request after redirect. See Redirect Attributes and Flash Attributes. 
@ModelAttribute | For access to an existing attribute in the model (instantiated if not present) with data binding and validation applied. See @ModelAttribute as well as Model and DataBinder.Note that use of @ModelAttribute is optional (for example, to set its attributes). See “Any other argument” at the end of this table. 
Errors, BindingResult | For access to errors from validation and data binding for a command object (that is, a @ModelAttribute argument) or errors from the validation of a @RequestBody or @RequestPart arguments. You must declare an Errors, or BindingResult argument immediately after the validated method argument. 
SessionStatus + class-level @SessionAttributes | For marking form processing complete, which triggers cleanup of session attributes declared through a class-level @SessionAttributes annotation. See @SessionAttributes for more details. 
UriComponentsBuilder | For preparing a URL relative to the current request’s host, port, scheme, context path, and the literal part of the servlet mapping. See URI Links. 
@SessionAttribute | For access to any session attribute, in contrast to model attributes stored in the session as a result of a class-level @SessionAttributes declaration. See @SessionAttribute for more details. 
@RequestAttribute | For access to request attributes. See @RequestAttribute for more details. 
Any other argument | If a method argument is not matched to any of the earlier values in this table and it is a simple type (as determined by BeanUtils#isSimpleProperty, it is a resolved as a @RequestParam. Otherwise, it is resolved as a @ModelAttribute. 


### **Return Values** 

<!-- tabs:start -->

#### ** English **

[WebFlux](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-return-types)
#### ** Chinese **

[WebFlux](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-return-types)

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The next table describes the supported controller method return values. Reactive types are supported for all return values.
#### ** Chinese **

下表描述了支持的控制器方法的返回值。所有的返回值都支持反应式类型。

<!-- tabs:end -->


Controller method return value | Description 
-|-
@ResponseBody | The return value is converted through HttpMessageConverter implementations and written to the response. See @ResponseBody. 
HttpEntity<B>, ResponseEntity<B> | The return value that specifies the full response (including HTTP headers and body) is to be converted through HttpMessageConverter implementations and written to the response. See ResponseEntity. 
HttpHeaders | For returning a response with headers and no body. 
String | A view name to be resolved with ViewResolver implementations and used together with the implicit model — determined through command objects and @ModelAttribute methods. The handler method can also programmatically enrich the model by declaring a Model argument (see Explicit Registrations). 
View | A View instance to use for rendering together with the implicit model — determined through command objects and @ModelAttribute methods. The handler method can also programmatically enrich the model by declaring a Model argument (see Explicit Registrations). 
java.util.Map, org.springframework.ui.Model | Attributes to be added to the implicit model, with the view name implicitly determined through a RequestToViewNameTranslator. 
@ModelAttribute | An attribute to be added to the model, with the view name implicitly determined through a RequestToViewNameTranslator.Note that @ModelAttribute is optional. See "Any other return value" at the end of this table. 
ModelAndView object | The view and model attributes to use and, optionally, a response status. 
void | A method with a void return type (or null return value) is considered to have fully handled the response if it also has a ServletResponse, an OutputStream argument, or an @ResponseStatus annotation. The same is also true if the controller has made a positive ETag or lastModified timestamp check (see Controllers for details).If none of the above is true, a void return type can also indicate “no response body” for REST controllers or a default view name selection for HTML controllers. 
DeferredResult<V> | Produce any of the preceding return values asynchronously from any thread — for example, as a result of some event or callback. See Asynchronous Requests and DeferredResult. 
Callable<V> | Produce any of the above return values asynchronously in a Spring MVC-managed thread. See Asynchronous Requests and Callable. 
ListenableFuture<V>, java.util.concurrent.CompletionStage<V>, java.util.concurrent.CompletableFuture<V> | Alternative to DeferredResult, as a convenience (for example, when an underlying service returns one of those). 
ResponseBodyEmitter, SseEmitter | Emit a stream of objects asynchronously to be written to the response with HttpMessageConverter implementations. Also supported as the body of a ResponseEntity. See Asynchronous Requests and HTTP Streaming. 
StreamingResponseBody | Write to the response OutputStream asynchronously. Also supported as the body of a ResponseEntity. See Asynchronous Requests and HTTP Streaming. 
Reactive types — Reactor, RxJava, or others through ReactiveAdapterRegistry | Alternative to DeferredResult with multi-value streams (for example, Flux, Observable) collected to a List.For streaming scenarios (for example, text/event-stream, application/json+stream), SseEmitter and ResponseBodyEmitter are used instead, where ServletOutputStream blocking I/O is performed on a Spring MVC-managed thread and back pressure is applied against the completion of each write.See Asynchronous Requests and Reactive Types. 
Any other return value | Any return value that does not match any of the earlier values in this table and that is a String or void is treated as a view name (default view name selection through RequestToViewNameTranslator applies), provided it is not a simple type, as determined by BeanUtils#isSimpleProperty. Values that are simple types remain unresolved. 


### **Type Conversion** 

<!-- tabs:start -->

#### ** English **

[WebFlux](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-typeconversion)
#### ** Chinese **

[WebFlux](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-typeconversion)

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Some annotated controller method arguments that represent `String`-based request input (such as `@RequestParam`, `@RequestHeader`, `@PathVariable`, `@MatrixVariable`, and `@CookieValue`) can require type conversion if the argument is declared as something other than `String`.
#### ** Chinese **

一些表示基于 `String`的请求输入的注释控制器方法参数（如 `@RequestParam`、`@RequestHeader`、`@PathVariable`、`@MatrixVariable`和`@CookieValue`），如果参数被声明为 `String`以外的东西，则可能需要进行类型转换。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

For such cases, type conversion is automatically applied based on the configured converters. By default, simple types (`int`, `long`, `Date`, and others) are supported. You can customize type conversion through a `WebDataBinder` (see [`DataBinder`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-initbinder)) or by registering `Formatters` with the `FormattingConversionService`. See [Spring Field Formatting](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#format).
#### ** Chinese **

对于这种情况，类型转换会根据配置的转换器自动应用。默认情况下，支持简单的类型（`int`、`long`、`Date`等）。您可以通过 `WebDataBinder`（参见 [`DataBinder`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-initbinder)）或通过注册 `FormattingConversionService`的`Formatters`来定制类型转换。参见[Spring字段格式化](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#format)。

<!-- tabs:end -->


### **Matrix Variables** 

<!-- tabs:start -->

#### ** English **

[WebFlux](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-matrix-variables)
#### ** Chinese **

[WebFlux](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-matrix-variables)

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

[RFC 3986](https://tools.ietf.org/html/rfc3986#section-3.3) discusses name-value pairs in path segments. In Spring MVC, we refer to those as “matrix variables” based on an [“old post”](https://www.w3.org/DesignIssues/MatrixURIs.html) by Tim Berners-Lee, but they can be also be referred to as URI path parameters.
#### ** Chinese **

RFC 3986](https://tools.ietf.org/html/rfc3986#section-3.3)讨论了路径段中的名-值对。在Spring MVC中，我们根据Tim Berners-Lee的一篇[老帖子](https://www.w3.org/DesignIssues/MatrixURIs.html)，将其称为 矩阵变量，但它们也可以被称为URI路径参数。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Matrix variables can appear in any path segment, with each variable separated by a semicolon and multiple values separated by comma (for example, `/cars;color=red,green;year=2012`). Multiple values can also be specified through repeated variable names (for example, `color=red;color=green;color=blue`).
#### ** Chinese **

矩阵变量可以出现在任何路径段中，每个变量之间用分号隔开，多个值之间用逗号隔开（例如，`/cars;color=red,green;year=2012`）。也可以通过重复的变量名指定多个值（例如，`color=red;color=green;color=blue`）。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

If a URL is expected to contain matrix variables, the request mapping for a controller method must use a URI variable to mask that variable content and ensure the request can be matched successfully independent of matrix variable order and presence. The following example uses a matrix variable:
#### ** Chinese **

如果一个URL预计会包含矩阵变量，那么控制器方法的请求映射必须使用URI变量来屏蔽该变量内容，并确保请求能够成功匹配，不受矩阵变量顺序和存在的影响。下面的例子使用了一个矩阵变量。

<!-- tabs:end -->


```java
// GET /pets/42;q=11;r=22

@GetMapping("/pets/{petId}")
public void findPet(@PathVariable String petId, @MatrixVariable int q) {

    // petId == 42
    // q == 11
}
```

<!-- tabs:start -->

#### ** English **

Given that all path segments may contain matrix variables, you may sometimes need to disambiguate which path variable the matrix variable is expected to be in. The following example shows how to do so:
#### ** Chinese **

考虑到所有的路径段都可能包含矩阵变量，因此有时可能需要区分矩阵变量在哪个路径变量中。下面的例子显示了如何做到这一点。

<!-- tabs:end -->


```java
// GET /owners/42;q=11/pets/21;q=22

@GetMapping("/owners/{ownerId}/pets/{petId}")
public void findPet(
        @MatrixVariable(name="q", pathVar="ownerId") int q1,
        @MatrixVariable(name="q", pathVar="petId") int q2) {

    // q1 == 11
    // q2 == 22
}
```

<!-- tabs:start -->

#### ** English **

A matrix variable may be defined as optional and a default value specified, as the following example shows:
#### ** Chinese **

矩阵变量可以定义为可选的，并指定一个默认值，如下例所示。

<!-- tabs:end -->


```java
// GET /pets/42

@GetMapping("/pets/{petId}")
public void findPet(@MatrixVariable(required=false, defaultValue="1") int q) {

    // q == 1
}
```

<!-- tabs:start -->

#### ** English **

To get all matrix variables, you can use a `MultiValueMap`, as the following example shows:
#### ** Chinese **

要获得所有的矩阵变量，可以使用`MultiValueMap`，如下例所示。

<!-- tabs:end -->


```java
// GET /owners/42;q=11;r=12/pets/21;q=22;s=23

@GetMapping("/owners/{ownerId}/pets/{petId}")
public void findPet(
        @MatrixVariable MultiValueMap<String, String> matrixVars,
        @MatrixVariable(pathVar="petId") MultiValueMap<String, String> petMatrixVars) {

    // matrixVars: ["q" : [11,22], "r" : 12, "s" : 23]
    // petMatrixVars: ["q" : 22, "s" : 23]
}
```

<!-- tabs:start -->

#### ** English **

Note that you need to enable the use of matrix variables. In the MVC Java configuration, you need to set a `UrlPathHelper` with `removeSemicolonContent=false` through [Path Matching](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-config-path-matching). In the MVC XML namespace, you can set `<mvc:annotation-driven enable-matrix-variables="true"/>`.
#### ** Chinese **

注意，你需要启用矩阵变量的使用。在MVC Java配置中，你需要通过[路径匹配](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-config-path-matching)设置一个`UrlPathHelper`，其中`removeSemicolonContent=false`。在MVC XML命名空间中，可以设置`<mvc:annotation-driven enable-matrix-variables="true"/>`。

<!-- tabs:end -->


### **`@RequestParam`** 

<!-- tabs:start -->

#### ** English **

[WebFlux](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-requestparam)
#### ** Chinese **

[WebFlux](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-requestparam)

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can use the `@RequestParam` annotation to bind Servlet request parameters (that is, query parameters or form data) to a method argument in a controller.
#### ** Chinese **

可以使用`@RequestParam` 注解来绑定Servlet请求参数（即查询参数或表单数据）到控制器中的方法参数。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following example shows how to do so:
#### ** Chinese **

下面的例子说明了如何做到这一点。

<!-- tabs:end -->


```java
@Controller
@RequestMapping("/pets")
public class EditPetForm {

    // ...

    @GetMapping
    public String setupForm(@RequestParam("petId") int petId, Model model) { (1)
        Pet pet = this.clinic.loadPet(petId);
        model.addAttribute("pet", pet);
        return "petForm";
    }

    // ...

}

//(1) Using @RequestParam to bind petId.
```

<!-- tabs:start -->

#### ** English **

By default, method parameters that use this annotation are required, but you can specify that a method parameter is optional by setting the `@RequestParam` annotation’s `required` flag to `false` or by declaring the argument with an `java.util.Optional` wrapper.
#### ** Chinese **

默认情况下，使用此注释的方法参数是必需的，但可以通过将`@RequestParam`注释的`required`标志设置为`false`或通过使用`java.util.Optional` wrapper声明参数，指定方法参数是可选的。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Type conversion is automatically applied if the target method parameter type is not `String`. See [Type Conversion](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-typeconversion).
#### ** Chinese **

如果目标方法参数类型不是`String`，则自动进行类型转换。参见[类型转换](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-typeconversion)。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Declaring the argument type as an array or list allows for resolving multiple parameter values for the same parameter name.
#### ** Chinese **

声明参数类型为数组或列表，可以解析同一参数名称的多个参数值。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

When an `@RequestParam` annotation is declared as a `Map<String, String>` or `MultiValueMap<String, String>`, without a parameter name specified in the annotation, then the map is populated with the request parameter values for each given parameter name.
#### ** Chinese **

当`@RequestParam`注释被声明为`Map<String, String>`或`MultiValueMap<String, String>`时，没有在注释中指定参数名，那么该映射将被填充为每个给定参数名的请求参数值。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Note that use of `@RequestParam` is optional (for example, to set its attributes). By default, any argument that is a simple value type (as determined by [BeanUtils#isSimpleProperty](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-)) and is not resolved by any other argument resolver, is treated as if it were annotated with `@RequestParam`.
#### ** Chinese **

注意，`@RequestParam`的使用是可选的（例如，设置它的属性）。默认情况下，任何参数如果是简单值类型（由[BeanUtils#isSimpleProperty](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-)决定），并且没有被任何其他参数解析器解析，那么就会被当作是用`@RequestParam`注释的参数来处理。

<!-- tabs:end -->


### **`@RequestHeader`** 

<!-- tabs:start -->

#### ** English **

[WebFlux](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-requestheader)
#### ** Chinese **

[WebFlux](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-requestheader)

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can use the `@RequestHeader` annotation to bind a request header to a method argument in a controller.
#### ** Chinese **

可以使用 `@RequestHeader` 注释将请求头绑定到控制器中的方法参数。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Consider the following request, with headers:
#### ** Chinese **

考虑以下请求，并附上标题：

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Host localhost:8080
#### ** Chinese **

Host localhost:8080

<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

Accept text/html,application/xhtml+xml,application/xml;q=0.9
#### ** Chinese **

接受text/html,application/xhtml+xml,application/xml;q=0.9

<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

Accept-Language fr,en-gb;q=0.7,en;q=0.3
#### ** Chinese **

Accept-Language en,en-gb;q=0.7,en;q=0.3

<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

Accept-Encoding gzip,deflate
#### ** Chinese **

Accept-Encoding gzip,deflate

<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

Accept-Charset ISO-8859-1,utf-8;q=0.7,*;q=0.7
#### ** Chinese **

Accept-Charset ISO-8859-1,utf-8;q=0.7,*;q=0.7

<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

Keep-Alive 300
#### ** Chinese **

保持活力300

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following example gets the value of the `Accept-Encoding` and `Keep-Alive` headers:
#### ** Chinese **

下面的例子可以得到`Accept-Encoding`和`Keep-Alive`头的值。

<!-- tabs:end -->


```java
@GetMapping("/demo")
public void handle(
        @RequestHeader("Accept-Encoding") String encoding, (1)
        @RequestHeader("Keep-Alive") long keepAlive) { (2)
    //...
}

//(1) Get the value of the Accept-Encoding header.
(2) Get the value of the Keep-Alive header.
```

<!-- tabs:start -->

#### ** English **

If the target method parameter type is not `String`, type conversion is automatically applied. See [Type Conversion](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-typeconversion).
#### ** Chinese **

如果目标方法的参数类型不是`String`，将自动进行类型转换。参见[类型转换](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-typeconversion)。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

When an `@RequestHeader` annotation is used on a `Map<String, String>`, `MultiValueMap<String, String>`, or `HttpHeaders` argument, the map is populated with all header values.
#### ** Chinese **

当`@RequestHeader`注释被用于`Map<String, String>`, `MultiValueMap<String, String>`, 或`HttpHeaders`参数时，该映射被填充了所有的头值。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Built-in support is available for converting a comma-separated string into an array or collection of strings or other types known to the type conversion system. For example, a method parameter annotated with `@RequestHeader("Accept")` can be of type `String` but also `String[]` or `List<String>`.
#### ** Chinese **

内置支持将逗号分隔的字符串转换为数组或字符串集合或类型转换系统已知的其他类型。例如，用 `@RequestHeader("Accept")`注释的方法参数可以是类型为`String`，也可以是类型为`String[]`或`List<String>`。

<!-- tabs:end -->


### **`@CookieValue`** 

<!-- tabs:start -->

#### ** English **

[WebFlux](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-cookievalue)
#### ** Chinese **

[WebFlux](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-cookievalue)

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can use the `@CookieValue` annotation to bind the value of an HTTP cookie to a method argument in a controller.
#### ** Chinese **

你可以使用`@CookieValue`注释将HTTP cookie的值绑定到控制器中的方法参数。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Consider a request with the following cookie:
#### ** Chinese **

考虑一个有以下cookie的请求：

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

JSESSIONID=415A4AC178C59DACE0B2C9CA727CDD84
#### ** Chinese **

jsessionid=415a4ac178c59dace0b2c9ca727cdd84

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following example shows how to get the cookie value:
#### ** Chinese **

下面的例子显示了如何获得cookie值。

<!-- tabs:end -->


```java
@GetMapping("/demo")
public void handle(@CookieValue("JSESSIONID") String cookie) { (1)
    //...
}

//(1) Get the value of the JSESSIONID cookie.
```

<!-- tabs:start -->

#### ** English **

If the target method parameter type is not `String`, type conversion is applied automatically. See [Type Conversion](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-typeconversion).
#### ** Chinese **

如果目标方法的参数类型不是`String`，类型转换将自动应用。参见[类型转换](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-typeconversion)。

<!-- tabs:end -->


### **`@ModelAttribute`** 

<!-- tabs:start -->

#### ** English **

[WebFlux](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-modelattrib-method-args)
#### ** Chinese **

[WebFlux](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-modelattrib-method-args)

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can use the `@ModelAttribute` annotation on a method argument to access an attribute from the model or have it be instantiated if not present. The model attribute is also overlain with values from HTTP Servlet request parameters whose names match to field names. This is referred to as data binding, and it saves you from having to deal with parsing and converting individual query parameters and form fields. The following example shows how to do so:
#### ** Chinese **

你可以使用方法参数上的 `@ModelAttribute` 注释来访问模型中的属性，或者如果不存在的话，可以将其实例化。模型属性也可以与HTTP Servlet请求参数中的值叠加，这些参数的名称与字段名匹配。这被称为数据绑定，它使你不必处理单个查询参数和表单字段的解析和转换。下面的例子显示了如何做到这一点。

<!-- tabs:end -->


```java
@PostMapping("/owners/{ownerId}/pets/{petId}/edit")
public String processSubmit(@ModelAttribute Pet pet) { } (1)

//(1) Bind an instance of Pet.
```

<!-- tabs:start -->

#### ** English **

The `Pet` instance above is resolved as follows:
#### ** Chinese **

上面的`Pet`实例解析如下。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

- From the model if already added by using [Model](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-modelattrib-methods).

- From the HTTP session by using [`@SessionAttributes`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-sessionattributes).

- From a URI path variable passed through a `Converter` (see the next example).

- From the invocation of a default constructor.

- From the invocation of a “primary constructor” with arguments that match to Servlet request parameters. Argument names are determined through JavaBeans `@ConstructorProperties` or through runtime-retained parameter names in the bytecode.

#### ** Chinese **

- 如果已经添加了模型，请使用[Model](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-modelattrib-methods)。

- 通过使用[`@SessionAttributes`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-sessionattributes)，从HTTP会话中获取。

- 来自于通过`Converter`传递的URI路径变量（见下一个例子）。

- 来自默认构造函数的调用。

- 来自 主构造函数 的调用，其参数与Servlet请求参数匹配。参数名称通过JavaBeans `@ConstructorProperties`或者通过字节码中的运行时引用的参数名称来确定。


<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

While it is common to use a [Model](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-modelattrib-methods) to populate the model with attributes, one other alternative is to rely on a `Converter<String, T>` in combination with a URI path variable convention. In the following example, the model attribute name, `account`, matches the URI path variable, `account`, and the `Account` is loaded by passing the `String` account number through a registered `Converter<String, Account>`:
#### ** Chinese **

虽然使用[Model](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-modelattrib-methods)来填充模型的属性是很常见的，但还有一种选择是依靠`Converter<String, T>`与URI路径变量约定的结合。在下面的例子中，模型的属性名`account`与URI路径变量`account`相匹配，通过注册的`Converter<String, Account>`将`String`帐号通过注册的`Converter<String, Account>`加载。

<!-- tabs:end -->


```java
@PutMapping("/accounts/{account}")
public String save(@ModelAttribute("account") Account account) {
    // ...
}
```

<!-- tabs:start -->

#### ** English **

After the model attribute instance is obtained, data binding is applied. The `WebDataBinder` class matches Servlet request parameter names (query parameters and form fields) to field names on the target `Object`. Matching fields are populated after type conversion is applied, where necessary. For more on data binding (and validation), see [Validation](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#validation). For more on customizing data binding, see [`DataBinder`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-initbinder).
#### ** Chinese **

在获得模型属性实例后，应用数据绑定。`WebDataBinder`类会将Servlet请求参数名（查询参数和表单字段）与目标`Object`上的字段名进行匹配。匹配的字段在应用类型转换后，必要时，会被填充。有关数据绑定（和验证）的更多信息，请参阅[验证](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#validation)。有关自定义数据绑定的更多信息，请参阅 [`DataBinder`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-initbinder)。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Data binding can result in errors. By default, a `BindException` is raised. However, to check for such errors in the controller method, you can add a `BindingResult` argument immediately next to the `@ModelAttribute`, as the following example shows:
#### ** Chinese **

数据绑定会导致错误。默认情况下，会产生一个`BindException`。但是，为了在控制器方法中检查此类错误，你可以在`@ModelAttribute`旁边添加一个`BindingResult`参数，如下例所示。

<!-- tabs:end -->


```java
@PostMapping("/owners/{ownerId}/pets/{petId}/edit")
public String processSubmit(@ModelAttribute("pet") Pet pet, BindingResult result) { (1)
    if (result.hasErrors()) {
        return "petForm";
    }
    // ...
}

//(1) Adding a BindingResult next to the @ModelAttribute.
```

<!-- tabs:start -->

#### ** English **

In some cases, you may want access to a model attribute without data binding. For such cases, you can inject the `Model` into the controller and access it directly or, alternatively, set `@ModelAttribute(binding=false)`, as the following example shows:
#### ** Chinese **

在某些情况下，你可能希望访问一个模型属性而不需要数据绑定。对于这种情况，你可以将`Model`注入到控制器中并直接访问它，或者，设置`@ModelAttribute(binding=false)`，如下面的例子所示。

<!-- tabs:end -->


```java
@ModelAttribute
public AccountForm setUpForm() {
    return new AccountForm();
}

@ModelAttribute
public Account findAccount(@PathVariable String accountId) {
    return accountRepository.findOne(accountId);
}

@PostMapping("update")
public String update(@Valid AccountForm form, BindingResult result,
        @ModelAttribute(binding=false) Account account) { (1)
    // ...
}

//(1) Setting @ModelAttribute(binding=false).
```

<!-- tabs:start -->

#### ** English **

You can automatically apply validation after data binding by adding the `javax.validation.Valid` annotation or Spring’s `@Validated` annotation ( [Bean Validation](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#validation-beanvalidation) and [Spring validation](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#validation)). The following example shows how to do so:
#### ** Chinese **

你可以在数据绑定后通过添加 `javax.validation.Valid`注解或Spring的`@Validated`注解（[[Bean Validation](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#validation-beanvalidation)和[Spring validation](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#validation)），自动应用验证。) 下面的例子显示了如何实现。

<!-- tabs:end -->


```java
@PostMapping("/owners/{ownerId}/pets/{petId}/edit")
public String processSubmit(@Valid @ModelAttribute("pet") Pet pet, BindingResult result) { (1)
    if (result.hasErrors()) {
        return "petForm";
    }
    // ...
}

//(1) Validate the Pet instance.
```

<!-- tabs:start -->

#### ** English **

Note that using `@ModelAttribute` is optional (for example, to set its attributes). By default, any argument that is not a simple value type (as determined by [BeanUtils#isSimpleProperty](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-)) and is not resolved by any other argument resolver is treated as if it were annotated with `@ModelAttribute`.
#### ** Chinese **

注意，使用`@ModelAttribute`是可选的（例如，设置它的属性）。默认情况下，任何不是简单值类型的参数（由[BeanUtils#isSimpleProperty](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-)决定），并且没有被任何其他参数解析器解析的参数都会被视为被注释了`@ModelAttribute`的参数。

<!-- tabs:end -->


### **`@SessionAttributes`** 

<!-- tabs:start -->

#### ** English **

[WebFlux](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-sessionattributes)
#### ** Chinese **

[WebFlux](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-sessionattributes)

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

`@SessionAttributes` is used to store model attributes in the HTTP Servlet session between requests. It is a type-level annotation that declares the session attributes used by a specific controller. This typically lists the names of model attributes or types of model attributes that should be transparently stored in the session for subsequent requests to access.
#### ** Chinese **

`@SessionAttributes`用于在请求之间存储HTTP Servlet会话中的模型属性。它是一个类型级注释，声明了特定控制器使用的会话属性。这通常会列出模型属性的名称或模型属性的类型，这些属性应该透明地存储在会话中，以便后续请求访问。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following example uses the `@SessionAttributes` annotation:
#### ** Chinese **

下面的示例使用了`@SessionAttributes`注释。

<!-- tabs:end -->


```java
@Controller
@SessionAttributes("pet") (1)
public class EditPetForm {
    // ...
}

//(1) Using the @SessionAttributes annotation.
```

<!-- tabs:start -->

#### ** English **

On the first request, when a model attribute with the name, `pet`, is added to the model, it is automatically promoted to and saved in the HTTP Servlet session. It remains there until another controller method uses a `SessionStatus` method argument to clear the storage, as the following example shows:
#### ** Chinese **

在第一次请求中，当一个名称为`pet`的模型属性被添加到模型中时，它将自动被提升到并保存在HTTP Servlet会话中。它一直保持在那里，直到另一个控制器方法使用`SessionStatus`方法参数来清除存储，如下例所示。

<!-- tabs:end -->


```java
@Controller
@SessionAttributes("pet") (1)
public class EditPetForm {

    // ...

    @PostMapping("/pets/{id}")
    public String handle(Pet pet, BindingResult errors, SessionStatus status) {
        if (errors.hasErrors) {
            // ...
        }
            status.setComplete(); (2)
            // ...
        }
    }
}

//(1) Storing the Pet value in the Servlet session.
(2) Clearing the Pet value from the Servlet session.
```

### **`@SessionAttribute`** 

<!-- tabs:start -->

#### ** English **

[WebFlux](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-sessionattribute)
#### ** Chinese **

[WebFlux](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-sessionattribute)

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

If you need access to pre-existing session attributes that are managed globally (that is, outside the controller — for example, by a filter) and may or may not be present, you can use the `@SessionAttribute` annotation on a method parameter, as the following example shows:
#### ** Chinese **

如果你需要访问全局管理的预先存在的会话属性（即在控制器之外--例如，通过过滤器），并且可能存在或不存在，你可以在方法参数上使用`@SessionAttribute`注释，如下例所示。

<!-- tabs:end -->


```java
@RequestMapping("/")
public String handle(@SessionAttribute User user) { (1)
    // ...
}

//(1) Using a @SessionAttribute annotation.
```

<!-- tabs:start -->

#### ** English **

For use cases that require adding or removing session attributes, consider injecting `org.springframework.web.context.request.WebRequest` or `javax.servlet.http.HttpSession` into the controller method.
#### ** Chinese **

对于需要添加或删除会话属性的用例，可以考虑在控制器方法中注入 `org.springframework.web.context.request.WebRequest`或`javax.servlet.http.HttpSession`。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

For temporary storage of model attributes in the session as part of a controller workflow, consider using `@SessionAttributes` as described in [`@SessionAttributes`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-sessionattributes).
#### ** Chinese **

对于作为控制器工作流的一部分在会话中临时存储模型属性，可以考虑使用`@SessionAttributes`，如[`@SessionAttributes`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-sessionattributes)中描述的那样。

<!-- tabs:end -->


### **`@RequestAttribute`** 

<!-- tabs:start -->

#### ** English **

[WebFlux](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-requestattrib)
#### ** Chinese **

[WebFlux](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-requestattrib)

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Similar to `@SessionAttribute`, you can use the `@RequestAttribute` annotations to access pre-existing request attributes created earlier (for example, by a Servlet `Filter` or `HandlerInterceptor`):
#### ** Chinese **

与 `@SessionAttribute`类似，您可以使用 `@RequestAttribute` 注解来访问先前创建的预先存在的请求属性（例如，由Servlet `Filter`或`HandlerInterceptor`）。

<!-- tabs:end -->


```java
@GetMapping("/")
public String handle(@RequestAttribute Client client) { (1)
    // ...
}

//(1) Using the @RequestAttribute annotation.
```

### **Redirect Attributes** 

<!-- tabs:start -->

#### ** English **

By default, all model attributes are considered to be exposed as URI template variables in the redirect URL. Of the remaining attributes, those that are primitive types or collections or arrays of primitive types are automatically appended as query parameters.
#### ** Chinese **

默认情况下，所有的模型属性都被认为是作为URI模板变量暴露在重定向URL中。在其余的属性中，那些是基元类型或集合或基元类型的集合或数组的属性会被自动附加为查询参数。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Appending primitive type attributes as query parameters can be the desired result if a model instance was prepared specifically for the redirect. However, in annotated controllers, the model can contain additional attributes added for rendering purposes (for example, drop-down field values). To avoid the possibility of having such attributes appear in the URL, a `@RequestMapping` method can declare an argument of type `RedirectAttributes` and use it to specify the exact attributes to make available to `RedirectView`. If the method does redirect, the content of `RedirectAttributes` is used. Otherwise, the content of the model is used.
#### ** Chinese **

如果一个模型实例是专门为重定向准备的，那么添加基元类型属性作为查询参数可能是理想的结果。然而，在注释控制器中，模型可以包含为渲染目的添加的附加属性（例如，下拉字段值）。为了避免这些属性出现在URL中的可能性，`@RequestMapping`方法可以声明一个类型为`RedirectAttributes`的参数，并使用它来指定要提供给`RedirectView`的确切属性。如果该方法确实重定向，则使用`RedirectAttributes`的内容。否则，将使用模型的内容。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The `RequestMappingHandlerAdapter` provides a flag called `ignoreDefaultModelOnRedirect`, which you can use to indicate that the content of the default `Model` should never be used if a controller method redirects. Instead, the controller method should declare an attribute of type `RedirectAttributes` or, if it does not do so, no attributes should be passed on to `RedirectView`. Both the MVC namespace and the MVC Java configuration keep this flag set to `false`, to maintain backwards compatibility. However, for new applications, we recommend setting it to `true`.
#### ** Chinese **

`RequestMappingHandlerAdapter`提供了一个名为`ignoreDefaultModelOnRedirect`的标志，你可以用它来表示，如果控制器方法重定向，就不应该使用默认的`Model`的内容。相反，控制器方法应该声明一个属性类型为`RedirectAttributes`的属性，或者，如果没有这样做，则不应该将任何属性传递给`RedirectView`。MVC命名空间和MVC Java配置都将此标志设置为`false`，以保持向后兼容性。但是，对于新的应用程序，我们建议将其设置为`true`。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Note that URI template variables from the present request are automatically made available when expanding a redirect URL, and you don’t need to explicitly add them through `Model` or `RedirectAttributes`. The following example shows how to define a redirect:
#### ** Chinese **

请注意，当扩展重定向URL时，当前请求中的URI模板变量会自动提供，您不需要通过`Model`或`RedirectAttributes`显式添加它们。下面的例子显示了如何定义一个重定向。

<!-- tabs:end -->


```java
@PostMapping("/files/{path}")
public String upload(...) {
    // ...
    return "redirect:files/{path}";
}
```

<!-- tabs:start -->

#### ** English **

Another way of passing data to the redirect target is by using flash attributes. Unlike other redirect attributes, flash attributes are saved in the HTTP session (and, hence, do not appear in the URL). See [Flash Attributes](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-flash-attributes) for more information.
#### ** Chinese **

另一种向重定向目标传递数据的方式是使用flash属性。与其他重定向属性不同，flash属性是保存在HTTP会话中的（因此，不会出现在URL中）。更多信息请参见[Flash属性](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-flash-attributes)。

<!-- tabs:end -->


### **Flash Attributes** 

<!-- tabs:start -->

#### ** English **

Flash attributes provide a way for one request to store attributes that are intended for use in another. This is most commonly needed when redirecting — for example, the Post-Redirect-Get pattern. Flash attributes are saved temporarily before the redirect (typically in the session) to be made available to the request after the redirect and are removed immediately.
#### ** Chinese **

Flash属性为一个请求提供了一种存储属性的方式，而这些属性要在另一个请求中使用。这在重定向时是最常用的--例如，Post-Redirect-Get模式。Flash属性在重定向之前（通常是在会话中）暂时保存，以便在重定向之后，立即被移除。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Spring MVC has two main abstractions in support of flash attributes. `FlashMap` is used to hold flash attributes, while `FlashMapManager` is used to store, retrieve, and manage `FlashMap` instances.
#### ** Chinese **

Spring MVC有两个主要的抽象来支持Flash属性。 `FlashMap`用于存放flash属性，而`FlashMapManager`用于存储、检索和管理`FlashMap`实例。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Flash attribute support is always “on” and does not need to be enabled explicitly. However, if not used, it never causes HTTP session creation. On each request, there is an “input” `FlashMap` with attributes passed from a previous request (if any) and an “output” `FlashMap` with attributes to save for a subsequent request. Both `FlashMap` instances are accessible from anywhere in Spring MVC through static methods in `RequestContextUtils`.
#### ** Chinese **

Flash属性支持始终是 开着的，不需要显式启用。但是，如果不使用，它永远不会导致HTTP会话的创建。在每个请求中，都有一个 输入`FlashMap`和一个 输出`FlashMap`，前者的属性来自于前一个请求（如果有的话），后者的属性是为后续请求保存的。这两个 `FlashMap`实例都可以通过`RequestContextUtils`中的静态方法从Spring MVC的任何地方访问。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Annotated controllers typically do not need to work with `FlashMap` directly. Instead, a `@RequestMapping` method can accept an argument of type `RedirectAttributes` and use it to add flash attributes for a redirect scenario. Flash attributes added through `RedirectAttributes` are automatically propagated to the “output” FlashMap. Similarly, after the redirect, attributes from the “input” `FlashMap` are automatically added to the `Model` of the controller that serves the target URL.
#### ** Chinese **

注释控制器通常不需要直接与`FlashMap`一起工作。相反，`@RequestMapping`方法可以接受一个类型为`RedirectAttributes`的参数，并使用它为重定向场景添加Flash属性。通过`RedirectAttributes`添加的Flash属性会自动传播到 输出 FlashMap中。同样，在重定向后，来自 输入`FlashMap`的属性会自动添加到服务于目标URL的控制器的`Model`中。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Matching requests to flash attributes
#### ** Chinese **

将请求与闪光属性匹配

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The concept of flash attributes exists in many other web frameworks and has proven to sometimes be exposed to concurrency issues. This is because, by definition, flash attributes are to be stored until the next request. However the very “next” request may not be the intended recipient but another asynchronous request (for example, polling or resource requests), in which case the flash attributes are removed too early.
#### ** Chinese **

闪存属性的概念在许多其他web框架中都存在，事实证明，有时会暴露出并发问题。这是因为，根据定义，flash属性要存储到下一个请求之前。然而，非常 下一个 请求可能不是预定的接收者，而是另一个异步请求（例如，轮询或资源请求），在这种情况下，flash属性会被过早地删除。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

To reduce the possibility of such issues, `RedirectView` automatically “stamps” `FlashMap` instances with the path and query parameters of the target redirect URL. In turn, the default `FlashMapManager` matches that information to incoming requests when it looks up the “input” `FlashMap`.
#### ** Chinese **

为了减少此类问题的可能性，`RedirectView`会用目标重定向URL的路径和查询参数自动 标记`FlashMap`实例。反过来，默认的`FlashMapManager`在查找 输入`FlashMap`时，会将这些信息与传入的请求匹配。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

This does not entirely eliminate the possibility of a concurrency issue but reduces it greatly with information that is already available in the redirect URL. Therefore, we recommend that you use flash attributes mainly for redirect scenarios.
#### ** Chinese **

这并不能完全消除并发问题的可能性，但由于重定向URL中已经有了信息，所以大大降低了并发问题。因此，我们建议主要在重定向的场景中使用flash属性。

<!-- tabs:end -->


### **Multipart** 

<!-- tabs:start -->

#### ** English **

[WebFlux](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-multipart-forms)
#### ** Chinese **

[WebFlux](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-multipart-forms)

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

After a `MultipartResolver` has been [enabled](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-multipart), the content of POST requests with `multipart/form-data` is parsed and accessible as regular request parameters. The following example accesses one regular form field and one uploaded file:
#### ** Chinese **

在`MultipartResolver`被[启用](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-multipart)后，带有`multipart/form-data`的POST请求的内容会被解析并作为常规请求参数访问。下面的示例访问了一个常规表单字段和一个上传的文件。

<!-- tabs:end -->


```java
@Controller
public class FileUploadController {

    @PostMapping("/form")
    public String handleFormUpload(@RequestParam("name") String name,
            @RequestParam("file") MultipartFile file) {

        if (!file.isEmpty()) {
            byte[] bytes = file.getBytes();
            // store the bytes somewhere
            return "redirect:uploadSuccess";
        }
        return "redirect:uploadFailure";
    }
}
```

<!-- tabs:start -->

#### ** English **

Declaring the argument type as a `List<MultipartFile>` allows for resolving multiple files for the same parameter name.
#### ** Chinese **

声明参数类型为`List<MultipartFile>`，可以解析多个文件的同一参数名。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

When the `@RequestParam` annotation is declared as a `Map<String, MultipartFile>` or `MultiValueMap<String, MultipartFile>`, without a parameter name specified in the annotation, then the map is populated with the multipart files for each given parameter name.
#### ** Chinese **

当`@RequestParam` 注解被声明为`Map<String, MultipartFile>`或`MultiValueMap<String, MultipartFile>`时，没有在注解中指定参数名，那么该映射将被填充为每个给定参数名的多部分文件。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

With Servlet 3.0 multipart parsing, you may also declare `javax.servlet.http.Part` instead of Spring’s `MultipartFile`, as a method argument or collection value type.
#### ** Chinese **

使用 Servlet 3.0 多部分解析，你也可以声明 `javax.servlet.http.Part`，而不是 Spring 的 `MultipartFile`，作为方法参数或集合值类型。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can also use multipart content as part of data binding to a [command object](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-modelattrib-method-args). For example, the form field and file from the preceding example could be fields on a form object, as the following example shows:
#### ** Chinese **

你也可以使用多部分内容作为数据绑定到[命令对象](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-modelattrib-method-args)的一部分。例如，前面例子中的表单字段和文件可以成为表单对象上的字段，如下图所示。

<!-- tabs:end -->


```java
class MyForm {

    private String name;

    private MultipartFile file;

    // ...
}

@Controller
public class FileUploadController {

    @PostMapping("/form")
    public String handleFormUpload(MyForm form, BindingResult errors) {
        if (!form.getFile().isEmpty()) {
            byte[] bytes = form.getFile().getBytes();
            // store the bytes somewhere
            return "redirect:uploadSuccess";
        }
        return "redirect:uploadFailure";
    }
}
```

<!-- tabs:start -->

#### ** English **

Multipart requests can also be submitted from non-browser clients in a RESTful service scenario. The following example shows a file with JSON:
#### ** Chinese **

在RESTful服务场景中，也可以从非浏览器客户端提交多部分请求。下面的例子显示了一个带JSON的文件。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

POST /someUrl
#### ** Chinese **

POST /someUrl

<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

Content-Type: multipart/mixed
#### ** Chinese **

内容类型：多部分/混合

<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

--edt7Tfrdusa7r3lNQc79vXuhIIMlatb7PQg7Vp
#### ** Chinese **

--edt7Tfrdusa7r3lNQc79vXuhIIMlatb7PQg7Vp

<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

Content-Disposition: form-data; name="meta-data"
#### ** Chinese **

Content-Disposition: form-data; name=meta-data

<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

Content-Type: application/json; charset=UTF-8
#### ** Chinese **

Content-Type: application/json; charset=UTF-8

<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

Content-Transfer-Encoding: 8bit
#### ** Chinese **

内容-传输-编码。8bit

<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

{ "name": "value"
#### ** Chinese **

{ name: value：

<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

}
#### ** Chinese **

}

<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

--edt7Tfrdusa7r3lNQc79vXuhIIMlatb7PQg7Vp
#### ** Chinese **

--edt7Tfrdusa7r3lNQc79vXuhIIMlatb7PQg7Vp

<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

Content-Disposition: form-data; name="file-data"; filename="file.properties"
#### ** Chinese **

Content-Disposition: form-data; name=file-data; filename=file.properties

<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

Content-Type: text/xml
#### ** Chinese **

内容类型：text/xml

<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

Content-Transfer-Encoding: 8bit
#### ** Chinese **

内容-传输-编码。8bit

<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

... File Data ...
#### ** Chinese **

... 日期文件.....

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can access the "meta-data" part with `@RequestParam` as a `String` but you’ll probably want it deserialized from JSON (similar to `@RequestBody`). Use the `@RequestPart` annotation to access a multipart after converting it with an [HttpMessageConverter](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#rest-message-conversion):
#### ** Chinese **

你可以用`@RequestParam`作为一个`String`来访问 元数据 部分，但你可能希望它从JSON中反序列化（类似于`@RequestBody`）。使用`@RequestPart`注解来访问一个用[HttpMessageConverter](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#rest-message-conversion)转换后的多部分。

<!-- tabs:end -->


```java
@PostMapping("/")
public String handle(@RequestPart("meta-data") MetaData metadata,
        @RequestPart("file-data") MultipartFile file) {
    // ...
}
```

<!-- tabs:start -->

#### ** English **

You can use `@RequestPart` in combination with `javax.validation.Valid` or use Spring’s `@Validated` annotation, both of which cause Standard Bean Validation to be applied. By default, validation errors cause a `MethodArgumentNotValidException`, which is turned into a 400 (BAD_REQUEST) response. Alternatively, you can handle validation errors locally within the controller through an `Errors` or `BindingResult` argument, as the following example shows:
#### ** Chinese **

你可以使用`@RequestPart`与`javax.validation.Valid`结合使用，或者使用Spring的`@Validated`注解，这两个注解都会导致标准Bean验证被应用。默认情况下，验证错误会引起一个`MethodArgumentNotValidException`，它被转化为一个400（BAD_REQUEST）响应。或者，您可以通过`Errors`或`BindingResult`参数在控制器内本地处理验证错误，如下例所示。

<!-- tabs:end -->


```java
@PostMapping("/")
public String handle(@Valid @RequestPart("meta-data") MetaData metadata,
        BindingResult result) {
    // ...
}
```

### **`@RequestBody`** 

<!-- tabs:start -->

#### ** English **

[WebFlux](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-requestbody)
#### ** Chinese **

[WebFlux](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-requestbody)

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can use the `@RequestBody` annotation to have the request body read and deserialized into an `Object` through an [`HttpMessageConverter`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#rest-message-conversion). The following example uses a `@RequestBody` argument:
#### ** Chinese **

你可以使用 `@RequestBody` 注解来让请求体通过 [`HttpMessageConverter`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#rest-message-conversion)被读取并反序列化为`Object`。下面的例子使用了一个`@RequestBody`参数。

<!-- tabs:end -->


```java
@PostMapping("/accounts")
public void handle(@RequestBody Account account) {
    // ...
}
```

<!-- tabs:start -->

#### ** English **

You can use the [Message Converters](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-config-message-converters) option of the [MVC Config](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-config) to configure or customize message conversion.
#### ** Chinese **

您可以使用[MVC Config](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-config)中的[Message Converters](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-config-message-converters)选项来配置或自定义消息转换。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can use `@RequestBody` in combination with `javax.validation.Valid` or Spring’s `@Validated` annotation, both of which cause Standard Bean Validation to be applied. By default, validation errors cause a `MethodArgumentNotValidException`, which is turned into a 400 (BAD_REQUEST) response. Alternatively, you can handle validation errors locally within the controller through an `Errors` or `BindingResult` argument, as the following example shows:
#### ** Chinese **

您可以将 `@RequestBody`与 `javax.validation.Valid` 或 Spring 的 `@Validated` 注解结合使用，这两个注解都会导致标准 Bean Validation 被应用。默认情况下，验证错误会引起一个`MethodArgumentNotValidException`，它被转化为一个400（BAD_REQUEST）响应。或者，您可以通过`Errors`或`BindingResult`参数在控制器内本地处理验证错误，如下例所示。

<!-- tabs:end -->


```java
@PostMapping("/accounts")
public void handle(@Valid @RequestBody Account account, BindingResult result) {
    // ...
}
```

### **HttpEntity** 

<!-- tabs:start -->

#### ** English **

[WebFlux](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-httpentity)
#### ** Chinese **

[WebFlux](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-httpentity)

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

`HttpEntity` is more or less identical to using [`@RequestBody`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-requestbody) but is based on a container object that exposes request headers and body. The following listing shows an example:
#### ** Chinese **

`HttpEntity`与使用[`@RequestBody`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-requestbody)大致相同，但它是基于一个容器对象，该容器对象会暴露请求头和body。下面的列表显示了一个例子。

<!-- tabs:end -->


```java
@PostMapping("/accounts")
public void handle(HttpEntity<Account> entity) {
    // ...
}
```

### **`@ResponseBody`** 

<!-- tabs:start -->

#### ** English **

[WebFlux](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-responsebody)
#### ** Chinese **

[WebFlux](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-responsebody)

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can use the `@ResponseBody` annotation on a method to have the return serialized to the response body through an [HttpMessageConverter](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#rest-message-conversion). The following listing shows an example:
#### ** Chinese **

你可以在一个方法上使用`@ResponseBody`注释，通过[HttpMessageConverter](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#rest-message-conversion)将返回序列化为响应体。下面的列表显示了一个例子。

<!-- tabs:end -->


```java
@GetMapping("/accounts/{id}")
@ResponseBody
public Account handle() {
    // ...
}
```

<!-- tabs:start -->

#### ** English **

`@ResponseBody` is also supported at the class level, in which case it is inherited by all controller methods. This is the effect of `@RestController`, which is nothing more than a meta-annotation marked with `@Controller` and `@ResponseBody`.
#### ** Chinese **

`@ResponseBody`也在类级支持，在这种情况下，它被所有的控制器方法继承。这就是 `@RestController`的效果，它不过是一个标有`@Controller`和`@ResponseBody`的元注释。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can use `@ResponseBody` with reactive types. See [Asynchronous Requests](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-async) and [Reactive Types](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-async-reactive-types) for more details.
#### ** Chinese **

你可以将`@ResponseBody`和反应式类型一起使用。有关详细信息，请参见 [异步请求](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-async) 和 [反应式类型](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-async-reactive-types) 。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can use the [Message Converters](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-config-message-converters) option of the [MVC Config](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-config) to configure or customize message conversion.
#### ** Chinese **

您可以使用[MVC Config](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-config)中的[Message Converters](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-config-message-converters)选项来配置或自定义消息转换。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can combine `@ResponseBody` methods with JSON serialization views. See [Jackson JSON](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-jackson) for details.
#### ** Chinese **

你可以将`@ResponseBody`方法与JSON序列化视图结合起来。详情请参阅[Jackson JSON](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-jackson)。

<!-- tabs:end -->


### **ResponseEntity** 

<!-- tabs:start -->

#### ** English **

[WebFlux](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-responseentity)
#### ** Chinese **

[WebFlux](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-responseentity)

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

`ResponseEntity` is like [`@ResponseBody`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-responsebody) but with status and headers. For example:
#### ** Chinese **

`ResponseEntity`就像[`@ResponseBody`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-responsebody)一样，但有状态和标题。比如说。

<!-- tabs:end -->


```java
@GetMapping("/something")
public ResponseEntity<String> handle() {
    String body = ... ;
    String etag = ... ;
    return ResponseEntity.ok().eTag(etag).build(body);
}
```

<!-- tabs:start -->

#### ** English **

Spring MVC supports using a single value [reactive type](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-async-reactive-types) to produce the `ResponseEntity` asynchronously, and/or single and multi-value reactive types for the body.
#### ** Chinese **

Spring MVC支持使用单值[反应式类型](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-async-reactive-types)异步生成`ResponseEntity`，和/或单值和多值反应式类型的主体。

<!-- tabs:end -->


### **Jackson JSON** 

<!-- tabs:start -->

#### ** English **

Spring offers support for the Jackson JSON library.
#### ** Chinese **

Spring提供了对JSON JSON库的支持。

<!-- tabs:end -->


### **JSON Views** 

<!-- tabs:start -->

#### ** English **

[WebFlux](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-jsonview)
#### ** Chinese **

[WebFlux](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-jsonview)

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Spring MVC provides built-in support for [Jackson’s Serialization Views](https://www.baeldung.com/jackson-json-view-annotation), which allow rendering only a subset of all fields in an `Object`. To use it with `@ResponseBody` or `ResponseEntity` controller methods, you can use Jackson’s `@JsonView` annotation to activate a serialization view class, as the following example shows:
#### ** Chinese **

Spring MVC提供了对[Jackson的序列化视图](https://www.baeldung.com/jackson-json-view-annotation)的内置支持，它允许只渲染`Object`中所有字段的一个子集。要与`@ResponseBody`或`ResponseEntity`控制器方法一起使用它，可以使用Jackson的`@JsonView`注释来激活序列化视图类，如下例所示。

<!-- tabs:end -->


```java
@RestController
public class UserController {

    @GetMapping("/user")
    @JsonView(User.WithoutPasswordView.class)
    public User getUser() {
        return new User("eric", "7!jd#h23");
    }
}

public class User {

    public interface WithoutPasswordView {};
    public interface WithPasswordView extends WithoutPasswordView {};

    private String username;
    private String password;

    public User() {
    }

    public User(String username, String password) {
        this.username = username;
        this.password = password;
    }

    @JsonView(WithoutPasswordView.class)
    public String getUsername() {
        return this.username;
    }

    @JsonView(WithPasswordView.class)
    public String getPassword() {
        return this.password;
    }
}
```

<!-- tabs:start -->

#### ** English **

`@JsonView` allows an array of view classes, but you can specify only one per controller method. If you need to activate multiple views, you can use a composite interface.
#### ** Chinese **

`@JsonView`允许一个视图类的数组，但每个控制器方法只能指定一个。如果你需要激活多个视图，你可以使用一个复合接口。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

For controllers that rely on view resolution, you can add the serialization view class to the model, as the following example shows:
#### ** Chinese **

对于依赖视图解析的控制器，可以将序列化视图类添加到模型中，如下例所示。

<!-- tabs:end -->


```java
@Controller
public class UserController extends AbstractController {

    @GetMapping("/user")
    public String getUser(Model model) {
        model.addAttribute("user", new User("eric", "7!jd#h23"));
        model.addAttribute(JsonView.class.getName(), User.WithoutPasswordView.class);
        return "userView";
    }
}
```

### **1.3.4. Model** 

<!-- tabs:start -->

#### ** English **

[WebFlux](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-modelattrib-methods)
#### ** Chinese **

[WebFlux](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-modelattrib-methods)

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can use the `@ModelAttribute` annotation:
#### ** Chinese **

你可以使用`@ModelAttribute`注释。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

- On a [method argument](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-modelattrib-method-args) in `@RequestMapping` methods to create or access an `Object` from the model and to bind it to the request through a `WebDataBinder`.

- As a method-level annotation in `@Controller` or `@ControllerAdvice` classes that help to initialize the model prior to any `@RequestMapping` method invocation.

- On a `@RequestMapping` method to mark its return value is a model attribute.

#### ** Chinese **

- 在`@RequestMapping`方法中的[方法参数](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-modelattrib-method-args)上，从模型中创建或访问一个`对象`，并通过`WebDataBinder`将其绑定到请求中。

- 作为`@Controller`或`@ControllerAdvice`类中的方法级注释，有助于在任何`@RequestMapping`方法调用之前初始化模型。

- 在`@RequestMapping`方法上标记它的返回值是一个模型属性。


<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

This section discusses `@ModelAttribute` methods — the second item in the preceding list. A controller can have any number of `@ModelAttribute` methods. All such methods are invoked before `@RequestMapping` methods in the same controller. A `@ModelAttribute` method can also be shared across controllers through `@ControllerAdvice`. See the section on [Controller Advice](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-controller-advice) for more details.
#### ** Chinese **

本节讨论了`@ModelAttribute`方法--前面列表中的第二项。一个控制器可以有任意数量的`@ModelAttribute`方法。所有这些方法都会在同一控制器中的`@RequestMapping`方法之前调用。一个`@ModelAttribute`方法也可以通过`@ControllerAdvice`跨控制器共享。更多详情，请参见[ControllerAdvice](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-controller-advice)章节。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

`@ModelAttribute` methods have flexible method signatures. They support many of the same arguments as `@RequestMapping` methods, except for `@ModelAttribute` itself or anything related to the request body.
#### ** Chinese **

`@ModelAttribute`方法具有灵活的方法签名。它们支持许多与`@RequestMapping`方法相同的参数，除了`@ModelAttribute`本身或任何与请求体相关的东西之外。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following example shows a `@ModelAttribute` method:
#### ** Chinese **

下面的例子显示了一个`@ModelAttribute`方法。

<!-- tabs:end -->


```java
@ModelAttribute
public void populateModel(@RequestParam String number, Model model) {
    model.addAttribute(accountRepository.findAccount(number));
    // add more ...
}
```

<!-- tabs:start -->

#### ** English **

The following example adds only one attribute:
#### ** Chinese **

下面的例子只增加了一个属性。

<!-- tabs:end -->


```java
@ModelAttribute
public Account addAccount(@RequestParam String number) {
    return accountRepository.findAccount(number);
}
```

<!-- tabs:start -->

#### ** English **

When a name is not explicitly specified, a default name is chosen based on the `Object` type, as explained in the javadoc for [`Conventions`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/core/Conventions.html). You can always assign an explicit name by using the overloaded `addAttribute` method or through the `name` attribute on `@ModelAttribute` (for a return value).
#### ** Chinese **

当没有显式指定名称时，会根据`Object`类型选择一个默认的名称，这在[`Conventions`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/core/Conventions.html)的javadoc中解释过。你可以通过使用重载的`addAttribute`方法或通过`@ModelAttribute`上的`name`属性（用于返回值）来指定一个显式名称。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can also use `@ModelAttribute` as a method-level annotation on `@RequestMapping` methods, in which case the return value of the `@RequestMapping` method is interpreted as a model attribute. This is typically not required, as it is the default behavior in HTML controllers, unless the return value is a `String` that would otherwise be interpreted as a view name. `@ModelAttribute` can also customize the model attribute name, as the following example shows:
#### ** Chinese **

您也可以在 `@ModelAttribute`方法上使用 `@RequestMapping`方法的方法级注释，在这种情况下，`@RequestMapping`方法的返回值被解释为模型属性。通常不需要这样做，因为这是HTML控制器中的默认行为，除非返回值是一个`String`，否则会被解释为视图名称。 `@ModelAttribute`也可以自定义模型属性名称，如下例所示。

<!-- tabs:end -->


```java
@GetMapping("/accounts/{id}")
@ModelAttribute("myAccount")
public Account handle() {
    // ...
    return account;
}
```

### **1.3.5.** **`DataBinder`** 

<!-- tabs:start -->

#### ** English **

[WebFlux](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-initbinder)
#### ** Chinese **

[WebFlux](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-initbinder)

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

`@Controller` or `@ControllerAdvice` classes can have `@InitBinder` methods that initialize instances of `WebDataBinder`, and those, in turn, can:
#### ** Chinese **

`@Controller`或`@ControllerAdvice`类可以有`@InitBinder`方法，这些方法可以初始化`WebDataBinder`的实例，反过来，这些方法也可以。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

- Bind request parameters (that is, form or query data) to a model object.

- Convert String-based request values (such as request parameters, path variables, headers, cookies, and others) to the target type of controller method arguments.

- Format model object values as `String` values when rendering HTML forms.

#### ** Chinese **

- 将请求参数（即表单或查询数据）绑定到模型对象。

- 将基于字符串的请求值（如请求参数、路径变量、头文件、cookies等）转换为控制器方法参数的目标类型。

- 在渲染HTML表单时，将模型对象的值格式化为`String`值。


<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

`@InitBinder` methods can register controller-specific `java.bean.PropertyEditor` or Spring `Converter` and `Formatter` components. In addition, you can use the [MVC config](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-config-conversion) to register `Converter` and `Formatter` types in a globally shared `FormattingConversionService`.
#### ** Chinese **

`@InitBinder`方法可以注册控制器特定的`java.bean.PropertyEditor`或Spring `Converter`和`Formatter`组件。此外，您可以使用[MVC config](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-config-conversion)在全局共享的`FormattingConversionService`和`Formatter`类型中注册`Converter`和`Formatter`。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

`@InitBinder` methods support many of the same arguments that `@RequestMapping` methods do, except for `@ModelAttribute` (command object) arguments. Typically, they are declared with a `WebDataBinder` argument (for registrations) and a `void` return value. The following listing shows an example:
#### ** Chinese **

`@InitBinder`方法支持许多与`@RequestMapping`方法相同的参数，但`@ModelAttribute`（命令对象）参数除外。通常情况下，它们都是用一个`WebDataBinder`参数（用于注册）和一个`void`返回值声明的。下面的列表显示了一个例子。

<!-- tabs:end -->


```java
@Controller
public class FormController {

    @InitBinder (1)
    public void initBinder(WebDataBinder binder) {
        SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
        dateFormat.setLenient(false);
        binder.registerCustomEditor(Date.class, new CustomDateEditor(dateFormat, false));
    }

    // ...
}

//(1) Defining an @InitBinder method.
```

<!-- tabs:start -->

#### ** English **

Alternatively, when you use a `Formatter`-based setup through a shared `FormattingConversionService`, you can re-use the same approach and register controller-specific `Formatter` implementations, as the following example shows:
#### ** Chinese **

另外，当您通过共享的`FormattingConversionService`使用基于`Formatter`的设置时，您可以重复使用相同的方法，并注册控制器特定的`Formatter`实现，如下例所示。

<!-- tabs:end -->


```java
@Controller
public class FormController {

    @InitBinder (1)
    protected void initBinder(WebDataBinder binder) {
        binder.addCustomFormatter(new DateFormatter("yyyy-MM-dd"));
    }

    // ...
}

//(1) Defining an @InitBinder method on a custom formatter.
```

### **1.3.6. Exceptions** 

<!-- tabs:start -->

#### ** English **

[WebFlux](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-controller-exceptions)
#### ** Chinese **

[WebFlux](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-controller-exceptions)

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

`@Controller` and [@ControllerAdvice](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-controller-advice) classes can have `@ExceptionHandler` methods to handle exceptions from controller methods, as the following example shows:
#### ** Chinese **

`@Controller`和[@ControllerAdvice](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-controller-advice)类可以有`@ExceptionHandler`方法来处理来自控制器方法的异常，如下例所示。

<!-- tabs:end -->


```java
@Controller
public class SimpleController {

    // ...

    @ExceptionHandler
    public ResponseEntity<String> handle(IOException ex) {
        // ...
    }
}
```

<!-- tabs:start -->

#### ** English **

The exception may match against a top-level exception being propagated (that is, a direct `IOException` being thrown) or against the immediate cause within a top-level wrapper exception (for example, an `IOException` wrapped inside an `IllegalStateException`).
#### ** Chinese **

异常可能与正在传播的顶层异常（即直接抛出的`IOException`，也可能与顶层包装器异常中的直接原因（例如，在`IllegalStateException`中包装的`IOException`）相匹配。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

For matching exception types, preferably declare the target exception as a method argument, as the preceding example shows. When multiple exception methods match, a root exception match is generally preferred to a cause exception match. More specifically, the `ExceptionDepthComparator` is used to sort exceptions based on their depth from the thrown exception type.
#### ** Chinese **

对于匹配的异常类型，最好将目标异常声明为方法参数，如前面的例子所示。当多个异常方法匹配时，一般情况下，根异常匹配比原因异常匹配更可取。更具体地说，`ExceptionDepthComparator`用于根据抛出的异常类型的深度来对异常进行排序。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Alternatively, the annotation declaration may narrow the exception types to match, as the following example shows:
#### ** Chinese **

或者，注解声明可以将异常类型缩小到匹配的范围，如下面的例子所示。

<!-- tabs:end -->


```java
@ExceptionHandler({FileSystemException.class, RemoteException.class})
public ResponseEntity<String> handle(IOException ex) {
    // ...
}
```

<!-- tabs:start -->

#### ** English **

You can even use a list of specific exception types with a very generic argument signature, as the following example shows:
#### ** Chinese **

你甚至可以使用一个特定异常类型的列表，并带有一个非常通用的参数签名，如下例所示。

<!-- tabs:end -->


```java
@ExceptionHandler({FileSystemException.class, RemoteException.class})
public ResponseEntity<String> handle(Exception ex) {
    // ...
}
```

<!-- tabs:start -->

#### ** English **

The distinction between root and cause exception matching can be surprising.
#### ** Chinese **

根源匹配和原因异常匹配的区别会让人感到惊讶。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

In the `IOException` variant shown earlier, the method is typically called with the actual `FileSystemException` or `RemoteException` instance as the argument, since both of them extend from `IOException`. However, if any such matching exception is propagated within a wrapper exception which is itself an `IOException`, the passed-in exception instance is that wrapper exception.
#### ** Chinese **

在前面显示的`IOException`变体中，该方法通常是用实际的`FileSystemException`或`RemoteException`实例作为参数来调用的，因为这两个实例都是从`IOException`扩展而来的。但是，如果任何这样的匹配异常在一个包装器异常中传播，而这个包装器异常本身就是一个`IOException`，那么传入的异常实例就是这个包装器异常。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The behavior is even simpler in the `handle(Exception)` variant. This is always invoked with the wrapper exception in a wrapping scenario, with the actually matching exception to be found through `ex.getCause()` in that case. The passed-in exception is the actual `FileSystemException` or `RemoteException` instance only when these are thrown as top-level exceptions.
#### ** Chinese **

在`handle(Exception)`变体中的行为更加简单。它总是在包装场景中与包装器异常一起被调用，在这种情况下，实际匹配的异常将通过`ex.getCause()`找到。传入的异常是实际的`FileSystemException`或`RemoteException`实例，只有当这些异常作为顶层异常被抛出时，才会被传入。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

We generally recommend that you be as specific as possible in the argument signature, reducing the potential for mismatches between root and cause exception types. Consider breaking a multi-matching method into individual `@ExceptionHandler` methods, each matching a single specific exception type through its signature.
#### ** Chinese **

我们通常建议你在参数签名中尽可能的具体化，这样可以减少根异常类型和原因异常类型不匹配的可能性。考虑将一个多匹配方法分解成单独的`@ExceptionHandler`方法，每个方法通过其签名匹配一个特定的异常类型。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

In a multi-`@ControllerAdvice` arrangement, we recommend declaring your primary root exception mappings on a `@ControllerAdvice` prioritized with a corresponding order. While a root exception match is preferred to a cause, this is defined among the methods of a given controller or `@ControllerAdvice` class. This means a cause match on a higher-priority `@ControllerAdvice` bean is preferred to any match (for example, root) on a lower-priority `@ControllerAdvice` bean.
#### ** Chinese **

在一个多`@ControllerAdvice`安排中，我们建议在`@ControllerAdvice`上声明你的主要根异常映射，并按照相应的顺序优先级来确定。虽然根异常匹配优于原因匹配，但这是在给定控制器或`@ControllerAdvice`类的方法中定义的。这意味着优先级较高的`@ControllerAdvice` Bean上的原因匹配比优先级较低的`@ControllerAdvice` Bean上的任何匹配（例如，根）优先。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Last but not least, an `@ExceptionHandler` method implementation can choose to back out of dealing with a given exception instance by rethrowing it in its original form. This is useful in scenarios where you are interested only in root-level matches or in matches within a specific context that cannot be statically determined. A rethrown exception is propagated through the remaining resolution chain, as though the given `@ExceptionHandler` method would not have matched in the first place.
#### ** Chinese **

最后但并非最不重要的是，`@ExceptionHandler`方法实现可以选择退出处理给定的异常实例，以其原始形式重新抛出。这在你只对根级匹配或无法静态确定的特定上下文中的匹配感兴趣的情况下非常有用。重抛的异常会通过剩余的解析链传播，就像给定的`@ExceptionHandler`方法一开始就不会匹配一样。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Support for `@ExceptionHandler` methods in Spring MVC is built on the `DispatcherServlet` level, [HandlerExceptionResolver](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-exceptionhandlers) mechanism.
#### ** Chinese **

Spring MVC中对`@ExceptionHandler`方法的支持是建立在`DispatcherServlet`层的[HandlerExceptionResolver](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-exceptionhandlers)机制上。

<!-- tabs:end -->


### **Method Arguments** 

<!-- tabs:start -->

#### ** English **

`@ExceptionHandler` methods support the following arguments:
#### ** Chinese **

`@ExceptionHandler`方法支持以下参数。

<!-- tabs:end -->


Method argument | Description 
-|-
Exception type | For access to the raised exception. 
HandlerMethod | For access to the controller method that raised the exception. 
WebRequest, NativeWebRequest | Generic access to request parameters and request and session attributes without direct use of the Servlet API. 
javax.servlet.ServletRequest, javax.servlet.ServletResponse | Choose any specific request or response type (for example, ServletRequest or HttpServletRequest or Spring’s MultipartRequest or MultipartHttpServletRequest). 
javax.servlet.http.HttpSession | Enforces the presence of a session. As a consequence, such an argument is never null.Note that session access is not thread-safe. Consider setting the RequestMappingHandlerAdapter instance’s synchronizeOnSession flag to true if multiple requests are allowed to access a session concurrently. 
java.security.Principal | Currently authenticated user — possibly a specific Principal implementation class if known. 
HttpMethod | The HTTP method of the request. 
java.util.Locale | The current request locale, determined by the most specific LocaleResolver available — in effect, the configured LocaleResolver or LocaleContextResolver. 
java.util.TimeZone, java.time.ZoneId | The time zone associated with the current request, as determined by a LocaleContextResolver. 
java.io.OutputStream, java.io.Writer | For access to the raw response body, as exposed by the Servlet API. 
java.util.Map, org.springframework.ui.Model, org.springframework.ui.ModelMap | For access to the model for an error response. Always empty. 
RedirectAttributes | Specify attributes to use in case of a redirect — (that is to be appended to the query string) and flash attributes to be stored temporarily until the request after the redirect. See Redirect Attributes and Flash Attributes. 
@SessionAttribute | For access to any session attribute, in contrast to model attributes stored in the session as a result of a class-level @SessionAttributes declaration. See @SessionAttribute for more details. 
@RequestAttribute | For access to request attributes. See @RequestAttribute for more details. 


### **Return Values** 

<!-- tabs:start -->

#### ** English **

`@ExceptionHandler` methods support the following return values:
#### ** Chinese **

`@ExceptionHandler`方法支持以下返回值。

<!-- tabs:end -->


Return value | Description 
-|-
@ResponseBody | The return value is converted through HttpMessageConverter instances and written to the response. See @ResponseBody. 
HttpEntity<B>, ResponseEntity<B> | The return value specifies that the full response (including the HTTP headers and the body) be converted through HttpMessageConverter instances and written to the response. See ResponseEntity. 
String | A view name to be resolved with ViewResolver implementations and used together with the implicit model — determined through command objects and @ModelAttribute methods. The handler method can also programmatically enrich the model by declaring a Model argument (described earlier). 
View | A View instance to use for rendering together with the implicit model — determined through command objects and @ModelAttribute methods. The handler method may also programmatically enrich the model by declaring a Model argument (descried earlier). 
java.util.Map, org.springframework.ui.Model | Attributes to be added to the implicit model with the view name implicitly determined through a RequestToViewNameTranslator. 
@ModelAttribute | An attribute to be added to the model with the view name implicitly determined through a RequestToViewNameTranslator.Note that @ModelAttribute is optional. See “Any other return value” at the end of this table. 
ModelAndView object | The view and model attributes to use and, optionally, a response status. 
void | A method with a void return type (or null return value) is considered to have fully handled the response if it also has a ServletResponse an OutputStream argument, or a @ResponseStatus annotation. The same is also true if the controller has made a positive ETag or lastModified timestamp check (see Controllers for details).If none of the above is true, a void return type can also indicate “no response body” for REST controllers or default view name selection for HTML controllers. 
Any other return value | If a return value is not matched to any of the above and is not a simple type (as determined by BeanUtils#isSimpleProperty), by default, it is treated as a model attribute to be added to the model. If it is a simple type, it remains unresolved. 


### **REST API exceptions** 

<!-- tabs:start -->

#### ** English **

[WebFlux](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-rest-exceptions)
#### ** Chinese **

[WebFlux](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-rest-exceptions)

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

A common requirement for REST services is to include error details in the body of the response. The Spring Framework does not automatically do this because the representation of error details in the response body is application-specific. However, a `@RestController` may use `@ExceptionHandler` methods with a `ResponseEntity` return value to set the status and the body of the response. Such methods can also be declared in `@ControllerAdvice` classes to apply them globally.
#### ** Chinese **

REST服务的一个常见需求是在响应主体中包含错误细节。由于响应体中错误细节的表示方式是特定于应用程序的，因此Spring框架不会自动做到这一点。但是，`@RestController`可以使用`@ExceptionHandler`方法，并带有`ResponseEntity`返回值来设置响应的状态和响应体。这样的方法也可以在`@ControllerAdvice`类中声明，以便全局应用。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Applications that implement global exception handling with error details in the response body should consider extending [`ResponseEntityExceptionHandler`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/web/servlet/mvc/method/annotation/ResponseEntityExceptionHandler.html), which provides handling for exceptions that Spring MVC raises and provides hooks to customize the response body. To make use of this, create a subclass of `ResponseEntityExceptionHandler`, annotate it with `@ControllerAdvice`, override the necessary methods, and declare it as a Spring bean.
#### ** Chinese **

在响应体中实现全局异常处理的应用程序应该考虑扩展 [`ResponseEntityExceptionHandler`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/web/servlet/mvc/method/annotation/ResponseEntityExceptionHandler.html)，它为Spring MVC引发的异常提供了处理方法，并提供了自定义响应体的钩子。要利用这一点，请创建一个`ResponseEntityExceptionHandler的子类`，用`@ControllerAdvice`注释它，覆盖必要的方法，并声明为Spring Bean。

<!-- tabs:end -->


### **1.3.7. Controller Advice** 

<!-- tabs:start -->

#### ** English **

[WebFlux](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-controller-advice)
#### ** Chinese **

[WebFlux](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-ann-controller-advice)

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Typically `@ExceptionHandler`, `@InitBinder`, and `@ModelAttribute` methods apply within the `@Controller` class (or class hierarchy) in which they are declared. If you want such methods to apply more globally (across controllers), you can declare them in a class annotated with `@ControllerAdvice` or `@RestControllerAdvice`.
#### ** Chinese **

通常情况下，`@ExceptionHandler`、`@InitBinder`和`@ModelAttribute`方法会在其中声明的`@Controller`类（或类层次结构）中应用。如果你想让这些方法在全局范围内（跨控制器）应用，你可以在类中声明这些方法，并以 `@ControllerAdvice`或`@RestControllerAdvice`注释。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

`@ControllerAdvice` is annotated with `@Component`, which means such classes can be registered as Spring beans through [component scanning](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-java-instantiating-container-scan). `@RestControllerAdvice` is a composed annotation that is annotated with both `@ControllerAdvice` and `@ResponseBody`, which essentially means `@ExceptionHandler` methods are rendered to the response body through message conversion (versus view resolution or template rendering).
#### ** Chinese **

`@ControllerAdvice`被注释为`@Component`，这意味着这样的类可以通过[组件扫描](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-java-instantiating-container-scan)注册为Spring Bean。 `@RestControllerAdvice`是一个组成的注释，它同时被注释为`@ControllerAdvice`和`@ResponseBody`，这本质上意味着`@ExceptionHandler`方法通过消息转换（相对于视图解析或模板渲染）渲染到响应体。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

On startup, the infrastructure classes for `@RequestMapping` and `@ExceptionHandler` methods detect Spring beans annotated with `@ControllerAdvice` and then apply their methods at runtime. Global `@ExceptionHandler` methods (from a `@ControllerAdvice`) are applied *after* local ones (from the `@Controller`). By contrast, global `@ModelAttribute` and `@InitBinder` methods are applied *before* local ones.
#### ** Chinese **

在启动时，`@RequestMapping`和`@ExceptionHandler`方法的基础架构类会检测到用`@ControllerAdvice`注释的Spring Bean，然后在运行时应用它们的方法。全局的 `@ExceptionHandler`方法（来自 `@ControllerAdvice`）是在*后应用本地方法（来自 `@Controller`）。相比之下，全局的 `@ModelAttribute` 和 `@InitBinder`方法是在*前应用于本地方法。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

By default, `@ControllerAdvice` methods apply to every request (that is, all controllers), but you can narrow that down to a subset of controllers by using attributes on the annotation, as the following example shows:
#### ** Chinese **

默认情况下，`@ControllerAdvice`方法适用于每个请求（也就是所有控制器），但你可以通过使用注释上的属性将其缩小到控制器的子集，如下例所示。

<!-- tabs:end -->


```java
// Target all Controllers annotated with @RestController
@ControllerAdvice(annotations = RestController.class)
public class ExampleAdvice1 {}

// Target all Controllers within specific packages
@ControllerAdvice("org.example.controllers")
public class ExampleAdvice2 {}

// Target all Controllers assignable to specific classes
@ControllerAdvice(assignableTypes = {ControllerInterface.class, AbstractController.class})
public class ExampleAdvice3 {}
```

<!-- tabs:start -->

#### ** English **

The selectors in the preceding example are evaluated at runtime and may negatively impact performance if used extensively. See the [`@ControllerAdvice`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/web/bind/annotation/ControllerAdvice.html) javadoc for more details.
#### ** Chinese **

前面例子中的选择器在运行时进行评估，如果大量使用，可能会对性能产生负面影响。有关详细信息，请参阅 [`@ControllerAdvice`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/web/bind/annotation/ControllerAdvice.html) javadoc。

<!-- tabs:end -->



[下一章](Spring-Framework-5.2.6.RELEASE/Web%20on%20Servlet%20Stack/1.4.%20Functional%20Endpoints.md)


[回目录](Spring-Framework-5.2.6.RELEASE/summary.md)

[回首页](/README)
