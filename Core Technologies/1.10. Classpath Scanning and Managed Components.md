# 1.10. Classpath Scanning and Managed Components

<!-- tabs:start -->

#### ** English **

Most examples in this chapter use XML to specify the configuration metadata that produces each `BeanDefinition` within the Spring container. The previous section ([Annotation-based Container Configuration](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-annotation-config)) demonstrates how to provide a lot of the configuration metadata through source-level annotations. Even in those examples, however, the “base” bean definitions are explicitly defined in the XML file, while the annotations drive only the dependency injection. This section describes an option for implicitly detecting the candidate components by scanning the classpath. Candidate components are classes that match against a filter criteria and have a corresponding bean definition registered with the container. This removes the need to use XML to perform bean registration. Instead, you can use annotations (for example, `@Component`), AspectJ type expressions, or your own custom filter criteria to select which classes have bean definitions registered with the container.
#### ** Chinese **

本章中的大多数示例都使用XML来指定在Spring容器中产生每个`BeanDefinition`的配置元数据。上一节([[基于注解的容器配置](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-annotation-config))演示了如何通过源级注解提供大量的配置元数据。然而，即使在这些例子中，"基础 "Bean定义也是在XML文件中显式定义的，而注解只驱动依赖注入。本节将介绍一种通过扫描classpath隐式检测候选组件的选项。候选组件是与筛选条件相匹配的类，并且在容器中注册了相应的bean定义。这样就不需要使用XML来执行Bean注册了。相反，您可以使用注解（例如，`@Component`）、AspectJ类型表达式或您自己的自定义过滤条件来选择哪些类有在容器中注册的Bean定义。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Starting with Spring 3.0, many features provided by the Spring JavaConfig project are part of the core Spring Framework. This allows you to define beans using Java rather than using the traditional XML files. Take a look at the `@Configuration`, `@Bean`, `@Import`, and `@DependsOn` annotations for examples of how to use these new features.
#### ** Chinese **

从Spring 3.0开始，Spring JavaConfig项目提供的许多功能都是核心Spring框架的一部分。这使得你可以使用Java来定义Bean，而不是使用传统的XML文件。请查看`@Configuration`、`@Bean`、`@Import`和`@DependsOn`注解，了解如何使用这些新特性的例子。
<!-- tabs:end -->


### **1.10.1.** **`@Component`** ** and Further Stereotype Annotations** 

<!-- tabs:start -->

#### ** English **

The `@Repository` annotation is a marker for any class that fulfills the role or stereotype of a repository (also known as Data Access Object or DAO). Among the uses of this marker is the automatic translation of exceptions, as described in [Exception Translation](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/data-access.html#orm-exception-translation).
#### ** Chinese **

`@Repository` 注解是一个标记，用于任何满足存储库（也称为数据访问对象或DAO）角色或定型的类。这个标记的用途之一是自动翻译异常，如[Exception Translation](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/data-access.html#orm-exception-translation)中描述的那样。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Spring provides further stereotype annotations: `@Component`, `@Service`, and `@Controller`. `@Component` is a generic stereotype for any Spring-managed component. `@Repository`, `@Service`, and `@Controller` are specializations of `@Component` for more specific use cases (in the persistence, service, and presentation layers, respectively). Therefore, you can annotate your component classes with `@Component`, but, by annotating them with `@Repository`, `@Service`, or `@Controller` instead, your classes are more properly suited for processing by tools or associating with aspects. For example, these stereotype annotations make ideal targets for pointcuts. `@Repository`, `@Service`, and `@Controller` can also carry additional semantics in future releases of the Spring Framework. Thus, if you are choosing between using `@Component` or `@Service` for your service layer, `@Service` is clearly the better choice. Similarly, as stated earlier, `@Repository` is already supported as a marker for automatic exception translation in your persistence layer.
#### ** Chinese **

Spring 提供了进一步的立体化注解。 `@Component`、`@Service`和`@Controller`。 `@Component`是任何Spring管理的组件的通用定型。 `@Repository`、`@Service`和`@Controller`是`@Component`的特殊化，用于更多特定的用例（分别在持久化层、服务层和展现层）。因此，你可以用 `@Component`来注解你的组件类，但是，通过用 `@Repository`、`@Service`或`@Controller`来注解它们，你的类更适合通过工具处理或与方面关联。例如，这些定型注解是点捷径的理想目标。 `@Repository`、`@Service`和`@Controller`也可以在Spring框架的未来版本中携带额外的语义。因此，如果您要在服务层中选择使用 `@Component`还是 `@Service`，`@Service`显然是更好的选择。同样的，正如前面所说，`@Repository`已经被支持为持久化层中的自动异常转换标记。
<!-- tabs:end -->


### **1.10.2. Using Meta-annotations and Composed Annotations** 

<!-- tabs:start -->

#### ** English **

Many of the annotations provided by Spring can be used as meta-annotations in your own code. A meta-annotation is an annotation that can be applied to another annotation. For example, the `@Service` annotation mentioned [earlier](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-stereotype-annotations) is meta-annotated with `@Component`, as the following example shows:
#### ** Chinese **

Spring 提供的许多注解都可以在自己的代码中作为元注解使用。元注解是一个可以应用到另一个注解的注解。例如，前面提到的 `@Service` 注解[https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-stereotype-annotations](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-stereotype-annotations)就是用`@Component`来进行元注解，如下图所示。
<!-- tabs:end -->


```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Component (1)
public @interface Service {

    // ...
}

//(1) The Component causes @Service to be treated in the same way as @Component.
```

<!-- tabs:start -->

#### ** English **

You can also combine meta-annotations to create “composed annotations”. For example, the `@RestController` annotation from Spring MVC is composed of `@Controller` and `@ResponseBody`.
#### ** Chinese **

你也可以将元注解组合起来，创建 "组成注解"。例如，Spring MVC中的`@RestController`注解由`@Controller`和`@ResponseBody`组成。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

In addition, composed annotations can optionally redeclare attributes from meta-annotations to allow customization. This can be particularly useful when you want to only expose a subset of the meta-annotation’s attributes. For example, Spring’s `@SessionScope` annotation hardcodes the scope name to `session` but still allows customization of the `proxyMode`. The following listing shows the definition of the `SessionScope` annotation:
#### ** Chinese **

此外，组成的注解可以选择从元注解中重新声明属性，以允许自定义。当你想只公开元注解的一个子集属性时，这可能特别有用。例如，Spring的`@SessionScope` 注解将作用域名称硬编码为`session`，但仍然允许自定义`proxyMode`。下面的列表显示了 `SessionScope` 注解的定义。
<!-- tabs:end -->


```java
@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Scope(WebApplicationContext.SCOPE_SESSION)
public @interface SessionScope {

    /**
     * Alias for {@link Scope#proxyMode}.
     * <p>Defaults to {@link ScopedProxyMode#TARGET_CLASS}.
     */
    @AliasFor(annotation = Scope.class)
    ScopedProxyMode proxyMode() default ScopedProxyMode.TARGET_CLASS;

}
```

<!-- tabs:start -->

#### ** English **

You can then use `@SessionScope` without declaring the `proxyMode` as follows:
#### ** Chinese **

然后你可以使用`@SessionScope`而不声明`proxyMode`，如下所示。
<!-- tabs:end -->


```java
@Service
@SessionScope
public class SessionScopedService {
    // ...
}
```

<!-- tabs:start -->

#### ** English **

You can also override the value for the `proxyMode`, as the following example shows:
#### ** Chinese **

你也可以覆盖`proxyMode`的值，如下例所示。
<!-- tabs:end -->


```java
@Service
@SessionScope(proxyMode = ScopedProxyMode.INTERFACES)
public class SessionScopedUserService implements UserService {
    // ...
}
```

<!-- tabs:start -->

#### ** English **

For further details, see the [Spring Annotation Programming Model](https://github.com/spring-projects/spring-framework/wiki/Spring-Annotation-Programming-Model) wiki page.
#### ** Chinese **

更多详情，请参阅[Spring Annotation Programming Model](https://github.com/spring-projects/spring-framework/wiki/Spring-Annotation-Programming-Model) wiki页面。
<!-- tabs:end -->


### **1.10.3. Automatically Detecting Classes and Registering Bean Definitions** 

<!-- tabs:start -->

#### ** English **

Spring can automatically detect stereotyped classes and register corresponding `BeanDefinition` instances with the `ApplicationContext`. For example, the following two classes are eligible for such autodetection:
#### ** Chinese **

Spring可以自动检测出被定型的类，并在`ApplicationContext`中注册相应的`BeanDefinition`实例。例如，以下两个类有资格进行这种自动检测。
<!-- tabs:end -->


```java
@Service
public class SimpleMovieLister {

    private MovieFinder movieFinder;

    public SimpleMovieLister(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }
}
```

```java
@Repository
public class JpaMovieFinder implements MovieFinder {
    // implementation elided for clarity
}
```

<!-- tabs:start -->

#### ** English **

To autodetect these classes and register the corresponding beans, you need to add `@ComponentScan` to your `@Configuration` class, where the `basePackages` attribute is a common parent package for the two classes. (Alternatively, you can specify a comma- or semicolon- or space-separated list that includes the parent package of each class.)
#### ** Chinese **

要自动检测这些类并注册相应的Bean，你需要在你的`@Configuration`类中添加`@ComponentScan`，其中`basePackages`属性是两个类的通用父包。(或者，你可以指定一个由逗号或分号或空格分隔的列表，其中包括每个类的父类包。)
<!-- tabs:end -->


```java
@Configuration
@ComponentScan(basePackages = "org.example")
public class AppConfig  {
    // ...
}
```

<!-- tabs:start -->

#### ** English **

For brevity, the preceding example could have used the `value` attribute of the annotation (that is, `@ComponentScan("org.example")`).
#### ** Chinese **

为了简洁起见，前面的例子可以使用注解的`value`属性（也就是`@ComponentScan("org.example")`）。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following alternative uses XML:
#### ** Chinese **

以下是使用XML的替代方案。
<!-- tabs:end -->


```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd">

    <context:component-scan base-package="org.example"/>

</beans>
```

<!-- tabs:start -->

#### ** English **

The use of `<context:component-scan>` implicitly enables the functionality of `<context:annotation-config>`. There is usually no need to include the `<context:annotation-config>` element when using `<context:component-scan>`.
#### ** Chinese **

使用`<context:component-scan>`隐含地实现了`<context:annotation-config>`的功能。在使用 `<context:component-scan>`时，通常不需要包含 `<context:annotation-config>`元素。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The scanning of classpath packages requires the presence of corresponding directory entries in the classpath. When you build JARs with Ant, make sure that you do not activate the files-only switch of the JAR task. Also, classpath directories may not be exposed based on security policies in some environments — for example, standalone apps on JDK 1.7.0_45 and higher (which requires 'Trusted-Library' setup in your manifests — see [https://stackoverflow.com/questions/19394570/java-jre-7u45-breaks-classloader-getresources](https://stackoverflow.com/questions/19394570/java-jre-7u45-breaks-classloader-getresources)).
#### ** Chinese **

扫描classpath包需要在classpath中存在相应的目录项。当你用Ant构建JAR时，请确保你没有激活JAR任务中的仅有文件开关。另外，在某些环境中，基于安全策略，classpath目录可能不会被暴露--例如，JDK 1.7.0_45及更高版本的独立应用程序（这需要在你的清单中设置 "Trusted-Library"--参见[https://stackoverflow.com/questions/19394570/java-jre-7u45-breaks-classloader-getresources](https://stackoverflow.com/questions/19394570/java-jre-7u45-breaks-classloader-getresources)）。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

On JDK 9’s module path (Jigsaw), Spring’s classpath scanning generally works as expected. However, make sure that your component classes are exported in your `module-info` descriptors. If you expect Spring to invoke non-public members of your classes, make sure that they are 'opened' (that is, that they use an `opens` declaration instead of an `exports` declaration in your `module-info` descriptor).
#### ** Chinese **

在JDK 9的模块路径(Jigsaw)上，Spring的classpath扫描一般都能正常工作。但是，请确保你的组件类在`module-info`描述符中导出。如果你希望Spring调用你的类的非公共成员，请确保它们被 "打开"（也就是说，它们使用了`opens`声明，而不是在你的`module-info`描述符中的`exports`声明）。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Furthermore, the `AutowiredAnnotationBeanPostProcessor` and `CommonAnnotationBeanPostProcessor` are both implicitly included when you use the component-scan element. That means that the two components are autodetected and wired together — all without any bean configuration metadata provided in XML.
#### ** Chinese **

此外，当你使用 component-scan 元素时，`AutowiredAnnotationBeanPostProcessor`和`CommonAnnotationBeanPostProcessor`都是隐式包含的。这意味着，这两个组件都是自动检测并连接在一起的 - 所有这些都不需要在 XML 中提供任何 bean 配置元数据。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can disable the registration of `AutowiredAnnotationBeanPostProcessor` and `CommonAnnotationBeanPostProcessor` by including the `annotation-config` attribute with a value of `false`.
#### ** Chinese **

您可以禁用`AutowiredAnnotationBeanPostProcessor`和`CommonAnnotationBeanPostProcessor`的注册，方法是在`annotation-config`属性中加入值为`false`的属性。
<!-- tabs:end -->


### **1.10.4. Using Filters to Customize Scanning** 

<!-- tabs:start -->

#### ** English **

By default, classes annotated with `@Component`, `@Repository`, `@Service`, `@Controller`, `@Configuration`, or a custom annotation that itself is annotated with `@Component` are the only detected candidate components. However, you can modify and extend this behavior by applying custom filters. Add them as `includeFilters` or `excludeFilters` attributes of the `@ComponentScan` annotation (or as `<context:include-filter />` or `<context:exclude-filter />` child elements of the `<context:component-scan>` element in XML configuration). Each filter element requires the `type` and `expression` attributes. The following table describes the filtering options:
#### ** Chinese **

默认情况下，注解了`@Component`、`@Repository`、`@Service`、`@Controller`、`@Configuration`的类，或者注解了`@Component`的自定义注解，或者注解了`@Component`的自定义注解，是唯一被检测到的候选组件。但是，你可以通过应用自定义过滤器来修改和扩展这个行为。将它们作为 `@ComponentScan`注解的 `includeFilters` 或 `excludeFilters` 属性添加（或作为 `<context:include-filter />` 或 `<context:exclude-filter />` `<context:component-scan>` 元素的子元素在 XML 配置中）。每个过滤器元素都需要`type`和`expression`属性。下表描述了过滤选项。
<!-- tabs:end -->


Filter Type | Example Expression | Description 
-|-|-
annotation (default) | org.example.SomeAnnotation | An annotation to be present or meta-present at the type level in target components. 
assignable | org.example.SomeClass | A class (or interface) that the target components are assignable to (extend or implement). 
aspectj | org.example..*Service+ | An AspectJ type expression to be matched by the target components. 
regex | org\.example\.Default.* | A regex expression to be matched by the target components' class names. 
custom | org.example.MyTypeFilter | A custom implementation of the org.springframework.core.type.TypeFilter interface. 


<!-- tabs:start -->

#### ** English **

The following example shows the configuration ignoring all `@Repository` annotations and using “stub” repositories instead:
#### ** Chinese **

下面的示例显示了忽略所有`@Repository`注解并使用 "stub "存储库的配置。
<!-- tabs:end -->


```java
@Configuration
@ComponentScan(basePackages = "org.example",
        includeFilters = @Filter(type = FilterType.REGEX, pattern = ".*Stub.*Repository"),
        excludeFilters = @Filter(Repository.class))
public class AppConfig {
    ...
}
```

<!-- tabs:start -->

#### ** English **

The following listing shows the equivalent XML:
#### ** Chinese **

下面的列表显示的是等效的XML。
<!-- tabs:end -->


```xml
<beans>
    <context:component-scan base-package="org.example">
        <context:include-filter type="regex"
                expression=".*Stub.*Repository"/>
        <context:exclude-filter type="annotation"
                expression="org.springframework.stereotype.Repository"/>
    </context:component-scan>
</beans>
```

<!-- tabs:start -->

#### ** English **

You can also disable the default filters by setting `useDefaultFilters=false` on the annotation or by providing `use-default-filters="false"` as an attribute of the `<component-scan/>` element. This effectively disables automatic detection of classes annotated or meta-annotated with `@Component`, `@Repository`, `@Service`, `@Controller`, `@RestController`, or `@Configuration`.
#### ** Chinese **

您也可以通过在注解上设置 `useDefaultFilters=false`，或者通过提供 `use-default-filters="false"` 作为 `<component-scan/>` 元素的属性，来禁用默认的过滤器。这将有效地禁止自动检测用 `@Component`、`@Repository`、`@Service`、`@Controller`、`@RestController`或`@Configuration`注解或元注解的类。
<!-- tabs:end -->


### **1.10.5. Defining Bean Metadata within Components** 

<!-- tabs:start -->

#### ** English **

Spring components can also contribute bean definition metadata to the container. You can do this with the same `@Bean` annotation used to define bean metadata within `@Configuration` annotated classes. The following example shows how to do so:
#### ** Chinese **

Spring 组件也可以将 bean 定义元数据贡献给容器。您可以使用同样的 `@Bean` 注解来定义 Bean 元数据，该注解用于在 `@Configuration` 注解的类中定义 Bean 元数据。下面的示例显示了如何做到这一点。
<!-- tabs:end -->


```java
@Component
public class FactoryMethodComponent {

    @Bean
    @Qualifier("public")
    public TestBean publicInstance() {
        return new TestBean("publicInstance");
    }

    public void doWork() {
        // Component method implementation omitted
    }
}
```

<!-- tabs:start -->

#### ** English **

The preceding class is a Spring component that has application-specific code in its `doWork()` method. However, it also contributes a bean definition that has a factory method referring to the method `publicInstance()`. The `@Bean` annotation identifies the factory method and other bean definition properties, such as a qualifier value through the `@Qualifier` annotation. Other method-level annotations that can be specified are `@Scope`, `@Lazy`, and custom qualifier annotations.
#### ** Chinese **

前面的类是一个Spring组件，它在其`doWork()`方法中包含了特定于应用程序的代码。但是，它也贡献了一个bean定义，其中有一个工厂方法引用了`publicInstance()`方法。`@Bean` 注解标识了工厂方法和其他 Bean 定义属性，例如通过 `@Qualifier` 注解的限定符值。其他可以指定的方法级注解是 `@Scope`、`@Lazy`和自定义的修饰符注解。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

In addition to its role for component initialization, you can also place the `@Lazy` annotation on injection points marked with `@Autowired` or `@Inject`. In this context, it leads to the injection of a lazy-resolution proxy.
#### ** Chinese **

除了对组件初始化的作用外，还可以将`@Lazy`注解放在标注有`@Autowired`或`@Inject`的注入点上。在这种情况下，它会导致注入一个懒惰分辨率的代理。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Autowired fields and methods are supported, as previously discussed, with additional support for autowiring of `@Bean` methods. The following example shows how to do so:
#### ** Chinese **

支持自动布线的字段和方法，如前文所述，还支持`@Bean`方法的自动布线。下面的例子显示了如何做到这一点。
<!-- tabs:end -->


```java
@Component
public class FactoryMethodComponent {

    private static int i;

    @Bean
    @Qualifier("public")
    public TestBean publicInstance() {
        return new TestBean("publicInstance");
    }

    // use of a custom qualifier and autowiring of method parameters
    @Bean
    protected TestBean protectedInstance(
            @Qualifier("public") TestBean spouse,
            @Value("#{privateInstance.age}") String country) {
        TestBean tb = new TestBean("protectedInstance", 1);
        tb.setSpouse(spouse);
        tb.setCountry(country);
        return tb;
    }

    @Bean
    private TestBean privateInstance() {
        return new TestBean("privateInstance", i++);
    }

    @Bean
    @RequestScope
    public TestBean requestScopedInstance() {
        return new TestBean("requestScopedInstance", 3);
    }
}
```

<!-- tabs:start -->

#### ** English **

The example autowires the `String` method parameter `country` to the value of the `age` property on another bean named `privateInstance`. A Spring Expression Language element defines the value of the property through the notation `#{ <expression> }`. For `@Value` annotations, an expression resolver is preconfigured to look for bean names when resolving expression text.
#### ** Chinese **

该示例将`String`方法参数`country`自动映射到另一个名为`privateInstance`的Bean上的`age`属性的值。Spring 表达式语言元素通过符号 `#{ <expression> }`定义了属性的值。对于 `@Value` 注解，在解析表达式文本时，会预先配置一个表达式解析器来查找Bean名。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

As of Spring Framework 4.3, you may also declare a factory method parameter of type `InjectionPoint` (or its more specific subclass: `DependencyDescriptor`) to access the requesting injection point that triggers the creation of the current bean. Note that this applies only to the actual creation of bean instances, not to the injection of existing instances. As a consequence, this feature makes most sense for beans of prototype scope. For other scopes, the factory method only ever sees the injection point that triggered the creation of a new bean instance in the given scope (for example, the dependency that triggered the creation of a lazy singleton bean). You can use the provided injection point metadata with semantic care in such scenarios. The following example shows how to use `InjectionPoint`:
#### ** Chinese **

从Spring Framework 4.3开始，您还可以声明一个类型为`InjectionPoint`的工厂方法参数（或其更具体的子类：`DependencyDescriptor`），以访问触发当前Bean创建的请求注入点。注意，这只适用于实际创建Bean实例，而不是注入现有实例。因此，这个特性对于原型作用域的Bean来说是最有意义的。对于其他作用域，工厂方法只看到触发了在给定作用域中创建新的bean实例的注入点（例如，触发了创建懒人单子bean的依赖关系）。在这种情况下，您可以使用所提供的注入点元数据，并注意语义。下面的例子显示了如何使用`InjectionPoint`。
<!-- tabs:end -->


```java
@Component
public class FactoryMethodComponent {

    @Bean @Scope("prototype")
    public TestBean prototypeInstance(InjectionPoint injectionPoint) {
        return new TestBean("prototypeInstance for " + injectionPoint.getMember());
    }
}
```

<!-- tabs:start -->

#### ** English **

The `@Bean` methods in a regular Spring component are processed differently than their counterparts inside a Spring `@Configuration` class. The difference is that `@Component` classes are not enhanced with CGLIB to intercept the invocation of methods and fields. CGLIB proxying is the means by which invoking methods or fields within `@Bean` methods in `@Configuration` classes creates bean metadata references to collaborating objects. Such methods are not invoked with normal Java semantics but rather go through the container in order to provide the usual lifecycle management and proxying of Spring beans, even when referring to other beans through programmatic calls to `@Bean` methods. In contrast, invoking a method or field in a `@Bean` method within a plain `@Component` class has standard Java semantics, with no special CGLIB processing or other constraints applying.
#### ** Chinese **

普通 Spring 组件中的 `@Bean`方法的处理方式与 Spring `@Configuration`类中的对应方法不同。不同的是，`@Component`类没有用CGLIB增强，以拦截方法和字段的调用。CGLIB proxying是指在`@Configuration`类中的`@Bean`方法中调用方法或字段，通过这种方法，可以创建指向协作对象的bean元数据引用。这些方法不是用正常的Java语义来调用，而是通过容器来提供Spring Bean的通常的生命周期管理和代理，即使是通过程序化调用`@Bean`方法来引用其他Bean时也是如此。相比之下，在普通的`@Bean`类中的`@Component`方法中调用一个方法或字段具有标准的Java语义，没有特殊的CGLIB处理或其他约束。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You may declare `@Bean` methods as `static`, allowing for them to be called without creating their containing configuration class as an instance. This makes particular sense when defining post-processor beans (for example, of type `BeanFactoryPostProcessor` or `BeanPostProcessor`), since such beans get initialized early in the container lifecycle and should avoid triggering other parts of the configuration at that point.
#### ** Chinese **

你可以将`@Bean`方法声明为`static`，这样就可以在不创建包含配置类的实例的情况下调用这些方法。这在定义后处理器Bean（例如，类型为`BeanFactoryPostProcessor`或`BeanPostProcessor`的BeanFactoryPostProcessor</x>）时特别有意义，因为这样的Bean在容器生命周期的早期就会被初始化，并且应该避免在这时触发配置的其他部分。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Calls to static `@Bean` methods never get intercepted by the container, not even within `@Configuration` classes (as described earlier in this section), due to technical limitations: CGLIB subclassing can override only non-static methods. As a consequence, a direct call to another `@Bean` method has standard Java semantics, resulting in an independent instance being returned straight from the factory method itself.
#### ** Chinese **

由于技术上的限制，对静态`@Bean`方法的调用永远不会被容器拦截，甚至在`@Configuration`类中也不会被拦截（如本节前面所述）。CGLIB子类只能覆盖非静态方法。因此，直接调用另一个`@Bean`方法具有标准的Java语义，结果是直接从工厂方法本身返回一个独立的实例。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The Java language visibility of `@Bean` methods does not have an immediate impact on the resulting bean definition in Spring’s container. You can freely declare your factory methods as you see fit in non-`@Configuration` classes and also for static methods anywhere. However, regular `@Bean` methods in `@Configuration` classes need to be overridable — that is, they must not be declared as `private` or `final`.
#### ** Chinese **

Java语言中`@Bean`方法的可见性并不会对Spring容器中的Bean定义产生直接影响。你可以在非`@Configuration`类中自由声明你的工厂方法，也可以在任何地方声明静态方法。但是，`@Configuration`类中的常规`@Bean`方法必须是可覆盖的，也就是说，它们不能被声明为`private`或`final`。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

`@Bean` methods are also discovered on base classes of a given component or configuration class, as well as on Java 8 default methods declared in interfaces implemented by the component or configuration class. This allows for a lot of flexibility in composing complex configuration arrangements, with even multiple inheritance being possible through Java 8 default methods as of Spring 4.2.
#### ** Chinese **

`@Bean`方法也可以在给定组件或配置类的基类上发现，也可以在组件或配置类实现的接口中声明的Java 8默认方法上发现。这使得组成复杂的配置安排有了很大的灵活性，从Spring 4.2开始，甚至可以通过Java 8的默认方法实现多重继承。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Finally, a single class may hold multiple `@Bean` methods for the same bean, as an arrangement of multiple factory methods to use depending on available dependencies at runtime. This is the same algorithm as for choosing the “greediest” constructor or factory method in other configuration scenarios: The variant with the largest number of satisfiable dependencies is picked at construction time, analogous to how the container selects between multiple `@Autowired` constructors.
#### ** Chinese **

最后，一个类可以为同一个Bean持有多个`@Bean`方法，作为在运行时根据可用的依赖关系安排多个工厂方法来使用。这和其他配置场景中选择 "最贪婪 "的构造函数或工厂方法的算法是一样的。在构造时选择可满足的依赖数量最多的变体，类似于容器如何在多个`@Autowired`构造函数之间选择。
<!-- tabs:end -->


### **1.10.6. Naming Autodetected Components** 

<!-- tabs:start -->

#### ** English **

When a component is autodetected as part of the scanning process, its bean name is generated by the `BeanNameGenerator` strategy known to that scanner. By default, any Spring stereotype annotation (`@Component`, `@Repository`, `@Service`, and `@Controller`) that contains a name `value` thereby provides that name to the corresponding bean definition.
#### ** Chinese **

当一个组件作为扫描过程的一部分被自动检测时，它的BeanNameGenerator</x>策略将由该扫描器已知的`BeanNameGenerator`策略生成。默认情况下，任何包含名称`value`的Spring立体类型注解（`@Component`、`@Repository`、`@Service`和`@Controller`），从而将该名称提供给相应的Bean定义。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

If such an annotation contains no name `value` or for any other detected component (such as those discovered by custom filters), the default bean name generator returns the uncapitalized non-qualified class name. For example, if the following component classes were detected, the names would be `myMovieLister` and `movieFinderImpl`:
#### ** Chinese **

如果这样的注解不包含名称`value`，或者对于任何其他检测到的组件（例如通过自定义过滤器发现的组件），默认的Bean名称生成器会返回未大写的非限定类名称。例如，如果检测到以下组件类，其名称将是 `myMovieLister`和`movieFinderImpl`。
<!-- tabs:end -->


```java
@Service("myMovieLister")
public class SimpleMovieLister {
    // ...
}
```

```java
@Repository
public class MovieFinderImpl implements MovieFinder {
    // ...
}
```

<!-- tabs:start -->

#### ** English **

If you do not want to rely on the default bean-naming strategy, you can provide a custom bean-naming strategy. First, implement the [`BeanNameGenerator`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/beans/factory/support/BeanNameGenerator.html) interface, and be sure to include a default no-arg constructor. Then, provide the fully qualified class name when configuring the scanner, as the following example annotation and bean definition show.
#### ** Chinese **

如果你不想依赖默认的bean命名策略，你可以提供一个自定义的bean命名策略。首先，实现[`BeanNameGenerator`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/beans/factory/support/BeanNameGenerator.html)接口，并确保包含一个默认的无arg构造函数。然后，在配置扫描器时提供完全限定的类名，如下面的注解和Bean定义示例所示。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

If you run into naming conflicts due to multiple autodetected components having the same non-qualified class name (i.e., classes with identical names but residing in different packages), you may need to configure a `BeanNameGenerator` that defaults to the fully qualified class name for the generated bean name. As of Spring Framework 5.2.3, the `FullyQualifiedAnnotationBeanNameGenerator` located in package `org.springframework.context.annotation` can be used for such purposes.
#### ** Chinese **

如果由于多个自动检测的组件具有相同的非限定类名（即具有相同名称但驻留在不同包中的类）而导致命名冲突，您可能需要配置一个`BeanNameGenerator`，该组件默认为生成的Bean名的完全限定类名。从Spring Framework 5.2.3开始，位于包 `org.springframework.context.annotation`中的`FullyQualifiedAnnotationBeanNameGenerator`可以用于此类目的。
<!-- tabs:end -->


```java
@Configuration
@ComponentScan(basePackages = "org.example", nameGenerator = MyNameGenerator.class)
public class AppConfig {
    // ...
}
```

```xml
<beans>
    <context:component-scan base-package="org.example"
        name-generator="org.example.MyNameGenerator" />
</beans>
```

<!-- tabs:start -->

#### ** English **

As a general rule, consider specifying the name with the annotation whenever other components may be making explicit references to it. On the other hand, the auto-generated names are adequate whenever the container is responsible for wiring.
#### ** Chinese **

作为一般规则，每当其他组件可能对其进行明确引用时，考虑用注解指定名称。另一方面，每当容器负责布线时，自动生成的名称就足够了。
<!-- tabs:end -->


### **1.10.7. Providing a Scope for Autodetected Components** 

<!-- tabs:start -->

#### ** English **

As with Spring-managed components in general, the default and most common scope for autodetected components is `singleton`. However, sometimes you need a different scope that can be specified by the `@Scope` annotation. You can provide the name of the scope within the annotation, as the following example shows:
#### ** Chinese **

与一般的Spring管理的组件一样，自动检测组件的默认和最常见的作用域是`singleton`。但是，有时您需要一个不同的作用域，可以通过`@Scope`注解来指定。您可以在注解中提供作用域的名称，如下面的例子所示。
<!-- tabs:end -->


```java
@Scope("prototype")
@Repository
public class MovieFinderImpl implements MovieFinder {
    // ...
}
```

<!-- tabs:start -->

#### ** English **

`@Scope` annotations are only introspected on the concrete bean class (for annotated components) or the factory method (for `@Bean` methods). In contrast to XML bean definitions, there is no notion of bean definition inheritance, and inheritance hierarchies at the class level are irrelevant for metadata purposes.
#### ** Chinese **

`@Scope`注解只对具体的bean类（对于注解的组件）或工厂方法（对于`@Bean`方法）进行反省。与XML bean定义不同的是，没有bean定义继承的概念，类级的继承层次结构与元数据的目的无关。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

For details on web-specific scopes such as “request” or “session” in a Spring context, see [Request, Session, Application, and WebSocket Scopes](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-scopes-other). As with the pre-built annotations for those scopes, you may also compose your own scoping annotations by using Spring’s meta-annotation approach: for example, a custom annotation meta-annotated with `@Scope("prototype")`, possibly also declaring a custom scoped-proxy mode.
#### ** Chinese **

有关 Web 专用的作用域（如 Spring 上下文中的 "request "或 "session"）的详细信息，请参阅 [Request、Session、Application 和 WebSocket 作用域](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-scopes-other)。与这些作用域的预建注解一样，您也可以使用Spring的元注解方法来编写自己的作用域注解：例如，用`@Scope("prototype")`进行元注解的自定义注解，可能还声明了自定义的作用域代理模式。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

To provide a custom strategy for scope resolution rather than relying on the annotation-based approach, you can implement the [`ScopeMetadataResolver`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/context/annotation/ScopeMetadataResolver.html) interface. Be sure to include a default no-arg constructor. Then you can provide the fully qualified class name when configuring the scanner, as the following example of both an annotation and a bean definition shows:
#### ** Chinese **

为了提供一个自定义的作用域解析策略，而不是依赖基于注解的方法，可以实现[`ScopeMetadataResolver`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/context/annotation/ScopeMetadataResolver.html)接口。请确保包含一个默认的无arg构造函数。然后你可以在配置扫描仪时提供完全限定的类名，就像下面的注解和Bean定义的例子一样。
<!-- tabs:end -->


```java
@Configuration
@ComponentScan(basePackages = "org.example", scopeResolver = MyScopeResolver.class)
public class AppConfig {
    // ...
}
```

```xml
<beans>
    <context:component-scan base-package="org.example" scope-resolver="org.example.MyScopeResolver"/>
</beans>
```

<!-- tabs:start -->

#### ** English **

When using certain non-singleton scopes, it may be necessary to generate proxies for the scoped objects. The reasoning is described in [Scoped Beans as Dependencies](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-scopes-other-injection). For this purpose, a scoped-proxy attribute is available on the component-scan element. The three possible values are: `no`, `interfaces`, and `targetClass`. For example, the following configuration results in standard JDK dynamic proxies:
#### ** Chinese **

当使用某些非单子的作用域时，可能需要为作用域对象生成代理。这个道理在[Scoped Beans as Dependencies](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-scopes-other-injection)中描述了。为此，在组件-scan元素上有一个scoped-proxy属性。三个可能的值是 `no`、`interfaces`和`targetClass`。例如，以下配置的结果是标准的JDK动态代理。
<!-- tabs:end -->


```java
@Configuration
@ComponentScan(basePackages = "org.example", scopedProxy = ScopedProxyMode.INTERFACES)
public class AppConfig {
    // ...
}
```

```xml
<beans>
    <context:component-scan base-package="org.example" scoped-proxy="interfaces"/>
</beans>
```

### **1.10.8. Providing Qualifier Metadata with Annotations** 

<!-- tabs:start -->

#### ** English **

The `@Qualifier` annotation is discussed in [Fine-tuning Annotation-based Autowiring with Qualifiers](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-autowired-annotation-qualifiers). The examples in that section demonstrate the use of the `@Qualifier` annotation and custom qualifier annotations to provide fine-grained control when you resolve autowire candidates. Because those examples were based on XML bean definitions, the qualifier metadata was provided on the candidate bean definitions by using the `qualifier` or `meta` child elements of the `bean` element in the XML. When relying upon classpath scanning for auto-detection of components, you can provide the qualifier metadata with type-level annotations on the candidate class. The following three examples demonstrate this technique:
#### ** Chinese **

`@Qualifier`注解在[Fine-tuning Annotation-based Autowiring with Qualifiers](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-autowired-annotation-qualifiers)中讨论过。这一节中的示例演示了使用 `@Qualifier` 注解和自定义修饰符注解时提供精细的控制。因为这些例子是基于 XML bean 定义的，所以通过使用 XML 中的 `qualifier` 或 `meta` 元素的 `bean` 子元素，在候选 bean 定义上提供了限定符元数据。当依赖classpath扫描来自动检测组件时，可以在候选类上提供具有类型级注解的qualifier元数据。下面的三个例子演示了这种技术。
<!-- tabs:end -->


```java
@Component
@Qualifier("Action")
public class ActionMovieCatalog implements MovieCatalog {
    // ...
}
```

```java
@Component
@Genre("Action")
public class ActionMovieCatalog implements MovieCatalog {
    // ...
}
```

```java
@Component
@Offline
public class CachingMovieCatalog implements MovieCatalog {
    // ...
}
```

<!-- tabs:start -->

#### ** English **

As with most annotation-based alternatives, keep in mind that the annotation metadata is bound to the class definition itself, while the use of XML allows for multiple beans of the same type to provide variations in their qualifier metadata, because that metadata is provided per-instance rather than per-class.
#### ** Chinese **

与大多数基于注解的替代方案一样，请记住，注解元数据被绑定到类定义本身，而XML的使用允许同一类型的多个Bean在其修饰器元数据中提供不同的元数据，因为元数据是按实例而不是按类提供的。
<!-- tabs:end -->


### **1.10.9. Generating an Index of Candidate Components** 

<!-- tabs:start -->

#### ** English **

While classpath scanning is very fast, it is possible to improve the startup performance of large applications by creating a static list of candidates at compilation time. In this mode, all modules that are target of component scan must use this mechanism.
#### ** Chinese **

虽然classpath扫描速度非常快，但通过在编译时创建一个静态的候选列表，可以提高大型应用程序的启动性能。在这种模式下，所有作为组件扫描目标的模块都必须使用这种机制。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Your existing `@ComponentScan` or `<context:component-scan` directives must stay as is to request the context to scan candidates in certain packages. When the `ApplicationContext` detects such an index, it automatically uses it rather than scanning the classpath.
#### ** Chinese **

你现有的 `@ComponentScan` 或 `<context:component-scan` 指令必须保持原样，以请求上下文扫描某些包中的候选包。当`ApplicationContext`检测到这样的索引时，它将自动使用它而不是扫描classpath。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

To generate the index, add an additional dependency to each module that contains components that are targets for component scan directives. The following example shows how to do so with Maven:
#### ** Chinese **

为了生成索引，在每个包含组件扫描指令目标的组件的模块中添加一个额外的依赖关系。下面的例子显示了如何用Maven来做。
<!-- tabs:end -->


```xml
<dependencies>
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-context-indexer</artifactId>
        <version>5.2.6.RELEASE</version>
        <optional>true</optional>
    </dependency>
</dependencies>
```

<!-- tabs:start -->

#### ** English **

With Gradle 4.5 and earlier, the dependency should be declared in the `compileOnly` configuration, as shown in the following example:
#### ** Chinese **

对于 Gradle 4.5 和更早的版本，依赖关系应该在 `compileOnly`配置中声明，如下图所示。
<!-- tabs:end -->


```
dependencies {
    compileOnly "org.springframework:spring-context-indexer:5.2.6.RELEASE"
}
```

<!-- tabs:start -->

#### ** English **

With Gradle 4.6 and later, the dependency should be declared in the `annotationProcessor` configuration, as shown in the following example:
#### ** Chinese **

对于 Gradle 4.6 及以后的版本，应该在 `annotationProcessor` 配置中声明依赖关系，如下例所示。
<!-- tabs:end -->


```
dependencies {
    annotationProcessor "org.springframework:spring-context-indexer:{spring-version}"
}
```

<!-- tabs:start -->

#### ** English **

That process generates a `META-INF/spring.components` file that is included in the jar file.
#### ** Chinese **

这个过程会生成一个`META-INF/spring.components`文件，该文件包含在jar文件中。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

When working with this mode in your IDE, the `spring-context-indexer` must be registered as an annotation processor to make sure the index is up-to-date when candidate components are updated.
#### ** Chinese **

在IDE中使用这种模式时，必须将`spring-context-indexer`注册为注解处理器，以确保候选组件更新时索引是最新的。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The index is enabled automatically when a `META-INF/spring.components` is found on the classpath. If an index is partially available for some libraries (or use cases) but could not be built for the whole application, you can fallback to a regular classpath arrangement (as though no index was present at all) by setting `spring.index.ignore` to `true`, either as a system property or in a `spring.properties` file at the root of the classpath.
#### ** Chinese **

当在classpath上找到`META-INF/spring.components`时，索引会自动启用。如果索引对某些库（或用例）部分可用，但无法为整个应用程序建立索引，可以通过设置 `spring.index.ignore` 为 `true`，作为系统属性或在 classpath 根部的 `spring.properties` 文件中设置为 `true`，从而回退到常规的 classpath 安排（就像根本没有索引一样）。
<!-- tabs:end -->



[下一章](Spring-Framework-5.2.6.RELEASE/Core%20Technologies/1.11.%20Using%20JSR%20330%20Standard%20Annotations.md)


[回目录](Spring-Framework-5.2.6.RELEASE/summary.md)

[回首页](/README)
