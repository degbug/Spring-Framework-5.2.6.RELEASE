# 1.9. Annotation-based Container Configuration

<!-- tabs:start -->

#### ** English **

Are annotations better than XML for configuring Spring?
#### ** Chinese **

注解是否比XML更适合配置Spring？
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The introduction of annotation-based configuration raised the question of whether this approach is “better” than XML. The short answer is “it depends.” The long answer is that each approach has its pros and cons, and, usually, it is up to the developer to decide which strategy suits them better. Due to the way they are defined, annotations provide a lot of context in their declaration, leading to shorter and more concise configuration. However, XML excels at wiring up components without touching their source code or recompiling them. Some developers prefer having the wiring close to the source while others argue that annotated classes are no longer POJOs and, furthermore, that the configuration becomes decentralized and harder to control.
#### ** Chinese **

基于注解的配置的引入，提出了这样一个问题：这种方法是否比XML "更好"。简单的答案是 "这要看情况"。长长的答案是，每一种方法都有其优点和缺点，通常情况下，由开发者决定哪种策略更适合他们。由于它们的定义方式，注解在声明中提供了大量的上下文，导致配置更短、更简洁。然而，XML擅长于在不触及组件的源代码或重新编译组件的情况下进行布线。一些开发人员喜欢将布线靠近源码，而另一些人则认为，注解类不再是POJO，此外，配置变得分散化，更难控制。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

No matter the choice, Spring can accommodate both styles and even mix them together. It is worth pointing out that through its [JavaConfig](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-java) option, Spring lets annotations be used in a non-invasive way, without touching the target components source code and that, in terms of tooling, all configuration styles are supported by the [Spring Tools for Eclipse](https://spring.io/tools).
#### ** Chinese **

无论选择哪种风格，Spring都可以容纳这两种风格，甚至可以混合使用。值得指出的是，通过其[JavaConfig](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-java)选项，Spring可以让注解以非侵入性的方式使用，而不触及目标组件的源代码，而且在工具方面，所有的配置风格都由[Spring Tools for Eclipse](https://spring.io/tools)支持。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

An alternative to XML setup is provided by annotation-based configuration, which relies on the bytecode metadata for wiring up components instead of angle-bracket declarations. Instead of using XML to describe a bean wiring, the developer moves the configuration into the component class itself by using annotations on the relevant class, method, or field declaration. As mentioned in [Example: The ](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-extension-bpp-examples-rabpp)[`RequiredAnnotationBeanPostProcessor`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-extension-bpp-examples-rabpp), using a `BeanPostProcessor` in conjunction with annotations is a common means of extending the Spring IoC container. For example, Spring 2.0 introduced the possibility of enforcing required properties with the [`@Required`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-required-annotation) annotation. Spring 2.5 made it possible to follow that same general approach to drive Spring’s dependency injection. Essentially, the `@Autowired` annotation provides the same capabilities as described in [Autowiring Collaborators](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-autowire) but with more fine-grained control and wider applicability. Spring 2.5 also added support for JSR-250 annotations, such as `@PostConstruct` and `@PreDestroy`. Spring 3.0 added support for JSR-330 (Dependency Injection for Java) annotations contained in the `javax.inject` package such as `@Inject` and `@Named`. Details about those annotations can be found in the [relevant section](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-standard-annotations).
#### ** Chinese **

基于注解的配置提供了一个替代XML设置的方法，它依靠字节码元数据来布线组件，而不是角括号声明。开发者不使用XML来描述Bean布线，而是通过在相关的类、方法或字段声明上使用注解将配置移到组件类本身。正如[示例：](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-extension-bpp-examples-rabpp)[`RequiredAnnotationBeanPostProcessor`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-extension-bpp-examples-rabpp)中提到的那样，使用`BeanPostProcessor`与注解结合使用是Spring IoC容器的常用扩展手段。例如，Spring 2.0引入了使用[`@Required`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-required-annotation)注解强制执行所需属性的可能性。Spring 2.5 让我们可以遵循同样的一般方法来驱动 Spring 的依赖注入。本质上，`@Autowired`注解提供了与[Autowiring Collaborators](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-autowire)中描述的相同的功能，但具有更精细的控制和更广泛的适用性。Spring 2.5 还增加了对 JSR-250 注解的支持，例如 `@PostConstruct` 和 `@PreDestroy`。Spring 3.0 增加了对 `javax.inject` 包中包含的 JSR-330（Java 的依赖注入）注解的支持，例如 `@Inject` 和 `@Named`。关于这些注解的详细信息可以在[相关章节](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-standard-annotations)中找到。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Annotation injection is performed before XML injection. Thus, the XML configuration overrides the annotations for properties wired through both approaches.
#### ** Chinese **

注解注入是在XML注入之前进行的。因此，通过这两种方法，XML配置覆盖了通过这两种方法连接的属性的注解。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

As always, you can register them as individual bean definitions, but they can also be implicitly registered by including the following tag in an XML-based Spring configuration (notice the inclusion of the `context` namespace):
#### ** Chinese **

一如既往，您可以将它们作为单独的Bean定义进行注册，但也可以通过在基于XML的Spring配置中包含以下标记来隐式注册（注意包含`context`命名空间）。
<!-- tabs:end -->


```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd">

    <context:annotation-config/>

</beans>
```

<!-- tabs:start -->

#### ** English **

(The implicitly registered post-processors include [`AutowiredAnnotationBeanPostProcessor`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/beans/factory/annotation/AutowiredAnnotationBeanPostProcessor.html), [`CommonAnnotationBeanPostProcessor`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/context/annotation/CommonAnnotationBeanPostProcessor.html), [`PersistenceAnnotationBeanPostProcessor`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/orm/jpa/support/PersistenceAnnotationBeanPostProcessor.html), and the aforementioned [`RequiredAnnotationBeanPostProcessor`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/beans/factory/annotation/RequiredAnnotationBeanPostProcessor.html).)
#### ** Chinese **

(隐式注册的后处理程序包括[`AutowiredAnnotationBeanPostProcessor`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/beans/factory/annotation/AutowiredAnnotationBeanPostProcessor.html)、[`CommonAnnotationBeanPostProcessor`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/context/annotation/CommonAnnotationBeanPostProcessor.html)、[`PersistenceAnnotationBeanPostProcessor`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/orm/jpa/support/PersistenceAnnotationBeanPostProcessor.html)，以及上述的[`RequiredAnnotationBeanPostProcessor`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/beans/factory/annotation/RequiredAnnotationBeanPostProcessor.html))。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

`<context:annotation-config/>` only looks for annotations on beans in the same application context in which it is defined. This means that, if you put `<context:annotation-config/>` in a `WebApplicationContext` for a `DispatcherServlet`, it only checks for `@Autowired` beans in your controllers, and not your services. See [The DispatcherServlet](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-servlet) for more information.
#### ** Chinese **

`<context:annotation-config/>`只在其定义的相同的应用程序上下文中查找bean上的注解。这意味着，如果你把 `<context:annotation-config/>`放在 `WebApplicationContext`中的 `DispatcherServlet`，它只会检查控制器中的 `@Autowired` bean，而不会检查你的服务。更多信息，请参阅[The DispatcherServlet](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-servlet)。
<!-- tabs:end -->


### **1.9.1. @Required** 

<!-- tabs:start -->

#### ** English **

The `@Required` annotation applies to bean property setter methods, as in the following example:
#### ** Chinese **

`@Required`注解适用于Bean属性设置器方法，如下例所示。
<!-- tabs:end -->


```java
public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Required
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // ...
}
```

<!-- tabs:start -->

#### ** English **

This annotation indicates that the affected bean property must be populated at configuration time, through an explicit property value in a bean definition or through autowiring. The container throws an exception if the affected bean property has not been populated. This allows for eager and explicit failure, avoiding `NullPointerException` instances or the like later on. We still recommend that you put assertions into the bean class itself (for example, into an init method). Doing so enforces those required references and values even when you use the class outside of a container.
#### ** Chinese **

这个注解表明，必须在配置时通过Bean定义中的显式属性值或通过自动布线来填充受影响的Bean属性。如果没有填充受影响的Bean属性，容器会抛出一个异常。这样可以急于求成和显式失败，避免以后出现`NullPointerException`实例或类似的情况。我们仍然建议你把断言放到Bean类本身（例如，放到init方法中）。即使在容器外使用该类时，这样做也会强制执行这些必要的引用和值。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The `@Required` annotation is formally deprecated as of Spring Framework 5.1, in favor of using constructor injection for required settings (or a custom implementation of `InitializingBean.afterPropertiesSet()` along with bean property setter methods).
#### ** Chinese **

`@Required`注解从Spring Framework 5.1开始正式取消了，改为使用构造函数注入进行必要的设置（或者自定义实现`InitializingBean.afterPropertiesSet()`和bean属性设置器方法）。
<!-- tabs:end -->


### **1.9.2. Using** **`@Autowired`** 

<!-- tabs:start -->

#### ** English **

JSR 330’s `@Inject` annotation can be used in place of Spring’s `@Autowired` annotation in the examples included in this section. See [here](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-standard-annotations) for more details.
#### ** Chinese **

JSR 330 的 `@Inject` 注解可以在本节所包含的示例中代替 Spring 的 `@Autowired` 注解。有关详细信息，请参阅 [此处](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-standard-annotations)。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can apply the `@Autowired` annotation to constructors, as the following example shows:
#### ** Chinese **

你可以将`@Autowired`注解应用到构造函数中，如下例所示。
<!-- tabs:end -->


```java
public class MovieRecommender {

    private final CustomerPreferenceDao customerPreferenceDao;

    @Autowired
    public MovieRecommender(CustomerPreferenceDao customerPreferenceDao) {
        this.customerPreferenceDao = customerPreferenceDao;
    }

    // ...
}
```

<!-- tabs:start -->

#### ** English **

As of Spring Framework 4.3, an `@Autowired` annotation on such a constructor is no longer necessary if the target bean defines only one constructor to begin with. However, if several constructors are available and there is no primary/default constructor, at least one of the constructors must be annotated with `@Autowired` in order to instruct the container which one to use. See the discussion on [constructor resolution](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-autowired-annotation-constructor-resolution) for details.
#### ** Chinese **

从Spring Framework 4.3开始，如果目标Bean一开始只定义了一个构造函数，那么在这样的构造函数上的`@Autowired`注解就不再需要了。但是，如果有多个构造函数可用，并且没有主/默认构造函数，那么至少有一个构造函数必须被注解为 `@Autowired`，以指示容器使用哪一个。有关详细信息，请参阅关于[构造函数解析](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-autowired-annotation-constructor-resolution)的讨论。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can also apply the `@Autowired` annotation to *traditional* setter methods, as the following example shows:
#### ** Chinese **

你也可以将`@Autowired`注解应用到*传统的*设置器方法中，如下例所示。
<!-- tabs:end -->


```java
public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Autowired
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // ...
}
```

<!-- tabs:start -->

#### ** English **

You can also apply the annotation to methods with arbitrary names and multiple arguments, as the following example shows:
#### ** Chinese **

你也可以将注解应用于具有任意名称和多个参数的方法，如下例所示。
<!-- tabs:end -->


```java
public class MovieRecommender {

    private MovieCatalog movieCatalog;

    private CustomerPreferenceDao customerPreferenceDao;

    @Autowired
    public void prepare(MovieCatalog movieCatalog,
            CustomerPreferenceDao customerPreferenceDao) {
        this.movieCatalog = movieCatalog;
        this.customerPreferenceDao = customerPreferenceDao;
    }

    // ...
}
```

<!-- tabs:start -->

#### ** English **

You can apply `@Autowired` to fields as well and even mix it with constructors, as the following example shows:
#### ** Chinese **

你也可以将`@Autowired`应用到字段中，甚至可以将其与构造函数混合使用，如下例所示。
<!-- tabs:end -->


```java
public class MovieRecommender {

    private final CustomerPreferenceDao customerPreferenceDao;

    @Autowired
    private MovieCatalog movieCatalog;

    @Autowired
    public MovieRecommender(CustomerPreferenceDao customerPreferenceDao) {
        this.customerPreferenceDao = customerPreferenceDao;
    }

    // ...
}
```

<!-- tabs:start -->

#### ** English **

Make sure that your target components (for example, `MovieCatalog` or `CustomerPreferenceDao`) are consistently declared by the type that you use for your `@Autowired`-annotated injection points. Otherwise, injection may fail due to a "no type match found" error at runtime.
#### ** Chinese **

确保你的目标组件（例如，`MovieCatalog`或`CustomerPreferenceDao`）是由你的`@Autowired`注解的注入点所使用的类型一致声明的。否则，在运行时可能会因为 "没有找到类型匹配 "错误而导致注入失败。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

For XML-defined beans or component classes found via classpath scanning, the container usually knows the concrete type up front. However, for `@Bean` factory methods, you need to make sure that the declared return type is sufficiently expressive. For components that implement several interfaces or for components potentially referred to by their implementation type, consider declaring the most specific return type on your factory method (at least as specific as required by the injection points referring to your bean).
#### ** Chinese **

对于XML定义的Bean或通过classpath扫描找到的组件类，容器通常会预先知道具体的类型。但是，对于`@Bean`工厂方法，你需要确保声明的返回类型有足够的表现力。对于实现了多个接口的组件，或者对于可能被其实现类型引用的组件，可以考虑在工厂方法上声明最具体的返回类型（至少是引用Bean的注入点所要求的具体类型）。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can also instruct Spring to provide all beans of a particular type from the `ApplicationContext` by adding the `@Autowired` annotation to a field or method that expects an array of that type, as the following example shows:
#### ** Chinese **

您还可以指示Spring从`ApplicationContext`中提供特定类型的所有Bean，方法是通过在一个字段或方法中添加`@Autowired`注解，该字段或方法期望一个数组的类型，如下例所示。
<!-- tabs:end -->


```java
public class MovieRecommender {

    @Autowired
    private MovieCatalog[] movieCatalogs;

    // ...
}
```

<!-- tabs:start -->

#### ** English **

The same applies for typed collections, as the following example shows:
#### ** Chinese **

同样的道理也适用于类型化集合，如下例所示。
<!-- tabs:end -->


```java
public class MovieRecommender {

    private Set<MovieCatalog> movieCatalogs;

    @Autowired
    public void setMovieCatalogs(Set<MovieCatalog> movieCatalogs) {
        this.movieCatalogs = movieCatalogs;
    }

    // ...
}
```

<!-- tabs:start -->

#### ** English **

Your target beans can implement the `org.springframework.core.Ordered` interface or use the `@Order` or standard `@Priority` annotation if you want items in the array or list to be sorted in a specific order. Otherwise, their order follows the registration order of the corresponding target bean definitions in the container.
#### ** Chinese **

你的目标Bean可以实现`org.springframework.core.Ordered`接口，或者如果你想让数组或列表中的项目按照特定的顺序排序，可以使用`@Order`或标准的`@Priority`注解。否则，它们的顺序遵循容器中相应的目标Bean定义的注册顺序。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can declare the `@Order` annotation at the target class level and on `@Bean` methods, potentially for individual bean definitions (in case of multiple definitions that use the same bean class). `@Order` values may influence priorities at injection points, but be aware that they do not influence singleton startup order, which is an orthogonal concern determined by dependency relationships and `@DependsOn` declarations.
#### ** Chinese **

你可以在目标类级别和`@Order`方法上声明`@Bean`注解，可能是针对单个Bean定义（如果有多个定义使用同一个Bean类）。 `@Order`值可能会影响注入点的优先级，但要注意，它们不会影响单子启动顺序，这是一个由依赖关系和`@DependsOn`声明决定的正交问题。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Note that the standard `javax.annotation.Priority` annotation is not available at the `@Bean` level, since it cannot be declared on methods. Its semantics can be modeled through `@Order` values in combination with `@Primary` on a single bean for each type.
#### ** Chinese **

请注意，标准的 `javax.annotation.Priority` 注解在 `@Bean` 级别上是不可用的，因为它不能在方法上声明。它的语义可以通过`@Order`值与`@Primary`结合在每个类型的单个Bean上进行建模。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Even typed `Map` instances can be autowired as long as the expected key type is `String`. The map values contain all beans of the expected type, and the keys contain the corresponding bean names, as the following example shows:
#### ** Chinese **

只要预期的键类型是`String`，即使是键入的`Map`实例也可以被自动连接。映射值包含所有预期类型的Bean，而键包含相应的Bean名，如下面的例子所示。
<!-- tabs:end -->


```java
public class MovieRecommender {

    private Map<String, MovieCatalog> movieCatalogs;

    @Autowired
    public void setMovieCatalogs(Map<String, MovieCatalog> movieCatalogs) {
        this.movieCatalogs = movieCatalogs;
    }

    // ...
}
```

<!-- tabs:start -->

#### ** English **

By default, autowiring fails when no matching candidate beans are available for a given injection point. In the case of a declared array, collection, or map, at least one matching element is expected.
#### ** Chinese **

默认情况下，当给定的注入点没有匹配的候选Bean可用时，自动布线会失败。在声明数组、集合或映射的情况下，预计至少有一个匹配的元素。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The default behavior is to treat annotated methods and fields as indicating required dependencies. You can change this behavior as demonstrated in the following example, enabling the framework to skip a non-satisfiable injection point through marking it as non-required (i.e., by setting the `required` attribute in `@Autowired` to `false`):
#### ** Chinese **

默认的行为是将注解的方法和字段视为表示必要的依赖关系。你可以改变这个行为，如下例所示，通过将`@Autowired`中的`required`属性设置为`false`，使框架能够跳过一个不可满足的注入点（即通过将`@Autowired`中的`required`属性设置为`false`）。
<!-- tabs:end -->


```java
public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Autowired(required = false)
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // ...
}
```

<!-- tabs:start -->

#### ** English **

A non-required method will not be called at all if its dependency (or one of its dependencies, in case of multiple arguments) is not available. A non-required field will not get populated at all in such cases, leaving its default value in place.
#### ** Chinese **

如果一个非必需方法的依赖关系（或其依赖关系中的一个，如果有多个参数的话）不可用，则根本不会被调用。在这种情况下，一个非必需的字段将不会被填充，只保留其默认值。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Injected constructor and factory method arguments are a special case since the `required` attribute in `@Autowired` has a somewhat different meaning due to Spring’s constructor resolution algorithm that may potentially deal with multiple constructors. Constructor and factory method arguments are effectively required by default but with a few special rules in a single-constructor scenario, such as multi-element injection points (arrays, collections, maps) resolving to empty instances if no matching beans are available. This allows for a common implementation pattern where all dependencies can be declared in a unique multi-argument constructor — for example, declared as a single public constructor without an `@Autowired` annotation.
#### ** Chinese **

注入的构造函数和工厂方法参数是一种特殊情况，因为在`@Autowired`中的`required`属性具有不同的含义，因为Spring的构造函数解析算法可能会处理多个构造函数。构造器和工厂方法参数在默认情况下是有效的，但在单构造器的场景中会有一些特殊的规则，例如，如果没有匹配的Bean可用，多元素注入点（数组、集合、映射）解析为空实例。这使得所有的依赖关系都可以在一个唯一的多参数构造函数中声明的通用实现模式成为可能--例如，在没有`@Autowired`注解的情况下，作为一个单一的公共构造函数声明。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Only one constructor of any given bean class may declare `@Autowired` with the `required` attribute set to `true`, indicating *the* constructor to autowire when used as a Spring bean. As a consequence, if the `required` attribute is left at its default value `true`, only a single constructor may be annotated with `@Autowired`. If multiple constructors declare the annotation, they will all have to declare `required=false` in order to be considered as candidates for autowiring (analogous to `autowire=constructor` in XML). The constructor with the greatest number of dependencies that can be satisfied by matching beans in the Spring container will be chosen. If none of the candidates can be satisfied, then a primary/default constructor (if present) will be used. Similarly, if a class declares multiple constructors but none of them is annotated with `@Autowired`, then a primary/default constructor (if present) will be used. If a class only declares a single constructor to begin with, it will always be used, even if not annotated. Note that an annotated constructor does not have to be public.
#### ** Chinese **

任何给定Bean类的构造函数只能声明`@Autowired`，并将`required`属性设置为`true`，表示作为Spring Bean使用时的**构造函数自动触发。因此，如果将`required`属性保留在默认值`true`，那么只有一个构造函数可能被注解为`@Autowired`。如果多个构造函数声明了这个注解，那么它们都必须声明`required=false`才能被视为自动布线的候选对象（类似于XML中的`autowire=constructor`）。在Spring容器中，将选择能够通过匹配Bean来满足最大数量的依赖关系的构造函数。如果没有一个候选者可以满足，那么将使用一个主/默认构造函数（如果存在的话）。同样，如果一个类声明了多个构造函数，但其中没有一个用`@Autowired`注解，那么将使用一个主/默认构造函数（如果存在的话）。如果一个类一开始只声明了一个构造函数，那么它将始终被使用，即使没有注解。注意，被注解的构造函数不一定是公共的。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The `required` attribute of `@Autowired` is recommended over the deprecated `@Required` annotation on setter methods. Setting the `required` attribute to `false` indicates that the property is not required for autowiring purposes, and the property is ignored if it cannot be autowired. `@Required`, on the other hand, is stronger in that it enforces the property to be set by any means supported by the container, and if no value is defined, a corresponding exception is raised.
#### ** Chinese **

建议使用`@Autowired`的`required`属性，而不是被废弃的`@Required`注解。将`required`属性设置为`false`表示该属性不需要自动布线，如果不能自动布线，则忽略该属性。 `@Required`则更强，因为它强制要求通过容器支持的任何方式来设置该属性，如果没有定义值，则会提出相应的异常。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Alternatively, you can express the non-required nature of a particular dependency through Java 8’s `java.util.Optional`, as the following example shows:
#### ** Chinese **

或者，你可以通过Java 8的`java.util.Optional`来表达特定依赖关系的非必需性质，如下例所示。
<!-- tabs:end -->


```java
public class SimpleMovieLister {

    @Autowired
    public void setMovieFinder(Optional<MovieFinder> movieFinder) {
        ...
    }
}
```

<!-- tabs:start -->

#### ** English **

As of Spring Framework 5.0, you can also use a `@Nullable` annotation (of any kind in any package — for example, `javax.annotation.Nullable` from JSR-305) or just leverage Kotlin builtin null-safety support:
#### ** Chinese **

从Spring Framework 5.0开始，您还可以使用`@Nullable`注解（任何包中的任何类型的注解--例如，JSR-305中的`javax.annotation.Nullable`），或者直接利用Kotlin内置的null-safety支持。
<!-- tabs:end -->


```java
public class SimpleMovieLister {

    @Autowired
    public void setMovieFinder(@Nullable MovieFinder movieFinder) {
        ...
    }
}
```

<!-- tabs:start -->

#### ** English **

You can also use `@Autowired` for interfaces that are well-known resolvable dependencies: `BeanFactory`, `ApplicationContext`, `Environment`, `ResourceLoader`, `ApplicationEventPublisher`, and `MessageSource`. These interfaces and their extended interfaces, such as `ConfigurableApplicationContext` or `ResourcePatternResolver`, are automatically resolved, with no special setup necessary. The following example autowires an `ApplicationContext` object:
#### ** Chinese **

你也可以使用`@Autowired`来处理众所周知的可解析依赖的接口。 `BeanFactory`、`ApplicationContext`、`Environment`、`ResourceLoader`、`ApplicationEventPublisher`和`MessageSource`。这些接口及其扩展的接口，如 `ConfigurableApplicationContext`或`ResourcePatternResolver`，都是自动解析的，无需特殊设置。下面的示例自动触发了一个`ApplicationContext`对象。
<!-- tabs:end -->


```java
public class MovieRecommender {

    @Autowired
    private ApplicationContext context;

    public MovieRecommender() {
    }

    // ...
}
```

<!-- tabs:start -->

#### ** English **

The `@Autowired`, `@Inject`, `@Value`, and `@Resource` annotations are handled by Spring `BeanPostProcessor` implementations. This means that you cannot apply these annotations within your own `BeanPostProcessor` or `BeanFactoryPostProcessor` types (if any). These types must be 'wired up' explicitly by using XML or a Spring `@Bean` method.
#### ** Chinese **

`@Autowired`、`@Inject`、`@Value`和`@Resource`注解由Spring `BeanPostProcessor`实现处理。这意味着您不能在自己的 `BeanPostProcessor`或 `BeanFactoryPostProcessor`类型（如果有的话）中应用这些注解。这些类型必须通过使用 XML 或 Spring `@Bean` 方法来显式地 "布线"。
<!-- tabs:end -->


### **1.9.3. Fine-tuning Annotation-based Autowiring with** **`@Primary`** 

<!-- tabs:start -->

#### ** English **

Because autowiring by type may lead to multiple candidates, it is often necessary to have more control over the selection process. One way to accomplish this is with Spring’s `@Primary` annotation. `@Primary` indicates that a particular bean should be given preference when multiple beans are candidates to be autowired to a single-valued dependency. If exactly one primary bean exists among the candidates, it becomes the autowired value.
#### ** Chinese **

由于按类型自动布线可能会导致多个候选人，因此通常需要对选择过程进行更多的控制。实现这一目标的一种方法是使用Spring的`@Primary`注解。 `@Primary`表示，当多个Bean作为候选对象被自动连接到一个单值依赖关系时，应该优先选择一个特定的Bean。如果候选豆中正好有一个主豆，它将成为自动连接值。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Consider the following configuration that defines `firstMovieCatalog` as the primary `MovieCatalog`:
#### ** Chinese **

考虑以下配置，将`firstMovieCatalog`定义为主`MovieCatalog`。
<!-- tabs:end -->


```java
@Configuration
public class MovieConfiguration {

    @Bean
    @Primary
    public MovieCatalog firstMovieCatalog() { ... }

    @Bean
    public MovieCatalog secondMovieCatalog() { ... }

    // ...
}
```

<!-- tabs:start -->

#### ** English **

With the preceding configuration, the following `MovieRecommender` is autowired with the `firstMovieCatalog`:
#### ** Chinese **

通过前面的配置，下面的`MovieRecommender`与`firstMovieCatalog`自动连接。
<!-- tabs:end -->


```java
public class MovieRecommender {

    @Autowired
    private MovieCatalog movieCatalog;

    // ...
}
```

<!-- tabs:start -->

#### ** English **

The corresponding bean definitions follow:
#### ** Chinese **

相应的豆子定义也随之而来。
<!-- tabs:end -->


```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd">

    <context:annotation-config/>

    <bean class="example.SimpleMovieCatalog" primary="true">
        <!-- inject any dependencies required by this bean -->
    </bean>

    <bean class="example.SimpleMovieCatalog">
        <!-- inject any dependencies required by this bean -->
    </bean>

    <bean id="movieRecommender" class="example.MovieRecommender"/>

</beans>
```

### **1.9.4. Fine-tuning Annotation-based Autowiring with Qualifiers** 

<!-- tabs:start -->

#### ** English **

`@Primary` is an effective way to use autowiring by type with several instances when one primary candidate can be determined. When you need more control over the selection process, you can use Spring’s `@Qualifier` annotation. You can associate qualifier values with specific arguments, narrowing the set of type matches so that a specific bean is chosen for each argument. In the simplest case, this can be a plain descriptive value, as shown in the following example:
#### ** Chinese **

`@Primary`是按类型自动布线的有效方法，当可以确定一个主候选者时，可以使用多个实例。当您需要对选择过程进行更多控制时，可以使用Spring的`@Qualifier`注解。你可以将qualifier值与特定的参数关联起来，缩小类型匹配的集合，以便为每个参数选择一个特定的Bean。在最简单的情况下，这可以是一个普通的描述性值，如下例所示。
<!-- tabs:end -->


```java
public class MovieRecommender {

    @Autowired
    @Qualifier("main")
    private MovieCatalog movieCatalog;

    // ...
}
```

<!-- tabs:start -->

#### ** English **

You can also specify the `@Qualifier` annotation on individual constructor arguments or method parameters, as shown in the following example:
#### ** Chinese **

你也可以在单个构造函数参数或方法参数上指定`@Qualifier`注解，如下例所示。
<!-- tabs:end -->


```java
public class MovieRecommender {

    private MovieCatalog movieCatalog;

    private CustomerPreferenceDao customerPreferenceDao;

    @Autowired
    public void prepare(@Qualifier("main") MovieCatalog movieCatalog,
            CustomerPreferenceDao customerPreferenceDao) {
        this.movieCatalog = movieCatalog;
        this.customerPreferenceDao = customerPreferenceDao;
    }

    // ...
}
```

<!-- tabs:start -->

#### ** English **

The following example shows corresponding bean definitions.
#### ** Chinese **

下面的例子显示了相应的豆子定义。
<!-- tabs:end -->


```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd">

    <context:annotation-config/>

    <bean class="example.SimpleMovieCatalog">
        <qualifier value="main"/> (1)

        <!-- inject any dependencies required by this bean -->
    </bean>

    <bean class="example.SimpleMovieCatalog">
        <qualifier value="action"/> (2)

        <!-- inject any dependencies required by this bean -->
    </bean>

    <bean id="movieRecommender" class="example.MovieRecommender"/>

</beans>
```

<!-- tabs:start -->

#### ** English **

(1)The bean with the `main` qualifier value is wired with the constructor argument that is qualified with the same value.
#### ** Chinese **

(1)带有`main`限定符值的Bean与具有相同值的构造函数参数的限定值的Bean连线。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

(2)The bean with the `action` qualifier value is wired with the constructor argument that is qualified with the same value.
#### ** Chinese **

(2)带有`action`限定符值的Bean与具有相同值的构造函数参数的限定值的Bean连线。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

For a fallback match, the bean name is considered a default qualifier value. Thus, you can define the bean with an `id` of `main` instead of the nested qualifier element, leading to the same matching result. However, although you can use this convention to refer to specific beans by name, `@Autowired` is fundamentally about type-driven injection with optional semantic qualifiers. This means that qualifier values, even with the bean name fallback, always have narrowing semantics within the set of type matches. They do not semantically express a reference to a unique bean `id`. Good qualifier values are `main` or `EMEA` or `persistent`, expressing characteristics of a specific component that are independent from the bean `id`, which may be auto-generated in case of an anonymous bean definition such as the one in the preceding example.
#### ** Chinese **

对于回落匹配，Bean名称被认为是默认的修饰符值。因此，您可以用`id`的`main`来定义Bean，而不是用嵌套的修饰符元素来代替嵌套的修饰符元素，从而得到相同的匹配结果。然而，尽管你可以使用这个约定来引用特定的bean名称，但`@Autowired`从根本上讲，它是用可选的语义修饰符进行类型驱动的注入。这意味着，修饰符值，即使有了Bean名的回落，也总是在类型匹配的集合中具有缩小的语义。它们不会在语义上表达对唯一的Bean `id`的引用。好的修饰符值是`main`或`EMEA`或`persistent`，表达的是一个特定组件的特性，这些特性独立于bean `id`，如果是匿名bean定义，如上例中的匿名bean定义，则可能是自动生成的。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Qualifiers also apply to typed collections, as discussed earlier — for example, to `Set<MovieCatalog>`. In this case, all matching beans, according to the declared qualifiers, are injected as a collection. This implies that qualifiers do not have to be unique. Rather, they constitute filtering criteria. For example, you can define multiple `MovieCatalog` beans with the same qualifier value “action”, all of which are injected into a `Set<MovieCatalog>` annotated with `@Qualifier("action")`.
#### ** Chinese **

修饰符也适用于类型化的集合，正如前面所讨论的那样--例如，`Set<MovieCatalog>`。在这种情况下，根据声明的限定符，所有匹配的豆子都会作为一个集合注入。这意味着，修饰符不一定是唯一的。相反，它们构成了过滤条件。例如，您可以定义多个具有相同的限定符值 "action "的 `MovieCatalog` Bean，所有这些 Bean 都会被注入到带有 `@Qualifier("action")`注解的 `集<MovieCatalog>`中。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Letting qualifier values select against target bean names, within the type-matching candidates, does not require a `@Qualifier` annotation at the injection point. If there is no other resolution indicator (such as a qualifier or a primary marker), for a non-unique dependency situation, Spring matches the injection point name (that is, the field name or parameter name) against the target bean names and choose the same-named candidate, if any.
#### ** Chinese **

让修饰符值与目标Bean名进行选择，在类型匹配的候选对象中，不需要在注入点处有`@Qualifier`注解。如果没有其他的解析指标（如限定符或主标记），对于非唯一依赖的情况，Spring会将注入点名称（即字段名或参数名）与目标Bean名进行匹配，如果有的话，则选择相同名称的候选对象。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

That said, if you intend to express annotation-driven injection by name, do not primarily use `@Autowired`, even if it is capable of selecting by bean name among type-matching candidates. Instead, use the JSR-250 `@Resource` annotation, which is semantically defined to identify a specific target component by its unique name, with the declared type being irrelevant for the matching process. `@Autowired` has rather different semantics: After selecting candidate beans by type, the specified `String` qualifier value is considered within those type-selected candidates only (for example, matching an `account` qualifier against beans marked with the same qualifier label).
#### ** Chinese **

也就是说，如果你打算通过名称来表达注解驱动的注入，不要主要使用`@Autowired`，即使它能够在类型匹配的候选对象中通过Bean名选择。相反，使用 JSR-250 `@Resource` 注解，该注解在语义上被定义为通过其唯一的名称来识别特定的目标组件，而声明的类型与匹配过程无关。 `@Autowired`的语义相当不同。在按类型选择候选豆后，指定的`String`修饰符值仅在这些类型选择的候选豆中被考虑（例如，将`account`修饰符与标记有相同修饰符标签的豆匹配）。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

For beans that are themselves defined as a collection, `Map`, or array type, `@Resource` is a fine solution, referring to the specific collection or array bean by unique name. That said, as of 4.3, collection, you can match `Map`, and array types through Spring’s `@Autowired` type matching algorithm as well, as long as the element type information is preserved in `@Bean` return type signatures or collection inheritance hierarchies. In this case, you can use qualifier values to select among same-typed collections, as outlined in the previous paragraph.
#### ** Chinese **

对于本身被定义为集合、`Map`或数组类型的bean，`@Resource`是一个很好的解决方案，通过唯一的名称来引用特定的集合或数组bean。也就是说，从4.3的集合开始，你也可以通过Spring的`@Map`类型匹配算法来匹配`@Autowired`类型，只要在`@Bean`返回类型签名或集合继承层次结构中保留了元素类型信息，就可以匹配`@Bean`。在这种情况下，可以使用修饰符值在相同类型的集合中进行选择，如上段所述。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

As of 4.3, `@Autowired` also considers self references for injection (that is, references back to the bean that is currently injected). Note that self injection is a fallback. Regular dependencies on other components always have precedence. In that sense, self references do not participate in regular candidate selection and are therefore in particular never primary. On the contrary, they always end up as lowest precedence. In practice, you should use self references as a last resort only (for example, for calling other methods on the same instance through the bean’s transactional proxy). Consider factoring out the affected methods to a separate delegate bean in such a scenario. Alternatively, you can use `@Resource`, which may obtain a proxy back to the current bean by its unique name.
#### ** Chinese **

从4.3开始，`@Autowired`也考虑到了注入的自引用（也就是返回到当前注入的Bean的引用）。请注意，自注入是一种回撤。对其他组件的常规依赖总是有优先权。从这个意义上说，自我引用不参与常规的候选选择，因此特别是永远不会是主要的。相反，它们最终总是作为最低优先级。在实践中，你应该把自引用作为最后的手段来使用（例如，通过bean的事务代理调用同一实例上的其他方法）。在这种情况下，可以考虑将受影响的方法导出到一个单独的 delegate Bean。或者，你可以使用`@Resource`，它可以通过其唯一的名称获得一个代理回当前Bean的代理。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Trying to inject the results from `@Bean` methods on the same configuration class is effectively a self-reference scenario as well. Either lazily resolve such references in the method signature where it is actually needed (as opposed to an autowired field in the configuration class) or declare the affected `@Bean` methods as `static`, decoupling them from the containing configuration class instance and its lifecycle. Otherwise, such beans are only considered in the fallback phase, with matching beans on other configuration classes selected as primary candidates instead (if available).
#### ** Chinese **

试图在同一个配置类上注入`@Bean`方法的结果，实际上也是一种自引用的情况。要么在实际需要的方法签名中懒洋洋地解析这样的引用（相对于配置类中的自引用字段），要么将受影响的`@Bean`方法声明为`static`，将其与包含的配置类实例及其生命周期解耦。否则，这样的Bean只在回落阶段被考虑，而其他配置类上的匹配Bean则被选为主要候选对象（如果可用的话）。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

`@Autowired` applies to fields, constructors, and multi-argument methods, allowing for narrowing through qualifier annotations at the parameter level. In contrast, `@Resource` is supported only for fields and bean property setter methods with a single argument. As a consequence, you should stick with qualifiers if your injection target is a constructor or a multi-argument method.
#### ** Chinese **

`@Autowired`适用于字段、构造函数和多参数方法，允许通过参数级的修饰符注解来缩小范围。相比之下，`@Resource`只支持字段和具有单个参数的bean属性设置器方法。因此，如果你的注入目标是构造函数或多参数方法，你应该坚持使用修饰符。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can create your own custom qualifier annotations. To do so, define an annotation and provide the `@Qualifier` annotation within your definition, as the following example shows:
#### ** Chinese **

你可以创建你自己的自定义修饰符注解。要这样做，请定义一个注解，并在定义中提供`@Qualifier`注解，如下例所示。
<!-- tabs:end -->


```java
@Target({ElementType.FIELD, ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
@Qualifier
public @interface Genre {

    String value();
}
```

<!-- tabs:start -->

#### ** English **

Then you can provide the custom qualifier on autowired fields and parameters, as the following example shows:
#### ** Chinese **

然后你可以在自动连接的字段和参数上提供自定义修饰符，如下例所示。
<!-- tabs:end -->


```java
public class MovieRecommender {

    @Autowired
    @Genre("Action")
    private MovieCatalog actionCatalog;

    private MovieCatalog comedyCatalog;

    @Autowired
    public void setComedyCatalog(@Genre("Comedy") MovieCatalog comedyCatalog) {
        this.comedyCatalog = comedyCatalog;
    }

    // ...
}
```

<!-- tabs:start -->

#### ** English **

Next, you can provide the information for the candidate bean definitions. You can add `<qualifier/>` tags as sub-elements of the `<bean/>` tag and then specify the `type` and `value` to match your custom qualifier annotations. The type is matched against the fully-qualified class name of the annotation. Alternately, as a convenience if no risk of conflicting names exists, you can use the short class name. The following example demonstrates both approaches:
#### ** Chinese **

接下来，你可以提供候选Bean定义的信息。您可以添加`<qualifier/>`标记作为`<bean/>`标记的子元素，然后指定`type`和`value`来匹配您的自定义qualifier注解。类型会与注解的完全限定的类名进行匹配。另外，为了方便起见，如果不存在名称冲突的风险，可以使用简短的类名。下面的示例演示了这两种方法。
<!-- tabs:end -->


```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd">

    <context:annotation-config/>

    <bean class="example.SimpleMovieCatalog">
        <qualifier type="Genre" value="Action"/>
        <!-- inject any dependencies required by this bean -->
    </bean>

    <bean class="example.SimpleMovieCatalog">
        <qualifier type="example.Genre" value="Comedy"/>
        <!-- inject any dependencies required by this bean -->
    </bean>

    <bean id="movieRecommender" class="example.MovieRecommender"/>

</beans>
```

<!-- tabs:start -->

#### ** English **

In [Classpath Scanning and Managed Components](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-classpath-scanning), you can see an annotation-based alternative to providing the qualifier metadata in XML. Specifically, see [Providing Qualifier Metadata with Annotations](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-scanning-qualifiers).
#### ** Chinese **

在 [Classpath 扫描和托管组件](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-classpath-scanning)中，你可以看到一个基于注解的替代方法来替代在 XML 中提供修饰符元数据。具体来说，请参阅[用注解提供修饰符元数据](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-scanning-qualifiers)。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

In some cases, using an annotation without a value may suffice. This can be useful when the annotation serves a more generic purpose and can be applied across several different types of dependencies. For example, you may provide an offline catalog that can be searched when no Internet connection is available. First, define the simple annotation, as the following example shows:
#### ** Chinese **

在某些情况下，使用一个没有值的注解可能就足够了。当注解服务于一个更通用的目的，并且可以应用于几种不同类型的依赖关系时，这可能很有用。例如，您可能提供一个离线目录，在没有互联网连接时可以搜索。首先，定义简单的注解，如下面的例子所示。
<!-- tabs:end -->


```java
@Target({ElementType.FIELD, ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
@Qualifier
public @interface Offline {

}
```

<!-- tabs:start -->

#### ** English **

Then add the annotation to the field or property to be autowired, as shown in the following example:
#### ** Chinese **

然后将注解添加到要自动布线的字段或属性中，如下面的例子所示。
<!-- tabs:end -->


```java
public class MovieRecommender {

    @Autowired
    @Offline (1)
    private MovieCatalog offlineCatalog;

    // ...
}

//(1) This line adds the @Offline annotation.
```

<!-- tabs:start -->

#### ** English **

Now the bean definition only needs a qualifier `type`, as shown in the following example:
#### ** Chinese **

现在Bean定义只需要一个修饰符`type`，如下面的例子所示。
<!-- tabs:end -->


```xml
<bean class="example.SimpleMovieCatalog">
    <qualifier type="Offline"/> (1)
    <!-- inject any dependencies required by this bean -->
</bean>
```

<!-- tabs:start -->

#### ** English **

(1)This element specifies the qualifier.
#### ** Chinese **

(1)这个元素指定了修饰语。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can also define custom qualifier annotations that accept named attributes in addition to or instead of the simple `value` attribute. If multiple attribute values are then specified on a field or parameter to be autowired, a bean definition must match all such attribute values to be considered an autowire candidate. As an example, consider the following annotation definition:
#### ** Chinese **

你也可以定义自定义的修饰符注解，在简单的`value`属性之外，还可以接受命名的属性，或者代替简单的`value`属性。如果在一个字段或参数上指定了多个属性值，那么Bean定义必须匹配所有这样的属性值才能被认为是一个自动连接的候选属性。作为一个例子，考虑下面的注解定义。
<!-- tabs:end -->


```java
@Target({ElementType.FIELD, ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
@Qualifier
public @interface MovieQualifier {

    String genre();

    Format format();
}
```

<!-- tabs:start -->

#### ** English **

In this case `Format` is an enum, defined as follows:
#### ** Chinese **

在这种情况下，`Format`是一个enum，定义如下。
<!-- tabs:end -->


```java
public enum Format {
    VHS, DVD, BLURAY
}
```

<!-- tabs:start -->

#### ** English **

The fields to be autowired are annotated with the custom qualifier and include values for both attributes: `genre` and `format`, as the following example shows:
#### ** Chinese **

要自动连接的字段用自定义修饰符进行注解，并包括两个属性的值。 `genre`和`format`，如下例所示。
<!-- tabs:end -->


```java
public class MovieRecommender {

    @Autowired
    @MovieQualifier(format=Format.VHS, genre="Action")
    private MovieCatalog actionVhsCatalog;

    @Autowired
    @MovieQualifier(format=Format.VHS, genre="Comedy")
    private MovieCatalog comedyVhsCatalog;

    @Autowired
    @MovieQualifier(format=Format.DVD, genre="Action")
    private MovieCatalog actionDvdCatalog;

    @Autowired
    @MovieQualifier(format=Format.BLURAY, genre="Comedy")
    private MovieCatalog comedyBluRayCatalog;

    // ...
}
```

<!-- tabs:start -->

#### ** English **

Finally, the bean definitions should contain matching qualifier values. This example also demonstrates that you can use bean meta attributes instead of the `<qualifier/>` elements. If available, the `<qualifier/>` element and its attributes take precedence, but the autowiring mechanism falls back on the values provided within the `<meta/>` tags if no such qualifier is present, as in the last two bean definitions in the following example:
#### ** Chinese **

最后，Bean定义应该包含匹配的修饰符值。这个例子也证明了你可以使用bean元属性来代替`<qualifier/>`元素。如果有的话，`<qualifier/>`元素和它的属性优先，但如果没有这样的修饰符，自动布线机制就会返回到`<meta/>`标记中提供的值上，就像下面例子中的最后两个bean定义一样。
<!-- tabs:end -->


```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd">

    <context:annotation-config/>

    <bean class="example.SimpleMovieCatalog">
        <qualifier type="MovieQualifier">
            <attribute key="format" value="VHS"/>
            <attribute key="genre" value="Action"/>
        </qualifier>
        <!-- inject any dependencies required by this bean -->
    </bean>

    <bean class="example.SimpleMovieCatalog">
        <qualifier type="MovieQualifier">
            <attribute key="format" value="VHS"/>
            <attribute key="genre" value="Comedy"/>
        </qualifier>
        <!-- inject any dependencies required by this bean -->
    </bean>

    <bean class="example.SimpleMovieCatalog">
        <meta key="format" value="DVD"/>
        <meta key="genre" value="Action"/>
        <!-- inject any dependencies required by this bean -->
    </bean>

    <bean class="example.SimpleMovieCatalog">
        <meta key="format" value="BLURAY"/>
        <meta key="genre" value="Comedy"/>
        <!-- inject any dependencies required by this bean -->
    </bean>

</beans>
```

### **1.9.5. Using Generics as Autowiring Qualifiers** 

<!-- tabs:start -->

#### ** English **

In addition to the `@Qualifier` annotation, you can use Java generic types as an implicit form of qualification. For example, suppose you have the following configuration:
#### ** Chinese **

除了`@Qualifier`注解之外，你还可以使用Java泛型类型作为隐式的限定形式。例如，假设你有以下配置。
<!-- tabs:end -->


```java
@Configuration
public class MyConfiguration {

    @Bean
    public StringStore stringStore() {
        return new StringStore();
    }

    @Bean
    public IntegerStore integerStore() {
        return new IntegerStore();
    }
}
```

<!-- tabs:start -->

#### ** English **

Assuming that the preceding beans implement a generic interface, (that is, `Store<String>` and `Store<Integer>`), you can `@Autowire` the `Store` interface and the generic is used as a qualifier, as the following example shows:
#### ** Chinese **

假设前面的Bean实现了一个通用接口（即`Store<String>`和`Store<Integer>`），你可以在`Store`接口上注解`@Autowire`，并且将通用作为修饰符来使用，如下例所示。
<!-- tabs:end -->


```java
@Autowired
private Store<String> s1; // <String> qualifier, injects the stringStore bean

@Autowired
private Store<Integer> s2; // <Integer> qualifier, injects the integerStore bean
```

<!-- tabs:start -->

#### ** English **

Generic qualifiers also apply when autowiring lists, `Map` instances and arrays. The following example autowires a generic `List`:
#### ** Chinese **

当自动触发列表、`Map`实例和数组时，通用限定符也适用。下面的示例自动触发了一个通用的 `List`。
<!-- tabs:end -->


```java
// Inject all Store beans as long as they have an <Integer> generic
// Store<String> beans will not appear in this list
@Autowired
private List<Store<Integer>> s;
```

### **1.9.6. Using** **`CustomAutowireConfigurer`** 

<!-- tabs:start -->

#### ** English **

[`CustomAutowireConfigurer`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/beans/factory/annotation/CustomAutowireConfigurer.html) is a `BeanFactoryPostProcessor` that lets you register your own custom qualifier annotation types, even if they are not annotated with Spring’s `@Qualifier` annotation. The following example shows how to use `CustomAutowireConfigurer`:
#### ** Chinese **

[`CustomAutowireConfigurer`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/beans/factory/annotation/CustomAutowireConfigurer.html)是一个`BeanFactoryPostProcessor`，它可以让你注册你自己的自定义修饰符注解类型，即使它们没有被Spring的`@Qualifier`注解注解。下面的例子显示了如何使用 `CustomAutowireConfigurer`。
<!-- tabs:end -->


```xml
<bean id="customAutowireConfigurer"
        class="org.springframework.beans.factory.annotation.CustomAutowireConfigurer">
    <property name="customQualifierTypes">
        <set>
            <value>example.CustomQualifier</value>
        </set>
    </property>
</bean>
```

<!-- tabs:start -->

#### ** English **

The `AutowireCandidateResolver` determines autowire candidates by:
#### ** Chinese **

`AutowireCandidateResolver`通过以下方法来确定自动轮回候选人。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

- The `autowire-candidate` value of each bean definition

- Any `default-autowire-candidates` patterns available on the `<beans/>` element

- The presence of `@Qualifier` annotations and any custom annotations registered with the `CustomAutowireConfigurer`

#### ** Chinese **

- 每个Bean定义的`autowire-candidate`的值

- 任何`<beans/>`元素上的任何`default-autowire-candidates`模式都可以使用。

- `@Qualifier`注解和任何在`CustomAutowireConfigurer`中注册的自定义注解的存在

<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

When multiple beans qualify as autowire candidates, the determination of a “primary” is as follows: If exactly one bean definition among the candidates has a `primary` attribute set to `true`, it is selected.
#### ** Chinese **

当多个Bean符合自动轮回候选者的条件时，"主要 "的确定方法如下。如果候选人中正好有一个Bean定义的`primary`属性设置为`true`，则该Bean被选中。
<!-- tabs:end -->


### **1.9.7. Injection with** **`@Resource`** 

<!-- tabs:start -->

#### ** English **

Spring also supports injection by using the JSR-250 `@Resource` annotation (`javax.annotation.Resource`) on fields or bean property setter methods. This is a common pattern in Java EE: for example, in JSF-managed beans and JAX-WS endpoints. Spring supports this pattern for Spring-managed objects as well.
#### ** Chinese **

Spring还支持通过在字段或Bean属性设置器方法上使用JSR-250 `@Resource`注解（`javax.annotation.Resource`）来注入。这是Java EE中常见的模式：例如，在JSF管理的Bean和JAX-WS端点中。Spring 也支持这种模式，用于 Spring 管理的对象。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

`@Resource` takes a name attribute. By default, Spring interprets that value as the bean name to be injected. In other words, it follows by-name semantics, as demonstrated in the following example:
#### ** Chinese **

`@Resource`取一个名称属性。默认情况下，Spring将该值解释为要注入的Bean名称。换句话说，正如下面的例子所展示的那样，它遵循了名称语义。
<!-- tabs:end -->


```java
public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Resource(name="myMovieFinder") (1)
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }
}

//(1) This line injects a @Resource.
```

<!-- tabs:start -->

#### ** English **

If no name is explicitly specified, the default name is derived from the field name or setter method. In case of a field, it takes the field name. In case of a setter method, it takes the bean property name. The following example is going to have the bean named `movieFinder` injected into its setter method:
#### ** Chinese **

如果没有明确指定名称，默认的名称来自于字段名或设置器方法。如果是字段，它取字段名。如果是一个setter方法，则采用Bean的属性名。下面的例子将把名为`movieFinder`的Bean注入到它的setter方法中。
<!-- tabs:end -->


```java
public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Resource
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }
}
```

<!-- tabs:start -->

#### ** English **

The name provided with the annotation is resolved as a bean name by the `ApplicationContext` of which the `CommonAnnotationBeanPostProcessor` is aware. The names can be resolved through JNDI if you configure Spring’s [`SimpleJndiBeanFactory`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/jndi/support/SimpleJndiBeanFactory.html) explicitly. However, we recommend that you rely on the default behavior and use Spring’s JNDI lookup capabilities to preserve the level of indirection.
#### ** Chinese **

与注解一起提供的名称由`ApplicationContext`解析为Bean名，而`CommonAnnotationBeanPostProcessor`意识到了其中的`ApplicationContext`。如果你配置了Spring的[`SimpleJndiBeanFactory`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/jndi/support/SimpleJndiBeanFactory.html)，那么这些名称可以通过JNDI解析。但是，我们建议你依赖默认的行为，并使用Spring的JNDI查找功能来保留隐性的级别。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

In the exclusive case of `@Resource` usage with no explicit name specified, and similar to `@Autowired`, `@Resource` finds a primary type match instead of a specific named bean and resolves well known resolvable dependencies: the `BeanFactory`, `ApplicationContext`, `ResourceLoader`, `ApplicationEventPublisher`, and `MessageSource` interfaces.
#### ** Chinese **

在`@Resource`使用时没有指定显式名称的专属情况下，与`@Autowired`类似，`@Resource`找到一个主类型匹配，而不是特定的命名Bean，并解析出众所周知的可解析依赖关系。`BeanFactory`、`ApplicationContext`、`ResourceLoader`、`ApplicationEventPublisher`和`MessageSource`接口。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Thus, in the following example, the `customerPreferenceDao` field first looks for a bean named "customerPreferenceDao" and then falls back to a primary type match for the type `CustomerPreferenceDao`:
#### ** Chinese **

因此，在下面的例子中，`customerPreferenceDao`字段首先寻找一个名为 "customerPreferenceDao "的Bean，然后回落到一个主类型匹配的类型`CustomerPreferenceDao`。
<!-- tabs:end -->


```java
public class MovieRecommender {

    @Resource
    private CustomerPreferenceDao customerPreferenceDao;

    @Resource
    private ApplicationContext context; (1)

    public MovieRecommender() {
    }

    // ...
}

//(1) The context field is injected based on the known resolvable dependency type: ApplicationContext.
```

### **1.9.8. Using** **`@Value`** 

<!-- tabs:start -->

#### ** English **

`@Value` is typically used to inject externalized properties:
#### ** Chinese **

`@Value`通常用于注入外部化属性。
<!-- tabs:end -->


```java
@Component
public class MovieRecommender {

    private final String catalog;

    public MovieRecommender(@Value("${catalog.name}") String catalog) {
        this.catalog = catalog;
    }
}
```

<!-- tabs:start -->

#### ** English **

With the following configuration:
#### ** Chinese **

采用以下配置：
<!-- tabs:end -->


```java
@Configuration
@PropertySource("classpath:application.properties")
public class AppConfig { }
```

<!-- tabs:start -->

#### ** English **

And the following `application.properties` file:
#### ** Chinese **

而下面的`application.properties`文件。
<!-- tabs:end -->


```
catalog.name=MovieCatalog
```

<!-- tabs:start -->

#### ** English **

In that case, the `catalog` parameter and field will be equal to the `MovieCatalog` value.
#### ** Chinese **

在这种情况下，`catalog`参数和字段将等于`MovieCatalog`的值。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

A default lenient embedded value resolver is provided by Spring. It will try to resolve the property value and if it cannot be resolved, the property name (for example `${catalog.name}`) will be injected as the value. If you want to maintain strict control over nonexistent values, you should declare a `PropertySourcesPlaceholderConfigurer` bean, as the following example shows:
#### ** Chinese **

Spring 提供了一个默认的宽松的嵌入式值解析器。它将尝试解析属性值，如果无法解析，则会将属性名（例如`${catalog.name}`）作为值注入。如果你想对不存在的值保持严格的控制，你应该声明一个`PropertySourcesPlaceholderConfigurer` bean，如下例所示。
<!-- tabs:end -->


```java
@Configuration
public class AppConfig {

     @Bean
     public static PropertySourcesPlaceholderConfigurer propertyPlaceholderConfigurer() {
           return new PropertySourcesPlaceholderConfigurer();
     }
}
```

<!-- tabs:start -->

#### ** English **

When configuring a `PropertySourcesPlaceholderConfigurer` using JavaConfig, the `@Bean` method must be `static`.
#### ** Chinese **

当使用JavaConfig配置`PropertySourcesPlaceholderConfigurer`时，`@Bean`方法必须是`static`。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Using the above configuration ensures Spring initialization failure if any `${}` placeholder could not be resolved. It is also possible to use methods like `setPlaceholderPrefix`, `setPlaceholderSuffix`, or `setValueSeparator` to customize placeholders.
#### ** Chinese **

如果任何`${}`占位符无法解析，使用上述配置可以确保Spring初始化失败。也可以使用`setPlaceholderPrefix`、`setPlaceholderSuffix`或`setValueSeparator`等方法来自定义占位符。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Spring Boot configures by default a `PropertySourcesPlaceholderConfigurer` bean that will get properties from `application.properties` and `application.yml` files.
#### ** Chinese **

Spring Boot 默认配置了一个 `PropertySourcesPlaceholderConfigurer` bean，它将从 `application.properties`和`application.yml`文件中获取属性。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Built-in converter support provided by Spring allows simple type conversion (to `Integer` or `int` for example) to be automatically handled. Multiple comma-separated values can be automatically converted to String array without extra effort.
#### ** Chinese **

Spring提供的内置转换器支持，可以自动处理简单的类型转换（例如：`Integer`或`int`）。多个逗号分隔的值可以自动转换为String数组，无需额外的努力。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

It is possible to provide a default value as following:
#### ** Chinese **

可以提供一个默认值如下：
<!-- tabs:end -->


```java
@Component
public class MovieRecommender {

    private final String catalog;

    public MovieRecommender(@Value("${catalog.name:defaultCatalog}") String catalog) {
        this.catalog = catalog;
    }
}
```

<!-- tabs:start -->

#### ** English **

A Spring `BeanPostProcessor` uses a `ConversionService` behind the scene to handle the process for converting the String value in `@Value` to the target type. If you want to provide conversion support for your own custom type, you can provide your own `ConversionService` bean instance as the following example shows:
#### ** Chinese **

一个 Spring `BeanPostProcessor`在后台使用`ConversionService`来处理将`@Value`中的String值转换为目标类型的过程。如果你想为自己的自定义类型提供转换支持，你可以提供自己的`ConversionService` bean实例，如下例所示。
<!-- tabs:end -->


```java
@Configuration
public class AppConfig {

    @Bean
    public ConversionService conversionService() {
        DefaultFormattingConversionService conversionService = new DefaultFormattingConversionService();
        conversionService.addConverter(new MyCustomConverter());
        return conversionService;
    }
}
```

<!-- tabs:start -->

#### ** English **

When `@Value` contains a [`SpEL`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#expressions)[ expression](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#expressions) the value will be dynamically computed at runtime as the following example shows:
#### ** Chinese **

当`@Value`包含一个[`SpEL`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#expressions)[表达式](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#expressions)时，该值将在运行时动态计算，如下例所示。
<!-- tabs:end -->


```java
@Component
public class MovieRecommender {

    private final String catalog;

    public MovieRecommender(@Value("#{systemProperties['user.catalog'] + 'Catalog' }") String catalog) {
        this.catalog = catalog;
    }
}
```

<!-- tabs:start -->

#### ** English **

SpEL also enables the use of more complex data structures:
#### ** Chinese **

SpEL还可以使用更复杂的数据结构。
<!-- tabs:end -->


```java
@Component
public class MovieRecommender {

    private final Map<String, Integer> countOfMoviesPerCatalog;

    public MovieRecommender(
            @Value("#{{'Thriller': 100, 'Comedy': 300}}") Map<String, Integer> countOfMoviesPerCatalog) {
        this.countOfMoviesPerCatalog = countOfMoviesPerCatalog;
    }
}
```

### **1.9.9. Using** **`@PostConstruct`** ** and** **`@PreDestroy`** 

<!-- tabs:start -->

#### ** English **

The `CommonAnnotationBeanPostProcessor` not only recognizes the `@Resource` annotation but also the JSR-250 lifecycle annotations: `javax.annotation.PostConstruct` and `javax.annotation.PreDestroy`. Introduced in Spring 2.5, the support for these annotations offers an alternative to the lifecycle callback mechanism described in [initialization callbacks](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-lifecycle-initializingbean) and [destruction callbacks](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-lifecycle-disposablebean). Provided that the `CommonAnnotationBeanPostProcessor` is registered within the Spring `ApplicationContext`, a method carrying one of these annotations is invoked at the same point in the lifecycle as the corresponding Spring lifecycle interface method or explicitly declared callback method. In the following example, the cache is pre-populated upon initialization and cleared upon destruction:
#### ** Chinese **

`CommonAnnotationBeanPostProcessor`不仅可以识别`@Resource`注解，还可以识别JSR-250生命周期注解。 `javax.annotation.PostConstruct`和`javax.annotation.PreDestroy`。这些注解在Spring 2.5中引入，对这些注解的支持提供了一个替代[初始化回调](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-lifecycle-initializingbean)和[销毁回调](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-lifecycle-disposablebean)中描述的生命周期回调机制。只要 `CommonAnnotationBeanPostProcessor`在Spring `ApplicationContext`中注册了</x>，那么携带这些注解之一的方法就会在生命周期中的同一时间点与相应的Spring生命周期接口方法或显式声明的回调方法一起被调用。在下面的例子中，缓存在初始化时被预填充，销毁时被清除。
<!-- tabs:end -->


```java
public class CachingMovieLister {

    @PostConstruct
    public void populateMovieCache() {
        // populates the movie cache upon initialization...
    }

    @PreDestroy
    public void clearMovieCache() {
        // clears the movie cache upon destruction...
    }
}
```

<!-- tabs:start -->

#### ** English **

For details about the effects of combining various lifecycle mechanisms, see [Combining Lifecycle Mechanisms](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-lifecycle-combined-effects).
#### ** Chinese **

关于结合各种生命周期机制的效果，详见【结合生命周期机制】(https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-lifecycle-combined-effects)。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Like `@Resource`, the `@PostConstruct` and `@PreDestroy` annotation types were a part of the standard Java libraries from JDK 6 to 8. However, the entire `javax.annotation` package got separated from the core Java modules in JDK 9 and eventually removed in JDK 11. If needed, the `javax.annotation-api` artifact needs to be obtained via Maven Central now, simply to be added to the application’s classpath like any other library.
#### ** Chinese **

和 `@Resource`一样，`@PostConstruct`和`@PreDestroy`注解类型也是JDK 6到8的标准Java库的一部分。然而，整个 `javax.annotation` 包在 JDK 9 中从核心 Java 模块中分离出来，最终在 JDK 11 中被删除。如果需要，现在需要通过Maven Central获得`javax.annotation-api`工件，只需像其他库一样添加到应用程序的classpath中即可。
<!-- tabs:end -->



[下一章](Spring-Framework-5.2.6.RELEASE/Core%20Technologies/1.10.%20Classpath%20Scanning%20and%20Managed%20Components.md)


[回目录](Spring-Framework-5.2.6.RELEASE/summary.md)

[回首页](/README)
