# 1.15. Additional Capabilities of the ApplicationContext

<!-- tabs:start -->

#### ** English **

As discussed in the [chapter introduction](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans), the `org.springframework.beans.factory` package provides basic functionality for managing and manipulating beans, including in a programmatic way. The `org.springframework.context` package adds the [`ApplicationContext`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/context/ApplicationContext.html) interface, which extends the `BeanFactory` interface, in addition to extending other interfaces to provide additional functionality in a more application framework-oriented style. Many people use the `ApplicationContext` in a completely declarative fashion, not even creating it programmatically, but instead relying on support classes such as `ContextLoader` to automatically instantiate an `ApplicationContext` as part of the normal startup process of a Java EE web application.
#### ** Chinese **

正如在[章节介绍](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans)中所讨论的那样，`org.springframework.beans.factory`包提供了管理和操作Bean的基本功能，包括以程序化的方式。`org.springframework.context`包增加了[`ApplicationContext`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/context/ApplicationContext.html)接口，该接口除了扩展了`BeanFactory`接口外，还扩展了其他接口，以更多面向应用框架的风格提供额外的功能。许多人完全以声明式的方式使用`ApplicationContext`，甚至不以程序化的方式创建它，而是依靠支持类，如`ContextLoader`来自动实例化一个`ApplicationContext`，作为Java EE Web应用程序正常启动过程的一部分。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

To enhance `BeanFactory` functionality in a more framework-oriented style, the context package also provides the following functionality:
#### ** Chinese **

为了以更加面向框架的风格增强`BeanFactory`功能，上下文包还提供了以下功能。
<!-- tabs:end -->


### **1.15.1. Internationalization using** **`MessageSource`** 

<!-- tabs:start -->

#### ** English **

The `ApplicationContext` interface extends an interface called `MessageSource` and, therefore, provides internationalization (“i18n”) functionality. Spring also provides the `HierarchicalMessageSource` interface, which can resolve messages hierarchically. Together, these interfaces provide the foundation upon which Spring effects message resolution. The methods defined on these interfaces include:
#### ** Chinese **

`ApplicationContext`接口扩展了一个名为`MessageSource`的接口，因此，它提供了国际化（"i18n"）功能。Spring还提供了`HierarchicalMessageSource`接口，它可以分层解析消息。这些接口共同提供了Spring对消息解析的基础。这些接口上定义的方法包括。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

- Access to messages in i18n-style, through the `MessageSource` interface.

- Access to resources, such as URLs and files, through the `ResourceLoader` interface.

- Event publication, namely to beans that implement the `ApplicationListener` interface, through the use of the `ApplicationEventPublisher` interface.

- Loading of multiple (hierarchical) contexts, letting each be focused on one particular layer, such as the web layer of an application, through the `HierarchicalBeanFactory` interface.

- `String getMessage(String code, Object[] args, String default, Locale loc)`: The basic method used to retrieve a message from the `MessageSource`. When no message is found for the specified locale, the default message is used. Any arguments passed in become replacement values, using the `MessageFormat` functionality provided by the standard library.

- `String getMessage(String code, Object[] args, Locale loc)`: Essentially the same as the previous method but with one difference: No default message can be specified. If the message cannot be found, a `NoSuchMessageException` is thrown.

- `String getMessage(MessageSourceResolvable resolvable, Locale locale)`: All properties used in the preceding methods are also wrapped in a class named `MessageSourceResolvable`, which you can use with this method.

#### ** Chinese **

- 通过`MessageSource`接口，以i18n风格访问消息。

- 通过`ResourceLoader`接口访问资源，如URLs和文件。

- 事件发布，即通过使用`ApplicationEventPublisher`接口，向实现`ApplicationListener`接口的Bean发布事件。

- 通过使用`HierarchicalBeanFactory`接口，加载多个（分层）上下文，让每个上下文都集中在一个特定的层上，例如应用程序的web层。

- `String getMessage(String code, Object[] args, String default, Locale loc)`：基本方法，用于从`MessageSource`中获取消息。如果没有找到指定的locale的消息，则使用默认的消息。使用标准库提供的`MessageFormat`功能，传入的任何参数都将成为替换值。

- `String getMessage(String code, Object[] args, Locale loc)`: 基本上与前一个方法相同，但有一个区别。不能指定默认消息。如果找不到消息，会抛出一个`NoSuchMessageException`。

- `String getMessage(MessageSourceResolvable resolvable, Locale locale)`。在前面的方法中使用的所有属性也被封装在一个名为`MessageSourceResolvable`的类中，你可以使用这个方法。

<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

When an `ApplicationContext` is loaded, it automatically searches for a `MessageSource` bean defined in the context. The bean must have the name `messageSource`. If such a bean is found, all calls to the preceding methods are delegated to the message source. If no message source is found, the `ApplicationContext` attempts to find a parent containing a bean with the same name. If it does, it uses that bean as the `MessageSource`. If the `ApplicationContext` cannot find any source for messages, an empty `DelegatingMessageSource` is instantiated in order to be able to accept calls to the methods defined above.
#### ** Chinese **

当加载`ApplicationContext`时，它会自动搜索在上下文中定义的`MessageSource` bean。该Bean必须具有`messageSource`的名称。如果找到了这样一个Bean，那么所有对前面的方法的调用都会被委托给消息源。如果没有找到消息源，`ApplicationContext`就会尝试找到一个包含同名Bean的父对象。如果找到了，它将使用该Bean作为`MessageSource`。如果 `ApplicationContext`无法找到任何消息源，则会实例化一个空的`DelegatingMessageSource`，以便能够接受对上面定义的方法的调用。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Spring provides two `MessageSource` implementations, `ResourceBundleMessageSource` and `StaticMessageSource`. Both implement `HierarchicalMessageSource` in order to do nested messaging. The `StaticMessageSource` is rarely used but provides programmatic ways to add messages to the source. The following example shows `ResourceBundleMessageSource`:
#### ** Chinese **

Spring提供了两种`MessageSource`实现，即`ResourceBundleMessageSource`和`StaticMessageSource`。两者都实现了`HierarchicalMessageSource`，以便进行嵌套消息传递。`StaticMessageSource`很少使用，但提供了程序化的方式来添加消息源。下面的例子显示了`ResourceBundleMessageSource`。
<!-- tabs:end -->


```xml
<beans>
    <bean id="messageSource"
            class="org.springframework.context.support.ResourceBundleMessageSource">
        <property name="basenames">
            <list>
                <value>format</value>
                <value>exceptions</value>
                <value>windows</value>
            </list>
        </property>
    </bean>
</beans>
```

<!-- tabs:start -->

#### ** English **

The example assumes that you have three resource bundles called `format`, `exceptions` and `windows` defined in your classpath. Any request to resolve a message is handled in the JDK-standard way of resolving messages through `ResourceBundle` objects. For the purposes of the example, assume the contents of two of the above resource bundle files are as follows:
#### ** Chinese **

这个例子假设你在classpath中定义了三个资源包，分别是`format`、`exceptions`和`windows`。任何解决消息的请求都是以 JDK 标准的方式通过 `ResourceBundle` 对象来处理的。在本例中，假设上述两个资源包文件的内容如下。
<!-- tabs:end -->


# in format.properties message=Alligators rock!

# in exceptions.properties argument.required=The {0} argument is required.

<!-- tabs:start -->

#### ** English **

The next example shows a program to execute the `MessageSource` functionality. Remember that all `ApplicationContext` implementations are also `MessageSource` implementations and so can be cast to the `MessageSource` interface.
#### ** Chinese **

下面的例子显示了一个执行`MessageSource`功能的程序。请记住，所有的 `ApplicationContext`实现也是`MessageSource`的实现，因此可以投向`MessageSource`接口。
<!-- tabs:end -->


```java
public static void main(String[] args) {
    MessageSource resources = new ClassPathXmlApplicationContext("beans.xml");
    String message = resources.getMessage("message", null, "Default", Locale.ENGLISH);
    System.out.println(message);
}
```

<!-- tabs:start -->

#### ** English **

The resulting output from the above program is as follows:
#### ** Chinese **

上述程序的输出结果如下。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Alligators rock!
#### ** Chinese **

大鳄们的摇滚！
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

To summarize, the `MessageSource` is defined in a file called `beans.xml`, which exists at the root of your classpath. The `messageSource` bean definition refers to a number of resource bundles through its `basenames` property. The three files that are passed in the list to the `basenames` property exist as files at the root of your classpath and are called `format.properties`, `exceptions.properties`, and `windows.properties`, respectively.
#### ** Chinese **

简而言之，`MessageSource`定义在一个名为`beans.xml`的文件中，它存在于classpath的根目录下。`messageSource` bean定义通过它的`basenames`属性引用了许多资源包。列表中传递给`basenames`属性的三个文件作为文件存在于classpath的根目录下，分别称为`format.properties`、`exceptions.properties`和`windows.properties`。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The next example shows arguments passed to the message lookup. These arguments are converted into `String` objects and inserted into placeholders in the lookup message.
#### ** Chinese **

下面的例子显示了传递给消息查找的参数。这些参数被转换为`String`对象，并插入到查找消息中的占位符中。
<!-- tabs:end -->


```xml
<beans>

    <!-- this MessageSource is being used in a web application -->
    <bean id="messageSource" class="org.springframework.context.support.ResourceBundleMessageSource">
        <property name="basename" value="exceptions"/>
    </bean>

    <!-- lets inject the above MessageSource into this POJO -->
    <bean id="example" class="com.something.Example">
        <property name="messages" ref="messageSource"/>
    </bean>

</beans>
```

```java
public class Example {

    private MessageSource messages;

    public void setMessages(MessageSource messages) {
        this.messages = messages;
    }

    public void execute() {
        String message = this.messages.getMessage("argument.required",
            new Object [] {"userDao"}, "Required", Locale.ENGLISH);
        System.out.println(message);
    }
}
```

<!-- tabs:start -->

#### ** English **

The resulting output from the invocation of the `execute()` method is as follows:
#### ** Chinese **

调用`execute()`方法所产生的输出如下。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The userDao argument is required.
#### ** Chinese **

用户Dao参数是必须的。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

With regard to internationalization (“i18n”), Spring’s various `MessageSource` implementations follow the same locale resolution and fallback rules as the standard JDK `ResourceBundle`. In short, and continuing with the example `messageSource` defined previously, if you want to resolve messages against the British (`en-GB`) locale, you would create files called `format_en_GB.properties`, `exceptions_en_GB.properties`, and `windows_en_GB.properties`, respectively.
#### ** Chinese **

关于国际化（"i18n"），Spring的各种`MessageSource`实现与标准的JDK `ResourceBundle`遵循相同的locale解析和回退规则。简而言之，继续之前定义的例子 `messageSource`，如果你想根据英国（`en-GB`）的 locale 来解析消息，你将创建分别名为 `format_en_GB.properties`、`exceptions_en_GB.properties` 和 `windows_en_GB.properties`的文件。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Typically, locale resolution is managed by the surrounding environment of the application. In the following example, the locale against which (British) messages are resolved is specified manually:
#### ** Chinese **

通常情况下，locale解析是由应用程序的周围环境管理的。在下面的例子中，手动指定了（英式）消息解析所对应的地域类型。
<!-- tabs:end -->


# in exceptions_en_GB.properties
<!-- tabs:start -->

#### ** English **

argument.required=Ebagum lad, the ''{0}'' argument is required, I say, required.
#### ** Chinese **

argument.required=Ebagum lad，{0}参数是需要的，我说，需要。
<!-- tabs:end -->


```java
public static void main(final String[] args) {
    MessageSource resources = new ClassPathXmlApplicationContext("beans.xml");
    String message = resources.getMessage("argument.required",
        new Object [] {"userDao"}, "Required", Locale.UK);
    System.out.println(message);
}
```

<!-- tabs:start -->

#### ** English **

The resulting output from the running of the above program is as follows:
#### ** Chinese **

上述程序运行后的输出结果如下。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Ebagum lad, the 'userDao' argument is required, I say, required.
#### ** Chinese **

Ebagum小伙子，userDao参数是必须的，我说，必须的。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can also use the `MessageSourceAware` interface to acquire a reference to any `MessageSource` that has been defined. Any bean that is defined in an `ApplicationContext` that implements the `MessageSourceAware` interface is injected with the application context’s `MessageSource` when the bean is created and configured.
#### ** Chinese **

你也可以使用`MessageSourceAware`接口来获取对任何已定义的`MessageSource`的引用。当Bean被创建和配置时，在实现了`ApplicationContext`接口的`ApplicationContext`中定义的任何Bean都会被注入应用上下文的`MessageSource`接口。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

As an alternative to `ResourceBundleMessageSource`, Spring provides a `ReloadableResourceBundleMessageSource` class. This variant supports the same bundle file format but is more flexible than the standard JDK based `ResourceBundleMessageSource` implementation. In particular, it allows for reading files from any Spring resource location (not only from the classpath) and supports hot reloading of bundle property files (while efficiently caching them in between). See the [`ReloadableResourceBundleMessageSource`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/context/support/ReloadableResourceBundleMessageSource.html) javadoc for details.
#### ** Chinese **

作为 `ResourceBundleMessageSource`的替代方案，Spring提供了一个`ReloadableResourceBundleMessageSource`类。这个变体支持相同的 bundle 文件格式，但比标准的基于 JDK 的 `ResourceBundleMessageSource` 实现更加灵活。特别是，它允许从任何Spring资源位置读取文件（不仅从classpath），还支持热重载bundle属性文件（同时在两者之间有效地缓存）。详情请参阅 [`ReloadableResourceBundleMessageSource`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/context/support/ReloadableResourceBundleMessageSource.html) javadoc。
<!-- tabs:end -->


### **1.15.2. Standard and Custom Events** 

<!-- tabs:start -->

#### ** English **

Event handling in the `ApplicationContext` is provided through the `ApplicationEvent` class and the `ApplicationListener` interface. If a bean that implements the `ApplicationListener` interface is deployed into the context, every time an `ApplicationEvent` gets published to the `ApplicationContext`, that bean is notified. Essentially, this is the standard Observer design pattern.
#### ** Chinese **

`ApplicationContext`中的事件处理是通过`ApplicationEvent`类和`ApplicationListener`接口提供的。如果一个实现了`ApplicationListener`接口的Bean被部署到上下文中，那么每当`ApplicationEvent`发布到`ApplicationContext`时，该Bean就会被通知。基本上，这就是标准的 Observer 设计模式。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

As of Spring 4.2, the event infrastructure has been significantly improved and offers an [annotation-based model](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#context-functionality-events-annotation) as well as the ability to publish any arbitrary event (that is, an object that does not necessarily extend from `ApplicationEvent`). When such an object is published, we wrap it in an event for you.
#### ** Chinese **

从Spring 4.2开始，事件基础设施得到了显著的改进，提供了一个[基于注解的模型](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#context-functionality-events-annotation)以及发布任意事件的能力（即不一定从`ApplicationEvent`扩展的对象）。当这样的对象被发布时，我们将其封装在一个事件中。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following table describes the standard events that Spring provides:
#### ** Chinese **

下面的表格描述了Spring提供的标准事件。
<!-- tabs:end -->


Event | Explanation 
-|-
ContextRefreshedEvent | Published when the ApplicationContext is initialized or refreshed (for example, by using the refresh() method on the ConfigurableApplicationContext interface). Here, “initialized” means that all beans are loaded, post-processor beans are detected and activated, singletons are pre-instantiated, and the ApplicationContext object is ready for use. As long as the context has not been closed, a refresh can be triggered multiple times, provided that the chosen ApplicationContext actually supports such “hot” refreshes. For example, XmlWebApplicationContext supports hot refreshes, but GenericApplicationContext does not. 
ContextStartedEvent | Published when the ApplicationContext is started by using the start() method on the ConfigurableApplicationContext interface. Here, “started” means that all Lifecycle beans receive an explicit start signal. Typically, this signal is used to restart beans after an explicit stop, but it may also be used to start components that have not been configured for autostart (for example, components that have not already started on initialization). 
ContextStoppedEvent | Published when the ApplicationContext is stopped by using the stop() method on the ConfigurableApplicationContext interface. Here, “stopped” means that all Lifecycle beans receive an explicit stop signal. A stopped context may be restarted through a start() call. 
ContextClosedEvent | Published when the ApplicationContext is being closed by using the close() method on the ConfigurableApplicationContext interface or via a JVM shutdown hook. Here, "closed" means that all singleton beans will be destroyed. Once the context is closed, it reaches its end of life and cannot be refreshed or restarted. 
RequestHandledEvent | A web-specific event telling all beans that an HTTP request has been serviced. This event is published after the request is complete. This event is only applicable to web applications that use Spring’s DispatcherServlet. 
ServletRequestHandledEvent | A subclass of RequestHandledEvent that adds Servlet-specific context information. 


<!-- tabs:start -->

#### ** English **

You can also create and publish your own custom events. The following example shows a simple class that extends Spring’s `ApplicationEvent` base class:
#### ** Chinese **

你也可以创建和发布你自己的自定义事件。下面的例子显示了一个简单的类，它扩展了Spring的`ApplicationEvent`基类。
<!-- tabs:end -->


```java
public class BlackListEvent extends ApplicationEvent {

    private final String address;
    private final String content;

    public BlackListEvent(Object source, String address, String content) {
        super(source);
        this.address = address;
        this.content = content;
    }

    // accessor and other methods...
}
```

<!-- tabs:start -->

#### ** English **

To publish a custom `ApplicationEvent`, call the `publishEvent()` method on an `ApplicationEventPublisher`. Typically, this is done by creating a class that implements `ApplicationEventPublisherAware` and registering it as a Spring bean. The following example shows such a class:
#### ** Chinese **

要发布自定义的`ApplicationEvent`，请在`ApplicationEventPublisher`上调用`publishEvent()`方法。通常情况下，可以通过创建一个实现`ApplicationEventPublisherAware`的类并将其注册为Spring Bean来实现。下面的例子显示了这样一个类。
<!-- tabs:end -->


```java
public class EmailService implements ApplicationEventPublisherAware {

    private List<String> blackList;
    private ApplicationEventPublisher publisher;

    public void setBlackList(List<String> blackList) {
        this.blackList = blackList;
    }

    public void setApplicationEventPublisher(ApplicationEventPublisher publisher) {
        this.publisher = publisher;
    }

    public void sendEmail(String address, String content) {
        if (blackList.contains(address)) {
            publisher.publishEvent(new BlackListEvent(this, address, content));
            return;
        }
        // send email...
    }
}
```

<!-- tabs:start -->

#### ** English **

At configuration time, the Spring container detects that `EmailService` implements `ApplicationEventPublisherAware` and automatically calls `setApplicationEventPublisher()`. In reality, the parameter passed in is the Spring container itself. You are interacting with the application context through its `ApplicationEventPublisher` interface.
#### ** Chinese **

在配置时，Spring容器会检测到`EmailService`实现了`ApplicationEventPublisherAware`，并自动调用`setApplicationEventPublisher()`。实际上，传入的参数是Spring容器本身。您是通过其`ApplicationEventPublisher`接口与应用程序上下文进行交互。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

To receive the custom `ApplicationEvent`, you can create a class that implements `ApplicationListener` and register it as a Spring bean. The following example shows such a class:
#### ** Chinese **

要接收自定义的`ApplicationEvent`，可以创建一个实现`ApplicationListener`的类，并将其注册为Spring Bean。下面的例子显示了这样一个类。
<!-- tabs:end -->


```java
public class BlackListNotifier implements ApplicationListener<BlackListEvent> {

    private String notificationAddress;

    public void setNotificationAddress(String notificationAddress) {
        this.notificationAddress = notificationAddress;
    }

    public void onApplicationEvent(BlackListEvent event) {
        // notify appropriate parties via notificationAddress...
    }
}
```

<!-- tabs:start -->

#### ** English **

Notice that `ApplicationListener` is generically parameterized with the type of your custom event (`BlackListEvent` in the preceding example). This means that the `onApplicationEvent()` method can remain type-safe, avoiding any need for downcasting. You can register as many event listeners as you wish, but note that, by default, event listeners receive events synchronously. This means that the `publishEvent()` method blocks until all listeners have finished processing the event. One advantage of this synchronous and single-threaded approach is that, when a listener receives an event, it operates inside the transaction context of the publisher if a transaction context is available. If another strategy for event publication becomes necessary, see the javadoc for Spring’s [`ApplicationEventMulticaster`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/context/event/ApplicationEventMulticaster.html) interface and [`SimpleApplicationEventMulticaster`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/context/event/SimpleApplicationEventMulticaster.html) implementation for configuration options.
#### ** Chinese **

请注意，`ApplicationListener`是用自定义事件的类型（在前面的例子中，`BlackListEvent`）来通用参数化的。这意味着`onApplicationEvent()`方法可以保持类型安全，避免了任何下划线的需要。你可以注册任意数量的事件监听器，但请注意，默认情况下，事件监听器是同步接收事件。这意味着`publishEvent()`方法会阻塞，直到所有的监听器都完成了事件的处理。这种同步和单线程方法的一个优点是，当监听器接收到一个事件时，如果有事务上下文可用，它将在发布器的事务上下文中操作。如果有必要使用另一种事件发布策略，请参阅Spring的[`ApplicationEventMulticaster`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/context/event/ApplicationEventMulticaster.html)接口和[`SimpleApplicationEventMulticaster`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/context/event/SimpleApplicationEventMulticaster.html)实现的javadoc，了解配置选项。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following example shows the bean definitions used to register and configure each of the classes above:
#### ** Chinese **

下面的示例显示了用于注册和配置上述每个类的Bean定义。
<!-- tabs:end -->


```xml
<bean id="emailService" class="example.EmailService">
    <property name="blackList">
        <list>
            <value>known.spammer@example.org</value>
            <value>known.hacker@example.org</value>
            <value>john.doe@example.org</value>
        </list>
    </property>
</bean>

<bean id="blackListNotifier" class="example.BlackListNotifier">
    <property name="notificationAddress" value="blacklist@example.org"/>
</bean>
```

<!-- tabs:start -->

#### ** English **

Putting it all together, when the `sendEmail()` method of the `emailService` bean is called, if there are any email messages that should be blacklisted, a custom event of type `BlackListEvent` is published. The `blackListNotifier` bean is registered as an `ApplicationListener` and receives the `BlackListEvent`, at which point it can notify appropriate parties.
#### ** Chinese **

综合起来，当`emailService` bean的`sendEmail()`方法被调用时，如果有任何邮件应该被列入黑名单，就会发布一个类型为`BlackListEvent`的自定义事件。`blackListNotifier` bean被注册为`ApplicationListener`，并接收到`BlackListEvent`，这时它可以通知适当的各方。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Spring’s eventing mechanism is designed for simple communication between Spring beans within the same application context. However, for more sophisticated enterprise integration needs, the separately maintained [Spring Integration](https://projects.spring.io/spring-integration/) project provides complete support for building lightweight, [pattern-oriented](https://www.enterpriseintegrationpatterns.com/), event-driven architectures that build upon the well-known Spring programming model.
#### ** Chinese **

Spring的事件处理机制是为同一应用程序上下文中Spring Bean之间的简单通信而设计的。然而，对于更复杂的企业集成需求，单独维护的[Spring Integration](https://projects.spring.io/spring-integration/)项目提供了完整的支持，可用于构建轻量级、[面向模式](https://www.enterpriseintegrationpatterns.com/)、事件驱动的架构，该架构建立在著名的Spring编程模型之上。
<!-- tabs:end -->


### **Annotation-based Event Listeners** 

<!-- tabs:start -->

#### ** English **

As of Spring 4.2, you can register an event listener on any public method of a managed bean by using the `@EventListener` annotation. The `BlackListNotifier` can be rewritten as follows:
#### ** Chinese **

从Spring 4.2开始，你可以通过使用`@EventListener`注解，在被管理的Bean的任何公共方法上注册一个事件监听器。`BlackListNotifier`可以重写如下。
<!-- tabs:end -->


```java
public class BlackListNotifier {

    private String notificationAddress;

    public void setNotificationAddress(String notificationAddress) {
        this.notificationAddress = notificationAddress;
    }

    @EventListener
    public void processBlackListEvent(BlackListEvent event) {
        // notify appropriate parties via notificationAddress...
    }
}
```

<!-- tabs:start -->

#### ** English **

The method signature once again declares the event type to which it listens, but, this time, with a flexible name and without implementing a specific listener interface. The event type can also be narrowed through generics as long as the actual event type resolves your generic parameter in its implementation hierarchy.
#### ** Chinese **

方法签名再一次声明了它所监听的事件类型，但这一次，使用了一个灵活的名称，并且没有实现特定的监听器接口。只要实际的事件类型在其实现层次结构中解决了你的通用参数，事件类型也可以通过通用参数来缩小。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

If your method should listen to several events or if you want to define it with no parameter at all, the event types can also be specified on the annotation itself. The following example shows how to do so:
#### ** Chinese **

如果你的方法应该监听多个事件，或者你想在没有参数的情况下定义它，那么事件类型也可以在注解本身上指定。下面的例子说明了如何做到这一点。
<!-- tabs:end -->


```java
@EventListener({ContextStartedEvent.class, ContextRefreshedEvent.class})
public void handleContextStart() {
    // ...
}
```

<!-- tabs:start -->

#### ** English **

It is also possible to add additional runtime filtering by using the `condition` attribute of the annotation that defines a [`SpEL`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#expressions)[ expression](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#expressions) , which should match to actually invoke the method for a particular event.
#### ** Chinese **

也可以通过使用注解的`condition`属性来增加额外的运行时过滤，该属性定义了一个[`SpEL`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#expressions)[expression](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#expressions)，该属性应该匹配到实际调用特定事件的方法。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following example shows how our notifier can be rewritten to be invoked only if the `content` attribute of the event is equal to `my-event`:
#### ** Chinese **

下面的例子显示了我们的notifier如何被重写，只有当事件的`content`属性等于`my-event`时，才能被调用。
<!-- tabs:end -->


```java
@EventListener(condition = "#blEvent.content == 'my-event'")
public void processBlackListEvent(BlackListEvent blEvent) {
    // notify appropriate parties via notificationAddress...
}
```

<!-- tabs:start -->

#### ** English **

Each `SpEL` expression evaluates against a dedicated context. The following table lists the items made available to the context so that you can use them for conditional event processing:
#### ** Chinese **

每个 `SpEL`表达式都会对专用上下文进行评估。下表列出了提供给上下文的项目，以便你可以使用它们来处理条件事件。
<!-- tabs:end -->


Name | Location | Description | Example 
-|-|-|-
Event | root object | The actual ApplicationEvent. | #root.event or event 
Arguments array | root object | The arguments (as an object array) used to invoke the method. | #root.args or args; args[0] to access the first argument, etc. 
Argument name | evaluation context | The name of any of the method arguments. If, for some reason, the names are not available (for example, because there is no debug information in the compiled byte code), individual arguments are also available using the #a<#arg> syntax where <#arg> stands for the argument index (starting from 0). | #blEvent or #a0 (you can also use #p0 or #p<#arg> parameter notation as an alias) 


<!-- tabs:start -->

#### ** English **

Note that `#root.event` gives you access to the underlying event, even if your method signature actually refers to an arbitrary object that was published.
#### ** Chinese **

请注意，`#root.event`让你可以访问底层事件，即使你的方法签名实际上是引用了一个被发布的任意对象。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

If you need to publish an event as the result of processing another event, you can change the method signature to return the event that should be published, as the following example shows:
#### ** Chinese **

如果你需要将一个事件作为处理另一个事件的结果来发布，你可以改变方法签名来返回应该发布的事件，如下例所示。
<!-- tabs:end -->


```java
@EventListener
public ListUpdateEvent handleBlackListEvent(BlackListEvent event) {
    // notify appropriate parties via notificationAddress and
    // then publish a ListUpdateEvent...
}
```

<!-- tabs:start -->

#### ** English **

This feature is not supported for [asynchronous listeners](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#context-functionality-events-async).
#### ** Chinese **

此功能不支持【异步监听器】(https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#context-functionality-events-async)。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

This new method publishes a new `ListUpdateEvent` for every `BlackListEvent` handled by the method above. If you need to publish several events, you can return a `Collection` of events instead.
#### ** Chinese **

这个新方法为上述方法处理的每一个`BlackListEvent`都会发布一个新的`ListUpdateEvent`。如果你需要发布多个事件，你可以返回一个事件的 `Collection`来代替。
<!-- tabs:end -->


### **Asynchronous Listeners** 

<!-- tabs:start -->

#### ** English **

If you want a particular listener to process events asynchronously, you can reuse the [regular ](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#scheduling-annotation-support-async)[`@Async`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#scheduling-annotation-support-async)[ support](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#scheduling-annotation-support-async). The following example shows how to do so:
#### ** Chinese **

如果你想让某个特定的监听器异步处理事件，可以重用[regular ](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#scheduling-annotation-support-async)[`@Async`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#scheduling-annotation-support-async)[ support](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#scheduling-annotation-support-async)。下面的例子显示了如何做到这一点。
<!-- tabs:end -->


```java
@EventListener
@Async
public void processBlackListEvent(BlackListEvent event) {
    // BlackListEvent is processed in a separate thread
}
```

<!-- tabs:start -->

#### ** English **

Be aware of the following limitations when using asynchronous events:
#### ** Chinese **

使用异步事件时要注意以下限制。
<!-- tabs:end -->


### **Ordering Listeners** 

<!-- tabs:start -->

#### ** English **

If you need one listener to be invoked before another one, you can add the `@Order` annotation to the method declaration, as the following example shows:
#### ** Chinese **

如果你需要一个监听器在另一个监听器之前被调用，你可以在方法声明中添加`@Order`注解，如下例所示。
<!-- tabs:end -->


```java
@EventListener
@Order(42)
public void processBlackListEvent(BlackListEvent event) {
    // notify appropriate parties via notificationAddress...
}
```

### **Generic Events** 

<!-- tabs:start -->

#### ** English **

You can also use generics to further define the structure of your event. Consider using an `EntityCreatedEvent<T>` where `T` is the type of the actual entity that got created. For example, you can create the following listener definition to receive only `EntityCreatedEvent` for a `Person`:
#### ** Chinese **

你也可以使用泛函来进一步定义事件的结构。考虑使用`EntityCreatedEvent<T>`，其中`T`是实际创建的实体的类型。例如，你可以创建下面的监听器定义，以便只接收`EntityCreatedEvent`的`Person`。
<!-- tabs:end -->


```java
@EventListener
public void onPersonCreated(EntityCreatedEvent<Person> event) {
    // ...
}
```

<!-- tabs:start -->

#### ** English **

Due to type erasure, this works only if the event that is fired resolves the generic parameters on which the event listener filters (that is, something like `class PersonCreatedEvent extends EntityCreatedEvent<Person> { …​ }`).
#### ** Chinese **

由于类型擦除的原因，只有当被触发的事件解析了事件监听器过滤的通用参数（即像`class PersonCreatedEvent extends EntityCreatedEvent<Person> { …​ }`这样的东西）时，这才会起作用。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

In certain circumstances, this may become quite tedious if all events follow the same structure (as should be the case for the event in the preceding example). In such a case, you can implement `ResolvableTypeProvider` to guide the framework beyond what the runtime environment provides. The following event shows how to do so:
#### ** Chinese **

在某些情况下，如果所有的事件都遵循相同的结构（就像前面例子中的事件一样），这可能会变得相当乏味。在这种情况下，你可以实现`ResolvableTypeProvider`来引导框架超越运行时环境所提供的内容。下面的事件显示了如何做到这一点。
<!-- tabs:end -->


```java
public class EntityCreatedEvent<T> extends ApplicationEvent implements ResolvableTypeProvider {

    public EntityCreatedEvent(T entity) {
        super(entity);
    }

    @Override
    public ResolvableType getResolvableType() {
        return ResolvableType.forClassWithGenerics(getClass(), ResolvableType.forInstance(getSource()));
    }
}
```

<!-- tabs:start -->

#### ** English **

This works not only for `ApplicationEvent` but any arbitrary object that you send as an event.
#### ** Chinese **

这不仅适用于`ApplicationEvent`，也适用于你作为事件发送的任何任意对象。
<!-- tabs:end -->


### **1.15.3. Convenient Access to Low-level Resources** 

<!-- tabs:start -->

#### ** English **

For optimal usage and understanding of application contexts, you should familiarize yourself with Spring’s `Resource` abstraction, as described in [Resources](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#resources).
#### ** Chinese **

为了获得最佳的使用和理解应用上下文，你应该熟悉Spring的`Resource`抽象，如[Resources](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#resources)中描述的那样。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

An application context is a `ResourceLoader`, which can be used to load `Resource` objects. A `Resource` is essentially a more feature rich version of the JDK `java.net.URL` class. In fact, the implementations of the `Resource` wrap an instance of `java.net.URL`, where appropriate. A `Resource` can obtain low-level resources from almost any location in a transparent fashion, including from the classpath, a filesystem location, anywhere describable with a standard URL, and some other variations. If the resource location string is a simple path without any special prefixes, where those resources come from is specific and appropriate to the actual application context type.
#### ** Chinese **

应用程序上下文是一个`ResourceLoader`，它可以用来加载`Resource`对象。`Resource`本质上是JDK `java.net.URL`类的一个更丰富的功能版本。事实上，`Resource`的实现会在适当的情况下包裹一个`java.net.URL`的实例。`Resource`可以从几乎任何位置以透明的方式获取低级资源，包括从classpath、文件系统位置、任何可以用标准URL描述的地方以及其他一些变体。如果资源位置字符串是一个简单的路径，没有任何特殊的前缀，那么这些资源的来源是特定的，并且适合于实际应用上下文类型。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can configure a bean deployed into the application context to implement the special callback interface, `ResourceLoaderAware`, to be automatically called back at initialization time with the application context itself passed in as the `ResourceLoader`. You can also expose properties of type `Resource`, to be used to access static resources. They are injected into it like any other properties. You can specify those `Resource` properties as simple `String` paths and rely on automatic conversion from those text strings to actual `Resource` objects when the bean is deployed.
#### ** Chinese **

你可以配置一个部署到应用程序上下文中的Bean，以实现特殊的回调接口`ResourceLoaderAware`，以便在初始化时自动回调，并将应用程序上下文本身作为`ResourceLoader`传递进来。你也可以公开类型为`Resource`的属性，用于访问静态资源。它们会像其他属性一样被注入到其中。你可以将这些`Resource`属性指定为简单的`String`路径，并在部署Bean时依靠这些文本字符串自动转换为实际的`Resource`对象。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The location path or paths supplied to an `ApplicationContext` constructor are actually resource strings and, in simple form, are treated appropriately according to the specific context implementation. For example `ClassPathXmlApplicationContext` treats a simple location path as a classpath location. You can also use location paths (resource strings) with special prefixes to force loading of definitions from the classpath or a URL, regardless of the actual context type.
#### ** Chinese **

提供给`ApplicationContext`构造函数的位置路径或路径实际上是资源字符串，用简单的形式来说，就是根据具体的上下文实现来适当处理。例如`ClassPathXmlApplicationContext`将简单的位置路径作为classpath位置处理。你也可以使用带有特殊前缀的位置路径（资源字符串）来强制加载来自classpath或URL的定义，而不考虑实际的上下文类型。
<!-- tabs:end -->


### **1.15.4. Convenient ApplicationContext Instantiation for Web Applications** 

<!-- tabs:start -->

#### ** English **

You can create `ApplicationContext` instances declaratively by using, for example, a `ContextLoader`. Of course, you can also create `ApplicationContext` instances programmatically by using one of the `ApplicationContext` implementations.
#### ** Chinese **

你可以通过使用`ApplicationContext`声明性地创建`ApplicationContext`实例，例如，使用`ContextLoader`。当然，您也可以通过使用 `ApplicationContext`实现中的一个`ApplicationContext`实例来编程地创建`ApplicationContext`实例。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can register an `ApplicationContext` by using the `ContextLoaderListener`, as the following example shows:
#### ** Chinese **

您可以通过使用`ContextLoaderListener`来注册一个`ApplicationContext`，如下例所示。
<!-- tabs:end -->


```xml
<context-param>
    <param-name>contextConfigLocation</param-name>
    <param-value>/WEB-INF/daoContext.xml /WEB-INF/applicationContext.xml</param-value>
</context-param>

<listener>
    <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
</listener>
```

<!-- tabs:start -->

#### ** English **

The listener inspects the `contextConfigLocation` parameter. If the parameter does not exist, the listener uses `/WEB-INF/applicationContext.xml` as a default. When the parameter does exist, the listener separates the `String` by using predefined delimiters (comma, semicolon, and whitespace) and uses the values as locations where application contexts are searched. Ant-style path patterns are supported as well. Examples are `/WEB-INF/*Context.xml` (for all files with names that end with `Context.xml` and that reside in the `WEB-INF` directory) and `/WEB-INF/**/*Context.xml` (for all such files in any subdirectory of `WEB-INF`).
#### ** Chinese **

监听器检查`contextConfigLocation`参数。如果该参数不存在，监听器将使用`/WEB-INF/applicationContext.xml`作为默认值。如果该参数确实存在，监听器会使用预定义的分隔符（逗号、分号和空格）来分隔`String`，并使用这些值作为应用程序上下文搜索的位置。也支持Ant风格的路径模式。例如 `/WEB-INF/*Context.xml` (用于所有名称以`Context.xml`结尾且位于`WEB-INF`目录中的所有文件)和`/WEB-INF/**/*Context.xml` (用于`WEB-INF`的任何子目录中的所有此类文件)。
<!-- tabs:end -->


### **1.15.5. Deploying a Spring** **`ApplicationContext`** ** as a Java EE RAR File** 

<!-- tabs:start -->

#### ** English **

It is possible to deploy a Spring `ApplicationContext` as a RAR file, encapsulating the context and all of its required bean classes and library JARs in a Java EE RAR deployment unit. This is the equivalent of bootstrapping a stand-alone `ApplicationContext` (only hosted in Java EE environment) being able to access the Java EE servers facilities. RAR deployment is a more natural alternative to a scenario of deploying a headless WAR file — in effect, a WAR file without any HTTP entry points that is used only for bootstrapping a Spring `ApplicationContext` in a Java EE environment.
#### ** Chinese **

可以将Spring `ApplicationContext`作为一个RAR文件来部署，将上下文和所有所需的Bean类和库JAR封装在一个Java EE RAR部署单元中。这相当于引导一个独立的`ApplicationContext`（仅在Java EE环境中托管）能够访问Java EE服务器的设施。RAR 部署是一种更自然的替代方案，它比部署一个无头的 WAR 文件更自然--实际上，一个没有任何 HTTP 入口点的 WAR 文件，只用于在 Java EE 环境中引导 Spring `ApplicationContext` 的引导。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

RAR deployment is ideal for application contexts that do not need HTTP entry points but rather consist only of message endpoints and scheduled jobs. Beans in such a context can use application server resources such as the JTA transaction manager and JNDI-bound JDBC `DataSource` instances and JMS `ConnectionFactory` instances and can also register with the platform’s JMX server — all through Spring’s standard transaction management and JNDI and JMX support facilities. Application components can also interact with the application server’s JCA `WorkManager` through Spring’s `TaskExecutor` abstraction.
#### ** Chinese **

RAR部署对于不需要HTTP入口点而仅由消息端点和预定作业组成的应用上下文来说是非常理想的。在这样的上下文中，Bean可以使用应用服务器资源，如JTA事务管理器和JNDI绑定的JDBC `DataSource`实例和JMS `ConnectionFactory`实例，并且还可以在平台的JMX服务器上注册--所有这些都是通过Spring的标准事务管理和JNDI和JMX支持设施来实现的。应用程序组件还可以通过Spring的`TaskExecutor`抽象与应用程序服务器的JCA `WorkManager`进行交互。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

See the javadoc of the [`SpringContextResourceAdapter`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/jca/context/SpringContextResourceAdapter.html) class for the configuration details involved in RAR deployment.
#### ** Chinese **

有关RAR部署中的配置细节，请参阅[`SpringContextResourceAdapter`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/jca/context/SpringContextResourceAdapter.html)类的javadoc。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

For a simple deployment of a Spring ApplicationContext as a Java EE RAR file:
#### ** Chinese **

对于一个简单的Spring ApplicationContext作为Java EE RAR文件的简单部署。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Package all application classes into a RAR file (which is a standard JAR file with a different file extension). .Add all required library JARs into the root of the RAR archive. .Add a `META-INF/ra.xml` deployment descriptor (as shown in the [javadoc for ](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/jca/context/SpringContextResourceAdapter.html)[`SpringContextResourceAdapter`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/jca/context/SpringContextResourceAdapter.html)) and the corresponding Spring XML bean definition file(s) (typically `META-INF/applicationContext.xml`).Drop the resulting RAR file into your application server’s deployment directory.
#### ** Chinese **

.将所有的应用程序类打包成一个RAR文件（这是一个标准的JAR文件，有不同的文件扩展名）。 .将所有所需的库JAR添加到RAR存档的根目录下。.添加一个`META-INF/ra.xml`部署描述符(如[javadoc for ](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/jca/context/SpringContextResourceAdapter.html)[`SpringContextResourceAdapter`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/jca/context/SpringContextResourceAdapter.html)中所示)和相应的Spring XML Bean定义文件(通常是`META-INF/applicationContext.xml`)。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Such RAR deployment units are usually self-contained. They do not expose components to the outside world, not even to other modules of the same application. Interaction with a RAR-based `ApplicationContext` usually occurs through JMS destinations that it shares with other modules. A RAR-based `ApplicationContext` may also, for example, schedule some jobs or react to new files in the file system (or the like). If it needs to allow synchronous access from the outside, it could (for example) export RMI endpoints, which may be used by other application modules on the same machine.
#### ** Chinese **

这种RAR部署单元通常是自成一体的。它们不向外部世界暴露组件，甚至不向同一应用程序的其他模块暴露。与基于RAR的`ApplicationContext`的交互通常是通过与其他模块共享的JMS目的地发生的。一个基于 RAR 的 `ApplicationContext`也可以，例如，安排一些作业或对文件系统中的新文件作出反应（或类似的）。如果它需要允许从外部同步访问，它可以（例如）导出RMI端点，这些端点可以被同一机器上的其他应用模块使用。
<!-- tabs:end -->



[下一章](Spring-Framework-5.2.6.RELEASE/Core%20Technologies/1.16.%20The BeanFactory.md)


[回目录](Spring-Framework-5.2.6.RELEASE/summary.md)

[回首页](/README)
