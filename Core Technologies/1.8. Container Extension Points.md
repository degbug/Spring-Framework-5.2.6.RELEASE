# 1.8. Container Extension Points

<!-- tabs:start -->

#### ** English **

Typically, an application developer does not need to subclass `ApplicationContext` implementation classes. Instead, the Spring IoC container can be extended by plugging in implementations of special integration interfaces. The next few sections describe these integration interfaces.
#### ** Chinese **

通常情况下，应用程序开发人员不需要子类`ApplicationContext`实现类。相反，可以通过插入特殊集成接口的实现来扩展Spring IoC容器。接下来的几节将描述这些集成接口。
<!-- tabs:end -->


### **1.8.1. Customizing Beans by Using a** **`BeanPostProcessor`** 

<!-- tabs:start -->

#### ** English **

The `BeanPostProcessor` interface defines callback methods that you can implement to provide your own (or override the container’s default) instantiation logic, dependency resolution logic, and so forth. If you want to implement some custom logic after the Spring container finishes instantiating, configuring, and initializing a bean, you can plug in one or more custom `BeanPostProcessor` implementations.
#### ** Chinese **

`BeanPostProcessor`接口定义了回调方法，您可以实现这些方法来提供自己的（或覆盖容器的默认）实例化逻辑、依赖解析逻辑等。如果你想在Spring容器完成实例化、配置和初始化Bean之后实现一些自定义逻辑，你可以插入一个或多个自定义`BeanPostProcessor`实现。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can configure multiple `BeanPostProcessor` instances, and you can control the order in which these `BeanPostProcessor` instances execute by setting the `order` property. You can set this property only if the `BeanPostProcessor` implements the `Ordered` interface. If you write your own `BeanPostProcessor`, you should consider implementing the `Ordered` interface, too. For further details, see the javadoc of the [`BeanPostProcessor`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/beans/factory/config/BeanPostProcessor.html) and [`Ordered`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/core/Ordered.html) interfaces. See also the note on [programmatic registration of ](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-programmatically-registering-beanpostprocessors)[`BeanPostProcessor`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-programmatically-registering-beanpostprocessors)[ instances](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-programmatically-registering-beanpostprocessors).
#### ** Chinese **

您可以配置多个`BeanPostProcessor`实例，并且可以通过设置`order`属性来控制这些`BeanPostProcessor`实例的执行顺序。只有当`BeanPostProcessor`实现了`Ordered`接口时，才能设置此属性。如果您编写了自己的 `BeanPostProcessor`，您也应该考虑实现`Ordered`接口。更多详情，请参阅 [`BeanPostProcessor`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/beans/factory/config/BeanPostProcessor.html)和 [`Ordered`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/core/Ordered.html) 接口的 javadoc。另请参阅关于[程序化注册](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-programmatically-registering-beanpostprocessors)[<`BeanPostProcessor`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-programmatically-registering-beanpostprocessors)[实例](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-programmatically-registering-beanpostprocessors)的注解。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

`BeanPostProcessor` instances operate on bean (or object) instances. That is, the Spring IoC container instantiates a bean instance and then `BeanPostProcessor` instances do their work.
#### ** Chinese **

`BeanPostProcessor`实例在bean（或对象）实例上操作。也就是说，Spring IoC 容器实例化了一个bean 实例，然后 `BeanPostProcessor` 实例就可以完成工作。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

`BeanPostProcessor` instances are scoped per-container. This is relevant only if you use container hierarchies. If you define a `BeanPostProcessor` in one container, it post-processes only the beans in that container. In other words, beans that are defined in one container are not post-processed by a `BeanPostProcessor` defined in another container, even if both containers are part of the same hierarchy.
#### ** Chinese **

`BeanPostProcessor`实例是按容器划分的。只有当您使用容器层次结构时，这才是相关的。如果您在一个容器中定义了 `BeanPostProcessor`，它将只对该容器中的 beans 进行后处理。换句话说，在一个容器中定义的豆子不会被定义在另一个容器中的 `BeanPostProcessor` 后处理，即使两个容器都是同一个层次结构的一部分。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

To change the actual bean definition (that is, the blueprint that defines the bean), you instead need to use a `BeanFactoryPostProcessor`, as described in [Customizing Configuration Metadata with a ](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-extension-factory-postprocessors)[`BeanFactoryPostProcessor`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-extension-factory-postprocessors).
#### ** Chinese **

要更改实际的Bean定义（即定义Bean的蓝图），您需要使用`BeanFactoryPostProcessor`，如[Customizing Configuration Metadata with a](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-extension-factory-postprocessors)[`BeanFactoryPostProcessor`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-extension-factory-postprocessors)中所述。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The `org.springframework.beans.factory.config.BeanPostProcessor` interface consists of exactly two callback methods. When such a class is registered as a post-processor with the container, for each bean instance that is created by the container, the post-processor gets a callback from the container both before container initialization methods (such as `InitializingBean.afterPropertiesSet()` or any declared `init` method) are called, and after any bean initialization callbacks. The post-processor can take any action with the bean instance, including ignoring the callback completely. A bean post-processor typically checks for callback interfaces, or it may wrap a bean with a proxy. Some Spring AOP infrastructure classes are implemented as bean post-processors in order to provide proxy-wrapping logic.
#### ** Chinese **

`org.springframework.beans.factory.config.BeanPostProcessor`接口正好由两个回调方法组成。当这样的类被容器注册为后处理器时，对于容器创建的每个bean实例，后处理器会在容器初始化方法（如`InitializingBean.afterPropertiesSet()`或任何声明的`init`方法）被调用之前，以及在任何bean初始化回调之后，从容器中获得一个回调。后处理程序可以对Bean实例采取任何动作，包括完全忽略回调。bean后处理程序通常会检查回调接口，或者它可能会用代理来包裹一个bean。一些Spring AOP基础架构类作为Bean后处理器来实现，以提供代理包裹逻辑。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

An `ApplicationContext` automatically detects any beans that are defined in the configuration metadata that implements the `BeanPostProcessor` interface. The `ApplicationContext` registers these beans as post-processors so that they can be called later, upon bean creation. Bean post-processors can be deployed in the container in the same fashion as any other beans.
#### ** Chinese **

`ApplicationContext`会自动检测到任何在配置元数据中定义了实现了`BeanPostProcessor`接口的Bean。`ApplicationContext`将这些Bean注册为后处理程序，以便以后在Bean创建时可以调用它们。Bean 后置处理器可以像其他Bean一样，以同样的方式部署在容器中。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Note that, when declaring a `BeanPostProcessor` by using an `@Bean` factory method on a configuration class, the return type of the factory method should be the implementation class itself or at least the `org.springframework.beans.factory.config.BeanPostProcessor` interface, clearly indicating the post-processor nature of that bean. Otherwise, the `ApplicationContext` cannot autodetect it by type before fully creating it. Since a `BeanPostProcessor` needs to be instantiated early in order to apply to the initialization of other beans in the context, this early type detection is critical.
#### ** Chinese **

注意，当在配置类上使用`@Bean`工厂方法声明`BeanPostProcessor`时，工厂方法的返回类型应该是实现类本身，或者至少是`org.springframework.beans.factory.config.BeanPostProcessor`接口，明确表示该Bean的后处理程序性质。否则，`ApplicationContext`在完全创建之前，`ApplicationContext`无法通过类型自动检测它。由于`BeanPostProcessor`需要提前实例化，以便应用于上下文中其他Bean的初始化，因此这种早期类型检测是至关重要的。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Programmatically registering `BeanPostProcessor` instances
#### ** Chinese **

程序化注册`BeanPostProcessor`实例
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

While the recommended approach for `BeanPostProcessor` registration is through `ApplicationContext` auto-detection (as described earlier), you can register them programmatically against a `ConfigurableBeanFactory` by using the `addBeanPostProcessor` method. This can be useful when you need to evaluate conditional logic before registration or even for copying bean post processors across contexts in a hierarchy. Note, however, that `BeanPostProcessor` instances added programmatically do not respect the `Ordered` interface. Here, it is the order of registration that dictates the order of execution. Note also that `BeanPostProcessor` instances registered programmatically are always processed before those registered through auto-detection, regardless of any explicit ordering.
#### ** Chinese **

虽然`BeanPostProcessor`注册的推荐方法是通过`ApplicationContext`自动检测（如前文所述），但你可以通过使用`addBeanPostProcessor`方法对`ConfigurableBeanFactory`进行编程注册。当你需要在注册前评估条件逻辑，或者甚至是在层次结构中跨上下文复制bean后处理程序时，这个方法会很有用。但是，请注意，程序化添加的`BeanPostProcessor`实例不尊重`Ordered`接口。这里，是注册的顺序决定了执行的顺序。还请注意 `BeanPostProcessor`实例总是先于通过自动检测注册的实例进行处理，而不考虑任何显式排序。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

`BeanPostProcessor` instances and AOP auto-proxying
#### ** Chinese **

`BeanPostProcessor`实例和AOP自动代理</x>。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Classes that implement the `BeanPostProcessor` interface are special and are treated differently by the container. All `BeanPostProcessor` instances and beans that they directly reference are instantiated on startup, as part of the special startup phase of the `ApplicationContext`. Next, all `BeanPostProcessor` instances are registered in a sorted fashion and applied to all further beans in the container. Because AOP auto-proxying is implemented as a `BeanPostProcessor` itself, neither `BeanPostProcessor` instances nor the beans they directly reference are eligible for auto-proxying and, thus, do not have aspects woven into them.
#### ** Chinese **

实现`BeanPostProcessor`接口的类是特殊的，并且被容器区别对待。所有的 `BeanPostProcessor`实例和它们直接引用的 beans 在启动时被实例化，作为 `ApplicationContext`特殊启动阶段的一部分。接下来，所有`BeanPostProcessor`实例都会以排序的方式注册，并应用到容器中的所有进一步的bean。因为AOP自动代理是作为`BeanPostProcessor`本身来实现的，所以无论是`BeanPostProcessor`实例还是它们直接引用的bean都不符合自动代理的条件，因此，没有编织到它们的方面。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

For any such bean, you should see an informational log message: `Bean someBean is not eligible for getting processed by all BeanPostProcessor interfaces (for example: not eligible for auto-proxying)`.
#### ** Chinese **

对于任何这样的Bean，你应该看到一条信息日志消息。 `Bean someBean is not eligible for getting processed by all BeanPostProcessor interfaces (for example: not eligible for auto-proxying)`。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

If you have beans wired into your `BeanPostProcessor` by using autowiring or `@Resource` (which may fall back to autowiring), Spring might access unexpected beans when searching for type-matching dependency candidates and, therefore, make them ineligible for auto-proxying or other kinds of bean post-processing. For example, if you have a dependency annotated with `@Resource` where the field or setter name does not directly correspond to the declared name of a bean and no name attribute is used, Spring accesses other beans for matching them by type.
#### ** Chinese **

如果您的 `BeanPostProcessor`中的bean通过使用自动布线或`@Resource`（可能会返回到自动布线），Spring可能会在搜索类型匹配的依赖候选者时访问到意想不到的bean，从而使它们不符合自动代理或其他类型的bean后处理条件。例如，如果您有一个用 `@Resource`注解的依赖关系，其中字段或设置器的名称并不直接对应于Bean的声明名称，并且没有使用名称属性，那么Spring会访问其他Bean，以便通过类型匹配它们。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following examples show how to write, register, and use `BeanPostProcessor` instances in an `ApplicationContext`.
#### ** Chinese **

下面的示例展示了如何在`ApplicationContext`中编写、注册和使用`BeanPostProcessor`实例。
<!-- tabs:end -->


### **Example: Hello World,** **`BeanPostProcessor`** **-style** 

<!-- tabs:start -->

#### ** English **

This first example illustrates basic usage. The example shows a custom `BeanPostProcessor` implementation that invokes the `toString()` method of each bean as it is created by the container and prints the resulting string to the system console.
#### ** Chinese **

这个第一个例子说明了基本的使用方法。这个例子显示了一个自定义的 `BeanPostProcessor`实现，它在每个Bean被容器创建时调用了`toString()`方法，并将结果字符串打印到系统控制台。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following listing shows the custom `BeanPostProcessor` implementation class definition:
#### ** Chinese **

下面列出了自定义`BeanPostProcessor`实现类定义。
<!-- tabs:end -->


```java
package scripting;

import org.springframework.beans.factory.config.BeanPostProcessor;

public class InstantiationTracingBeanPostProcessor implements BeanPostProcessor {

    // simply return the instantiated bean as-is
    public Object postProcessBeforeInitialization(Object bean, String beanName) {
        return bean; // we could potentially return any object reference here...
    }

    public Object postProcessAfterInitialization(Object bean, String beanName) {
        System.out.println("Bean '" + beanName + "' created : " + bean.toString());
        return bean;
    }
}
```

<!-- tabs:start -->

#### ** English **

The following `beans` element uses the `InstantiationTracingBeanPostProcessor`:
#### ** Chinese **

以下`beans`元素使用`InstantiationTracingBeanPostProcessor`。
<!-- tabs:end -->


```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:lang="http://www.springframework.org/schema/lang"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/lang
        https://www.springframework.org/schema/lang/spring-lang.xsd">

    <lang:groovy id="messenger"
            script-source="classpath:org/springframework/scripting/groovy/Messenger.groovy">
        <lang:property name="message" value="Fiona Apple Is Just So Dreamy."/>
    </lang:groovy>

    <!--
    when the above bean (messenger) is instantiated, this custom
    BeanPostProcessor implementation will output the fact to the system console
    -->
    <bean class="scripting.InstantiationTracingBeanPostProcessor"/>

</beans>
```

<!-- tabs:start -->

#### ** English **

Notice how the `InstantiationTracingBeanPostProcessor` is merely defined. It does not even have a name, and, because it is a bean, it can be dependency-injected as you would any other bean. (The preceding configuration also defines a bean that is backed by a Groovy script. The Spring dynamic language support is detailed in the chapter entitled [Dynamic Language Support](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/languages.html#dynamic-language).)
#### ** Chinese **

请注意`InstantiationTracingBeanPostProcessor`仅仅是被定义了。它甚至没有名字，而且因为它是一个Bean，所以可以像其他Bean一样被依赖注入。(前面的配置也定义了一个由Groovy脚本支持的Bean。Spring的动态语言支持在[动态语言支持](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/languages.html#dynamic-language)一章中有详细介绍。)
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following Java application runs the preceding code and configuration:
#### ** Chinese **

下面的Java应用程序运行前面的代码和配置。
<!-- tabs:end -->


```java
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.springframework.scripting.Messenger;

public final class Boot {

    public static void main(final String[] args) throws Exception {
        ApplicationContext ctx = new ClassPathXmlApplicationContext("scripting/beans.xml");
        Messenger messenger = ctx.getBean("messenger", Messenger.class);
        System.out.println(messenger);
    }

}
```

<!-- tabs:start -->

#### ** English **

The output of the preceding application resembles the following:
#### ** Chinese **

前面的应用程序的输出类似于以下内容：
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Bean 'messenger' created : org.springframework.scripting.groovy.GroovyMessenger@272961
#### ** Chinese **

Bean messenger 创建： org.springframework.scripting.groovy.GroovyMessenger@272961
<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

org.springframework.scripting.groovy.GroovyMessenger@272961
#### ** Chinese **

org.springframework.scripting.groovy.GroovyMessenger@272961
<!-- tabs:end -->


### **Example: The** **`RequiredAnnotationBeanPostProcessor`** 

<!-- tabs:start -->

#### ** English **

Using callback interfaces or annotations in conjunction with a custom `BeanPostProcessor` implementation is a common means of extending the Spring IoC container. An example is Spring’s `RequiredAnnotationBeanPostProcessor` — a `BeanPostProcessor` implementation that ships with the Spring distribution and that ensures that JavaBean properties on beans that are marked with an (arbitrary) annotation are actually (configured to be) dependency-injected with a value.
#### ** Chinese **

使用回调接口或注解与自定义的 `BeanPostProcessor`实现结合使用是扩展Spring IoC容器的常用方法。一个例子是Spring的`RequiredAnnotationBeanPostProcessor`--一个随Spring发行版一起提供的`BeanPostProcessor`实现，它可以确保在bean上标记有（任意）注解的JavaBean属性实际上（配置为）依赖注入一个值。
<!-- tabs:end -->


### **1.8.2. Customizing Configuration Metadata with a** **`BeanFactoryPostProcessor`** 

<!-- tabs:start -->

#### ** English **

The next extension point that we look at is the `org.springframework.beans.factory.config.BeanFactoryPostProcessor`. The semantics of this interface are similar to those of the `BeanPostProcessor`, with one major difference: `BeanFactoryPostProcessor` operates on the bean configuration metadata. That is, the Spring IoC container lets a `BeanFactoryPostProcessor` read the configuration metadata and potentially change it *before* the container instantiates any beans other than `BeanFactoryPostProcessor` instances.
#### ** Chinese **

下一个我们看的扩展点是`org.springframework.beans.factory.config.BeanFactoryPostProcessor`。这个接口的语义与`BeanPostProcessor`类似，但有一个主要的区别。 `BeanFactoryPostProcessor`在Bean配置元数据上操作。也就是说，Spring IoC 容器允许 `BeanFactoryPostProcessor`读取配置元数据，并可能在*之前*容器实例化除 `BeanFactoryPostProcessor` 实例之外的任何 bean 之前更改配置元数据。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can configure multiple `BeanFactoryPostProcessor` instances, and you can control the order in which these `BeanFactoryPostProcessor` instances run by setting the `order` property. However, you can only set this property if the `BeanFactoryPostProcessor` implements the `Ordered` interface. If you write your own `BeanFactoryPostProcessor`, you should consider implementing the `Ordered` interface, too. See the javadoc of the [`BeanFactoryPostProcessor`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/beans/factory/config/BeanFactoryPostProcessor.html) and [`Ordered`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/core/Ordered.html) interfaces for more details.
#### ** Chinese **

您可以配置多个`BeanFactoryPostProcessor`实例，并且可以通过设置`order`属性来控制这些`BeanFactoryPostProcessor`实例的运行顺序。但是，只有当 `BeanFactoryPostProcessor`实现了 `Ordered` 接口时，才能设置此属性。如果您编写了自己的 `BeanFactoryPostProcessor`，您也应该考虑实现`Ordered`接口。有关详细信息，请参阅 [`BeanFactoryPostProcessor`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/beans/factory/config/BeanFactoryPostProcessor.html) 和 [`Ordered`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/core/Ordered.html) 接口的 javadoc。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

If you want to change the actual bean instances (that is, the objects that are created from the configuration metadata), then you instead need to use a `BeanPostProcessor` (described earlier in [Customizing Beans by Using a ](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-extension-bpp)[`BeanPostProcessor`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-extension-bpp)). While it is technically possible to work with bean instances within a `BeanFactoryPostProcessor` (for example, by using `BeanFactory.getBean()`), doing so causes premature bean instantiation, violating the standard container lifecycle. This may cause negative side effects, such as bypassing bean post processing.
#### ** Chinese **

如果你想改变实际的Bean实例（即从配置元数据中创建的对象），那么你需要使用`BeanPostProcessor`（在前面的[Customizing Beans by Using a ](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-extension-bpp)[`BeanPostProcessor`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-extension-bpp)中描述过）。虽然在技术上可以在`BeanFactoryPostProcessor`中使用Bean实例（例如，通过使用`BeanFactory.getBean()`），但这样做会导致过早地进行Bean实例化，违反了标准容器生命周期。这可能会导致负面影响，例如绕过Bean后处理。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Also, `BeanFactoryPostProcessor` instances are scoped per-container. This is only relevant if you use container hierarchies. If you define a `BeanFactoryPostProcessor` in one container, it is applied only to the bean definitions in that container. Bean definitions in one container are not post-processed by `BeanFactoryPostProcessor` instances in another container, even if both containers are part of the same hierarchy.
#### ** Chinese **

另外，`BeanFactoryPostProcessor`实例是按容器划分的。这只有在使用容器层次结构的情况下才有意义。如果您在一个容器中定义了 `BeanFactoryPostProcessor`，它只应用于该容器中的 Bean 定义。一个容器中的 Bean 定义不会被另一个容器中的 `BeanFactoryPostProcessor` 实例后处理，即使两个容器都是同一个层次结构的一部分。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

A bean factory post-processor is automatically executed when it is declared inside an `ApplicationContext`, in order to apply changes to the configuration metadata that define the container. Spring includes a number of predefined bean factory post-processors, such as `PropertyOverrideConfigurer` and `PropertySourcesPlaceholderConfigurer`. You can also use a custom `BeanFactoryPostProcessor` — for example, to register custom property editors.
#### ** Chinese **

当在`ApplicationContext`中声明了一个bean工厂后处理程序时，会自动执行，以便对定义容器的配置元数据进行更改。Spring包含了许多预定义的Bean工厂后处理程序，例如`PropertyOverrideConfigurer`和`PropertySourcesPlaceholderConfigurer`。您也可以使用自定义的`BeanFactoryPostProcessor`--例如，注册自定义属性编辑器。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

An `ApplicationContext` automatically detects any beans that are deployed into it that implement the `BeanFactoryPostProcessor` interface. It uses these beans as bean factory post-processors, at the appropriate time. You can deploy these post-processor beans as you would any other bean.
#### ** Chinese **

`ApplicationContext`会自动检测部署到它的任何实现了`BeanFactoryPostProcessor`接口的bean。它在适当的时候将这些Bean作为Bean工厂后处理程序。你可以像部署任何其他的Bean一样部署这些后处理器Bean。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

As with `BeanPostProcessor`s , you typically do not want to configure `BeanFactoryPostProcessor`s for lazy initialization. If no other bean references a `Bean(Factory)PostProcessor`, that post-processor will not get instantiated at all. Thus, marking it for lazy initialization will be ignored, and the `Bean(Factory)PostProcessor` will be instantiated eagerly even if you set the `default-lazy-init` attribute to `true` on the declaration of your `<beans />` element.
#### ** Chinese **

和 `BeanPostProcessor`s一样，你通常不希望配置`BeanFactoryPostProcessor`s用于懒惰初始化。如果没有其他 Bean 引用一个 `Bean(Factory)PostProcessor`，那么这个后处理程序将不会被实例化。因此，标记它进行懒惰初始化将被忽略，即使你在`<beans />`元素的声明中设置了`default-lazy-init`属性为`true`，`Bean(Factory)PostProcessor`也会被急切地实例化。
<!-- tabs:end -->


### **Example: The Class Name Substitution** **`PropertySourcesPlaceholderConfigurer`** 

<!-- tabs:start -->

#### ** English **

You can use the `PropertySourcesPlaceholderConfigurer` to externalize property values from a bean definition in a separate file by using the standard Java `Properties` format. Doing so enables the person deploying an application to customize environment-specific properties, such as database URLs and passwords, without the complexity or risk of modifying the main XML definition file or files for the container.
#### ** Chinese **

您可以使用`PropertySourcesPlaceholderConfigurer`，通过使用标准的Java `Properties`格式，将Bean定义中的属性值外部化，并将其放在一个单独的文件中。这样做使部署应用程序的人能够自定义环境特定属性，如数据库 URL 和密码等，而无需修改容器的主 XML 定义文件或文件的复杂性或风险。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Consider the following XML-based configuration metadata fragment, where a `DataSource` with placeholder values is defined:
#### ** Chinese **

考虑以下基于XML的配置元数据片段，其中定义了一个带有占位符值的`DataSource`。
<!-- tabs:end -->


```xml
<bean class="org.springframework.context.support.PropertySourcesPlaceholderConfigurer">
    <property name="locations" value="classpath:com/something/jdbc.properties"/>
</bean>

<bean id="dataSource" destroy-method="close"
        class="org.apache.commons.dbcp.BasicDataSource">
    <property name="driverClassName" value="${jdbc.driverClassName}"/>
    <property name="url" value="${jdbc.url}"/>
    <property name="username" value="${jdbc.username}"/>
    <property name="password" value="${jdbc.password}"/>
</bean>
```

<!-- tabs:start -->

#### ** English **

The example shows properties configured from an external `Properties` file. At runtime, a `PropertySourcesPlaceholderConfigurer` is applied to the metadata that replaces some properties of the DataSource. The values to replace are specified as placeholders of the form `${property-name}`, which follows the Ant and log4j and JSP EL style.
#### ** Chinese **

该示例显示了从外部`Properties`文件中配置的属性。在运行时，`PropertySourcesPlaceholderConfigurer`被应用到元数据中，用于替换DataSource的一些属性。要替换的值被指定为`${property-name}`形式的占位符，它遵循Ant和log4j以及JSP EL样式。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The actual values come from another file in the standard Java `Properties` format:
#### ** Chinese **

实际值来自标准的Java `Properties`格式的另一个文件。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

jdbc.driverClassName=org.hsqldb.jdbcDriver
#### ** Chinese **

jdbc.driverClassName=org.hsqldb.jdbcDriver
<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

jdbc.url=jdbc:hsqldb:hsql://production:9002
#### ** Chinese **

jdbc.url=jdbc:hsqldb:hsql://production:9002
<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

jdbc.username=sa
#### ** Chinese **

jdbc.username=sa
<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

jdbc.password=root
#### ** Chinese **

jdbc.password=root
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Therefore, the `${jdbc.username}` string is replaced at runtime with the value, 'sa', and the same applies for other placeholder values that match keys in the properties file. The `PropertySourcesPlaceholderConfigurer` checks for placeholders in most properties and attributes of a bean definition. Furthermore, you can customize the placeholder prefix and suffix.
#### ** Chinese **

因此，`${jdbc.username}`字符串在运行时被替换为值sa，同样的，其他与属性文件中的键值相匹配的占位符值也是如此。`PropertySourcesPlaceholderConfigurer`在Bean定义的大多数属性和属性中检查占位符。此外，你可以自定义占位符前缀和后缀。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

With the `context` namespace introduced in Spring 2.5, you can configure property placeholders with a dedicated configuration element. You can provide one or more locations as a comma-separated list in the `location` attribute, as the following example shows:
#### ** Chinese **

通过Spring 2.5中引入的`context`命名空间，您可以使用专用的配置元素配置属性占位符。您可以在`location`属性中以逗号分隔的列表形式提供一个或多个位置，如下例所示。
<!-- tabs:end -->


```xml
<context:property-placeholder location="classpath:com/something/jdbc.properties"/>
```

<!-- tabs:start -->

#### ** English **

The `PropertySourcesPlaceholderConfigurer` not only looks for properties in the `Properties` file you specify. By default, if it cannot find a property in the specified properties files, it checks against Spring `Environment` properties and regular Java `System` properties.
#### ** Chinese **

`PropertySourcesPlaceholderConfigurer`不仅在您指定的`Properties`文件中寻找属性。默认情况下，如果它在指定的属性文件中找不到属性，则会检查Spring `Environment`属性和常规的Java `System`属性。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can use the `PropertySourcesPlaceholderConfigurer` to substitute class names, which is sometimes useful when you have to pick a particular implementation class at runtime. The following example shows how to do so:
#### ** Chinese **

你可以使用`PropertySourcesPlaceholderConfigurer`来替换类名，当你必须在运行时选择一个特定的实现类时，这有时会很有用。下面的例子显示了如何做到这一点。
<!-- tabs:end -->


```xml
<bean class="org.springframework.beans.factory.config.PropertySourcesPlaceholderConfigurer">
    <property name="locations">
        <value>classpath:com/something/strategy.properties</value>
    </property>
    <property name="properties">
        <value>custom.strategy.class=com.something.DefaultStrategy</value>
    </property>
</bean>

<bean id="serviceStrategy" class="${custom.strategy.class}"/>
```

<!-- tabs:start -->

#### ** English **

If the class cannot be resolved at runtime to a valid class, resolution of the bean fails when it is about to be created, which is during the `preInstantiateSingletons()` phase of an `ApplicationContext` for a non-lazy-init bean.
#### ** Chinese **

如果类在运行时不能被解析为有效的类，那么当Bean即将创建时，即在`ApplicationContext`的`preInstantiateSingletons()`阶段，对非lazy-init Bean的`ApplicationContext`期间，Bean的解析就会失败。
<!-- tabs:end -->


### **Example: The** **`PropertyOverrideConfigurer`** 

<!-- tabs:start -->

#### ** English **

The `PropertyOverrideConfigurer`, another bean factory post-processor, resembles the `PropertySourcesPlaceholderConfigurer`, but unlike the latter, the original definitions can have default values or no values at all for bean properties. If an overriding `Properties` file does not have an entry for a certain bean property, the default context definition is used.
#### ** Chinese **

`PropertyOverrideConfigurer`是另一个Bean工厂后处理程序，它类似于`PropertySourcesPlaceholderConfigurer`，但与后者不同的是，原始定义可以为Bean属性提供默认值，也可以完全没有值。如果覆盖的`Properties`文件中没有某个Bean属性的条目，则使用默认的上下文定义。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Note that the bean definition is not aware of being overridden, so it is not immediately obvious from the XML definition file that the override configurer is being used. In case of multiple `PropertyOverrideConfigurer` instances that define different values for the same bean property, the last one wins, due to the overriding mechanism.
#### ** Chinese **

注意，Bean定义并没有意识到被重写，所以从XML定义文件中并不能立刻看出使用了覆盖配置器。如果有多个`PropertyOverrideConfigurer`实例为同一个bean属性定义了不同的值，由于覆盖机制，最后一个实例获胜。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Properties file configuration lines take the following format:
#### ** Chinese **

属性文件配置行采用以下格式：
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

beanName.property=value
#### ** Chinese **

beanName.property=value
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following listing shows an example of the format:
#### ** Chinese **

下面列举了一个格式的例子。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

dataSource.driverClassName=com.mysql.jdbc.Driver
#### ** Chinese **

dataSource.driverClassName=com.mysql.jdbc.Driver
<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

dataSource.url=jdbc:mysql:mydb
#### ** Chinese **

dataSource.url=jdbc:mysql:mydb
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

This example file can be used with a container definition that contains a bean called `dataSource` that has `driver` and `url` properties.
#### ** Chinese **

这个示例文件可以与容器定义一起使用，其中包含一个名为`dataSource`的Bean，该Bean具有`driver`和`url`属性。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Compound property names are also supported, as long as every component of the path except the final property being overridden is already non-null (presumably initialized by the constructors). In the following example, the `sammy` property of the `bob` property of the `fred` property of the `tom` bean is set to the scalar value `123`:
#### ** Chinese **

只要路径中除了被覆盖的最终属性之外的每一个组件都已经是非空的（大概是由构造函数初始化的），那么也支持复合属性名。在下面的例子中，`sammy`的`bob`属性中的`fred` bean的`tom`属性被设置为标量值`123`。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

tom.fred.bob.sammy=123
#### ** Chinese **

tom.fred.bob.sammy=123
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Specified override values are always literal values. They are not translated into bean references. This convention also applies when the original value in the XML bean definition specifies a bean reference.
#### ** Chinese **

指定的覆盖值始终是字面值。它们不会被翻译成bean引用。当 XML bean 定义中的原始值指定了 bean 引用时，这个约定也适用。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

With the `context` namespace introduced in Spring 2.5, it is possible to configure property overriding with a dedicated configuration element, as the following example shows:
#### ** Chinese **

通过Spring 2.5中引入的`context`命名空间，可以用一个专门的配置元素来配置属性覆盖，如下例所示。
<!-- tabs:end -->


```xml
<context:property-override location="classpath:override.properties"/>
```

### **1.8.3. Customizing Instantiation Logic with a** **`FactoryBean`** 

<!-- tabs:start -->

#### ** English **

You can implement the `org.springframework.beans.factory.FactoryBean` interface for objects that are themselves factories.
#### ** Chinese **

你可以实现`org.springframework.beans.factory.FactoryBean`接口，对象本身就是工厂。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The `FactoryBean` interface is a point of pluggability into the Spring IoC container’s instantiation logic. If you have complex initialization code that is better expressed in Java as opposed to a (potentially) verbose amount of XML, you can create your own `FactoryBean`, write the complex initialization inside that class, and then plug your custom `FactoryBean` into the container.
#### ** Chinese **

`FactoryBean`接口是Spring IoC容器的实例化逻辑的可插拔点。如果您有复杂的初始化代码，可以用Java来表达，而不是用（潜在的）冗长的XML来表达，您可以创建自己的`FactoryBean`，在该类中编写复杂的初始化，然后将您的自定义`FactoryBean`插入到容器中。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The `FactoryBean` interface provides three methods:
#### ** Chinese **

`FactoryBean`接口提供了三种方法。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

- `Object getObject()`: Returns an instance of the object this factory creates. The instance can possibly be shared, depending on whether this factory returns singletons or prototypes.

- `boolean isSingleton()`: Returns `true` if this `FactoryBean` returns singletons or `false` otherwise.

- `Class getObjectType()`: Returns the object type returned by the `getObject()` method or `null` if the type is not known in advance.

#### ** Chinese **

- `Object getObject()`。返回这个工厂创建的对象的实例。这个实例可能会被共享，这取决于这个工厂是返回单体还是原型。

- `boolean isSingleton()`：返回`true`。如果这个`FactoryBean`返回单子，则返回`true`，否则返回`false`。

- `Class getObjectType()`。返回由 `getObject()`方法返回的对象类型，如果事先不知道类型，则返回`null`。

<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

The `FactoryBean` concept and interface is used in a number of places within the Spring Framework. More than 50 implementations of the `FactoryBean` interface ship with Spring itself.
#### ** Chinese **

`FactoryBean`概念和接口在Spring框架中的许多地方都有使用。`FactoryBean`接口有50多种实现，Spring本身就有50多种实现。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

When you need to ask a container for an actual `FactoryBean` instance itself instead of the bean it produces, preface the bean’s `id` with the ampersand symbol (`&`) when calling the `getBean()` method of the `ApplicationContext`. So, for a given `FactoryBean` with an `id` of `myBean`, invoking `getBean("myBean")` on the container returns the product of the `FactoryBean`, whereas invoking `getBean("&myBean")` returns the `FactoryBean` instance itself.
#### ** Chinese **

当你需要向容器询问一个实际的`FactoryBean`实例本身而不是它所产生的bean时，在调用`ApplicationContext`的`getBean()`方法时，在bean的`id`前加上了一个符号(`&`)。因此，对于一个给定的`FactoryBean`的`id`为`myBean`，在容器上调用`getBean("myBean")`会返回`FactoryBean`的乘积，而调用`getBean("&myBean")`会返回`FactoryBean`实例本身。
<!-- tabs:end -->


### **1.9. Annotation-based Container Configuration** 

<!-- tabs:start -->

#### ** English **

Are annotations better than XML for configuring Spring?
#### ** Chinese **

注解是否比XML更适合配置Spring？
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The introduction of annotation-based configuration raised the question of whether this approach is “better” than XML. The short answer is “it depends.” The long answer is that each approach has its pros and cons, and, usually, it is up to the developer to decide which strategy suits them better. Due to the way they are defined, annotations provide a lot of context in their declaration, leading to shorter and more concise configuration. However, XML excels at wiring up components without touching their source code or recompiling them. Some developers prefer having the wiring close to the source while others argue that annotated classes are no longer POJOs and, furthermore, that the configuration becomes decentralized and harder to control.
#### ** Chinese **

基于注解的配置的引入，提出了这样一个问题：这种方法是否比XML "更好"。简单的答案是 "这要看情况"。长长的答案是，每一种方法都有其优点和缺点，通常情况下，由开发者决定哪种策略更适合他们。由于它们的定义方式，注解在声明中提供了大量的上下文，导致配置更短、更简洁。然而，XML擅长于在不触及组件的源代码或重新编译组件的情况下进行布线。一些开发人员喜欢将布线靠近源码，而另一些人则认为，注解类不再是POJO，此外，配置变得分散化，更难控制。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

No matter the choice, Spring can accommodate both styles and even mix them together. It is worth pointing out that through its [JavaConfig](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-java) option, Spring lets annotations be used in a non-invasive way, without touching the target components source code and that, in terms of tooling, all configuration styles are supported by the [Spring Tools for Eclipse](https://spring.io/tools).
#### ** Chinese **

无论选择哪种风格，Spring都可以容纳这两种风格，甚至可以混合使用。值得指出的是，通过其[JavaConfig](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-java)选项，Spring可以让注解以非侵入性的方式使用，而不触及目标组件的源代码，而且在工具方面，所有的配置风格都由[Spring Tools for Eclipse](https://spring.io/tools)支持。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

An alternative to XML setup is provided by annotation-based configuration, which relies on the bytecode metadata for wiring up components instead of angle-bracket declarations. Instead of using XML to describe a bean wiring, the developer moves the configuration into the component class itself by using annotations on the relevant class, method, or field declaration. As mentioned in [Example: The ](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-extension-bpp-examples-rabpp)[`RequiredAnnotationBeanPostProcessor`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-extension-bpp-examples-rabpp), using a `BeanPostProcessor` in conjunction with annotations is a common means of extending the Spring IoC container. For example, Spring 2.0 introduced the possibility of enforcing required properties with the [`@Required`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-required-annotation) annotation. Spring 2.5 made it possible to follow that same general approach to drive Spring’s dependency injection. Essentially, the `@Autowired` annotation provides the same capabilities as described in [Autowiring Collaborators](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-autowire) but with more fine-grained control and wider applicability. Spring 2.5 also added support for JSR-250 annotations, such as `@PostConstruct` and `@PreDestroy`. Spring 3.0 added support for JSR-330 (Dependency Injection for Java) annotations contained in the `javax.inject` package such as `@Inject` and `@Named`. Details about those annotations can be found in the [relevant section](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-standard-annotations).
#### ** Chinese **

基于注解的配置提供了一个替代XML设置的方法，它依靠字节码元数据来布线组件，而不是角括号声明。开发者不使用XML来描述Bean布线，而是通过在相关的类、方法或字段声明上使用注解将配置移到组件类本身。正如[示例：](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-extension-bpp-examples-rabpp)[`RequiredAnnotationBeanPostProcessor`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-extension-bpp-examples-rabpp)中提到的那样，使用`BeanPostProcessor`与注解结合使用是Spring IoC容器的常用扩展手段。例如，Spring 2.0引入了使用[`@Required`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-required-annotation)注解强制执行所需属性的可能性。Spring 2.5 让我们可以遵循同样的一般方法来驱动 Spring 的依赖注入。本质上，`@Autowired`注解提供了与[Autowiring Collaborators](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-autowire)中描述的相同的功能，但具有更精细的控制和更广泛的适用性。Spring 2.5 还增加了对 JSR-250 注解的支持，例如 `@PostConstruct` 和 `@PreDestroy`。Spring 3.0 增加了对 `javax.inject` 包中包含的 JSR-330（Java 的依赖注入）注解的支持，例如 `@Inject` 和 `@Named`。关于这些注解的详细信息可以在[相关章节](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-standard-annotations)中找到。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Annotation injection is performed before XML injection. Thus, the XML configuration overrides the annotations for properties wired through both approaches.
#### ** Chinese **

注解注入是在XML注入之前进行的。因此，通过这两种方法，XML配置覆盖了通过这两种方法连接的属性的注解。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

As always, you can register them as individual bean definitions, but they can also be implicitly registered by including the following tag in an XML-based Spring configuration (notice the inclusion of the `context` namespace):
#### ** Chinese **

一如既往，您可以将它们作为单独的Bean定义进行注册，但也可以通过在基于XML的Spring配置中包含以下标记来隐式注册（注意包含`context`命名空间）。
<!-- tabs:end -->


```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd">

    <context:annotation-config/>

</beans>
```

<!-- tabs:start -->

#### ** English **

(The implicitly registered post-processors include [`AutowiredAnnotationBeanPostProcessor`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/beans/factory/annotation/AutowiredAnnotationBeanPostProcessor.html), [`CommonAnnotationBeanPostProcessor`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/context/annotation/CommonAnnotationBeanPostProcessor.html), [`PersistenceAnnotationBeanPostProcessor`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/orm/jpa/support/PersistenceAnnotationBeanPostProcessor.html), and the aforementioned [`RequiredAnnotationBeanPostProcessor`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/beans/factory/annotation/RequiredAnnotationBeanPostProcessor.html).)
#### ** Chinese **

(隐式注册的后处理程序包括[`AutowiredAnnotationBeanPostProcessor`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/beans/factory/annotation/AutowiredAnnotationBeanPostProcessor.html)、[`CommonAnnotationBeanPostProcessor`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/context/annotation/CommonAnnotationBeanPostProcessor.html)、[`PersistenceAnnotationBeanPostProcessor`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/orm/jpa/support/PersistenceAnnotationBeanPostProcessor.html)，以及上述的[`RequiredAnnotationBeanPostProcessor`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/beans/factory/annotation/RequiredAnnotationBeanPostProcessor.html))。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

`<context:annotation-config/>` only looks for annotations on beans in the same application context in which it is defined. This means that, if you put `<context:annotation-config/>` in a `WebApplicationContext` for a `DispatcherServlet`, it only checks for `@Autowired` beans in your controllers, and not your services. See [The DispatcherServlet](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-servlet) for more information.
#### ** Chinese **

`<context:annotation-config/>`只在其定义的相同的应用程序上下文中查找bean上的注解。这意味着，如果你把 `<context:annotation-config/>`放在 `WebApplicationContext`中的 `DispatcherServlet`，它只会检查控制器中的 `@Autowired` bean，而不会检查你的服务。更多信息，请参阅[The DispatcherServlet](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-servlet)。
<!-- tabs:end -->



[下一章](Spring-Framework-5.2.6.RELEASE/Core%20Technologies/1.9.%20Annotation-based%20Container%20Configuration.md)


[回目录](Spring-Framework-5.2.6.RELEASE/summary.md)

[回首页](/README)
