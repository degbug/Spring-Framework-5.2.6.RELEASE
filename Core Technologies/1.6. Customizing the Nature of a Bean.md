# 1.6. Customizing the Nature of a Bean

<!-- tabs:start -->

#### ** English **

The Spring Framework provides a number of interfaces you can use to customize the nature of a bean. This section groups them as follows:
#### ** Chinese **

Spring框架提供了许多接口，你可以用来定制Bean的性质。本节将其归类如下。
<!-- tabs:end -->


### **1.6.1. Lifecycle Callbacks** 

<!-- tabs:start -->

#### ** English **

To interact with the container’s management of the bean lifecycle, you can implement the Spring `InitializingBean` and `DisposableBean` interfaces. The container calls `afterPropertiesSet()` for the former and `destroy()` for the latter to let the bean perform certain actions upon initialization and destruction of your beans.
#### ** Chinese **

为了与容器对Bean生命周期的管理交互，可以实现Spring `InitializingBean`和`DisposableBean`接口。对于前者，容器会调用 `afterPropertiesSet()`，对于后者，容器会调用 `destroy()`，以便在初始化和销毁Bean时让Bean执行某些操作。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The JSR-250 `@PostConstruct` and `@PreDestroy` annotations are generally considered best practice for receiving lifecycle callbacks in a modern Spring application. Using these annotations means that your beans are not coupled to Spring-specific interfaces. For details, see [Using ](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-postconstruct-and-predestroy-annotations)[`@PostConstruct`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-postconstruct-and-predestroy-annotations)[ and ](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-postconstruct-and-predestroy-annotations)[`@PreDestroy`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-postconstruct-and-predestroy-annotations).
#### ** Chinese **

JSR-250 `@PostConstruct` 和 `@PreDestroy` 注解通常被认为是现代 Spring 应用程序中接收生命周期回调的最佳实践。使用这些注解意味着你的Bean没有被耦合到Spring特定的接口。有关详细信息，请参阅 [使用 ](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-postconstruct-and-predestroy-annotations)[`@PostConstruct`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-postconstruct-and-predestroy-annotations)[ 和 ](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-postconstruct-and-predestroy-annotations)[`@PreDestroy`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-postconstruct-and-predestroy-annotations)。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

If you do not want to use the JSR-250 annotations but you still want to remove coupling, consider `init-method` and `destroy-method` bean definition metadata.
#### ** Chinese **

如果你不想使用JSR-250注解，但你仍然想去除耦合，可以考虑`init-method`和`destroy-method` bean定义元数据。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Internally, the Spring Framework uses `BeanPostProcessor` implementations to process any callback interfaces it can find and call the appropriate methods. If you need custom features or other lifecycle behavior Spring does not by default offer, you can implement a `BeanPostProcessor` yourself. For more information, see [Container Extension Points](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-extension).
#### ** Chinese **

在内部，Spring框架使用`BeanPostProcessor`实现来处理它能找到的任何回调接口并调用相应的方法。如果你需要自定义功能或其他Spring默认不提供的生命周期行为，你可以自己实现一个`BeanPostProcessor`。有关更多信息，请参阅[容器扩展点](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-extension)。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

In addition to the initialization and destruction callbacks, Spring-managed objects may also implement the `Lifecycle` interface so that those objects can participate in the startup and shutdown process, as driven by the container’s own lifecycle.
#### ** Chinese **

除了初始化和销毁回调之外，Spring管理的对象还可以实现`Lifecycle`接口，这样这些对象就可以参与到启动和关闭过程中，因为这是由容器自身的生命周期驱动的。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The lifecycle callback interfaces are described in this section.
#### ** Chinese **

本节将介绍生命周期回调接口。
<!-- tabs:end -->


### **Initialization Callbacks** 

<!-- tabs:start -->

#### ** English **

The `org.springframework.beans.factory.InitializingBean` interface lets a bean perform initialization work after the container has set all necessary properties on the bean. The `InitializingBean` interface specifies a single method:
#### ** Chinese **

`org.springframework.beans.factory.InitializingBean`接口可以让一个bean在容器设置了bean上的所有必要属性后执行初始化工作。`InitializingBean`接口指定了一个方法。
<!-- tabs:end -->


```java
void afterPropertiesSet() throws Exception;
```

<!-- tabs:start -->

#### ** English **

We recommend that you do not use the `InitializingBean` interface, because it unnecessarily couples the code to Spring. Alternatively, we suggest using the [`@PostConstruct`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-postconstruct-and-predestroy-annotations) annotation or specifying a POJO initialization method. In the case of XML-based configuration metadata, you can use the `init-method` attribute to specify the name of the method that has a void no-argument signature. With Java configuration, you can use the `initMethod` attribute of `@Bean`. See [Receiving Lifecycle Callbacks](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-java-lifecycle-callbacks). Consider the following example:
#### ** Chinese **

我们建议不要使用`InitializingBean`接口，因为它不必要地将代码与Spring耦合。另外，我们建议使用[`@PostConstruct`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-postconstruct-and-predestroy-annotations)注解或指定一个POJO初始化方法。对于基于XML的配置元数据，可以使用`init-method`属性来指定具有void无参数签名的方法名称。对于Java配置，可以使用`@Bean`的`initMethod`属性。参见[接收生命周期回调](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-java-lifecycle-callbacks)。考虑一下下面的例子。
<!-- tabs:end -->


```xml
<bean id="exampleInitBean" class="examples.ExampleBean" init-method="init"/>
```

```java
public class ExampleBean {

    public void init() {
        // do some initialization work
    }
}
```

<!-- tabs:start -->

#### ** English **

The preceding example has almost exactly the same effect as the following example (which consists of two listings):
#### ** Chinese **

前面的例子和下面的例子（由两个列表组成）的效果几乎完全一样。
<!-- tabs:end -->


```xml
<bean id="exampleInitBean" class="examples.AnotherExampleBean"/>
```

```java
public class AnotherExampleBean implements InitializingBean {

    @Override
    public void afterPropertiesSet() {
        // do some initialization work
    }
}
```

<!-- tabs:start -->

#### ** English **

However, the first of the two preceding examples does not couple the code to Spring.
#### ** Chinese **

然而，前面两个例子中的第一个没有将代码与Spring绑定。
<!-- tabs:end -->


### **Destruction Callbacks** 

<!-- tabs:start -->

#### ** English **

Implementing the `org.springframework.beans.factory.DisposableBean` interface lets a bean get a callback when the container that contains it is destroyed. The `DisposableBean` interface specifies a single method:
#### ** Chinese **

实现`org.springframework.beans.factory.DisposableBean`接口可以让一个bean在包含它的容器被销毁时获得回调。`DisposableBean`接口指定了一个方法。
<!-- tabs:end -->


```java
void destroy() throws Exception;
```

<!-- tabs:start -->

#### ** English **

We recommend that you do not use the `DisposableBean` callback interface, because it unnecessarily couples the code to Spring. Alternatively, we suggest using the [`@PreDestroy`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-postconstruct-and-predestroy-annotations) annotation or specifying a generic method that is supported by bean definitions. With XML-based configuration metadata, you can use the `destroy-method` attribute on the `<bean/>`. With Java configuration, you can use the `destroyMethod` attribute of `@Bean`. See [Receiving Lifecycle Callbacks](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-java-lifecycle-callbacks). Consider the following definition:
#### ** Chinese **

我们建议您不要使用 `DisposableBean`回调接口，因为它不必要地将代码耦合到Spring。另外，我们建议使用[`@PreDestroy`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-postconstruct-and-predestroy-annotations)注解，或者指定一个由Bean定义支持的通用方法。对于基于XML的配置元数据，可以在`<bean/>`上使用`destroy-method`属性。对于Java配置，可以使用`@Bean`的`destroyMethod`属性。参见[接收生命周期回调](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-java-lifecycle-callbacks)。考虑一下下面的定义。
<!-- tabs:end -->


```xml
<bean id="exampleInitBean" class="examples.ExampleBean" destroy-method="cleanup"/>
```

```java
public class ExampleBean {

    public void cleanup() {
        // do some destruction work (like releasing pooled connections)
    }
}
```

<!-- tabs:start -->

#### ** English **

The preceding definition has almost exactly the same effect as the following definition:
#### ** Chinese **

前面的定义与下面的定义几乎有完全相同的效果。
<!-- tabs:end -->


```xml
<bean id="exampleInitBean" class="examples.AnotherExampleBean"/>
```

```java
public class AnotherExampleBean implements DisposableBean {

    @Override
    public void destroy() {
        // do some destruction work (like releasing pooled connections)
    }
}
```

<!-- tabs:start -->

#### ** English **

However, the first of the two preceding definitions does not couple the code to Spring.
#### ** Chinese **

然而，前面两个定义中的第一个没有将代码与Spring绑定。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can assign the `destroy-method` attribute of a `<bean>` element a special `(inferred)` value, which instructs Spring to automatically detect a public `close` or `shutdown` method on the specific bean class. (Any class that implements `java.lang.AutoCloseable` or `java.io.Closeable` would therefore match.) You can also set this special `(inferred)` value on the `default-destroy-method` attribute of a `<beans>` element to apply this behavior to an entire set of beans (see [Default Initialization and Destroy Methods](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-lifecycle-default-init-destroy-methods)). Note that this is the default behavior with Java configuration.
#### ** Chinese **

您可以为 `<bean>`元素的 `destroy-method` 属性分配一个特殊的 `(inferred)` 值，它可以指示 Spring 自动检测特定 Bean 类上的公共 `close` 或 `shutdown` 方法。(任何实现了 `java.lang.AutoCloseable`或 `java.io.Closeable`的类都会匹配）。) 您还可以在 `<beans>`元素的 `default-destroy-method` 属性上设置这个特殊的 `(inferred)` 值，以便将此行为应用到整个bean集（参见 [Default Initialization and Destroy Methods](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-lifecycle-default-init-destroy-methods)）。注意，这是Java配置中的默认行为。
<!-- tabs:end -->


### **Default Initialization and Destroy Methods** 

<!-- tabs:start -->

#### ** English **

When you write initialization and destroy method callbacks that do not use the Spring-specific `InitializingBean` and `DisposableBean` callback interfaces, you typically write methods with names such as `init()`, `initialize()`, `dispose()`, and so on. Ideally, the names of such lifecycle callback methods are standardized across a project so that all developers use the same method names and ensure consistency.
#### ** Chinese **

当您编写不使用 Spring 专用的 `InitializingBean` 和 `DisposableBean` 回调接口的初始化和销毁方法回调时，您通常会编写的方法名称为 `init()`、`initialize()`、`dispose()`等。理想情况下，这些生命周期回调方法的名称在整个项目中都是标准化的，这样所有的开发人员都可以使用相同的方法名称，并确保一致性。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can configure the Spring container to “look” for named initialization and destroy callback method names on every bean. This means that you, as an application developer, can write your application classes and use an initialization callback called `init()`, without having to configure an `init-method="init"` attribute with each bean definition. The Spring IoC container calls that method when the bean is created (and in accordance with the standard lifecycle callback contract [described previously](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-lifecycle)). This feature also enforces a consistent naming convention for initialization and destroy method callbacks.
#### ** Chinese **

你可以在每个Bean上配置Spring容器来 "寻找 "命名的初始化和销毁回调方法名。这意味着，作为应用程序开发人员，您可以编写应用程序类并使用名为`init()`的初始化回调，而无需为每个Bean定义配置`init-method="init"`属性。当创建Bean时，Spring IoC容器会调用该方法（并按照标准的生命周期回调合同[前文所述](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-lifecycle)）。此功能还为初始化和销毁方法回调强制执行了一致的命名惯例。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Suppose that your initialization callback methods are named `init()` and your destroy callback methods are named `destroy()`. Your class then resembles the class in the following example:
#### ** Chinese **

假设你的初始化回调方法被命名为`init()`，你的销毁回调方法被命名为`destroy()`。那么你的类类似于下面的例子中的类。
<!-- tabs:end -->


```java
public class DefaultBlogService implements BlogService {

    private BlogDao blogDao;

    public void setBlogDao(BlogDao blogDao) {
        this.blogDao = blogDao;
    }

    // this is (unsurprisingly) the initialization callback method
    public void init() {
        if (this.blogDao == null) {
            throw new IllegalStateException("The [blogDao] property must be set.");
        }
    }
}
```

<!-- tabs:start -->

#### ** English **

You could then use that class in a bean resembling the following:
#### ** Chinese **

然后你可以在一个类似于下面的bean中使用该类。
<!-- tabs:end -->


```xml
<beans default-init-method="init">

    <bean id="blogService" class="com.something.DefaultBlogService">
        <property name="blogDao" ref="blogDao" />
    </bean>

</beans>
```

<!-- tabs:start -->

#### ** English **

The presence of the `default-init-method` attribute on the top-level `<beans/>` element attribute causes the Spring IoC container to recognize a method called `init` on the bean class as the initialization method callback. When a bean is created and assembled, if the bean class has such a method, it is invoked at the appropriate time.
#### ** Chinese **

顶层 `<beans/>`元素属性上的 `default-init-method` 属性的存在会导致 Spring IoC 容器将 bean 类上的一个名为 `init` 的方法识别为初始化方法回调。当创建和组装一个Bean时，如果Bean类有这样的方法，则会在适当的时候调用该方法。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can configure destroy method callbacks similarly (in XML, that is) by using the `default-destroy-method` attribute on the top-level `<beans/>` element.
#### ** Chinese **

你可以通过使用顶层`<beans/>`元素上的`default-destroy-method`属性来配置销毁方法的回调，也是类似的（在XML中）。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Where existing bean classes already have callback methods that are named at variance with the convention, you can override the default by specifying (in XML, that is) the method name by using the `init-method` and `destroy-method` attributes of the `<bean/>` itself.
#### ** Chinese **

如果现有的Bean类已经有回调方法，而这些回调方法的命名与惯例不同，你可以通过在`<bean/>`上使用`init-method`和`destroy-method`属性指定方法名称来覆盖默认的方法。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The Spring container guarantees that a configured initialization callback is called immediately after a bean is supplied with all dependencies. Thus, the initialization callback is called on the raw bean reference, which means that AOP interceptors and so forth are not yet applied to the bean. A target bean is fully created first and then an AOP proxy (for example) with its interceptor chain is applied. If the target bean and the proxy are defined separately, your code can even interact with the raw target bean, bypassing the proxy. Hence, it would be inconsistent to apply the interceptors to the `init` method, because doing so would couple the lifecycle of the target bean to its proxy or interceptors and leave strange semantics when your code interacts directly with the raw target bean.
#### ** Chinese **

Spring容器保证在提供了一个bean的所有依赖关系后，立即调用配置的初始化回调。因此，初始化回调是在原始Bean引用上调用的，这意味着AOP拦截器等还没有应用到Bean上。先完全创建一个目标Bean，然后应用AOP代理（例如）及其拦截器链。如果目标Bean和代理分开定义，你的代码甚至可以与原始目标Bean交互，绕过代理。因此，将拦截器应用到`init`方法中是不一致的，因为这样做会把目标Bean的生命周期和它的代理或拦截器耦合在一起，当你的代码直接与原始目标Bean交互时，会留下奇怪的语义。
<!-- tabs:end -->


### **Combining Lifecycle Mechanisms** 

<!-- tabs:start -->

#### ** English **

As of Spring 2.5, you have three options for controlling bean lifecycle behavior:
#### ** Chinese **

从Spring 2.5开始，你有三个选项来控制Bean的生命周期行为。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

- [Lifecycle Callbacks](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-lifecycle)

- [`ApplicationContextAware`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-aware)[ and ](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-aware)[`BeanNameAware`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-aware)

- [Other ](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#aware-list)[`Aware`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#aware-list)[ Interfaces](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#aware-list)

- The [`InitializingBean`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-lifecycle-initializingbean) and [`DisposableBean`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-lifecycle-disposablebean) callback interfaces

- Custom `init()` and `destroy()` methods

- The [`@PostConstruct`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-postconstruct-and-predestroy-annotations)[ and ](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-postconstruct-and-predestroy-annotations)[`@PreDestroy`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-postconstruct-and-predestroy-annotations)[ annotations](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-postconstruct-and-predestroy-annotations). You can combine these mechanisms to control a given bean.

#### ** Chinese **

- 生命周期回调](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-lifecycle)

- [`ApplicationContextAware`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-aware)[ 和 ](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-aware)[`BeanNameAware`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-aware)

- [其他](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#aware-list)[`Aware`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#aware-list)[ 接口](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#aware-list)

- [`InitializingBean`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-lifecycle-initializingbean)和[`DisposableBean`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-lifecycle-disposablebean)回调接口

- 自定义`init()`和`destroy()`方法

- `@PostConstruct`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-postconstruct-and-predestroy-annotations)[和](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-postconstruct-and-predestroy-annotations)[`@PreDestroy`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-postconstruct-and-predestroy-annotations)[注解](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-postconstruct-and-predestroy-annotations)。你可以结合这些机制来控制一个给定的Bean。

<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

If multiple lifecycle mechanisms are configured for a bean and each mechanism is configured with a different method name, then each configured method is executed in the order listed after this note. However, if the same method name is configured — for example, `init()` for an initialization method — for more than one of these lifecycle mechanisms, that method is executed once, as explained in the [preceding section](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-lifecycle-default-init-destroy-methods).
#### ** Chinese **

如果为一个bean配置了多个生命周期机制，并且每个机制都配置了不同的方法名，那么每个配置的方法都会按照本说明后面列出的顺序执行。但是，如果为多个生命周期机制配置了相同的方法名--例如，初始化方法的`init()`--则该方法将被执行一次，如[上一节](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-lifecycle-default-init-destroy-methods)中所解释的那样。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Multiple lifecycle mechanisms configured for the same bean, with different initialization methods, are called as follows:
#### ** Chinese **

为同一个Bean配置的多个生命周期机制，初始化方法不同，其调用方式如下。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Methods annotated with `@PostConstructafterPropertiesSet()` as defined by the `InitializingBean` callback interfaceA custom configured `init()` method
#### ** Chinese **

由`InitializingBean`回调接口A自定义配置的`init()`方法注解`@PostConstructafterPropertiesSet()` 的方法
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Destroy methods are called in the same order:
#### ** Chinese **

销毁方法的调用顺序是一样的。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Methods annotated with `@PreDestroydestroy()` as defined by the `DisposableBean` callback interfaceA custom configured `destroy()` method
#### ** Chinese **

由`DisposableBean`回调接口A自定义配置的`destroy()`方法`@PreDestroydestroy()`注解的方法
<!-- tabs:end -->


### **Startup and Shutdown Callbacks** 

<!-- tabs:start -->

#### ** English **

The `Lifecycle` interface defines the essential methods for any object that has its own lifecycle requirements (such as starting and stopping some background process):
#### ** Chinese **

`Lifecycle`接口定义了任何有自身生命周期要求的对象的基本方法（如启动和停止某些后台进程）。
<!-- tabs:end -->


```java
public interface Lifecycle {

    void start();

    void stop();

    boolean isRunning();
}
```

<!-- tabs:start -->

#### ** English **

Any Spring-managed object may implement the `Lifecycle` interface. Then, when the `ApplicationContext` itself receives start and stop signals (for example, for a stop/restart scenario at runtime), it cascades those calls to all `Lifecycle` implementations defined within that context. It does this by delegating to a `LifecycleProcessor`, shown in the following listing:
#### ** Chinese **

任何Spring管理的对象都可以实现`Lifecycle`接口。然后，当 `ApplicationContext`本身接收到启动和停止信号时（例如，在运行时的停止/重启场景），它会将这些调用级联到该上下文中定义的所有`Lifecycle`实现。它通过委托给一个`LifecycleProcessor`来实现，如下表所示。
<!-- tabs:end -->


```java
public interface LifecycleProcessor extends Lifecycle {

    void onRefresh();

    void onClose();
}
```

<!-- tabs:start -->

#### ** English **

Notice that the `LifecycleProcessor` is itself an extension of the `Lifecycle` interface. It also adds two other methods for reacting to the context being refreshed and closed.
#### ** Chinese **

注意，`LifecycleProcessor`本身就是`Lifecycle`接口的扩展。它还增加了另外两种方法，用于对刷新和关闭上下文做出反应。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Note that the regular `org.springframework.context.Lifecycle` interface is a plain contract for explicit start and stop notifications and does not imply auto-startup at context refresh time. For fine-grained control over auto-startup of a specific bean (including startup phases), consider implementing `org.springframework.context.SmartLifecycle` instead.
#### ** Chinese **

注意，常规的 `org.springframework.context.Lifecycle`接口是一个用于显式启动和停止通知的纯合同，并不意味着在上下文刷新时自动启动。要对特定Bean的自动启动（包括启动阶段）进行精细化控制，请考虑实现`org.springframework.context.SmartLifecycle`。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Also, please note that stop notifications are not guaranteed to come before destruction. On regular shutdown, all `Lifecycle` beans first receive a stop notification before the general destruction callbacks are being propagated. However, on hot refresh during a context’s lifetime or on aborted refresh attempts, only destroy methods are called.
#### ** Chinese **

另外，请注意，停止通知并不保证在销毁之前就会出现。在定期关闭时，所有`Lifecycle` bean首先会收到一个停止通知，然后再传播一般的销毁回调。但是，在上下文的生命周期内的热刷新或中止刷新尝试时，只调用销毁方法。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The order of startup and shutdown invocations can be important. If a “depends-on” relationship exists between any two objects, the dependent side starts after its dependency, and it stops before its dependency. However, at times, the direct dependencies are unknown. You may only know that objects of a certain type should start prior to objects of another type. In those cases, the `SmartLifecycle` interface defines another option, namely the `getPhase()` method as defined on its super-interface, `Phased`. The following listing shows the definition of the `Phased` interface:
#### ** Chinese **

启动和关闭调用的顺序可能很重要。如果任何两个对象之间存在 "依赖关系"，那么被依赖方在其依赖方之后启动，而在其依赖方之前停止。然而，有时候，直接的依赖关系是未知的。你可能只知道某种类型的对象应该在另一种类型的对象之前开始。在这种情况下，`SmartLifecycle`接口定义了另一个选项，即在其超级接口`Phase()`上定义的`getPhase()`方法。下面的列表显示了`Phased`接口的定义。
<!-- tabs:end -->


```java
public interface Phased {

    int getPhase();
}
```

<!-- tabs:start -->

#### ** English **

The following listing shows the definition of the `SmartLifecycle` interface:
#### ** Chinese **

下面列出了`SmartLifecycle`接口的定义。
<!-- tabs:end -->


```java
public interface SmartLifecycle extends Lifecycle, Phased {

    boolean isAutoStartup();

    void stop(Runnable callback);
}
```

<!-- tabs:start -->

#### ** English **

When starting, the objects with the lowest phase start first. When stopping, the reverse order is followed. Therefore, an object that implements `SmartLifecycle` and whose `getPhase()` method returns `Integer.MIN_VALUE` would be among the first to start and the last to stop. At the other end of the spectrum, a phase value of `Integer.MAX_VALUE` would indicate that the object should be started last and stopped first (likely because it depends on other processes to be running). When considering the phase value, it is also important to know that the default phase for any “normal” `Lifecycle` object that does not implement `SmartLifecycle` is `0`. Therefore, any negative phase value indicates that an object should start before those standard components (and stop after them). The reverse is true for any positive phase value.
#### ** Chinese **

启动时，相位最低的对象先启动。当停止时，遵循相反的顺序。因此，实现了`SmartLifecycle`，并且其`getPhase()`方法返回`Integer.MIN_VALUE`的对象将是最先开始和最后停止的对象。在光谱的另一端，相位值`Integer.MAX_VALUE`表示对象应该是最后启动，最后停止（很可能是因为它取决于其他进程的运行）。在考虑相位值时，还必须知道，任何 "正常"`Lifecycle`对象如果没有实现`SmartLifecycle`，其默认的相位值是`0`。因此，任何负相位值表示对象应该在这些标准组件之前开始（并在它们之后停止）。对于任何正相位值来说，相反的情况也是如此。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The stop method defined by `SmartLifecycle` accepts a callback. Any implementation must invoke that callback’s `run()` method after that implementation’s shutdown process is complete. That enables asynchronous shutdown where necessary, since the default implementation of the `LifecycleProcessor` interface, `DefaultLifecycleProcessor`, waits up to its timeout value for the group of objects within each phase to invoke that callback. The default per-phase timeout is 30 seconds. You can override the default lifecycle processor instance by defining a bean named `lifecycleProcessor` within the context. If you want only to modify the timeout, defining the following would suffice:
#### ** Chinese **

`SmartLifecycle`定义的停止方法接受一个回调。任何实现都必须在该实现的关机过程完成后调用该回调的`run()`方法。这样就可以在必要时实现异步关机，因为`LifecycleProcessor`接口的默认实现`DefaultLifecycleProcessor`会在每个阶段内的对象组中等待到其超时值来调用该回调。每个阶段的默认超时时间是30秒。您可以通过在上下文中定义一个名为`lifecycleProcessor`的Bean来覆盖默认的生命周期处理器实例。如果你只想修改超时，定义以下内容就足够了。
<!-- tabs:end -->


```xml
<bean id="lifecycleProcessor" class="org.springframework.context.support.DefaultLifecycleProcessor">
    <!-- timeout value in milliseconds -->
    <property name="timeoutPerShutdownPhase" value="10000"/>
</bean>
```

<!-- tabs:start -->

#### ** English **

As mentioned earlier, the `LifecycleProcessor` interface defines callback methods for the refreshing and closing of the context as well. The latter drives the shutdown process as if `stop()` had been called explicitly, but it happens when the context is closing. The 'refresh' callback, on the other hand, enables another feature of `SmartLifecycle` beans. When the context is refreshed (after all objects have been instantiated and initialized), that callback is invoked. At that point, the default lifecycle processor checks the boolean value returned by each `SmartLifecycle` object’s `isAutoStartup()` method. If `true`, that object is started at that point rather than waiting for an explicit invocation of the context’s or its own `start()` method (unlike the context refresh, the context start does not happen automatically for a standard context implementation). The `phase` value and any “depends-on” relationships determine the startup order as described earlier.
#### ** Chinese **

如前所述，`LifecycleProcessor`接口定义了刷新和关闭上下文的回调方法。后者驱动关闭进程，就像`stop()`被显式调用一样，但它是在上下文关闭时发生的。另一方面，"刷新 "回调可以实现`SmartLifecycle` Bean的另一个特性。当上下文被刷新时（在所有对象被实例化和初始化后），该回调会被调用。此时，默认的生命周期处理器会检查每个`SmartLifecycle`对象的`isAutoStartup()`方法返回的布尔值。如果`true`，则该对象在该点启动，而不是等待显式调用上下文或其自身的`start()`方法（与上下文刷新不同，对于标准上下文实现来说，上下文启动不会自动发生）。`phase`值和任何 "依赖 "关系决定了前面描述的启动顺序。
<!-- tabs:end -->


### **Shutting Down the Spring IoC Container Gracefully in Non-Web Applications** 

<!-- tabs:start -->

#### ** English **

This section applies only to non-web applications. Spring’s web-based `ApplicationContext` implementations already have code in place to gracefully shut down the Spring IoC container when the relevant web application is shut down.
#### ** Chinese **

本节仅适用于非 Web 应用程序。Spring 的基于 Web 的 `ApplicationContext`实现已经有代码，可在相关 Web 应用程序关闭时优雅地关闭 Spring IoC 容器。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

If you use Spring’s IoC container in a non-web application environment (for example, in a rich client desktop environment), register a shutdown hook with the JVM. Doing so ensures a graceful shutdown and calls the relevant destroy methods on your singleton beans so that all resources are released. You must still configure and implement these destroy callbacks correctly.
#### ** Chinese **

如果您在非网络应用环境中使用Spring的IoC容器（例如，在富客户端桌面环境中），请在JVM中注册一个关闭钩子。这样做可以确保优雅地关闭，并在单子豆上调用相关的销毁方法，从而释放所有资源。您仍然必须正确配置和实现这些销毁回调。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

To register a shutdown hook, call the `registerShutdownHook()` method that is declared on the `ConfigurableApplicationContext` interface, as the following example shows:
#### ** Chinese **

要注册一个关闭钩子，请调用在`ConfigurableApplicationContext`接口上声明的`registerShutdownHook()`方法，如下例所示。
<!-- tabs:end -->


```java
import org.springframework.context.ConfigurableApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public final class Boot {

    public static void main(final String[] args) throws Exception {
        ConfigurableApplicationContext ctx = new ClassPathXmlApplicationContext("beans.xml");

        // add a shutdown hook for the above context...
        ctx.registerShutdownHook();

        // app runs here...

        // main method exits, hook is called prior to the app shutting down...
    }
}
```

### **1.6.2.** **`ApplicationContextAware`** ** and** **`BeanNameAware`** 

<!-- tabs:start -->

#### ** English **

When an `ApplicationContext` creates an object instance that implements the `org.springframework.context.ApplicationContextAware` interface, the instance is provided with a reference to that `ApplicationContext`. The following listing shows the definition of the `ApplicationContextAware` interface:
#### ** Chinese **

当`ApplicationContext`创建了一个实现了`org.springframework.context.ApplicationContextAware`接口的对象实例时，该实例将被提供给该`ApplicationContext`的引用。下面的列表显示了`ApplicationContextAware`接口的定义。
<!-- tabs:end -->


```java
public interface ApplicationContextAware {

    void setApplicationContext(ApplicationContext applicationContext) throws BeansException;
}
```

<!-- tabs:start -->

#### ** English **

Thus, beans can programmatically manipulate the `ApplicationContext` that created them, through the `ApplicationContext` interface or by casting the reference to a known subclass of this interface (such as `ConfigurableApplicationContext`, which exposes additional functionality). One use would be the programmatic retrieval of other beans. Sometimes this capability is useful. However, in general, you should avoid it, because it couples the code to Spring and does not follow the Inversion of Control style, where collaborators are provided to beans as properties. Other methods of the `ApplicationContext` provide access to file resources, publishing application events, and accessing a `MessageSource`. These additional features are described in [Additional Capabilities of the ](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#context-introduction)[`ApplicationContext`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#context-introduction).
#### ** Chinese **

因此，Bean可以通过`ApplicationContext`接口，或者通过对该接口的已知子类的引用（如`ConfigurableApplicationContext`，它揭示了额外的功能），对创建它们的`ApplicationContext`进行程序化操作。一个用途是对其他Bean进行程序化检索。有时候，这个功能是很有用的。但是，一般情况下，你应该避免使用它，因为它将代码与Spring耦合，并且不遵循Inversion of Control风格，即协作者作为属性提供给Bean。`ApplicationContext`的其他方法提供了对文件资源的访问，发布应用程序事件，以及访问`MessageSource`。这些附加功能在[附加功能](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#context-introduction)[`ApplicationContext`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#context-introduction)中描述。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Autowiring is another alternative to obtain a reference to the `ApplicationContext`. The *traditional* `constructor` and `byType` autowiring modes (as described in [Autowiring Collaborators](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-autowire)) can provide a dependency of type `ApplicationContext` for a constructor argument or a setter method parameter, respectively. For more flexibility, including the ability to autowire fields and multiple parameter methods, use the annotation-based autowiring features. If you do, the `ApplicationContext` is autowired into a field, constructor argument, or method parameter that expects the `ApplicationContext` type if the field, constructor, or method in question carries the `@Autowired` annotation. For more information, see [Using ](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-autowired-annotation)[`@Autowired`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-autowired-annotation).
#### ** Chinese **

自动布线是获得`ApplicationContext`引用的另一种选择。*传统的* `constructor`和`byType`自动布线模式（如[Autowiring Collaborators](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-autowire)中描述的那样）可以分别为构造函数参数或设置器方法参数提供一个依赖类型为`ApplicationContext`的依赖。如果想获得更多的灵活性，包括自动布线字段和多个参数方法的能力，请使用基于注解的自动布线功能。如果您使用了这个功能，如果字段、构造器参数或方法携带了`@Autowired`注解，那么`ApplicationContext`就会被自动连线到一个字段、构造器参数或方法参数中，如果该字段、构造器或方法携带了`@Autowired`注解，那么`ApplicationContext`就会被自动连线到一个字段、构造器参数或方法参数中，而该参数期望的`ApplicationContext`类型。有关更多信息，请参阅[使用](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-autowired-annotation)[`@Autowired`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-autowired-annotation)。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

When an `ApplicationContext` creates a class that implements the `org.springframework.beans.factory.BeanNameAware` interface, the class is provided with a reference to the name defined in its associated object definition. The following listing shows the definition of the BeanNameAware interface:
#### ** Chinese **

当`ApplicationContext`创建一个实现了`org.springframework.beans.factory.BeanNameAware`接口的类时，该类将被提供一个引用到其关联对象定义中定义的名称。下面的列表显示了BeanNameAware接口的定义。
<!-- tabs:end -->


```java
public interface BeanNameAware {

    void setBeanName(String name) throws BeansException;
}
```

<!-- tabs:start -->

#### ** English **

The callback is invoked after population of normal bean properties but before an initialization callback such as `InitializingBean`, `afterPropertiesSet`, or a custom init-method.
#### ** Chinese **

该回调是在普通Bean属性人口化之后，但在初始化回调（如`InitializingBean`、`afterPropertiesSet`或自定义的init-method）之前调用的。
<!-- tabs:end -->


### **1.6.3. Other** **`Aware`** ** Interfaces** 

<!-- tabs:start -->

#### ** English **

Besides `ApplicationContextAware` and `BeanNameAware` (discussed [earlier](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-aware)), Spring offers a wide range of `Aware` callback interfaces that let beans indicate to the container that they require a certain infrastructure dependency. As a general rule, the name indicates the dependency type. The following table summarizes the most important `Aware` interfaces:
#### ** Chinese **

除了`ApplicationContextAware`和`BeanNameAware`（前面已经讨论过了）(https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-aware），Spring还提供了大量的`Aware`回调接口，可以让bean向容器指示它们需要某种基础架构依赖。作为一般规则，名称表示依赖类型。下表总结了最重要的`Aware`接口。
<!-- tabs:end -->


Name | Injected Dependency | Explained in…​ 
-|-|-
ApplicationContextAware | Declaring ApplicationContext. | ApplicationContextAware and BeanNameAware 
ApplicationEventPublisherAware | Event publisher of the enclosing ApplicationContext. | Additional Capabilities of the ApplicationContext 
BeanClassLoaderAware | Class loader used to load the bean classes. | Instantiating Beans 
BeanFactoryAware | Declaring BeanFactory. | ApplicationContextAware and BeanNameAware 
BeanNameAware | Name of the declaring bean. | ApplicationContextAware and BeanNameAware 
BootstrapContextAware | Resource adapter BootstrapContext the container runs in. Typically available only in JCA-aware ApplicationContext instances. | JCA CCI 
LoadTimeWeaverAware | Defined weaver for processing class definition at load time. | Load-time Weaving with AspectJ in the Spring Framework 
MessageSourceAware | Configured strategy for resolving messages (with support for parametrization and internationalization). | Additional Capabilities of the ApplicationContext 
NotificationPublisherAware | Spring JMX notification publisher. | Notifications 
ResourceLoaderAware | Configured loader for low-level access to resources. | Resources 
ServletConfigAware | Current ServletConfig the container runs in. Valid only in a web-aware Spring ApplicationContext. | Spring MVC 
ServletContextAware | Current ServletContext the container runs in. Valid only in a web-aware Spring ApplicationContext. | Spring MVC 


<!-- tabs:start -->

#### ** English **

Note again that using these interfaces ties your code to the Spring API and does not follow the Inversion of Control style. As a result, we recommend them for infrastructure beans that require programmatic access to the container.
#### ** Chinese **

再次注意，使用这些接口会将您的代码与Spring API联系在一起，并且不遵循反转控制风格。因此，我们建议将它们用于需要对容器进行程序化访问的基础架构Bean。
<!-- tabs:end -->



[下一章](Spring-Framework-5.2.6.RELEASE/Core%20Technologies/1.7.%20Bean%20Definition%20Inheritance.md)


[回目录](Spring-Framework-5.2.6.RELEASE/summary.md)

[回首页](/README)
