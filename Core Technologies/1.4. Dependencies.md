# 1.4. Dependencies

<!-- tabs:start -->

#### ** English **

A typical enterprise application does not consist of a single object (or bean in the Spring parlance). Even the simplest application has a few objects that work together to present what the end-user sees as a coherent application. This next section explains how you go from defining a number of bean definitions that stand alone to a fully realized application where objects collaborate to achieve a goal.
#### ** Chinese **

一个典型的企业级应用程序并不是由单个对象（或Spring中的Bean）组成。即使是最简单的应用程序，也有一些对象一起工作，以呈现出终端用户所看到的连贯的应用程序。下一节将解释如何从定义一些单独的Bean定义到一个完全实现的应用程序，在这个应用程序中，对象协作实现一个目标。
<!-- tabs:end -->


### **1.4.1. Dependency Injection** 

<!-- tabs:start -->

#### ** English **

Dependency injection (DI) is a process whereby objects define their dependencies (that is, the other objects with which they work) only through constructor arguments, arguments to a factory method, or properties that are set on the object instance after it is constructed or returned from a factory method. The container then injects those dependencies when it creates the bean. This process is fundamentally the inverse (hence the name, Inversion of Control) of the bean itself controlling the instantiation or location of its dependencies on its own by using direct construction of classes or the Service Locator pattern.
#### ** Chinese **

依赖注入(DI)是一个过程，在这个过程中，对象只通过构造器参数、工厂方法的参数，或者在对象实例被构造或从工厂方法返回后，在对象实例上设置的属性来定义它们的依赖关系(也就是与它们一起工作的其他对象)。然后容器在创建Bean时注入这些依赖关系。这个过程从根本上说是Bean本身通过使用类的直接构造或服务定位器模式来控制其依赖关系的实例化或位置的反转（故名Inversion of Control）。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Code is cleaner with the DI principle, and decoupling is more effective when objects are provided with their dependencies. The object does not look up its dependencies and does not know the location or class of the dependencies. As a result, your classes become easier to test, particularly when the dependencies are on interfaces or abstract base classes, which allow for stub or mock implementations to be used in unit tests.
#### ** Chinese **

使用DI原理的代码更干净，当对象提供了依赖关系时，解耦更有效。对象不会去查询它的依赖关系，也不知道依赖关系的位置和类。因此，你的类变得更容易测试，特别是当依赖对象是在接口或抽象基类上的时候，可以在单元测试中使用存根或模拟实现。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

DI exists in two major variants: [Constructor-based dependency injection](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-constructor-injection) and [Setter-based dependency injection](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-setter-injection).
#### ** Chinese **

DI有两种主要的变体。 基于构造函数的依赖注入](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-constructor-injection)和基于Setter的依赖注入](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-setter-injection)。
<!-- tabs:end -->


### **Constructor-based Dependency Injection** 

<!-- tabs:start -->

#### ** English **

Constructor-based DI is accomplished by the container invoking a constructor with a number of arguments, each representing a dependency. Calling a `static` factory method with specific arguments to construct the bean is nearly equivalent, and this discussion treats arguments to a constructor and to a `static` factory method similarly. The following example shows a class that can only be dependency-injected with constructor injection:
#### ** Chinese **

基于构造函数的DI是通过容器调用一个具有若干参数的构造函数来完成的，每个参数代表一个依赖关系。调用一个带有特定参数的`static`工厂方法来构造Bean几乎是等价的，本讨论对构造函数的参数和对`static`工厂方法的参数也是类似的。下面的例子显示了一个只能用构造函数注入依赖注入的类。
<!-- tabs:end -->


```java
public class SimpleMovieLister {

    // the SimpleMovieLister has a dependency on a MovieFinder
    private MovieFinder movieFinder;

    // a constructor so that the Spring container can inject a MovieFinder
    public SimpleMovieLister(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // business logic that actually uses the injected MovieFinder is omitted...
}
```

<!-- tabs:start -->

#### ** English **

Notice that there is nothing special about this class. It is a POJO that has no dependencies on container specific interfaces, base classes or annotations.
#### ** Chinese **

注意，这个类没有什么特别之处。它是一个POJO，没有依赖容器特定的接口、基类或注解。
<!-- tabs:end -->


### **Constructor Argument Resolution** 

<!-- tabs:start -->

#### ** English **

Constructor argument resolution matching occurs by using the argument’s type. If no potential ambiguity exists in the constructor arguments of a bean definition, the order in which the constructor arguments are defined in a bean definition is the order in which those arguments are supplied to the appropriate constructor when the bean is being instantiated. Consider the following class:
#### ** Chinese **

构造器参数解析匹配是通过使用参数的类型进行的。如果Bean定义的构造函数参数中不存在潜在的歧义，那么当Bean被实例化时，构造函数参数在Bean定义中定义的顺序就是这些参数被提供给相应的构造函数的顺序。考虑一下下面的类。
<!-- tabs:end -->


```java
package x.y;

public class ThingOne {

    public ThingOne(ThingTwo thingTwo, ThingThree thingThree) {
        // ...
    }
}
```

<!-- tabs:start -->

#### ** English **

Assuming that `ThingTwo` and `ThingThree` classes are not related by inheritance, no potential ambiguity exists. Thus, the following configuration works fine, and you do not need to specify the constructor argument indexes or types explicitly in the `<constructor-arg/>` element.
#### ** Chinese **

假设`ThingTwo`和`ThingThree`类不存在继承关系，就不存在潜在的歧义。因此，下面的配置可以正常工作，不需要在`<constructor-arg/>`元素中明确指定构造函数参数索引或类型。
<!-- tabs:end -->


```xml
<beans>
    <bean id="beanOne" class="x.y.ThingOne">
        <constructor-arg ref="beanTwo"/>
        <constructor-arg ref="beanThree"/>
    </bean>

    <bean id="beanTwo" class="x.y.ThingTwo"/>

    <bean id="beanThree" class="x.y.ThingThree"/>
</beans>
```

<!-- tabs:start -->

#### ** English **

When another bean is referenced, the type is known, and matching can occur (as was the case with the preceding example). When a simple type is used, such as `<value>true</value>`, Spring cannot determine the type of the value, and so cannot match by type without help. Consider the following class:
#### ** Chinese **

当引用另一个bean时，类型是已知的，可以进行匹配（就像前面的例子一样）。当使用简单的类型时，如`<value>true</value>`，Spring无法确定值的类型，因此无法在没有帮助的情况下进行类型匹配。考虑一下下面的类。
<!-- tabs:end -->


```java
package examples;

public class ExampleBean {

    // Number of years to calculate the Ultimate Answer
    private int years;

    // The Answer to Life, the Universe, and Everything
    private String ultimateAnswer;

    public ExampleBean(int years, String ultimateAnswer) {
        this.years = years;
        this.ultimateAnswer = ultimateAnswer;
    }
}
```

<!-- tabs:start -->

#### ** English **

**Constructor argument type matching** 

#### ** Chinese **

***构造函数参数类型匹配*** 

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

In the preceding scenario, the container can use type matching with simple types if you explicitly specify the type of the constructor argument by using the `type` attribute. as the following example shows:
#### ** Chinese **

在前面的情况下，如果你通过使用`type`属性明确指定了构造函数参数的类型，那么容器就可以使用简单类型的类型匹配，如下例所示。
<!-- tabs:end -->


```xml
<bean id="exampleBean" class="examples.ExampleBean">
    <constructor-arg type="int" value="7500000"/>
    <constructor-arg type="java.lang.String" value="42"/>
</bean>
```

<!-- tabs:start -->

#### ** English **

**Constructor argument index** 
#### ** Chinese **

***构造函数参数索引*** 
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can use the `index` attribute to specify explicitly the index of constructor arguments, as the following example shows:
#### ** Chinese **

你可以使用`index`属性来明确指定构造函数参数的索引，如下例所示。
<!-- tabs:end -->


```xml
<bean id="exampleBean" class="examples.ExampleBean">
    <constructor-arg index="0" value="7500000"/>
    <constructor-arg index="1" value="42"/>
</bean>
```

<!-- tabs:start -->

#### ** English **

In addition to resolving the ambiguity of multiple simple values, specifying an index resolves ambiguity where a constructor has two arguments of the same type.
#### ** Chinese **

除了解决了多个简单值的模糊性之外，指定一个索引还解决了构造函数有两个相同类型的参数时的模糊性。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The index is 0-based.
#### ** Chinese **

该指数以0为基础。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

**Constructor argument name** 
#### ** Chinese **

***构造函数参数名称*** 
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can also use the constructor parameter name for value disambiguation, as the following example shows:
#### ** Chinese **

你也可以使用构造函数的参数名来进行值的分辩，如下例所示。
<!-- tabs:end -->


```xml
<bean id="exampleBean" class="examples.ExampleBean">
    <constructor-arg name="years" value="7500000"/>
    <constructor-arg name="ultimateAnswer" value="42"/>
</bean>
```

<!-- tabs:start -->

#### ** English **

Keep in mind that, to make this work out of the box, your code must be compiled with the debug flag enabled so that Spring can look up the parameter name from the constructor. If you cannot or do not want to compile your code with the debug flag, you can use the [@ConstructorProperties](https://download.oracle.com/javase/8/docs/api/java/beans/ConstructorProperties.html) JDK annotation to explicitly name your constructor arguments. The sample class would then have to look as follows:
#### ** Chinese **

请记住，为了使这个功能开箱即用，你的代码必须在编译时启用调试标志，这样Spring可以从构造函数中查找参数名称。如果您不能或不想在编译代码时启用调试标志，可以使用[@ConstructorProperties](https://download.oracle.com/javase/8/docs/api/java/beans/ConstructorProperties.html) JDK 注解来明确命名你的构造函数参数。然后，示例类的外观如下。
<!-- tabs:end -->


```java
package examples;

public class ExampleBean {

    // Fields omitted

    @ConstructorProperties({"years", "ultimateAnswer"})
    public ExampleBean(int years, String ultimateAnswer) {
        this.years = years;
        this.ultimateAnswer = ultimateAnswer;
    }
}
```

### **Setter-based Dependency Injection** 

<!-- tabs:start -->

#### ** English **

Setter-based DI is accomplished by the container calling setter methods on your beans after invoking a no-argument constructor or a no-argument `static` factory method to instantiate your bean.
#### ** Chinese **

基于setter的DI是通过容器在调用无参数构造函数或无参数的`static`工厂方法来实例化你的Bean之后，在你的Bean上调用setter方法来实现的。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following example shows a class that can only be dependency-injected by using pure setter injection. This class is conventional Java. It is a POJO that has no dependencies on container specific interfaces, base classes, or annotations.
#### ** Chinese **

下面的例子显示了一个只能通过使用纯setter注入的依赖注入类。这个类是传统的Java类。它是一个POJO，没有依赖容器特定的接口、基类或注解。
<!-- tabs:end -->


```java
public class SimpleMovieLister {

    // the SimpleMovieLister has a dependency on the MovieFinder
    private MovieFinder movieFinder;

    // a setter method so that the Spring container can inject a MovieFinder
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // business logic that actually uses the injected MovieFinder is omitted...
}
```

<!-- tabs:start -->

#### ** English **

The `ApplicationContext` supports constructor-based and setter-based DI for the beans it manages. It also supports setter-based DI after some dependencies have already been injected through the constructor approach. You configure the dependencies in the form of a `BeanDefinition`, which you use in conjunction with `PropertyEditor` instances to convert properties from one format to another. However, most Spring users do not work with these classes directly (that is, programmatically) but rather with XML `bean` definitions, annotated components (that is, classes annotated with `@Component`, `@Controller`, and so forth), or `@Bean` methods in Java-based `@Configuration` classes. These sources are then converted internally into instances of `BeanDefinition` and used to load an entire Spring IoC container instance.
#### ** Chinese **

`ApplicationContext`支持基于构造函数和基于setter的DI。它还支持在一些依赖关系已经通过构造器方法注入后，基于setter的DI。你以`BeanDefinition`的形式配置依赖关系，你可以将其与`PropertyEditor`实例一起使用，将属性从一种格式转换为另一种格式。然而，大多数Spring用户并不直接使用这些类（也就是程序化的），而是使用XML `bean`定义、注解的组件（也就是用`@Component`、`@Controller`等注解的类），或者基于Java的`@Configuration`类中的`@Bean`方法。然后这些源会被内部转换为 `BeanDefinition`的实例，并用于加载整个Spring IoC容器实例。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Constructor-based or setter-based DI?
#### ** Chinese **

基于构造器还是基于设置器的DI？
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Since you can mix constructor-based and setter-based DI, it is a good rule of thumb to use constructors for mandatory dependencies and setter methods or configuration methods for optional dependencies. Note that use of the [@Required](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-required-annotation) annotation on a setter method can be used to make the property be a required dependency; however, constructor injection with programmatic validation of arguments is preferable.
#### ** Chinese **

由于你可以混合使用基于构造函数和基于setter的DI，所以使用构造函数来实现强制依赖，而使用setter方法或配置方法来实现可选的依赖是一个很好的经验法则。注意，在setter方法上使用[@Required](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-required-annotation)注解可以使属性成为必要的依赖关系；但是，构造函数注入与参数的程序化验证是比较好的。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The Spring team generally advocates constructor injection, as it lets you implement application components as immutable objects and ensures that required dependencies are not `null`. Furthermore, constructor-injected components are always returned to the client (calling) code in a fully initialized state. As a side note, a large number of constructor arguments is a bad code smell, implying that the class likely has too many responsibilities and should be refactored to better address proper separation of concerns.
#### ** Chinese **

Spring团队通常提倡使用构造函数注入，因为它可以让你将应用程序组件作为不可变对象来实现，并确保所需的依赖关系不是`null`。此外，构造函数注入的组件总是以完全初始化的状态返回给客户端（调用）代码。作为一个侧面的说明，大量的构造函数参数是一种不好的代码味道，暗示着这个类很可能有太多的责任，应该重构以更好地解决适当的分离问题。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Setter injection should primarily only be used for optional dependencies that can be assigned reasonable default values within the class. Otherwise, not-null checks must be performed everywhere the code uses the dependency. One benefit of setter injection is that setter methods make objects of that class amenable to reconfiguration or re-injection later. Management through [JMX MBeans](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#jmx) is therefore a compelling use case for setter injection.
#### ** Chinese **

Setter注入主要应该只用于可选的依赖关系，这些依赖关系在类内可以被分配合理的默认值。否则，在代码使用依赖关系的任何地方都必须执行非空检查。设置器注入的一个好处是，设置器方法使该类的对象可以在以后重新配置或重新注入。因此，通过[JMX MBeans](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#jmx)进行管理是一个非常有说服力的setter注入用例。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Use the DI style that makes the most sense for a particular class. Sometimes, when dealing with third-party classes for which you do not have the source, the choice is made for you. For example, if a third-party class does not expose any setter methods, then constructor injection may be the only available form of DI.
#### ** Chinese **

使用对特定类最有意义的DI风格。有时，当处理第三方类的时候，你没有源码，这时你可以自己选择。例如，如果一个第三方类没有暴露任何setter方法，那么构造函数注入可能是唯一可用的DI形式。
<!-- tabs:end -->


### **Dependency Resolution Process** 

<!-- tabs:start -->

#### ** English **

The container performs bean dependency resolution as follows:
#### ** Chinese **

容器按以下方式执行bean依赖性解析。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

- The `ApplicationContext` is created and initialized with configuration metadata that describes all the beans. Configuration metadata can be specified by XML, Java code, or annotations.

- For each bean, its dependencies are expressed in the form of properties, constructor arguments, or arguments to the static-factory method (if you use that instead of a normal constructor). These dependencies are provided to the bean, when the bean is actually created.

- Each property or constructor argument is an actual definition of the value to set, or a reference to another bean in the container.

- Each property or constructor argument that is a value is converted from its specified format to the actual type of that property or constructor argument. By default, Spring can convert a value supplied in string format to all built-in types, such as `int`, `long`, `String`, `boolean`, and so forth.

#### ** Chinese **

- `ApplicationContext`是用描述所有Bean的配置元数据创建和初始化的。配置元数据可以通过XML、Java代码或注解来指定。

- 对于每个Bean，它的依赖关系以属性、构造器参数或静态-factory方法的参数（如果你使用的是静态-factory方法而不是普通构造器）的形式表示。这些依赖关系是在Bean实际创建时提供给Bean的。

- 每个属性或构造函数参数都是一个要设置的值的实际定义，或者是对容器中另一个Bean的引用。

- 每个作为值的属性或构造函数参数都会从其指定的格式转换为该属性或构造函数参数的实际类型。默认情况下，Spring可以将以字符串格式提供的值转换为所有内置类型，如`int`、`long`、`String`、`boolean`等。

<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

The Spring container validates the configuration of each bean as the container is created. However, the bean properties themselves are not set until the bean is actually created. Beans that are singleton-scoped and set to be pre-instantiated (the default) are created when the container is created. Scopes are defined in [Bean Scopes](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-scopes). Otherwise, the bean is created only when it is requested. Creation of a bean potentially causes a graph of beans to be created, as the bean’s dependencies and its dependencies' dependencies (and so on) are created and assigned. Note that resolution mismatches among those dependencies may show up late — that is, on first creation of the affected bean.
#### ** Chinese **

在创建容器时，Spring容器会验证每个Bean的配置。但是，在实际创建Bean之前，Bean属性本身不会被设置。当创建容器时，会创建单子-作用域并设置为预初始化（默认值）的bean。作用域在[Bean Scopes](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-scopes)中定义。否则，只有在被请求时才会创建该Bean。创建一个Bean可能会导致创建一个Bean的图，因为Bean的依赖关系和它的依赖关系（等等）被创建和分配。请注意，这些依赖关系之间的解析不匹配可能会在后期出现--也就是说，在第一次创建受影响的Bean时就会出现。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Circular dependencies
#### ** Chinese **

循环从属关系
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

If you use predominantly constructor injection, it is possible to create an unresolvable circular dependency scenario.
#### ** Chinese **

如果你主要使用构造函数注入，就有可能产生一个无法解决的循环依赖场景。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

For example: Class A requires an instance of class B through constructor injection, and class B requires an instance of class A through constructor injection. If you configure beans for classes A and B to be injected into each other, the Spring IoC container detects this circular reference at runtime, and throws a `BeanCurrentlyInCreationException`.
#### ** Chinese **

比如说。类 A 需要通过构造函数注入类 B 的实例，而类 B 需要通过构造函数注入类 A 的实例。如果您为类 A 和类 B 配置了 bean，要相互注入，Spring IoC 容器会在运行时检测到此循环引用，并抛出 `BeanCurrentlyInCreationException`。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

One possible solution is to edit the source code of some classes to be configured by setters rather than constructors. Alternatively, avoid constructor injection and use setter injection only. In other words, although it is not recommended, you can configure circular dependencies with setter injection.
#### ** Chinese **

一个可能的解决方案是编辑一些类的源代码，让它由setter而不是构造函数来配置。另外，也可以避免构造函数注入，只使用setter注入。换句话说，虽然不建议使用设置器注入，但可以用设置器注入来配置循环依赖。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Unlike the typical case (with no circular dependencies), a circular dependency between bean A and bean B forces one of the beans to be injected into the other prior to being fully initialized itself (a classic chicken-and-egg scenario).
#### ** Chinese **

不同于典型的情况（没有循环依赖），豆A和豆B之间的循环依赖会迫使其中一个豆在完全初始化之前就被注入到另一个豆中（典型的鸡飞狗跳的情况）。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can generally trust Spring to do the right thing. It detects configuration problems, such as references to non-existent beans and circular dependencies, at container load-time. Spring sets properties and resolves dependencies as late as possible, when the bean is actually created. This means that a Spring container that has loaded correctly can later generate an exception when you request an object if there is a problem creating that object or one of its dependencies — for example, the bean throws an exception as a result of a missing or invalid property. This potentially delayed visibility of some configuration issues is why `ApplicationContext` implementations by default pre-instantiate singleton beans. At the cost of some upfront time and memory to create these beans before they are actually needed, you discover configuration issues when the `ApplicationContext` is created, not later. You can still override this default behavior so that singleton beans initialize lazily, rather than being pre-instantiated.
#### ** Chinese **

一般来说，你可以相信Spring会做正确的事情。它可以在容器加载时检测到配置问题，例如对不存在的Bean的引用和循环依赖等。Spring会尽可能晚地设置属性并解决依赖关系，即在实际创建Bean时。这意味着，如果创建对象或其依赖关系中的一个对象出现了问题，那么已经正确加载的Spring容器可能会在以后请求一个对象时产生异常--例如，Bean因为缺失或无效的属性而抛出异常。这种潜在的延迟可见性可能导致了一些配置问题的延迟可见性，这就是为什么`ApplicationContext`实现默认情况下会预设单子化Bean的原因。在实际需要这些Bean之前创建这些Bean需要花费一些前期的时间和内存，但代价是在创建`ApplicationContext`时发现配置问题，而不是以后才发现。你仍然可以重写这个默认行为，这样单子系统Bean就会懒洋洋地初始化，而不是被预先初始化。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

If no circular dependencies exist, when one or more collaborating beans are being injected into a dependent bean, each collaborating bean is totally configured prior to being injected into the dependent bean. This means that, if bean A has a dependency on bean B, the Spring IoC container completely configures bean B prior to invoking the setter method on bean A. In other words, the bean is instantiated (if it is not a pre-instantiated singleton), its dependencies are set, and the relevant lifecycle methods (such as a [configured init method](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-lifecycle-initializingbean) or the [InitializingBean callback method](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-lifecycle-initializingbean)) are invoked.
#### ** Chinese **

如果不存在循环依赖关系，当一个或多个协作豆被注入到依赖豆时，每个协作豆在被注入到依赖豆之前都会被完全配置。这意味着，如果 bean A 对 bean B 有依赖关系，Spring IoC 容器在调用 bean A 上的 setter 方法之前，会完全配置 bean B。换句话说，如果 bean 不是预实例化的单子，则会实例化该 bean（如果它不是预实例化的单子），设置其依赖关系，并调用相关的生命周期方法（如[配置的 init 方法](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-lifecycle-initializingbean)或[InitializingBean 回调方法](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-lifecycle-initializingbean)）。
<!-- tabs:end -->


### **Examples of Dependency Injection** 

<!-- tabs:start -->

#### ** English **

The following example uses XML-based configuration metadata for setter-based DI. A small part of a Spring XML configuration file specifies some bean definitions as follows:
#### ** Chinese **

下面的例子使用了基于XML的配置元数据，用于基于setter的DI。Spring XML 配置文件中的一小部分指定了一些bean定义，如下所示。
<!-- tabs:end -->


```xml
<bean id="exampleBean" class="examples.ExampleBean">
    <!-- setter injection using the nested ref element -->
    <property name="beanOne">
        <ref bean="anotherExampleBean"/>
    </property>

    <!-- setter injection using the neater ref attribute -->
    <property name="beanTwo" ref="yetAnotherBean"/>
    <property name="integerProperty" value="1"/>
</bean>

<bean id="anotherExampleBean" class="examples.AnotherBean"/>
<bean id="yetAnotherBean" class="examples.YetAnotherBean"/>
```

<!-- tabs:start -->

#### ** English **

The following example shows the corresponding `ExampleBean` class:
#### ** Chinese **

下面的示例显示了相应的`ExampleBean`类。
<!-- tabs:end -->


```java
public class ExampleBean {

    private AnotherBean beanOne;

    private YetAnotherBean beanTwo;

    private int i;

    public void setBeanOne(AnotherBean beanOne) {
        this.beanOne = beanOne;
    }

    public void setBeanTwo(YetAnotherBean beanTwo) {
        this.beanTwo = beanTwo;
    }

    public void setIntegerProperty(int i) {
        this.i = i;
    }
}
```

<!-- tabs:start -->

#### ** English **

In the preceding example, setters are declared to match against the properties specified in the XML file. The following example uses constructor-based DI:
#### ** Chinese **

在前面的例子中，声明设置器是为了与XML文件中指定的属性匹配。下面的例子使用了基于构造函数的DI。
<!-- tabs:end -->


```xml
<bean id="exampleBean" class="examples.ExampleBean">
    <!-- constructor injection using the nested ref element -->
    <constructor-arg>
        <ref bean="anotherExampleBean"/>
    </constructor-arg>

    <!-- constructor injection using the neater ref attribute -->
    <constructor-arg ref="yetAnotherBean"/>

    <constructor-arg type="int" value="1"/>
</bean>

<bean id="anotherExampleBean" class="examples.AnotherBean"/>
<bean id="yetAnotherBean" class="examples.YetAnotherBean"/>
```

<!-- tabs:start -->

#### ** English **

The following example shows the corresponding `ExampleBean` class:
#### ** Chinese **

下面的示例显示了相应的`ExampleBean`类。
<!-- tabs:end -->


```java
public class ExampleBean {

    private AnotherBean beanOne;

    private YetAnotherBean beanTwo;

    private int i;

    public ExampleBean(
        AnotherBean anotherBean, YetAnotherBean yetAnotherBean, int i) {
        this.beanOne = anotherBean;
        this.beanTwo = yetAnotherBean;
        this.i = i;
    }
}
```

<!-- tabs:start -->

#### ** English **

The constructor arguments specified in the bean definition are used as arguments to the constructor of the `ExampleBean`.
#### ** Chinese **

在Bean定义中指定的构造函数参数被用作`ExampleBean`构造函数的参数。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Now consider a variant of this example, where, instead of using a constructor, Spring is told to call a `static` factory method to return an instance of the object:
#### ** Chinese **

现在考虑这个例子的一个变体，在这个例子中，Spring被告知要调用一个`static`工厂方法来返回对象的实例，而不是使用构造函数。
<!-- tabs:end -->


```xml
<bean id="exampleBean" class="examples.ExampleBean" factory-method="createInstance">
    <constructor-arg ref="anotherExampleBean"/>
    <constructor-arg ref="yetAnotherBean"/>
    <constructor-arg value="1"/>
</bean>

<bean id="anotherExampleBean" class="examples.AnotherBean"/>
<bean id="yetAnotherBean" class="examples.YetAnotherBean"/>
```

<!-- tabs:start -->

#### ** English **

The following example shows the corresponding `ExampleBean` class:
#### ** Chinese **

下面的示例显示了相应的`ExampleBean`类。
<!-- tabs:end -->


```java
public class ExampleBean {

    // a private constructor
    private ExampleBean(...) {
        ...
    }

    // a static factory method; the arguments to this method can be
    // considered the dependencies of the bean that is returned,
    // regardless of how those arguments are actually used.
    public static ExampleBean createInstance (
        AnotherBean anotherBean, YetAnotherBean yetAnotherBean, int i) {

        ExampleBean eb = new ExampleBean (...);
        // some other operations...
        return eb;
    }
}
```

<!-- tabs:start -->

#### ** English **

Arguments to the `static` factory method are supplied by `<constructor-arg/>` elements, exactly the same as if a constructor had actually been used. The type of the class being returned by the factory method does not have to be of the same type as the class that contains the `static` factory method (although, in this example, it is). An instance (non-static) factory method can be used in an essentially identical fashion (aside from the use of the `factory-bean` attribute instead of the `class` attribute), so we do not discuss those details here.
#### ** Chinese **

`static`工厂方法的参数由`<constructor-arg/>`元素提供，与实际使用构造函数的情况完全相同。工厂方法返回的类的类型不一定和包含`static`工厂方法的类的类型相同（尽管在这个例子中，它是相同的）。一个实例（非静态）工厂方法可以以基本相同的方式使用（除了使用`factory-bean`属性而不是`class`属性之外），所以我们在这里不讨论这些细节。
<!-- tabs:end -->


### **1.4.2. Dependencies and Configuration in Detail** 

<!-- tabs:start -->

#### ** English **

As mentioned in the [previous section](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-collaborators), you can define bean properties and constructor arguments as references to other managed beans (collaborators) or as values defined inline. Spring’s XML-based configuration metadata supports sub-element types within its `<property/>` and `<constructor-arg/>` elements for this purpose.
#### ** Chinese **

正如在[上一节](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-collaborators)中提到的那样，你可以将Bean属性和构造函数参数定义为对其他被管理的Bean（合作者）的引用，也可以将其定义为内联值。Spring 的基于 XML 的配置元数据支持在其 `<property/>` 和 `<constructor-arg/>` 元素中的子元素类型。
<!-- tabs:end -->


### **Straight Values (Primitives, Strings, and so on)** 

<!-- tabs:start -->

#### ** English **

The `value` attribute of the `<property/>` element specifies a property or constructor argument as a human-readable string representation. Spring’s [conversion service](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#core-convert-ConversionService-API) is used to convert these values from a `String` to the actual type of the property or argument. The following example shows various values being set:
#### ** Chinese **

`<property/>`元素的`value`属性指定了一个属性或构造函数参数作为人类可读的字符串表示。Spring的[转换服务](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#core-convert-ConversionService-API)用于将这些值从`String`转换为属性或参数的实际类型。下面的例子显示了各种值的设置。
<!-- tabs:end -->


```xml
<bean id="myDataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close">
    <!-- results in a setDriverClassName(String) call -->
    <property name="driverClassName" value="com.mysql.jdbc.Driver"/>
    <property name="url" value="jdbc:mysql://localhost:3306/mydb"/>
    <property name="username" value="root"/>
    <property name="password" value="masterkaoli"/>
</bean>
```

<!-- tabs:start -->

#### ** English **

The following example uses the [p-namespace](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-p-namespace) for even more succinct XML configuration:
#### ** Chinese **

下面的例子使用[p-namespace](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-p-namespace)进行更简洁的XML配置。
<!-- tabs:end -->


```xml
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:p="http://www.springframework.org/schema/p"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
    https://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="myDataSource" class="org.apache.commons.dbcp.BasicDataSource"
        destroy-method="close"
        p:driverClassName="com.mysql.jdbc.Driver"
        p:url="jdbc:mysql://localhost:3306/mydb"
        p:username="root"
        p:password="masterkaoli"/>

</beans>
```

<!-- tabs:start -->

#### ** English **

The preceding XML is more succinct. However, typos are discovered at runtime rather than design time, unless you use an IDE (such as [IntelliJ IDEA](https://www.jetbrains.com/idea/) or the [Spring Tools for Eclipse](https://spring.io/tools)) that supports automatic property completion when you create bean definitions. Such IDE assistance is highly recommended.
#### ** Chinese **

前面的XML比较简洁。但是，除非你使用的IDE（如[IntelliJ IDEA](https://www.jetbrains.com/idea/)或[Spring Tools for Eclipse](https://spring.io/tools)）在创建Bean定义时支持自动完成属性完成，否则在运行时而不是设计时就会发现错误。强烈推荐使用这样的IDE帮助。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can also configure a `java.util.Properties` instance, as follows:
#### ** Chinese **

您还可以配置`java.util.Properties`实例，如下所示。
<!-- tabs:end -->


```xml
<bean id="mappings"
    class="org.springframework.context.support.PropertySourcesPlaceholderConfigurer">

    <!-- typed as a java.util.Properties -->
    <property name="properties">
        <value>
            jdbc.driver.className=com.mysql.jdbc.Driver
            jdbc.url=jdbc:mysql://localhost:3306/mydb
        </value>
    </property>
</bean>
```

<!-- tabs:start -->

#### ** English **

The Spring container converts the text inside the `<value/>` element into a `java.util.Properties` instance by using the JavaBeans `PropertyEditor` mechanism. This is a nice shortcut, and is one of a few places where the Spring team do favor the use of the nested `<value/>` element over the `value` attribute style.
#### ** Chinese **

Spring 容器通过使用 JavaBeans `PropertyEditor`机制，将 `<value/>`元素内的文本转换为 `java.util.Properties`实例。这是一个很好的捷径，也是Spring团队喜欢使用嵌套`<value/>`元素而不是`value`属性样式的少数几个地方之一。
<!-- tabs:end -->


### **The** **`idref`** ** element** 

<!-- tabs:start -->

#### ** English **

The `idref` element is simply an error-proof way to pass the `id` (a string value - not a reference) of another bean in the container to a `<constructor-arg/>` or `<property/>` element. The following example shows how to use it:
#### ** Chinese **

`idref`元素只是一个简单的防错方法，它可以将容器中另一个bean的`id`（一个字符串值--不是引用）传递给`<constructor-arg/>`或`<property/>`元素。下面的例子显示了如何使用它。
<!-- tabs:end -->


```xml
<bean id="theTargetBean" class="..."/>

<bean id="theClientBean" class="...">
    <property name="targetName">
        <idref bean="theTargetBean"/>
    </property>
</bean>
```

<!-- tabs:start -->

#### ** English **

The preceding bean definition snippet is exactly equivalent (at runtime) to the following snippet:
#### ** Chinese **

上面的bean定义片段与下面的片段完全等同（在运行时）。
<!-- tabs:end -->


```xml
<bean id="theTargetBean" class="..." />

<bean id="client" class="...">
    <property name="targetName" value="theTargetBean"/>
</bean>
```

<!-- tabs:start -->

#### ** English **

The first form is preferable to the second, because using the `idref` tag lets the container validate at deployment time that the referenced, named bean actually exists. In the second variation, no validation is performed on the value that is passed to the `targetName` property of the `client` bean. Typos are only discovered (with most likely fatal results) when the `client` bean is actually instantiated. If the `client` bean is a [prototype](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-scopes) bean, this typo and the resulting exception may only be discovered long after the container is deployed.
#### ** Chinese **

第一种形式比第二种形式更好，因为使用 `idref` 标记可以让容器在部署时验证被引用的、被命名的 bean 实际存在。在第二种变化中，不会对传递给 `client` bean 的 `targetName` 属性的值进行验证。只有在`client` bean实际实例化时，才会发现错误（很可能是致命的结果）。如果 `client` bean 是一个 [prototype](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-scopes) bean，那么这个 typo 和由此产生的异常可能只有在容器部署后很久之后才会被发现。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The `local` attribute on the `idref` element is no longer supported in the 4.0 beans XSD, since it does not provide value over a regular `bean` reference any more. Change your existing `idref local` references to `idref bean` when upgrading to the 4.0 schema.
#### ** Chinese **

`idref`元素上的`local`属性在4.0 beans XSD中不再支持，因为它不再提供常规的`bean`引用的值。升级到4.0模式时，请将现有的`idref local`引用改为`idref bean`。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

A common place (at least in versions earlier than Spring 2.0) where the `<idref/>` element brings value is in the configuration of [AOP interceptors](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#aop-pfb-1) in a `ProxyFactoryBean` bean definition. Using `<idref/>` elements when you specify the interceptor names prevents you from misspelling an interceptor ID.
#### ** Chinese **

`<idref/>`元素带来价值的一个常见地方（至少在Spring 2.0之前的版本中）是在`ProxyFactoryBean` bean定义中的[AOP拦截器](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#aop-pfb-1)配置中。在指定拦截器名称时使用`<idref/>`元素，可以防止你错写一个拦截器ID。
<!-- tabs:end -->


### **References to Other Beans (Collaborators)** 

<!-- tabs:start -->

#### ** English **

The `ref` element is the final element inside a `<constructor-arg/>` or `<property/>` definition element. Here, you set the value of the specified property of a bean to be a reference to another bean (a collaborator) managed by the container. The referenced bean is a dependency of the bean whose property is to be set, and it is initialized on demand as needed before the property is set. (If the collaborator is a singleton bean, it may already be initialized by the container.) All references are ultimately a reference to another object. Scoping and validation depend on whether you specify the ID or name of the other object through the `bean` or `parent` attribute.
#### ** Chinese **

`ref`元素是`<constructor-arg/>`或`<property/>`定义元素中的最后一个元素。在这里，您可以将 bean 的指定属性的值设置为对容器管理的另一个 bean（合作者）的引用。被引用的Bean是要设置属性的Bean的一个依赖，在设置属性之前，它会根据需要进行初始化。(如果合作者是一个单子Bean，它可能已经被容器初始化了)。所有的引用最终都是对另一个对象的引用。范围和验证取决于你是否通过`bean`或`parent`属性指定另一个对象的ID或名称。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Specifying the target bean through the `bean` attribute of the `<ref/>` tag is the most general form and allows creation of a reference to any bean in the same container or parent container, regardless of whether it is in the same XML file. The value of the `bean` attribute may be the same as the `id` attribute of the target bean or be the same as one of the values in the `name` attribute of the target bean. The following example shows how to use a `ref` element:
#### ** Chinese **

通过`<ref/>`标记的`bean`属性指定目标Bean是最通用的形式，它允许在同一容器或父容器中创建对任何Bean的引用，无论它是否在同一XML文件中。`bean`属性的值可以与目标Bean的`id`属性相同，也可以与目标Bean的`name`属性中的一个值相同。下面的例子显示了如何使用`ref`元素。
<!-- tabs:end -->


```xml
<ref bean="someBean"/>
```

<!-- tabs:start -->

#### ** English **

Specifying the target bean through the `parent` attribute creates a reference to a bean that is in a parent container of the current container. The value of the `parent` attribute may be the same as either the `id` attribute of the target bean or one of the values in the `name` attribute of the target bean. The target bean must be in a parent container of the current one. You should use this bean reference variant mainly when you have a hierarchy of containers and you want to wrap an existing bean in a parent container with a proxy that has the same name as the parent bean. The following pair of listings shows how to use the `parent` attribute:
#### ** Chinese **

通过`parent`属性指定目标Bean，会创建一个指向当前容器的父容器中的Bean的引用。`parent`属性的值可以与目标Bean的`id`属性或目标Bean的`name`属性中的一个值相同。目标Bean必须位于当前Bean的父容器中。你应该主要在你有一个容器的层次结构，并且你想在父容器中用一个与父Bean名称相同的代理将一个现有的Bean封装在父容器中时使用这个Bean引用变体。下面的一对列表展示了如何使用`parent`属性。
<!-- tabs:end -->


```xml
<!-- in the parent context -->
<bean id="accountService" class="com.something.SimpleAccountService">
    <!-- insert dependencies as required as here -->
</bean>
```

```xml
<!-- in the child (descendant) context -->
<bean id="accountService" <!-- bean name is the same as the parent bean -->
    class="org.springframework.aop.framework.ProxyFactoryBean">
    <property name="target">
        <ref parent="accountService"/> <!-- notice how we refer to the parent bean -->
    </property>
    <!-- insert other configuration and dependencies as required here -->
</bean>
```

<!-- tabs:start -->

#### ** English **

The `local` attribute on the `ref` element is no longer supported in the 4.0 beans XSD, since it does not provide value over a regular `bean` reference any more. Change your existing `ref local` references to `ref bean` when upgrading to the 4.0 schema.
#### ** Chinese **

`ref`元素上的`local`属性在4.0 beans XSD中不再支持，因为它不再为普通的`bean`引用提供值。升级到4.0模式时，请将现有的`ref local`引用改为`ref bean`。
<!-- tabs:end -->


### **Inner Beans** 

<!-- tabs:start -->

#### ** English **

A `<bean/>` element inside the `<property/>` or `<constructor-arg/>` elements defines an inner bean, as the following example shows:
#### ** Chinese **

在`<property/>`或`<constructor-arg/>`元素内的`<bean/>`元素定义了一个内部Bean，如下例所示。
<!-- tabs:end -->


```xml
<bean id="outer" class="...">
    <!-- instead of using a reference to a target bean, simply define the target bean inline -->
    <property name="target">
        <bean class="com.example.Person"> <!-- this is the inner bean -->
            <property name="name" value="Fiona Apple"/>
            <property name="age" value="25"/>
        </bean>
    </property>
</bean>
```

<!-- tabs:start -->

#### ** English **

An inner bean definition does not require a defined ID or name. If specified, the container does not use such a value as an identifier. The container also ignores the `scope` flag on creation, because inner beans are always anonymous and are always created with the outer bean. It is not possible to access inner beans independently or to inject them into collaborating beans other than into the enclosing bean.
#### ** Chinese **

内部Bean定义不需要定义ID或名称。如果指定了，容器不会使用这样的值作为标识符。容器在创建时也会忽略`scope`标志，因为内部Bean总是匿名的，并且总是与外部Bean一起创建。不可能独立地访问内部Bean，也不可能将其注入到合作的Bean中，而不是注入到包围的Bean中。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

As a corner case, it is possible to receive destruction callbacks from a custom scope — for example, for a request-scoped inner bean contained within a singleton bean. The creation of the inner bean instance is tied to its containing bean, but destruction callbacks let it participate in the request scope’s lifecycle. This is not a common scenario. Inner beans typically simply share their containing bean’s scope.
#### ** Chinese **

作为一种特殊情况，可以从自定义作用域中接收销毁回调--例如，对于包含在单子bean中的请求作用域内的内部Bean，可以接收销毁回调。内部Bean实例的创建与它所包含的Bean绑定，但销毁回调让它参与到请求作用域的生命周期中。这不是一个常见的场景。内部Bean通常只是简单地共享其包含的Bean的作用域。
<!-- tabs:end -->


### **Collections** 

<!-- tabs:start -->

#### ** English **

The `<list/>`, `<set/>`, `<map/>`, and `<props/>` elements set the properties and arguments of the Java `Collection` types `List`, `Set`, `Map`, and `Properties`, respectively. The following example shows how to use them:
#### ** Chinese **

`<list/>`, `<set/>`, `<map/>`和`<props/>`元素分别设置了Java `Collection`类型`List`、`Set`、`Map`和`Properties`的属性和参数。下面的例子显示了如何使用这些类型。
<!-- tabs:end -->


```xml
<bean id="moreComplexObject" class="example.ComplexObject">
    <!-- results in a setAdminEmails(java.util.Properties) call -->
    <property name="adminEmails">
        <props>
            <prop key="administrator">administrator@example.org</prop>
            <prop key="support">support@example.org</prop>
            <prop key="development">development@example.org</prop>
        </props>
    </property>
    <!-- results in a setSomeList(java.util.List) call -->
    <property name="someList">
        <list>
            <value>a list element followed by a reference</value>
            <ref bean="myDataSource" />
        </list>
    </property>
    <!-- results in a setSomeMap(java.util.Map) call -->
    <property name="someMap">
        <map>
            <entry key="an entry" value="just some string"/>
            <entry key ="a ref" value-ref="myDataSource"/>
        </map>
    </property>
    <!-- results in a setSomeSet(java.util.Set) call -->
    <property name="someSet">
        <set>
            <value>just some string</value>
            <ref bean="myDataSource" />
        </set>
    </property>
</bean>
```

<!-- tabs:start -->

#### ** English **

The value of a map key or value, or a set value, can also be any of the following elements:
#### ** Chinese **

地图键或值的值，或者是设定的值，也可以是以下任何一个元素：
<!-- tabs:end -->


```
bean | ref | idref | list | set | map | props | value | null
```

### **Collection Merging** 

<!-- tabs:start -->

#### ** English **

The Spring container also supports merging collections. An application developer can define a parent `<list/>`, `<map/>`, `<set/>` or `<props/>` element and have child `<list/>`, `<map/>`, `<set/>` or `<props/>` elements inherit and override values from the parent collection. That is, the child collection’s values are the result of merging the elements of the parent and child collections, with the child’s collection elements overriding values specified in the parent collection.
#### ** Chinese **

Spring 容器还支持合并集合。应用程序开发人员可以定义一个父集合`<list/>`、`<map/>`、`<set/>`或`<props/>`元素，并让子集合`<list/>`、`<map/></>`、`<set/>`或`<props/>`元素继承并覆盖父集合的值。也就是说，子集合的值是父集合和子集合的元素合并的结果，子集合的元素覆盖父集合中指定的值。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

This section on merging discusses the parent-child bean mechanism. Readers unfamiliar with parent and child bean definitions may wish to read the [relevant section](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-child-bean-definitions) before continuing.
#### ** Chinese **

本节关于合并的部分讨论了父子豆机制。不熟悉父子豆定义的读者不妨先阅读[相关章节](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-child-bean-definitions)，然后再继续讨论。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following example demonstrates collection merging:
#### ** Chinese **

下面的例子演示了集合合并。
<!-- tabs:end -->


```xml
<beans>
    <bean id="parent" abstract="true" class="example.ComplexObject">
        <property name="adminEmails">
            <props>
                <prop key="administrator">administrator@example.com</prop>
                <prop key="support">support@example.com</prop>
            </props>
        </property>
    </bean>
    <bean id="child" parent="parent">
        <property name="adminEmails">
            <!-- the merge is specified on the child collection definition -->
            <props merge="true">
                <prop key="sales">sales@example.com</prop>
                <prop key="support">support@example.co.uk</prop>
            </props>
        </property>
    </bean>
<beans>
```

<!-- tabs:start -->

#### ** English **

Notice the use of the `merge=true` attribute on the `<props/>` element of the `adminEmails` property of the `child` bean definition. When the `child` bean is resolved and instantiated by the container, the resulting instance has an `adminEmails` `Properties` collection that contains the result of merging the child’s `adminEmails` collection with the parent’s `adminEmails` collection. The following listing shows the result:
#### ** Chinese **

注意在`child` bean定义的`<props/>`属性的`<props/>`元素上使用了`merge=true`属性。当`child` bean被容器解析并实例化后，生成的实例有一个`adminEmails` `Properties`集合，该集合包含了将子对象的`adminEmails`集合与父对象的`adminEmails`集合合并的结果。下面的列表显示了合并的结果。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

administrator=administrator@example.com
#### ** Chinese **

administrator=administrator@example.com
<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

sales=sales@example.com
#### ** Chinese **

sales=sales@example.com
<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

support=support@example.co.uk
#### ** Chinese **

support=support@example.co.uk
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The child `Properties` collection’s value set inherits all property elements from the parent `<props/>`, and the child’s value for the `support` value overrides the value in the parent collection.
#### ** Chinese **

子`Properties`集合的值集继承了父`<props/>`中的所有属性元素，并且子集的`support`的值覆盖了父集合中的值。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

This merging behavior applies similarly to the `<list/>`, `<map/>`, and `<set/>` collection types. In the specific case of the `<list/>` element, the semantics associated with the `List` collection type (that is, the notion of an `ordered` collection of values) is maintained. The parent’s values precede all of the child list’s values. In the case of the `Map`, `Set`, and `Properties` collection types, no ordering exists. Hence, no ordering semantics are in effect for the collection types that underlie the associated `Map`, `Set`, and `Properties` implementation types that the container uses internally.
#### ** Chinese **

这种合并行为同样适用于`<list/>`, `<map/>`和`<set/>`集合类型。在 `<list/>` 元素的特殊情况下，保留了与 `List`集合类型相关的语义（也就是说，是一个`有序的`值集合的概念）。父的值在所有子列表的值之前。在`Map`、`Set`和`Properties`集合类型的情况下，不存在排序。因此，对于容器内部使用的相关的 `Map`、`Set`和`Properties`实现类型的基础集合类型，没有任何排序语义。
<!-- tabs:end -->


### **Limitations of Collection Merging** 

<!-- tabs:start -->

#### ** English **

You cannot merge different collection types (such as a `Map` and a `List`). If you do attempt to do so, an appropriate `Exception` is thrown. The `merge` attribute must be specified on the lower, inherited, child definition. Specifying the `merge` attribute on a parent collection definition is redundant and does not result in the desired merging.
#### ** Chinese **

您不能合并不同的集合类型（例如`Map`和`List`）。如果您尝试这样做，会抛出一个适当的 `Exception`。`merge`属性必须在下级继承的子定义中指定。在父集合定义上指定`merge`属性是多余的，不会导致所需的合并。
<!-- tabs:end -->


### **Strongly-typed collection** 

<!-- tabs:start -->

#### ** English **

With the introduction of generic types in Java 5, you can use strongly typed collections. That is, it is possible to declare a `Collection` type such that it can only contain (for example) `String` elements. If you use Spring to dependency-inject a strongly-typed `Collection` into a bean, you can take advantage of Spring’s type-conversion support such that the elements of your strongly-typed `Collection` instances are converted to the appropriate type prior to being added to the `Collection`. The following Java class and bean definition show how to do so:
#### ** Chinese **

在Java 5中引入了通用类型后，你可以使用强类型化的集合。也就是说，可以声明一个`Collection`类型，使其只能包含（例如）`String`元素。如果您使用Spring将强类型化的`Collection`依赖注入到Bean中，您可以利用Spring的类型转换支持，这样您的强类型化的`Collection`实例的元素在被添加到`Collection`之前就会被转换为相应的类型。下面的Java类和Bean定义展示了如何进行转换。
<!-- tabs:end -->


```java
public class SomeClass {

    private Map<String, Float> accounts;

    public void setAccounts(Map<String, Float> accounts) {
        this.accounts = accounts;
    }
}
```

```xml
<beans>
    <bean id="something" class="x.y.SomeClass">
        <property name="accounts">
            <map>
                <entry key="one" value="9.99"/>
                <entry key="two" value="2.75"/>
                <entry key="six" value="3.99"/>
            </map>
        </property>
    </bean>
</beans>
```

<!-- tabs:start -->

#### ** English **

When the `accounts` property of the `something` bean is prepared for injection, the generics information about the element type of the strongly-typed `Map<String, Float>` is available by reflection. Thus, Spring’s type conversion infrastructure recognizes the various value elements as being of type `Float`, and the string values (`9.99, 2.75`, and `3.99`) are converted into an actual `Float` type.
#### ** Chinese **

当`something` bean的`accounts`属性准备注入时，通过反射就可以获得关于强类型`Map<String, Float>`的元素类型的属性信息。因此，Spring的类型转换基础架构将各种值元素识别为类型为`Float`，而字符串值（`9.99, 2.75`和`3.99`）则被转换为实际的`Float`类型。
<!-- tabs:end -->


### **Null and Empty String Values** 

<!-- tabs:start -->

#### ** English **

Spring treats empty arguments for properties and the like as empty `Strings`. The following XML-based configuration metadata snippet sets the `email` property to the empty `String` value ("").
#### ** Chinese **

Spring 将属性等的空参数视为空 `Strings`。以下基于 XML 的配置元数据片段将 `email` 属性设置为空的 `String` 值（""）。
<!-- tabs:end -->


```xml
<bean class="ExampleBean">
    <property name="email" value=""/>
</bean>
```

<!-- tabs:start -->

#### ** English **

The preceding example is equivalent to the following Java code:
#### ** Chinese **

前面的例子相当于下面的Java代码。
<!-- tabs:end -->


```java
exampleBean.setEmail("");
```

<!-- tabs:start -->

#### ** English **

The `<null/>` element handles `null` values. The following listing shows an example:
#### ** Chinese **

`<null/>`元素处理`null`值。下面的列表显示了一个例子。
<!-- tabs:end -->


```xml
<bean class="ExampleBean">
    <property name="email">
        <null/>
    </property>
</bean>
```

<!-- tabs:start -->

#### ** English **

The preceding configuration is equivalent to the following Java code:
#### ** Chinese **

前面的配置相当于下面的Java代码。
<!-- tabs:end -->


```java
exampleBean.setEmail(null);
```

### **XML Shortcut with the p-namespace** 

<!-- tabs:start -->

#### ** English **

The p-namespace lets you use the `bean` element’s attributes (instead of nested `<property/>` elements) to describe your property values collaborating beans, or both.
#### ** Chinese **

p-命名空间让你可以使用`bean`元素的属性（而不是嵌套的`<property/>`元素）来描述你的属性值协作豆，或者两者都有。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Spring supports extensible configuration formats [with namespaces](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#xsd-schemas), which are based on an XML Schema definition. The `beans` configuration format discussed in this chapter is defined in an XML Schema document. However, the p-namespace is not defined in an XSD file and exists only in the core of Spring.
#### ** Chinese **

Spring 支持可扩展的配置格式[带命名空间](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#xsd-schemas)，它是基于 XML Schema 定义的。本章讨论的`beans`配置格式是在XML Schema文档中定义的。但是，p-命名空间没有在XSD文件中定义，只存在于Spring的核心中。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following example shows two XML snippets (the first uses standard XML format and the second uses the p-namespace) that resolve to the same result:
#### ** Chinese **

下面的例子显示了两个XML片段（第一个使用标准的XML格式，第二个使用p-命名空间），解析到相同的结果。
<!-- tabs:end -->


```xml
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:p="http://www.springframework.org/schema/p"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean name="classic" class="com.example.ExampleBean">
        <property name="email" value="someone@somewhere.com"/>
    </bean>

    <bean name="p-namespace" class="com.example.ExampleBean"
        p:email="someone@somewhere.com"/>
</beans>
```

<!-- tabs:start -->

#### ** English **

The example shows an attribute in the p-namespace called `email` in the bean definition. This tells Spring to include a property declaration. As previously mentioned, the p-namespace does not have a schema definition, so you can set the name of the attribute to the property name.
#### ** Chinese **

这个例子显示了在bean定义中的p命名空间中的一个属性，名为`email`。这告诉Spring要包含一个属性声明。如前所述，p-命名空间没有模式定义，所以可以将属性的名称设置为属性名称。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

This next example includes two more bean definitions that both have a reference to another bean:
#### ** Chinese **

接下来的例子中又包括了两个豆子的定义，这两个定义都有对另一个豆子的引用。
<!-- tabs:end -->


```xml
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:p="http://www.springframework.org/schema/p"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean name="john-classic" class="com.example.Person">
        <property name="name" value="John Doe"/>
        <property name="spouse" ref="jane"/>
    </bean>

    <bean name="john-modern"
        class="com.example.Person"
        p:name="John Doe"
        p:spouse-ref="jane"/>

    <bean name="jane" class="com.example.Person">
        <property name="name" value="Jane Doe"/>
    </bean>
</beans>
```

<!-- tabs:start -->

#### ** English **

This example includes not only a property value using the p-namespace but also uses a special format to declare property references. Whereas the first bean definition uses `<property name="spouse" ref="jane"/>` to create a reference from bean `john` to bean `jane`, the second bean definition uses `p:spouse-ref="jane"` as an attribute to do the exact same thing. In this case, `spouse` is the property name, whereas the `-ref` part indicates that this is not a straight value but rather a reference to another bean.
#### ** Chinese **

这个例子不仅包含了使用p-命名空间的属性值，还使用了一种特殊的格式来声明属性引用。第一个bean定义使用`<property name="spouse" ref="jane"/>`来创建一个从bean `john`到bean `jane`的引用，而第二个bean定义使用`p:spouse-ref="jane"`作为属性来做同样的事情。在这种情况下，`spouse`是属性名，而`-ref`部分表示这不是一个直接的值，而是对另一个Bean的引用。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The p-namespace is not as flexible as the standard XML format. For example, the format for declaring property references clashes with properties that end in `Ref`, whereas the standard XML format does not. We recommend that you choose your approach carefully and communicate this to your team members to avoid producing XML documents that use all three approaches at the same time.
#### ** Chinese **

p-命名空间不像标准的XML格式那样灵活。例如，声明属性引用的格式与以`Ref`结尾的属性冲突，而标准的XML格式则不冲突。我们建议您谨慎选择您的方法，并向您的团队成员传达这一点，以避免同时产生同时使用这三种方法的XML文档。
<!-- tabs:end -->


### **XML Shortcut with the c-namespace** 

<!-- tabs:start -->

#### ** English **

Similar to the [XML Shortcut with the p-namespace](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-p-namespace), the c-namespace, introduced in Spring 3.1, allows inlined attributes for configuring the constructor arguments rather then nested `constructor-arg` elements.
#### ** Chinese **

与[使用p-namespace的XML快捷方式](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-p-namespace)类似，在Spring 3.1中引入的c-namespace允许内嵌式属性来配置构造函数参数，而不是嵌套`constructor-arg`元素。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following example uses the `c:` namespace to do the same thing as the from [Constructor-based Dependency Injection](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-constructor-injection):
#### ** Chinese **

下面的示例使用`c:`命名空间来做与from[基于构造函数的依赖注入](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-constructor-injection)相同的事情。
<!-- tabs:end -->


```xml
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:c="http://www.springframework.org/schema/c"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="beanTwo" class="x.y.ThingTwo"/>
    <bean id="beanThree" class="x.y.ThingThree"/>

    <!-- traditional declaration with optional argument names -->
    <bean id="beanOne" class="x.y.ThingOne">
        <constructor-arg name="thingTwo" ref="beanTwo"/>
        <constructor-arg name="thingThree" ref="beanThree"/>
        <constructor-arg name="email" value="something@somewhere.com"/>
    </bean>

    <!-- c-namespace declaration with argument names -->
    <bean id="beanOne" class="x.y.ThingOne" c:thingTwo-ref="beanTwo"
        c:thingThree-ref="beanThree" c:email="something@somewhere.com"/>

</beans>
```

<!-- tabs:start -->

#### ** English **

The `c:` namespace uses the same conventions as the `p:` one (a trailing `-ref` for bean references) for setting the constructor arguments by their names. Similarly, it needs to be declared in the XML file even though it is not defined in an XSD schema (it exists inside the Spring core).
#### ** Chinese **

`c:`命名空间使用与`p:`命名空间相同的约定（Bean引用的尾部有一个`-ref`），以其名称设置构造函数参数。同样，即使它没有在XSD模式中定义，也需要在XML文件中声明（它存在于Spring内核中）。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

For the rare cases where the constructor argument names are not available (usually if the bytecode was compiled without debugging information), you can use fallback to the argument indexes, as follows:
#### ** Chinese **

对于构造函数参数名不可用的罕见情况（通常是在编译字节码时没有调试信息的情况下），可以使用回落参数索引，如下所示。
<!-- tabs:end -->


```xml
<!-- c-namespace index declaration -->
<bean id="beanOne" class="x.y.ThingOne" c:_0-ref="beanTwo" c:_1-ref="beanThree"
    c:_2="something@somewhere.com"/>
```

<!-- tabs:start -->

#### ** English **

Due to the XML grammar, the index notation requires the presence of the leading `_`, as XML attribute names cannot start with a number (even though some IDEs allow it). A corresponding index notation is also available for `<constructor-arg>` elements but not commonly used since the plain order of declaration is usually sufficient there.
#### ** Chinese **

由于 XML 语法的原因，索引符号要求前导 `_`的存在，因为 XML 属性名不能以数字开头（尽管有些 IDE 允许这样做）。`<constructor-arg>`元素也可以使用相应的索引符号，但不常用，因为那里的声明顺序通常只需要简单的声明就可以了。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

In practice, the constructor resolution [mechanism](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-ctor-arguments-resolution) is quite efficient in matching arguments, so unless you really need to, we recommend using the name notation through-out your configuration.
#### ** Chinese **

在实践中，构造函数解析[机制](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-ctor-arguments-resolution)在匹配参数方面是相当有效的，所以除非你真的有必要，否则我们建议你的配置中全程使用名称符号。
<!-- tabs:end -->


### **Compound Property Names** 

<!-- tabs:start -->

#### ** English **

You can use compound or nested property names when you set bean properties, as long as all components of the path except the final property name are not `null`. Consider the following bean definition:
#### ** Chinese **

当你设置Bean属性时，你可以使用复合或嵌套的属性名，只要路径中除了最终的属性名以外的所有组件都不是`null`。考虑下面的Bean定义。
<!-- tabs:end -->


```xml
<bean id="something" class="things.ThingOne">
    <property name="fred.bob.sammy" value="123" />
</bean>
```

<!-- tabs:start -->

#### ** English **

The `something` bean has a `fred` property, which has a `bob` property, which has a `sammy` property, and that final `sammy` property is being set to a value of `123`. In order for this to work, the `fred` property of `something` and the `bob` property of `fred` must not be `null` after the bean is constructed. Otherwise, a `NullPointerException` is thrown.
#### ** Chinese **

`something` bean有一个`fred`属性，它有一个`bob`属性，它有一个`sammy`属性，而那个最后的`sammy`属性被设置为`123`的值。为了使这一点起作用，在构建Bean之后，`something`的`fred`属性和`fred`的`bob`属性不能为`null`。否则，会抛出一个`NullPointerException`。
<!-- tabs:end -->


### **1.4.3. Using** **`depends-on`** 

<!-- tabs:start -->

#### ** English **

If a bean is a dependency of another bean, that usually means that one bean is set as a property of another. Typically you accomplish this with the [`<ref/>`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-ref-element)[ element](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-ref-element) in XML-based configuration metadata. However, sometimes dependencies between beans are less direct. An example is when a static initializer in a class needs to be triggered, such as for database driver registration. The `depends-on` attribute can explicitly force one or more beans to be initialized before the bean using this element is initialized. The following example uses the `depends-on` attribute to express a dependency on a single bean:
#### ** Chinese **

如果一个bean是另一个bean的依赖关系，通常意味着一个bean被设置为另一个bean的属性。通常情况下，你可以通过基于 XML 的配置元数据中的 [`<ref/>`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-ref-element)[元素](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-ref-element)来实现。然而，有时Bean之间的依赖关系没有那么直接。一个例子是当一个类中的静态初始化器需要被触发时，比如数据库驱动注册。`depends-on`属性可以显式地强制一个或多个Bean在使用该元素的Bean初始化之前被初始化。下面的示例使用`depends-on`属性来表达对单个Bean的依赖关系。
<!-- tabs:end -->


```xml
<bean id="beanOne" class="ExampleBean" depends-on="manager"/>
<bean id="manager" class="ManagerBean" />
```

<!-- tabs:start -->

#### ** English **

To express a dependency on multiple beans, supply a list of bean names as the value of the `depends-on` attribute (commas, whitespace, and semicolons are valid delimiters):
#### ** Chinese **

要表达对多个Bean的依赖关系，请提供一个Bean名称的列表作为`depends-on`属性的值（逗号、空格和分号是有效的分隔符）。
<!-- tabs:end -->


```xml
<bean id="beanOne" class="ExampleBean" depends-on="manager,accountDao">
    <property name="manager" ref="manager" />
</bean>

<bean id="manager" class="ManagerBean" />
<bean id="accountDao" class="x.y.jdbc.JdbcAccountDao" />
```

<!-- tabs:start -->

#### ** English **

The `depends-on` attribute can specify both an initialization-time dependency and, in the case of [singleton](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-scopes-singleton) beans only, a corresponding destruction-time dependency. Dependent beans that define a `depends-on` relationship with a given bean are destroyed first, prior to the given bean itself being destroyed. Thus, `depends-on` can also control shutdown order.
#### ** Chinese **

`depends-on`属性既可以指定初始化时的依赖关系，也可以指定相应的销毁时的依赖关系，在[singleton](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-scopes-singleton)bean的情况下，只指定相应的销毁时的依赖关系。定义了`depends-on`关系的依赖豆，在给定的Bean本身被销毁之前，会先销毁。因此，`depends-on`也可以控制关闭顺序。
<!-- tabs:end -->


### **1.4.4. Lazy-initialized Beans** 

<!-- tabs:start -->

#### ** English **

By default, `ApplicationContext` implementations eagerly create and configure all [singleton](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-scopes-singleton) beans as part of the initialization process. Generally, this pre-instantiation is desirable, because errors in the configuration or surrounding environment are discovered immediately, as opposed to hours or even days later. When this behavior is not desirable, you can prevent pre-instantiation of a singleton bean by marking the bean definition as being lazy-initialized. A lazy-initialized bean tells the IoC container to create a bean instance when it is first requested, rather than at startup.
#### ** Chinese **

默认情况下，`ApplicationContext`实现会急切地创建和配置所有[singleton](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-scopes-singleton)Bean，作为初始化过程的一部分。一般来说，这种预初始化是可取的，因为配置或周围环境中的错误会立即被发现，而不是几个小时甚至几天后才发现。当这种行为不可取时，你可以通过将bean定义标记为懒惰初始化，来防止对单子bean进行预初始化。lazy-initialized bean会告诉IoC容器在第一次请求时，而不是在启动时创建一个bean实例。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

In XML, this behavior is controlled by the `lazy-init` attribute on the `<bean/>` element, as the following example shows:
#### ** Chinese **

在XML中，这种行为由`<bean/>`元素上的`lazy-init`属性控制，如下图所示。
<!-- tabs:end -->


```xml
<bean id="lazy" class="com.something.ExpensiveToCreateBean" lazy-init="true"/>
<bean name="not.lazy" class="com.something.AnotherBean"/>
```

<!-- tabs:start -->

#### ** English **

When the preceding configuration is consumed by an `ApplicationContext`, the `lazy` bean is not eagerly pre-instantiated when the `ApplicationContext` starts, whereas the `not.lazy` bean is eagerly pre-instantiated.
#### ** Chinese **

当前面的配置被`ApplicationContext`消耗时，当`ApplicationContext`启动时，`lazy` bean并不急于预强化，而`not.lazy` bean则急于预强化。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

However, when a lazy-initialized bean is a dependency of a singleton bean that is not lazy-initialized, the `ApplicationContext` creates the lazy-initialized bean at startup, because it must satisfy the singleton’s dependencies. The lazy-initialized bean is injected into a singleton bean elsewhere that is not lazy-initialized.
#### ** Chinese **

但是，当一个懒惰初始化的Bean是一个没有懒惰初始化的单体Bean的依赖关系时，`ApplicationContext`会在启动时创建这个懒惰初始化的Bean，因为它必须满足单体Bean的依赖关系。懒惰初始化的Bean被注入到其他地方没有懒惰初始化的单体Bean中。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can also control lazy-initialization at the container level by using the `default-lazy-init` attribute on the `<beans/>` element, a the following example shows:
#### ** Chinese **

你也可以通过在`<beans/>`元素上使用`default-lazy-init`属性来控制容器级的懒惰初始化，下面的例子显示了这样的情况。
<!-- tabs:end -->


```xml
<beans default-lazy-init="true">
    <!-- no beans will be pre-instantiated... -->
</beans>
```

### **1.4.5. Autowiring Collaborators** 

<!-- tabs:start -->

#### ** English **

The Spring container can autowire relationships between collaborating beans. You can let Spring resolve collaborators (other beans) automatically for your bean by inspecting the contents of the `ApplicationContext`. Autowiring has the following advantages:
#### ** Chinese **

Spring容器可以自动触发协作Bean之间的关系。你可以通过检查`ApplicationContext`中的内容，让Spring自动为你的Bean解决协作豆（其他Bean）。Autowiring有以下优点。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

- Autowiring can significantly reduce the need to specify properties or constructor arguments. (Other mechanisms such as a bean template [discussed elsewhere in this chapter](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-child-bean-definitions) are also valuable in this regard.)

- Autowiring can update a configuration as your objects evolve. For example, if you need to add a dependency to a class, that dependency can be satisfied automatically without you needing to modify the configuration. Thus autowiring can be especially useful during development, without negating the option of switching to explicit wiring when the code base becomes more stable.

#### ** Chinese **

- 自动布线可以大大减少指定属性或构造函数参数的需求。(其他机制，如Bean模板[在本章其他地方讨论](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-child-bean-definitions)在这方面也很有价值。)

- Autowiring可以随着对象的发展而更新配置。例如，如果你需要给一个类添加一个依赖关系，这个依赖关系可以自动满足，而不需要修改配置。因此，自动布线在开发过程中特别有用，而不至于在代码基础变得更稳定时，就可以选择切换到显式布线。

<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

When using XML-based configuration metadata (see [Dependency Injection](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-collaborators)), you can specify the autowire mode for a bean definition with the `autowire` attribute of the `<bean/>` element. The autowiring functionality has four modes. You specify autowiring per bean and can thus choose which ones to autowire. The following table describes the four autowiring modes:
#### ** Chinese **

当使用基于 XML 的配置元数据（参见 [Dependency Injection](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-collaborators)）时，可以使用 `autowire`属性的 `<bean/>` 元素为 Bean 定义指定自动布线模式。自动布线功能有四种模式。你可以指定每个Bean的autowiring，从而选择要自动布线的模式。下表描述了四种自动布线模式。
<!-- tabs:end -->


Mode | Explanation 
-|-
no | (Default) No autowiring. Bean references must be defined by ref elements. Changing the default setting is not recommended for larger deployments, because specifying collaborators explicitly gives greater control and clarity. To some extent, it documents the structure of a system. 
byName | Autowiring by property name. Spring looks for a bean with the same name as the property that needs to be autowired. For example, if a bean definition is set to autowire by name and it contains a master property (that is, it has a setMaster(..) method), Spring looks for a bean definition named master and uses it to set the property. 
byType | Lets a property be autowired if exactly one bean of the property type exists in the container. If more than one exists, a fatal exception is thrown, which indicates that you may not use byType autowiring for that bean. If there are no matching beans, nothing happens (the property is not set). 
constructor | Analogous to byType but applies to constructor arguments. If there is not exactly one bean of the constructor argument type in the container, a fatal error is raised. 


<!-- tabs:start -->

#### ** English **

With `byType` or `constructor` autowiring mode, you can wire arrays and typed collections. In such cases, all autowire candidates within the container that match the expected type are provided to satisfy the dependency. You can autowire strongly-typed `Map` instances if the expected key type is `String`. An autowired `Map` instance’s values consist of all bean instances that match the expected type, and the `Map` instance’s keys contain the corresponding bean names.
#### ** Chinese **

使用`byType`或`constructor`自动布线模式，可以给数组和类型化集合布线。在这种情况下，容器中所有与预期类型相匹配的自动布线候选对象都会被提供来满足依赖关系。如果预期的关键字类型是 `String`，则可以自动布线强类型的 `Map`实例。自动触发的 `Map` 实例的值由所有匹配预期类型的 Bean 实例组成，而 `Map` 实例的键包含相应的 Bean 名。
<!-- tabs:end -->


### **Limitations and Disadvantages of Autowiring** 

<!-- tabs:start -->

#### ** English **

Autowiring works best when it is used consistently across a project. If autowiring is not used in general, it might be confusing to developers to use it to wire only one or two bean definitions.
#### ** Chinese **

自动布线在整个项目中一致使用时效果最好。如果不普遍使用自动布线，如果只用它来布线一个或两个bean定义，可能会让开发人员感到困惑。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Consider the limitations and disadvantages of autowiring:
#### ** Chinese **

考虑到自动布线的局限性和缺点。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

- Explicit dependencies in `property` and `constructor-arg` settings always override autowiring. You cannot autowire simple properties such as primitives, `Strings`, and `Classes` (and arrays of such simple properties). This limitation is by-design.

- Autowiring is less exact than explicit wiring. Although, as noted in the earlier table, Spring is careful to avoid guessing in case of ambiguity that might have unexpected results. The relationships between your Spring-managed objects are no longer documented explicitly.

- Wiring information may not be available to tools that may generate documentation from a Spring container.

- Multiple bean definitions within the container may match the type specified by the setter method or constructor argument to be autowired. For arrays, collections, or `Map` instances, this is not necessarily a problem. However, for dependencies that expect a single value, this ambiguity is not arbitrarily resolved. If no unique bean definition is available, an exception is thrown.

#### ** Chinese **

- 在 `property`和`constructor-arg`设置中的显式依赖总是覆盖自动布线。您不能自动触发简单属性，如私有属性、`字符串`和`类`（以及此类简单属性的数组）。这个限制是设计上的限制。

- 自动布线不如显式布线那么精确。虽然，正如前面的表格中提到的，Spring会小心翼翼地避免猜测可能会产生意想不到的结果。您的Spring管理的对象之间的关系不再被显式记录。

- 可能从Spring容器中生成文档的工具可能无法获得接线信息。

- 容器内的多个bean定义可能会与setter方法或构造函数参数指定的类型相匹配，以便自动布线。对于数组、集合或`Map`实例，这不一定是个问题。但是，对于期望有一个值的依赖关系，这种模糊性是不能任意解决的。如果没有唯一的Bean定义，就会抛出一个异常。

<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

In the latter scenario, you have several options:
#### ** Chinese **

在后一种情况下，你有几个选择。
<!-- tabs:end -->


### **Excluding a Bean from Autowiring** 

<!-- tabs:start -->

#### ** English **

On a per-bean basis, you can exclude a bean from autowiring. In Spring’s XML format, set the `autowire-candidate` attribute of the `<bean/>` element to `false`. The container makes that specific bean definition unavailable to the autowiring infrastructure (including annotation style configurations such as [`@Autowired`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-autowired-annotation)).
#### ** Chinese **

在每个bean的基础上，你可以从自动布线中排除一个bean。在Spring的XML格式中，将`<bean/>`元素的`autowire-candidate`属性设置为`false`。容器会使该特定的bean定义对autowiring基础架构（包括注解样式配置，如[`@Autowired`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-autowired-annotation)）不可用。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The `autowire-candidate` attribute is designed to only affect type-based autowiring. It does not affect explicit references by name, which get resolved even if the specified bean is not marked as an autowire candidate. As a consequence, autowiring by name nevertheless injects a bean if the name matches.
#### ** Chinese **

`autowire-candidate`属性被设计成只影响基于类型的自动布线。它不影响通过名称的显式引用，即使指定的Bean没有被标记为autowire candidate，它也会被解析。因此，如果名称匹配的话，通过名称自动布线还是会注入一个Bean。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can also limit autowire candidates based on pattern-matching against bean names. The top-level `<beans/>` element accepts one or more patterns within its `default-autowire-candidates` attribute. For example, to limit autowire candidate status to any bean whose name ends with `Repository`, provide a value of `*Repository`. To provide multiple patterns, define them in a comma-separated list. An explicit value of `true` or `false` for a bean definition’s `autowire-candidate` attribute always takes precedence. For such beans, the pattern matching rules do not apply.
#### ** Chinese **

你也可以根据模式匹配Bean名来限制自动线的候选模式。顶层`<beans/>`元素在其`default-autowire-candidates`属性中接受一个或多个模式。例如，要将autowire候选状态限制在名称以`Repository`结尾的任何Bean中，提供一个值`*Repository`。要提供多个模式，请用逗号分隔的列表来定义它们。对于Bean定义的`autowire-candidate`属性的`true`或`false`的显式值总是优先。对于这样的Bean，模式匹配规则不适用。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

These techniques are useful for beans that you never want to be injected into other beans by autowiring. It does not mean that an excluded bean cannot itself be configured by using autowiring. Rather, the bean itself is not a candidate for autowiring other beans.
#### ** Chinese **

这些技术对于你永远不希望通过自动布线注入到其他豆子中的豆子是有用的。这并不意味着一个被排除的Bean本身不能通过使用自动布线来配置。相反，豆子本身并不是自动布线其他豆子的候选者。
<!-- tabs:end -->


### **1.4.6. Method Injection** 

<!-- tabs:start -->

#### ** English **

In most application scenarios, most beans in the container are [singletons](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-scopes-singleton). When a singleton bean needs to collaborate with another singleton bean or a non-singleton bean needs to collaborate with another non-singleton bean, you typically handle the dependency by defining one bean as a property of the other. A problem arises when the bean lifecycles are different. Suppose singleton bean A needs to use non-singleton (prototype) bean B, perhaps on each method invocation on A. The container creates the singleton bean A only once, and thus only gets one opportunity to set the properties. The container cannot provide bean A with a new instance of bean B every time one is needed.
#### ** Chinese **

在大多数应用场景中，容器中的大多数Bean都是[singleton](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-scopes-singleton)。当一个单子豆需要与另一个单子豆协作时，或者一个非单子豆需要与另一个非单子豆协作时，你通常通过定义一个豆作为另一个豆的属性来处理依赖关系。当Bean的生命周期不同时，就会出现一个问题。假设单子Bean A需要使用非单子（原型）Bean B，也许在A上的每次方法调用时，容器只创建了一次单子Bean A，因此只获得一次设置属性的机会。容器不能在每次需要Bean B的时候，都为Bean A提供一个新的实例。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

A solution is to forego some inversion of control. You can [make bean A aware of the container](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-aware) by implementing the `ApplicationContextAware` interface, and by [making a ](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-client)[`getBean("B")`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-client)[ call to the container](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-client) ask for (a typically new) bean B instance every time bean A needs it. The following example shows this approach:
#### ** Chinese **

一个解决方案是放弃一些倒置控制。你可以通过实现`ApplicationContextAware`接口，并在每次Bean A需要的时候[做一个](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-client)[`getBean("B")`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-client)[调用容器](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-client)[让Bean A意识到容器](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-aware)，并请求(典型的新的)Bean B实例。下面的例子显示了这种方法。
<!-- tabs:end -->


```java
// a class that uses a stateful Command-style class to perform some processing
package fiona.apple;

// Spring-API imports
import org.springframework.beans.BeansException;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;

public class CommandManager implements ApplicationContextAware {

    private ApplicationContext applicationContext;

    public Object process(Map commandState) {
        // grab a new instance of the appropriate Command
        Command command = createCommand();
        // set the state on the (hopefully brand new) Command instance
        command.setState(commandState);
        return command.execute();
    }

    protected Command createCommand() {
        // notice the Spring API dependency!
        return this.applicationContext.getBean("command", Command.class);
    }

    public void setApplicationContext(
            ApplicationContext applicationContext) throws BeansException {
        this.applicationContext = applicationContext;
    }
}
```

<!-- tabs:start -->

#### ** English **

The preceding is not desirable, because the business code is aware of and coupled to the Spring Framework. Method Injection, a somewhat advanced feature of the Spring IoC container, lets you handle this use case cleanly.
#### ** Chinese **

前面说的是不可取的，因为业务代码是意识到并耦合到Spring框架的。方法注入，这是Spring IoC容器的一个有点高级的功能，可以让你干净利落地处理这个用例。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can read more about the motivation for Method Injection in [this blog entry](https://spring.io/blog/2004/08/06/method-injection/).
#### ** Chinese **

你可以在[这篇博文](https://spring.io/blog/2004/08/06/method-injection/)中了解到更多关于方法注入的动机。
<!-- tabs:end -->


### **Lookup Method Injection** 

<!-- tabs:start -->

#### ** English **

Lookup method injection is the ability of the container to override methods on container-managed beans and return the lookup result for another named bean in the container. The lookup typically involves a prototype bean, as in the scenario described in [the preceding section](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-method-injection). The Spring Framework implements this method injection by using bytecode generation from the CGLIB library to dynamically generate a subclass that overrides the method.
#### ** Chinese **

查找方法注入是指容器能够覆盖容器管理的bean上的方法，并返回容器中另一个命名的bean的查找结果。这种查找通常涉及到一个原型Bean，就像[上一节](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-method-injection)中描述的场景一样。Spring框架通过使用CGLIB库中的字节码生成来实现这种方法注入，动态生成一个子类来重写该方法。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

- Abandon autowiring in favor of explicit wiring.

- Avoid autowiring for a bean definition by setting its `autowire-candidate` attributes to `false`, as described in the [next section](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-autowire-candidate).

- Designate a single bean definition as the primary candidate by setting the `primary` attribute of its `<bean/>` element to `true`.

- Implement the more fine-grained control available with annotation-based configuration, as described in [Annotation-based Container Configuration](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-annotation-config).

- For this dynamic subclassing to work, the class that the Spring bean container subclasses cannot be `final`, and the method to be overridden cannot be `final`, either.

- Unit-testing a class that has an `abstract` method requires you to subclass the class yourself and to supply a stub implementation of the `abstract` method.

- Concrete methods are also necessary for component scanning, which requires concrete classes to pick up.

- A further key limitation is that lookup methods do not work with factory methods and in particular not with `@Bean` methods in configuration classes, since, in that case, the container is not in charge of creating the instance and therefore cannot create a runtime-generated subclass on the fly.

#### ** Chinese **

- 放弃自动布线，改成显式布线。

- 通过将其 `autowire-candidate`属性设置为 `false`来避免自动布线，如[下一节](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-autowire-candidate)所述。

- 通过将其`<bean/>`元素的`primary`属性设置为`true`，将单个Bean定义指定为主候选。

- 如[基于注解的容器配置](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-annotation-config)中描述的那样，实现基于注解的配置所提供的更精细的控制。

- 为了使这种动态子类发挥作用，Spring bean 容器子类的类不能是 `final`，而且要重载的方法也不能是 `final`。

- 对一个有`abstract`方法的类进行单元测试，需要你自己对该类进行子类化，并提供一个`abstract`方法的存根实现。

- 具体的方法也需要组件扫描，这就需要具体的类来拾取。

- 还有一个关键的限制是，查找方法不能与工厂方法一起工作，特别是不能与配置类中的`@Bean`方法一起工作，因为在这种情况下，容器不负责创建实例，因此不能即时创建一个运行时生成的子类。

<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

In the case of the `CommandManager` class in the previous code snippet, the Spring container dynamically overrides the implementation of the `createCommand()` method. The `CommandManager` class does not have any Spring dependencies, as the reworked example shows:
#### ** Chinese **

在前面代码片段中的`CommandManager`类的情况下，Spring容器动态地覆盖了`createCommand()`方法的实现。`CommandManager`类没有任何Spring的依赖关系，正如重做后的示例所示。
<!-- tabs:end -->


```java
package fiona.apple;

// no more Spring imports!

public abstract class CommandManager {

    public Object process(Object commandState) {
        // grab a new instance of the appropriate Command interface
        Command command = createCommand();
        // set the state on the (hopefully brand new) Command instance
        command.setState(commandState);
        return command.execute();
    }

    // okay... but where is the implementation of this method?
    protected abstract Command createCommand();
}
```

<!-- tabs:start -->

#### ** English **

In the client class that contains the method to be injected (the `CommandManager` in this case), the method to be injected requires a signature of the following form:
#### ** Chinese **

在包含要注入方法的客户端类中（本例中的`CommandManager`），要注入的方法需要以下形式的签名。
<!-- tabs:end -->


```xml
<public|protected> [abstract] <return-type> theMethodName(no-arguments);
```

<!-- tabs:start -->

#### ** English **

If the method is `abstract`, the dynamically-generated subclass implements the method. Otherwise, the dynamically-generated subclass overrides the concrete method defined in the original class. Consider the following example:
#### ** Chinese **

如果方法是`抽象的`，动态生成的子类就实现了该方法。否则，动态生成的子类将覆盖原始类中定义的具体方法。考虑一下下面的例子。
<!-- tabs:end -->


```xml
<!-- a stateful bean deployed as a prototype (non-singleton) -->
<bean id="myCommand" class="fiona.apple.AsyncCommand" scope="prototype">
    <!-- inject dependencies here as required -->
</bean>

<!-- commandProcessor uses statefulCommandHelper -->
<bean id="commandManager" class="fiona.apple.CommandManager">
    <lookup-method name="createCommand" bean="myCommand"/>
</bean>
```

<!-- tabs:start -->

#### ** English **

The bean identified as `commandManager` calls its own `createCommand()` method whenever it needs a new instance of the `myCommand` bean. You must be careful to deploy the `myCommand` bean as a prototype if that is actually what is needed. If it is a [singleton](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-scopes-singleton), the same instance of the `myCommand` bean is returned each time.
#### ** Chinese **

被标识为 `commandManager`的 bean 每当它需要一个新的 `myCommand` bean 的实例时，就会调用它自己的 `createCommand()` 方法。如果实际需要，您必须小心地将 `myCommand` bean 作为原型来部署。如果它是一个[singleton](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-scopes-singleton)，每次都会返回相同的 `myCommand` bean 实例。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Alternatively, within the annotation-based component model, you can declare a lookup method through the `@Lookup` annotation, as the following example shows:
#### ** Chinese **

另外，在基于注解的组件模型中，可以通过`@Lookup`注解声明一个查找方法，如下例所示。
<!-- tabs:end -->


```java
public abstract class CommandManager {

    public Object process(Object commandState) {
        Command command = createCommand();
        command.setState(commandState);
        return command.execute();
    }

    @Lookup("myCommand")
    protected abstract Command createCommand();
}
```

<!-- tabs:start -->

#### ** English **

Or, more idiomatically, you can rely on the target bean getting resolved against the declared return type of the lookup method:
#### ** Chinese **

或者，更俗套的说，你可以依靠目标Bean得到与查找方法的声明的返回类型相对应的解析。
<!-- tabs:end -->


```java
public abstract class CommandManager {

    public Object process(Object commandState) {
        MyCommand command = createCommand();
        command.setState(commandState);
        return command.execute();
    }

    @Lookup
    protected abstract MyCommand createCommand();
}
```

<!-- tabs:start -->

#### ** English **

Note that you should typically declare such annotated lookup methods with a concrete stub implementation, in order for them to be compatible with Spring’s component scanning rules where abstract classes get ignored by default. This limitation does not apply to explicitly registered or explicitly imported bean classes.
#### ** Chinese **

请注意，您通常应该用具体的存根实现来声明这样的注解查找方法，以便与Spring的组件扫描规则兼容，因为在Spring的组件扫描规则中，抽象类会被默认忽略。这个限制不适用于显式注册或显式导入的bean类。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Another way of accessing differently scoped target beans is an `ObjectFactory`/ `Provider` injection point. See [Scoped Beans as Dependencies](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-scopes-other-injection).
#### ** Chinese **

另一种访问不同Scoped目标Bean的方法是`ObjectFactory`/`Provider`注入点。参见[Scoped Beans as Dependencies](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-scopes-other-injection)。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You may also find the `ServiceLocatorFactoryBean` (in the `org.springframework.beans.factory.config` package) to be useful.
#### ** Chinese **

你可能会发现`ServiceLocatorFactoryBean`（在`org.springframework.beans.factory.config`包中）也很有用。
<!-- tabs:end -->


### **Arbitrary Method Replacement** 

<!-- tabs:start -->

#### ** English **

A less useful form of method injection than lookup method injection is the ability to replace arbitrary methods in a managed bean with another method implementation. You can safely skip the rest of this section until you actually need this functionality.
#### ** Chinese **

与查找方法注入相比，方法注入的一种不那么有用的形式是用另一个方法实现来替换管理Bean中的任意方法。你可以安全地跳过本节的其余部分，直到你真正需要这个功能为止。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

With XML-based configuration metadata, you can use the `replaced-method` element to replace an existing method implementation with another, for a deployed bean. Consider the following class, which has a method called `computeValue` that we want to override:
#### ** Chinese **

使用基于 XML 的配置元数据，你可以使用 `replaced-method` 元素来替换现有的方法实现，用于部署的 Bean。考虑一下下面的类，它有一个叫做`computeValue`的方法，我们要覆盖这个方法。
<!-- tabs:end -->


```java
public class MyValueCalculator {

    public String computeValue(String input) {
        // some real code...
    }

    // some other methods...
}
```

<!-- tabs:start -->

#### ** English **

A class that implements the `org.springframework.beans.factory.support.MethodReplacer` interface provides the new method definition, as the following example shows:
#### ** Chinese **

一个实现了`org.springframework.beans.factory.support.MethodReplacer`接口的类提供了新的方法定义，如下例所示。
<!-- tabs:end -->


```java
/**
 * meant to be used to override the existing computeValue(String)
 * implementation in MyValueCalculator
 */
public class ReplacementComputeValue implements MethodReplacer {

    public Object reimplement(Object o, Method m, Object[] args) throws Throwable {
        // get the input value, work with it, and return a computed result
        String input = (String) args[0];
        ...
        return ...;
    }
}
```

<!-- tabs:start -->

#### ** English **

The bean definition to deploy the original class and specify the method override would resemble the following example:
#### ** Chinese **

部署原始类并指定方法覆盖的Bean定义类似于下面的例子。
<!-- tabs:end -->


```xml
<bean id="myValueCalculator" class="x.y.z.MyValueCalculator">
    <!-- arbitrary method replacement -->
    <replaced-method name="computeValue" replacer="replacementComputeValue">
        <arg-type>String</arg-type>
    </replaced-method>
</bean>

<bean id="replacementComputeValue" class="a.b.c.ReplacementComputeValue"/>
```

<!-- tabs:start -->

#### ** English **

You can use one or more `<arg-type/>` elements within the `<replaced-method/>` element to indicate the method signature of the method being overridden. The signature for the arguments is necessary only if the method is overloaded and multiple variants exist within the class. For convenience, the type string for an argument may be a substring of the fully qualified type name. For example, the following all match `java.lang.String`:
#### ** Chinese **

你可以在`<replaced-method/>`元素中使用一个或多个`<arg-type/>`元素来表示被重载的方法的方法签名。只有当方法被重载且类内存在多个变体时，才需要使用参数的签名。为了方便起见，参数的类型字符串可以是完全限定的类型名称的子串。例如，下面的参数都符合 `java.lang.String`。
<!-- tabs:end -->


```
java.lang.String
String
Str
```

<!-- tabs:start -->

#### ** English **

Because the number of arguments is often enough to distinguish between each possible choice, this shortcut can save a lot of typing, by letting you type only the shortest string that matches an argument type.
#### ** Chinese **

因为参数的数量往往足以区分每一个可能的选择，所以这个快捷方式可以节省大量的键入量，让你只键入与参数类型相匹配的最短的字符串，从而节省了大量的键入量。
<!-- tabs:end -->



[下一章](Spring-Framework-5.2.6.RELEASE/Core%20Technologies/1.5.%20Bean%20Scopes.md)


[回目录](Spring-Framework-5.2.6.RELEASE/summary.md)

[回首页](/README)
