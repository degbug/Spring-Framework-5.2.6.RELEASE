# 1.12. Java-based Container Configuration

<!-- tabs:start -->

#### ** English **

This section covers how to use annotations in your Java code to configure the Spring container. It includes the following topics:
#### ** Chinese **

本节介绍如何在 Java 代码中使用注解来配置 Spring 容器。它包括以下主题。
<!-- tabs:end -->


### **1.12.1. Basic Concepts:** **`@Bean`** ** and** **`@Configuration`** 

<!-- tabs:start -->

#### ** English **

The central artifacts in Spring’s new Java-configuration support are `@Configuration`-annotated classes and `@Bean`-annotated methods.
#### ** Chinese **

Spring新的Java配置支持中的核心工件是`@Configuration`-注解类和`@Bean`-注解方法。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The `@Bean` annotation is used to indicate that a method instantiates, configures, and initializes a new object to be managed by the Spring IoC container. For those familiar with Spring’s `<beans/>` XML configuration, the `@Bean` annotation plays the same role as the `<bean/>` element. You can use `@Bean`-annotated methods with any Spring `@Component`. However, they are most often used with `@Configuration` beans.
#### ** Chinese **

`@Bean` 注解用于指示方法实例化、配置和初始化要由 Spring IoC 容器管理的新对象。对于那些熟悉 Spring 的 `<beans/>` XML 配置的人来说，`@Bean` 注解与 `<bean/>` 元素的作用相同。您可以在任何 Spring `@Component` 注解的方法中使用 `@Bean` 注解的方法。但是，它们最常用于 `@Configuration` Bean。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Annotating a class with `@Configuration` indicates that its primary purpose is as a source of bean definitions. Furthermore, `@Configuration` classes let inter-bean dependencies be defined by calling other `@Bean` methods in the same class. The simplest possible `@Configuration` class reads as follows:
#### ** Chinese **

用`@Configuration`注解一个类，表明它的主要目的是作为Bean定义的来源。此外，`@Configuration`类允许通过调用同一类中的其他`@Bean`方法来定义bean之间的依赖关系。最简单的`@Configuration`类如下所示。
<!-- tabs:end -->


```java
@Configuration
public class AppConfig {

    @Bean
    public MyService myService() {
        return new MyServiceImpl();
    }
}
```

<!-- tabs:start -->

#### ** English **

The preceding `AppConfig` class is equivalent to the following Spring `<beans/>` XML:
#### ** Chinese **

前面的`AppConfig`类相当于下面的Spring `<beans/>` XML。
<!-- tabs:end -->


```xml
<beans>
    <bean id="myService" class="com.acme.services.MyServiceImpl"/>
</beans>
```

<!-- tabs:start -->

#### ** English **

Full @Configuration vs “lite” @Bean mode?
#### ** Chinese **

完整的@Configuration vs "lite" @Bean模式？
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

When `@Bean` methods are declared within classes that are not annotated with `@Configuration`, they are referred to as being processed in a “lite” mode. Bean methods declared in a `@Component` or even in a plain old class are considered to be “lite”, with a different primary purpose of the containing class and a `@Bean` method being a sort of bonus there. For example, service components may expose management views to the container through an additional `@Bean` method on each applicable component class. In such scenarios, `@Bean` methods are a general-purpose factory method mechanism.
#### ** Chinese **

当`@Bean`方法被声明在没有用`@Configuration`注解的类中时，这些方法被称为以 "lite "模式处理。在`@Component`中声明的Bean方法，甚至在一个普通的老类中声明的Bean方法也被认为是 "轻量级 "的，因为包含类的主要目的不同，而`@Bean`方法是那里的一种奖励。例如，服务组件可能通过在每个适用的组件类上的额外的 `@Bean`方法向容器暴露管理视图。在这种情况下，`@Bean`方法是一种通用的工厂方法机制。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Unlike full `@Configuration`, lite `@Bean` methods cannot declare inter-bean dependencies. Instead, they operate on their containing component’s internal state and, optionally, on arguments that they may declare. Such a `@Bean` method should therefore not invoke other `@Bean` methods. Each such method is literally only a factory method for a particular bean reference, without any special runtime semantics. The positive side-effect here is that no CGLIB subclassing has to be applied at runtime, so there are no limitations in terms of class design (that is, the containing class may be `final` and so forth).
#### ** Chinese **

与完整的`@Configuration`方法不同，lite `@Bean`方法不能声明bean之间的依赖关系。相反，它们操作的是它们所包含的组件的内部状态，并且可以选择声明参数。因此，这样的`@Bean`方法不应该调用其他`@Bean`方法。每个这样的方法都只是一个特定Bean引用的工厂方法，没有任何特殊的运行时语义。这里的积极的副作用是，在运行时不需要应用CGLIB子类，因此在类设计方面没有任何限制（也就是说，包含的类可以是`final`等）。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

In common scenarios, `@Bean` methods are to be declared within `@Configuration` classes, ensuring that “full” mode is always used and that cross-method references therefore get redirected to the container’s lifecycle management. This prevents the same `@Bean` method from accidentally being invoked through a regular Java call, which helps to reduce subtle bugs that can be hard to track down when operating in “lite” mode.
#### ** Chinese **

在常见的场景中，`@Bean`方法要在`@Configuration`类中声明，以确保始终使用 "完整 "模式，并确保交叉方法引用因此被重定向到容器的生命周期管理。这可以防止同一`@Bean`方法通过常规的Java调用意外地被调用，这有助于减少在 "lite "模式下运行时难以追踪的微妙bug。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The `@Bean` and `@Configuration` annotations are discussed in depth in the following sections. First, however, we cover the various ways of creating a spring container using by Java-based configuration.
#### ** Chinese **

`@Bean`和`@Configuration`注解将在下面的章节中深入讨论。不过，首先，我们将讨论使用基于 Java 的配置创建 Spring 容器的各种方法。
<!-- tabs:end -->


### **1.12.2. Instantiating the Spring Container by Using** **`AnnotationConfigApplicationContext`** 

<!-- tabs:start -->

#### ** English **

The following sections document Spring’s `AnnotationConfigApplicationContext`, introduced in Spring 3.0. This versatile `ApplicationContext` implementation is capable of accepting not only `@Configuration` classes as input but also plain `@Component` classes and classes annotated with JSR-330 metadata.
#### ** Chinese **

下面的章节记录了Spring 3.0中引入的Spring的`AnnotationConfigApplicationContext`。这个多功能的 `ApplicationContext`实现不仅能够接受`@Configuration`类作为输入，而且还能接受普通的`@Component`类和用JSR-330元数据注解的类。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

When `@Configuration` classes are provided as input, the `@Configuration` class itself is registered as a bean definition and all declared `@Bean` methods within the class are also registered as bean definitions.
#### ** Chinese **

当`@Configuration`类被提供为输入时，`@Configuration`类本身被注册为Bean定义，并且类内所有声明的`@Bean`方法也被注册为Bean定义。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

When `@Component` and JSR-330 classes are provided, they are registered as bean definitions, and it is assumed that DI metadata such as `@Autowired` or `@Inject` are used within those classes where necessary.
#### ** Chinese **

当提供了`@Component`和JSR-330类时，它们被注册为Bean定义，并假定必要时在这些类中使用DI元数据，如`@Autowired`或`@Inject`。
<!-- tabs:end -->


### **Simple Construction** 

<!-- tabs:start -->

#### ** English **

In much the same way that Spring XML files are used as input when instantiating a `ClassPathXmlApplicationContext`, you can use `@Configuration` classes as input when instantiating an `AnnotationConfigApplicationContext`. This allows for completely XML-free usage of the Spring container, as the following example shows:
#### ** Chinese **

在实例化`ClassPathXmlApplicationContext`时，与Spring XML文件作为输入的方式大体相同，在实例化`AnnotationConfigApplicationContext`时，可以使用`@Configuration`类作为输入。这使得Spring容器的使用完全不需要XML，正如下面的示例所示。
<!-- tabs:end -->


```java
public static void main(String[] args) {
    ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class);
    MyService myService = ctx.getBean(MyService.class);
    myService.doStuff();
}
```

<!-- tabs:start -->

#### ** English **

As mentioned earlier, `AnnotationConfigApplicationContext` is not limited to working only with `@Configuration` classes. Any `@Component` or JSR-330 annotated class may be supplied as input to the constructor, as the following example shows:
#### ** Chinese **

如前所述，`AnnotationConfigApplicationContext`并不局限于只与`@Configuration`类一起工作。任何`@Component`或JSR-330注解类都可以作为构造函数的输入，如下例所示。
<!-- tabs:end -->


```java
public static void main(String[] args) {
    ApplicationContext ctx = new AnnotationConfigApplicationContext(MyServiceImpl.class, Dependency1.class, Dependency2.class);
    MyService myService = ctx.getBean(MyService.class);
    myService.doStuff();
}
```

<!-- tabs:start -->

#### ** English **

The preceding example assumes that `MyServiceImpl`, `Dependency1`, and `Dependency2` use Spring dependency injection annotations such as `@Autowired`.
#### ** Chinese **

前面的例子假设`MyServiceImpl`、`Dependency1`和`Dependency2`使用Spring依赖注入注解，如`@Autowired`。
<!-- tabs:end -->


### **Building the Container Programmatically by Using** **`register(Class<?>…​)`** 

<!-- tabs:start -->

#### ** English **

You can instantiate an `AnnotationConfigApplicationContext` by using a no-arg constructor and then configure it by using the `register()` method. This approach is particularly useful when programmatically building an `AnnotationConfigApplicationContext`. The following example shows how to do so:
#### ** Chinese **

您可以通过使用无参数构造函数实例化一个 `AnnotationConfigApplicationContext`，然后通过使用 `register()`方法对其进行配置。这种方法在程序化构建 `AnnotationConfigApplicationContext`时特别有用。下面的示例显示了如何实现这一目的。
<!-- tabs:end -->


```java
public static void main(String[] args) {
    AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
    ctx.register(AppConfig.class, OtherConfig.class);
    ctx.register(AdditionalConfig.class);
    ctx.refresh();
    MyService myService = ctx.getBean(MyService.class);
    myService.doStuff();
}
```

### **Enabling Component Scanning with** **`scan(String…​)`** 

<!-- tabs:start -->

#### ** English **

To enable component scanning, you can annotate your `@Configuration` class as follows:
#### ** Chinese **

要启用组件扫描，您可以对`@Configuration`类进行如下注解。
<!-- tabs:end -->


```java
@Configuration
@ComponentScan(basePackages = "com.acme") (1)
public class AppConfig  {
    ...
}

//(1) This annotation enables component scanning.
```

<!-- tabs:start -->

#### ** English **

Experienced Spring users may be familiar with the XML declaration equivalent from Spring’s `context:` namespace, shown in the following example:
#### ** Chinese **

有经验的Spring用户可能对Spring的`context:`命名空间中的XML声明等价物很熟悉，如下例所示。
<!-- tabs:end -->


```xml
<beans>
    <context:component-scan base-package="com.acme"/>
</beans>
```

<!-- tabs:start -->

#### ** English **

In the preceding example, the `com.acme` package is scanned to look for any `@Component`-annotated classes, and those classes are registered as Spring bean definitions within the container. `AnnotationConfigApplicationContext` exposes the `scan(String…​)` method to allow for the same component-scanning functionality, as the following example shows:
#### ** Chinese **

在前面的示例中，我们扫描了`com.acme`包以查找任何`@Component`-annotation类，这些类被注册为容器中的Spring Bean定义。 `AnnotationConfigApplicationContext`公开了`scan(String…​)`方法，以实现相同的组件扫描功能，如下例所示。
<!-- tabs:end -->


```java
public static void main(String[] args) {
    AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
    ctx.scan("com.acme");
    ctx.refresh();
    MyService myService = ctx.getBean(MyService.class);
}
```

<!-- tabs:start -->

#### ** English **

Remember that `@Configuration` classes are [meta-annotated](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-meta-annotations) with `@Component`, so they are candidates for component-scanning. In the preceding example, assuming that `AppConfig` is declared within the `com.acme` package (or any package underneath), it is picked up during the call to `scan()`. Upon `refresh()`, all its `@Bean` methods are processed and registered as bean definitions within the container.
#### ** Chinese **

请记住，`@Configuration`类与`@Component`是[元注解](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-meta-annotations)，所以它们是候选的组件扫描类。在前面的例子中，假设`AppConfig`是在`com.acme`包（或下面的任何包）中声明的，那么在调用`scan()`时，它就会被选中。当 `refresh()`时，它的所有`@Bean`方法都会被处理并注册为容器中的Bean定义。
<!-- tabs:end -->


### **Support for Web Applications with** **`AnnotationConfigWebApplicationContext`** 

<!-- tabs:start -->

#### ** English **

A `WebApplicationContext` variant of `AnnotationConfigApplicationContext` is available with `AnnotationConfigWebApplicationContext`. You can use this implementation when configuring the Spring `ContextLoaderListener` servlet listener, Spring MVC `DispatcherServlet`, and so forth. The following `web.xml` snippet configures a typical Spring MVC web application (note the use of the `contextClass` context-param and init-param):
#### ** Chinese **

`AnnotationConfigApplicationContext`的`AnnotationConfigWebApplicationContext`的一个`WebApplicationContext`变体可以使用`AnnotationConfigWebApplicationContext`。在配置Spring `ContextLoaderListener` servlet监听器、Spring MVC `DispatcherServlet`等的时候，可以使用这个实现。下面的`web.xml`片段配置了一个典型的Spring MVC web应用程序（注意使用了`contextClass`context-param和init-param）。
<!-- tabs:end -->


```xml
<web-app>
    <!-- Configure ContextLoaderListener to use AnnotationConfigWebApplicationContext
        instead of the default XmlWebApplicationContext -->
    <context-param>
        <param-name>contextClass</param-name>
        <param-value>
            org.springframework.web.context.support.AnnotationConfigWebApplicationContext
        </param-value>
    </context-param>

    <!-- Configuration locations must consist of one or more comma- or space-delimited
        fully-qualified @Configuration classes. Fully-qualified packages may also be
        specified for component-scanning -->
    <context-param>
        <param-name>contextConfigLocation</param-name>
        <param-value>com.acme.AppConfig</param-value>
    </context-param>

    <!-- Bootstrap the root application context as usual using ContextLoaderListener -->
    <listener>
        <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
    </listener>

    <!-- Declare a Spring MVC DispatcherServlet as usual -->
    <servlet>
        <servlet-name>dispatcher</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
        <!-- Configure DispatcherServlet to use AnnotationConfigWebApplicationContext
            instead of the default XmlWebApplicationContext -->
        <init-param>
            <param-name>contextClass</param-name>
            <param-value>
                org.springframework.web.context.support.AnnotationConfigWebApplicationContext
            </param-value>
        </init-param>
        <!-- Again, config locations must consist of one or more comma- or space-delimited
            and fully-qualified @Configuration classes -->
        <init-param>
            <param-name>contextConfigLocation</param-name>
            <param-value>com.acme.web.MvcConfig</param-value>
        </init-param>
    </servlet>

    <!-- map all requests for /app/* to the dispatcher servlet -->
    <servlet-mapping>
        <servlet-name>dispatcher</servlet-name>
        <url-pattern>/app/*</url-pattern>
    </servlet-mapping>
</web-app>
```

### **1.12.3. Using the** **`@Bean`** ** Annotation** 

<!-- tabs:start -->

#### ** English **

`@Bean` is a method-level annotation and a direct analog of the XML `<bean/>` element. The annotation supports some of the attributes offered by `<bean/>`, such as: * [init-method](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-lifecycle-initializingbean) * [destroy-method](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-lifecycle-disposablebean) * [autowiring](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-autowire) * `name`.
#### ** Chinese **

`@Bean`是一个方法级注解，是XML `<bean/>`元素的直接类似物。该注解支持`<bean/>`所提供的一些属性，例如。* [init-method](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-lifecycle-initializingbean) * [destroy-method](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-lifecycle-disposablebean) * [autowiring](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-autowire) * `name`。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can use the `@Bean` annotation in a `@Configuration`-annotated or in a `@Component`-annotated class.
#### ** Chinese **

你可以在`@Bean`注解中使用`@Configuration`-注解，或者在`@Component`-注解的类中使用`@Bean`注解。
<!-- tabs:end -->


### **Declaring a Bean** 

<!-- tabs:start -->

#### ** English **

To declare a bean, you can annotate a method with the `@Bean` annotation. You use this method to register a bean definition within an `ApplicationContext` of the type specified as the method’s return value. By default, the bean name is the same as the method name. The following example shows a `@Bean` method declaration:
#### ** Chinese **

要声明一个Bean，可以用`@Bean`注解方法。你可以使用这个方法在`ApplicationContext`中注册一个Bean定义，其类型指定为方法的返回值。默认情况下，Bean的名称与方法名称相同。下面的例子显示了一个`@Bean`方法声明。
<!-- tabs:end -->


```java
@Configuration
public class AppConfig {

    @Bean
    public TransferServiceImpl transferService() {
        return new TransferServiceImpl();
    }
}
```

<!-- tabs:start -->

#### ** English **

The preceding configuration is exactly equivalent to the following Spring XML:
#### ** Chinese **

上面的配置完全等同于下面的Spring XML。
<!-- tabs:end -->


```xml
<beans>
    <bean id="transferService" class="com.acme.TransferServiceImpl"/>
</beans>
```

<!-- tabs:start -->

#### ** English **

Both declarations make a bean named `transferService` available in the `ApplicationContext`, bound to an object instance of type `TransferServiceImpl`, as the following text image shows:
#### ** Chinese **

这两个声明使一个名为`transferService`的Bean在`ApplicationContext`中可用，并绑定到类型`TransferServiceImpl`的对象实例，如下图所示。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

transferService -> com.acme.TransferServiceImpl
#### ** Chinese **

transferService -> com.acme.TransferServiceImpl
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can also declare your `@Bean` method with an interface (or base class) return type, as the following example shows:
#### ** Chinese **

你也可以声明你的`@Bean`方法的接口(或基类)返回类型，如下例所示。
<!-- tabs:end -->


```java
@Configuration
public class AppConfig {

    @Bean
    public TransferService transferService() {
        return new TransferServiceImpl();
    }
}
```

<!-- tabs:start -->

#### ** English **

However, this limits the visibility for advance type prediction to the specified interface type (`TransferService`). Then, with the full type (`TransferServiceImpl`) known to the container only once, the affected singleton bean has been instantiated. Non-lazy singleton beans get instantiated according to their declaration order, so you may see different type matching results depending on when another component tries to match by a non-declared type (such as `@Autowired TransferServiceImpl`, which resolves only once the `transferService` bean has been instantiated).
#### ** Chinese **

然而，这就将预先类型预测的可见性限制在指定的接口类型(`TransferService`)。然后，在容器只知道一次完整类型(`TransferServiceImpl`)的情况下，受影响的单子豆被实例化了。非懒惰的单子豆会根据其声明顺序被实例化，所以当另一个组件试图通过非声明类型进行匹配时，您可能会看到不同的类型匹配结果（例如`@Autowired TransferServiceImpl`，它只在`transferService` bean被实例化后才会解析）。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

If you consistently refer to your types by a declared service interface, your `@Bean` return types may safely join that design decision. However, for components that implement several interfaces or for components potentially referred to by their implementation type, it is safer to declare the most specific return type possible (at least as specific as required by the injection points that refer to your bean).
#### ** Chinese **

如果你一致地通过声明的服务接口来引用你的类型，你的`@Bean`返回类型可以安全地加入这个设计决定。然而，对于实现了多个接口的组件，或者对于可能被其实现类型引用的组件，更安全的做法是声明最具体的返回类型（至少是引用你的Bean的注入点所要求的那样具体）。
<!-- tabs:end -->


### **Bean Dependencies** 

<!-- tabs:start -->

#### ** English **

A `@Bean`-annotated method can have an arbitrary number of parameters that describe the dependencies required to build that bean. For instance, if our `TransferService` requires an `AccountRepository`, we can materialize that dependency with a method parameter, as the following example shows:
#### ** Chinese **

`@Bean`注解的方法可以有任意数量的参数，这些参数描述了构建该Bean所需的依赖关系。例如，如果我们的`TransferService`需要一个`AccountRepository`，我们可以用一个方法参数来具体化这个依赖关系，如下图所示。
<!-- tabs:end -->


```java
@Configuration
public class AppConfig {

    @Bean
    public TransferService transferService(AccountRepository accountRepository) {
        return new TransferServiceImpl(accountRepository);
    }
}
```

<!-- tabs:start -->

#### ** English **

The resolution mechanism is pretty much identical to constructor-based dependency injection. See [the relevant section](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-constructor-injection) for more details.
#### ** Chinese **

解决机制与基于构造函数的依赖注入基本相同。详情请参见[相关章节](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-constructor-injection)。
<!-- tabs:end -->


### **Receiving Lifecycle Callbacks** 

<!-- tabs:start -->

#### ** English **

Any classes defined with the `@Bean` annotation support the regular lifecycle callbacks and can use the `@PostConstruct` and `@PreDestroy` annotations from JSR-250. See [JSR-250 annotations](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-postconstruct-and-predestroy-annotations) for further details.
#### ** Chinese **

任何使用 `@Bean` 注解定义的类都支持常规的生命周期回调，并且可以使用 JSR-250 中的 `@PostConstruct` 和 `@PreDestroy` 注解。更多详情请参见[JSR-250注解](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-postconstruct-and-predestroy-annotations)。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The regular Spring [lifecycle](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-nature) callbacks are fully supported as well. If a bean implements `InitializingBean`, `DisposableBean`, or `Lifecycle`, their respective methods are called by the container.
#### ** Chinese **

常规的 Spring [lifecycle](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-nature) 回调也完全支持。如果一个Bean实现了`InitializingBean`、`DisposableBean`或`Lifecycle`，那么它们各自的方法就会被容器调用。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The standard set of `*Aware` interfaces (such as [BeanFactoryAware](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-beanfactory), [BeanNameAware](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-aware), [MessageSourceAware](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#context-functionality-messagesource), [ApplicationContextAware](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-aware), and so on) are also fully supported.
#### ** Chinese **

标准的`*Aware`接口集（如[BeanFactoryAware](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-beanfactory)、[BeanNameAware](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-aware)、[MessageSourceAware](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#context-functionality-messagesource)、[ApplicationContextAware](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-aware)等）也完全支持。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The `@Bean` annotation supports specifying arbitrary initialization and destruction callback methods, much like Spring XML’s `init-method` and `destroy-method` attributes on the `bean` element, as the following example shows:
#### ** Chinese **

`@Bean`注解支持指定任意的初始化和销毁回调方法，就像Spring XML中的`init-method`和`destroy-method`属性在`bean`元素上一样，如下图所示。
<!-- tabs:end -->


```java
public class BeanOne {

    public void init() {
        // initialization logic
    }
}

public class BeanTwo {

    public void cleanup() {
        // destruction logic
    }
}

@Configuration
public class AppConfig {

    @Bean(initMethod = "init")
    public BeanOne beanOne() {
        return new BeanOne();
    }

    @Bean(destroyMethod = "cleanup")
    public BeanTwo beanTwo() {
        return new BeanTwo();
    }
}
```

<!-- tabs:start -->

#### ** English **

By default, beans defined with Java configuration that have a public `close` or `shutdown` method are automatically enlisted with a destruction callback. If you have a public `close` or `shutdown` method and you do not wish for it to be called when the container shuts down, you can add `@Bean(destroyMethod="")` to your bean definition to disable the default `(inferred)` mode.
#### ** Chinese **

默认情况下，用Java配置定义的Bean如果有公共的`close`或`shutdown`方法，会自动加入销毁回调。如果您有一个公共的`close`或`shutdown`方法，并且您不希望在容器关闭时调用该方法，您可以在Bean定义中添加`@Bean(destroyMethod="")`，以禁用默认的`(inferred)`模式。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You may want to do that by default for a resource that you acquire with JNDI, as its lifecycle is managed outside the application. In particular, make sure to always do it for a `DataSource`, as it is known to be problematic on Java EE application servers.
#### ** Chinese **

你可能希望对使用JNDI获取的资源默认情况下这样做，因为它的生命周期是在应用程序之外管理的。特别是，请确保总是对`DataSource`进行这样的操作，因为在Java EE应用程序服务器上这是有问题的。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following example shows how to prevent an automatic destruction callback for a `DataSource`:
#### ** Chinese **

下面的示例显示了如何防止一个`DataSource`的自动销毁回调。
<!-- tabs:end -->


```java
@Bean(destroyMethod="")
public DataSource dataSource() throws NamingException {
    return (DataSource) jndiTemplate.lookup("MyDS");
}
```

<!-- tabs:start -->

#### ** English **

Also, with `@Bean` methods, you typically use programmatic JNDI lookups, either by using Spring’s `JndiTemplate` or `JndiLocatorDelegate` helpers or straight JNDI `InitialContext` usage but not the `JndiObjectFactoryBean` variant (which would force you to declare the return type as the `FactoryBean` type instead of the actual target type, making it harder to use for cross-reference calls in other `@Bean` methods that intend to refer to the provided resource here).
#### ** Chinese **

另外，使用`@Bean`方法，通常使用程序化的JNDI查找方法。或者使用Spring的`JndiTemplate`或`JndiLocatorDelegate`助手，或者直接使用JNDI的`InitialContext`用法，但不使用`JndiObjectFactoryBean`变体（这将迫使你声明返回类型为`FactoryBean`类型，而不是实际的目标类型。使得它更难用于其他`@Bean`方法中的交叉引用调用，而这些方法打算引用这里提供的资源）。)
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

In the case of `BeanOne` from the example above the preceding note, it would be equally valid to call the `init()` method directly during construction, as the following example shows:
#### ** Chinese **

对于前面注解的例子中的`BeanOne`，在构造过程中直接调用`init()`方法同样有效，如下例所示。
<!-- tabs:end -->


```java
@Configuration
public class AppConfig {

    @Bean
    public BeanOne beanOne() {
        BeanOne beanOne = new BeanOne();
        beanOne.init();
        return beanOne;
    }

    // ...
}
```

<!-- tabs:start -->

#### ** English **

When you work directly in Java, you can do anything you like with your objects and do not always need to rely on the container lifecycle.
#### ** Chinese **

当你直接在Java中工作时，你可以对你的对象做任何你喜欢的事情，不需要总是依赖容器的生命周期。
<!-- tabs:end -->


### **Specifying Bean Scope** 

<!-- tabs:start -->

#### ** English **

Spring includes the `@Scope` annotation so that you can specify the scope of a bean.
#### ** Chinese **

Spring包含了`@Scope`注解，这样你就可以指定一个bean的范围。
<!-- tabs:end -->


### **Using the** **`@Scope`** ** Annotation** 

<!-- tabs:start -->

#### ** English **

You can specify that your beans defined with the `@Bean` annotation should have a specific scope. You can use any of the standard scopes specified in the [Bean Scopes](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-scopes) section.
#### ** Chinese **

您可以指定用`@Bean`注解定义的Bean应该有一个特定的作用域。您可以使用[Bean Scopes](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-scopes)部分中指定的任何一个标准作用域。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The default scope is `singleton`, but you can override this with the `@Scope` annotation, as the following example shows:
#### ** Chinese **

默认的作用域是`singleton`，但你可以用`@Scope`注解来覆盖，如下例所示。
<!-- tabs:end -->


```java
@Configuration
public class MyConfiguration {

    @Bean
    @Scope("prototype")
    public Encryptor encryptor() {
        // ...
    }
}
```

### **`@Scope`** ** and** **`scoped-proxy`** 

<!-- tabs:start -->

#### ** English **

Spring offers a convenient way of working with scoped dependencies through [scoped proxies](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-scopes-other-injection). The easiest way to create such a proxy when using the XML configuration is the `<aop:scoped-proxy/>` element. Configuring your beans in Java with a `@Scope` annotation offers equivalent support with the `proxyMode` attribute. The default is no proxy (`ScopedProxyMode.NO`), but you can specify `ScopedProxyMode.TARGET_CLASS` or `ScopedProxyMode.INTERFACES`.
#### ** Chinese **

Spring通过[scoped proxies](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-scopes-other-injection)提供了一种方便的方法来处理scoped依赖关系。使用XML配置时，创建这样一个代理的最简单的方法是`<aop:scoped-proxy/>`元素。在Java中用`@Scope`注解配置你的Bean，可以用`proxyMode`属性提供等效的支持。默认情况下是无代理(`ScopedProxyMode.NO`)，但你可以指定`ScopedProxyMode.TARGET_CLASS`或`ScopedProxyMode.INTERFACES`。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

If you port the scoped proxy example from the XML reference documentation (see [scoped proxies](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-scopes-other-injection)) to our `@Bean` using Java, it resembles the following:
#### ** Chinese **

如果你将XML参考文档中的scoped proxy示例(参见[scoped proxies](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-scopes-other-injection))移植到我们的`@Bean`中，使用Java，它类似于下面的例子。
<!-- tabs:end -->


```java
// an HTTP Session-scoped bean exposed as a proxy
@Bean
@SessionScope
public UserPreferences userPreferences() {
    return new UserPreferences();
}

@Bean
public Service userService() {
    UserService service = new SimpleUserService();
    // a reference to the proxied userPreferences bean
    service.setUserPreferences(userPreferences());
    return service;
}
```

### **Customizing Bean Naming** 

<!-- tabs:start -->

#### ** English **

By default, configuration classes use a `@Bean` method’s name as the name of the resulting bean. This functionality can be overridden, however, with the `name` attribute, as the following example shows:
#### ** Chinese **

默认情况下，配置类使用`@Bean`方法的名称作为生成的Bean的名称。但是，这个功能可以用`name`属性来重写，如下例所示。
<!-- tabs:end -->


```java
@Configuration
public class AppConfig {

    @Bean(name = "myThing")
    public Thing thing() {
        return new Thing();
    }
}
```

### **Bean Aliasing** 

<!-- tabs:start -->

#### ** English **

As discussed in [Naming Beans](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-beanname), it is sometimes desirable to give a single bean multiple names, otherwise known as bean aliasing. The `name` attribute of the `@Bean` annotation accepts a String array for this purpose. The following example shows how to set a number of aliases for a bean:
#### ** Chinese **

正如[Naming Beans](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-beanname)中所讨论的那样，有时给一个Bean起多个名字是可取的，也就是所谓的Bean别名。`@Bean`注解中的`name`属性可以接受一个String数组。下面的例子显示了如何为一个bean设置多个别名。
<!-- tabs:end -->


```java
@Configuration
public class AppConfig {

    @Bean({"dataSource", "subsystemA-dataSource", "subsystemB-dataSource"})
    public DataSource dataSource() {
        // instantiate, configure and return DataSource bean...
    }
}
```

### **Bean Description** 

<!-- tabs:start -->

#### ** English **

Sometimes, it is helpful to provide a more detailed textual description of a bean. This can be particularly useful when beans are exposed (perhaps through JMX) for monitoring purposes.
#### ** Chinese **

有时，提供一个豆子更详细的文本描述是很有帮助的。当豆子被曝光（也许是通过JMX）用于监控目的时，这可能特别有用。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

To add a description to a `@Bean`, you can use the [`@Description`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/context/annotation/Description.html) annotation, as the following example shows:
#### ** Chinese **

要给`@Bean`添加描述，可以使用[`@Description`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/context/annotation/Description.html)注解，如下例所示。
<!-- tabs:end -->


```java
@Configuration
public class AppConfig {

    @Bean
    @Description("Provides a basic example of a bean")
    public Thing thing() {
        return new Thing();
    }
}
```

### **1.12.4. Using the** **`@Configuration`** ** annotation** 

<!-- tabs:start -->

#### ** English **

`@Configuration` is a class-level annotation indicating that an object is a source of bean definitions. `@Configuration` classes declare beans through public `@Bean` annotated methods. Calls to `@Bean` methods on `@Configuration` classes can also be used to define inter-bean dependencies. See [Basic Concepts: ](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-java-basic-concepts)[`@Bean`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-java-basic-concepts)[ and ](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-java-basic-concepts)[`@Configuration`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-java-basic-concepts) for a general introduction.
#### ** Chinese **

`@Configuration`是类级注解，表示对象是Bean定义的来源。 `@Configuration`类通过公共的`@Bean`注解方法来声明Bean。对`@Bean`类上的`@Configuration`方法的调用也可以用来定义bean之间的依赖关系。请参见 [基本概念： ](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-java-basic-concepts)[`@Bean`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-java-basic-concepts)[ 和 ](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-java-basic-concepts)[`@Configuration`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-java-basic-concepts)了解一般介绍。
<!-- tabs:end -->


### **Injecting Inter-bean Dependencies** 

<!-- tabs:start -->

#### ** English **

When beans have dependencies on one another, expressing that dependency is as simple as having one bean method call another, as the following example shows:
#### ** Chinese **

当Bean相互之间有依赖关系时，表达这种依赖关系就像让一个Bean方法调用另一个方法一样简单，就像下面的例子所示。
<!-- tabs:end -->


```java
@Configuration
public class AppConfig {

    @Bean
    public BeanOne beanOne() {
        return new BeanOne(beanTwo());
    }

    @Bean
    public BeanTwo beanTwo() {
        return new BeanTwo();
    }
}
```

<!-- tabs:start -->

#### ** English **

In the preceding example, `beanOne` receives a reference to `beanTwo` through constructor injection.
#### ** Chinese **

在前面的例子中，`beanOne`通过构造函数注入接收到`beanTwo`的引用。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

This method of declaring inter-bean dependencies works only when the `@Bean` method is declared within a `@Configuration` class. You cannot declare inter-bean dependencies by using plain `@Component` classes.
#### ** Chinese **

只有当`@Bean`方法在`@Configuration`类中声明了`@Bean`方法时，这种声明豆间依赖关系的方法才有效。你不能通过使用普通的 `@Component`类来声明豆间依赖关系。
<!-- tabs:end -->


### **Lookup Method Injection** 

<!-- tabs:start -->

#### ** English **

As noted earlier, [lookup method injection](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-method-injection) is an advanced feature that you should use rarely. It is useful in cases where a singleton-scoped bean has a dependency on a prototype-scoped bean. Using Java for this type of configuration provides a natural means for implementing this pattern. The following example shows how to use lookup method injection:
#### ** Chinese **

如前所述，[查找方法注入](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-method-injection)是一个高级功能，你应该很少使用。它在单子标记的Bean对prototype标记的Bean有依赖性的情况下非常有用。在这种类型的配置中使用Java提供了实现这种模式的自然手段。下面的例子显示了如何使用查找方法注入。
<!-- tabs:end -->


```java
public abstract class CommandManager {
    public Object process(Object commandState) {
        // grab a new instance of the appropriate Command interface
        Command command = createCommand();
        // set the state on the (hopefully brand new) Command instance
        command.setState(commandState);
        return command.execute();
    }

    // okay... but where is the implementation of this method?
    protected abstract Command createCommand();
}
```

<!-- tabs:start -->

#### ** English **

By using Java configuration, you can create a subclass of `CommandManager` where the abstract `createCommand()` method is overridden in such a way that it looks up a new (prototype) command object. The following example shows how to do so:
#### ** Chinese **

通过使用Java配置，您可以创建一个`CommandManager`的子类，其中抽象的`createCommand()`方法被重写，从而查找一个新的（原型）命令对象。下面的例子显示了如何做到这一点。
<!-- tabs:end -->


```java
@Bean
@Scope("prototype")
public AsyncCommand asyncCommand() {
    AsyncCommand command = new AsyncCommand();
    // inject dependencies here as required
    return command;
}

@Bean
public CommandManager commandManager() {
    // return new anonymous implementation of CommandManager with createCommand()
    // overridden to return a new prototype Command object
    return new CommandManager() {
        protected Command createCommand() {
            return asyncCommand();
        }
    }
}
```

### **Further Information About How Java-based Configuration Works Internally** 

<!-- tabs:start -->

#### ** English **

Consider the following example, which shows a `@Bean` annotated method being called twice:
#### ** Chinese **

考虑以下例子，它显示了一个`@Bean`注解方法被调用两次。
<!-- tabs:end -->


```java
@Configuration
public class AppConfig {

    @Bean
    public ClientService clientService1() {
        ClientServiceImpl clientService = new ClientServiceImpl();
        clientService.setClientDao(clientDao());
        return clientService;
    }

    @Bean
    public ClientService clientService2() {
        ClientServiceImpl clientService = new ClientServiceImpl();
        clientService.setClientDao(clientDao());
        return clientService;
    }

    @Bean
    public ClientDao clientDao() {
        return new ClientDaoImpl();
    }
}
```

<!-- tabs:start -->

#### ** English **

`clientDao()` has been called once in `clientService1()` and once in `clientService2()`. Since this method creates a new instance of `ClientDaoImpl` and returns it, you would normally expect to have two instances (one for each service). That definitely would be problematic: In Spring, instantiated beans have a `singleton` scope by default. This is where the magic comes in: All `@Configuration` classes are subclassed at startup-time with `CGLIB`. In the subclass, the child method checks the container first for any cached (scoped) beans before it calls the parent method and creates a new instance.
#### ** Chinese **

`clientDao()`已经在`clientService1()`中调用过一次，在`clientService2()`中调用过一次。由于这个方法创建了一个新的`ClientDaoImpl`实例并返回它，所以通常情况下，你会期望有两个实例（每个服务一个）。这肯定会有问题：在Spring中，实例化的Bean默认有一个`singleton`作用域。这就是神奇的地方。所有`@Configuration`类都会在启动时用`CGLIB`进行子类化。在子类中，子方法在调用父方法并创建新实例之前，首先检查容器中是否有任何缓存（scoped）Bean。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The behavior could be different according to the scope of your bean. We are talking about singletons here.
#### ** Chinese **

根据你的Bean的范围不同，行为可能是不同的。我们这里说的是单子。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

As of Spring 3.2, it is no longer necessary to add CGLIB to your classpath because CGLIB classes have been repackaged under `org.springframework.cglib` and included directly within the spring-core JAR.
#### ** Chinese **

从Spring 3.2开始，不再需要在classpath中添加CGLIB，因为CGLIB类已经被重新打包到`org.springframework.cglib`下，并直接包含在spring-core JAR中。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

There are a few restrictions due to the fact that CGLIB dynamically adds features at startup-time. In particular, configuration classes must not be final. However, as of 4.3, any constructors are allowed on configuration classes, including the use of `@Autowired` or a single non-default constructor declaration for default injection.
#### ** Chinese **

由于CGLIB在启动时动态添加特性，所以有一些限制。特别是，配置类不能是最终的。但是，从4.3开始，允许在配置类上使用任何构造函数，包括使用`@Autowired`或单一的非默认构造函数声明进行默认注入。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

If you prefer to avoid any CGLIB-imposed limitations, consider declaring your `@Bean` methods on non-`@Configuration` classes (for example, on plain `@Component` classes instead). Cross-method calls between `@Bean` methods are not then intercepted, so you have to exclusively rely on dependency injection at the constructor or method level there.
#### ** Chinese **

如果你想避免任何 CGLIB 强加的限制，可以考虑将 `@Bean`方法声明在非`@Configuration`类上（例如，将其声明在普通的 `@Component`类上）。`@Bean`方法之间的交叉方法调用不会被拦截，所以你必须完全依赖构造函数或方法级的依赖注入。
<!-- tabs:end -->


### **1.12.5. Composing Java-based Configurations** 

<!-- tabs:start -->

#### ** English **

Spring’s Java-based configuration feature lets you compose annotations, which can reduce the complexity of your configuration.
#### ** Chinese **

Spring的基于Java的配置功能让你可以编写注解，这可以降低配置的复杂性。
<!-- tabs:end -->


### **Using the** **`@Import`** ** Annotation** 

<!-- tabs:start -->

#### ** English **

Much as the `<import/>` element is used within Spring XML files to aid in modularizing configurations, the `@Import` annotation allows for loading `@Bean` definitions from another configuration class, as the following example shows:
#### ** Chinese **

正如 `<import/>`元素在Spring XML文件中用于帮助模块化配置一样，`@Import`注解也允许从另一个配置类中加载`@Bean`定义，如下例所示。
<!-- tabs:end -->


```java
@Configuration
public class ConfigA {

    @Bean
    public A a() {
        return new A();
    }
}

@Configuration
@Import(ConfigA.class)
public class ConfigB {

    @Bean
    public B b() {
        return new B();
    }
}
```

<!-- tabs:start -->

#### ** English **

Now, rather than needing to specify both `ConfigA.class` and `ConfigB.class` when instantiating the context, only `ConfigB` needs to be supplied explicitly, as the following example shows:
#### ** Chinese **

现在，不再需要在实例化上下文时同时指定`ConfigA.class`和`ConfigB.class`，而只需要显式提供`ConfigB`，如下例所示。
<!-- tabs:end -->


```java
public static void main(String[] args) {
    ApplicationContext ctx = new AnnotationConfigApplicationContext(ConfigB.class);

    // now both beans A and B will be available...
    A a = ctx.getBean(A.class);
    B b = ctx.getBean(B.class);
}
```

<!-- tabs:start -->

#### ** English **

This approach simplifies container instantiation, as only one class needs to be dealt with, rather than requiring you to remember a potentially large number of `@Configuration` classes during construction.
#### ** Chinese **

这种方法简化了容器的实例化，因为只需要处理一个类，而不需要在构造过程中记住大量的`@Configuration`类。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

As of Spring Framework 4.2, `@Import` also supports references to regular component classes, analogous to the `AnnotationConfigApplicationContext.register` method. This is particularly useful if you want to avoid component scanning, by using a few configuration classes as entry points to explicitly define all your components.
#### ** Chinese **

从Spring Framework 4.2开始，`@Import`还支持对常规组件类的引用，类似于`AnnotationConfigApplicationContext.register`方法。如果你想通过使用一些配置类作为入口点来显式定义所有组件，避免组件扫描，这一点特别有用。
<!-- tabs:end -->


### **Injecting Dependencies on Imported** **`@Bean`** ** Definitions** 

<!-- tabs:start -->

#### ** English **

The preceding example works but is simplistic. In most practical scenarios, beans have dependencies on one another across configuration classes. When using XML, this is not an issue, because no compiler is involved, and you can declare `ref="someBean"` and trust Spring to work it out during container initialization. When using `@Configuration` classes, the Java compiler places constraints on the configuration model, in that references to other beans must be valid Java syntax.
#### ** Chinese **

前面的例子很好用，但是很简单。在大多数实际应用场景中，Bean跨配置类之间有相互依赖关系。使用 XML 时，这不是一个问题，因为不涉及编译器，您可以声明 `ref="someBean"`，并信任 Spring 在容器初始化过程中解决这个问题。当使用`@Configuration`类时，Java编译器会对配置模型施加约束，即对其他bean的引用必须是有效的Java语法。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Fortunately, solving this problem is simple. As [we already discussed](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-java-dependencies), a `@Bean` method can have an arbitrary number of parameters that describe the bean dependencies. Consider the following more real-world scenario with several `@Configuration` classes, each depending on beans declared in the others:
#### ** Chinese **

幸运的是，解决这个问题很简单。正如[我们已经讨论过的](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-java-dependencies)，一个`@Bean`方法可以有任意数量的参数来描述bean的依赖关系。考虑下面这个更真实的场景，有几个`@Configuration`类，每个类都依赖于在其他类中声明的Bean。
<!-- tabs:end -->


```java
@Configuration
public class ServiceConfig {

    @Bean
    public TransferService transferService(AccountRepository accountRepository) {
        return new TransferServiceImpl(accountRepository);
    }
}

@Configuration
public class RepositoryConfig {

    @Bean
    public AccountRepository accountRepository(DataSource dataSource) {
        return new JdbcAccountRepository(dataSource);
    }
}

@Configuration
@Import({ServiceConfig.class, RepositoryConfig.class})
public class SystemTestConfig {

    @Bean
    public DataSource dataSource() {
        // return new DataSource
    }
}

public static void main(String[] args) {
    ApplicationContext ctx = new AnnotationConfigApplicationContext(SystemTestConfig.class);
    // everything wires up across configuration classes...
    TransferService transferService = ctx.getBean(TransferService.class);
    transferService.transfer(100.00, "A123", "C456");
}
```

<!-- tabs:start -->

#### ** English **

There is another way to achieve the same result. Remember that `@Configuration` classes are ultimately only another bean in the container: This means that they can take advantage of `@Autowired` and `@Value` injection and other features the same as any other bean.
#### ** Chinese **

还有一种方法可以达到同样的效果。记住，`@Configuration`类最终只是容器中的另一个Bean。这意味着它们可以像其他Bean一样利用`@Autowired`和`@Value`注入和其他特性。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Make sure that the dependencies you inject that way are of the simplest kind only. `@Configuration` classes are processed quite early during the initialization of the context, and forcing a dependency to be injected this way may lead to unexpected early initialization. Whenever possible, resort to parameter-based injection, as in the preceding example.
#### ** Chinese **

确保你以这种方式注入的依赖关系只能是最简单的那种。 `@Configuration`类在上下文的初始化过程中很早就被处理了，如果强行以这种方式注入依赖关系，可能会导致意外的早期初始化。在可能的情况下，尽可能采用基于参数的注入方式，就像前面的例子一样。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Also, be particularly careful with `BeanPostProcessor` and `BeanFactoryPostProcessor` definitions through `@Bean`. Those should usually be declared as `static @Bean` methods, not triggering the instantiation of their containing configuration class. Otherwise, `@Autowired` and `@Value` may not work on the configuration class itself, since it is possible to create it as a bean instance earlier than [`AutowiredAnnotationBeanPostProcessor`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/beans/factory/annotation/AutowiredAnnotationBeanPostProcessor.html).
#### ** Chinese **

另外，要特别注意通过`@Bean`定义的`BeanPostProcessor`和`BeanFactoryPostProcessor`。这些通常应该被声明为`static @Bean`方法，而不是触发其包含的配置类的实例化。否则，`@Autowired`和`@Value`可能无法对配置类本身起作用，因为它可能比[`AutowiredAnnotationBeanPostProcessor`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/beans/factory/annotation/AutowiredAnnotationBeanPostProcessor.html)更早地以Bean实例的形式创建。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following example shows how one bean can be autowired to another bean:
#### ** Chinese **

下面的例子显示了一个豆子如何自动连接到另一个豆子上。
<!-- tabs:end -->


```java
@Configuration
public class ServiceConfig {

    @Autowired
    private AccountRepository accountRepository;

    @Bean
    public TransferService transferService() {
        return new TransferServiceImpl(accountRepository);
    }
}

@Configuration
public class RepositoryConfig {

    private final DataSource dataSource;

    public RepositoryConfig(DataSource dataSource) {
        this.dataSource = dataSource;
    }

    @Bean
    public AccountRepository accountRepository() {
        return new JdbcAccountRepository(dataSource);
    }
}

@Configuration
@Import({ServiceConfig.class, RepositoryConfig.class})
public class SystemTestConfig {

    @Bean
    public DataSource dataSource() {
        // return new DataSource
    }
}

public static void main(String[] args) {
    ApplicationContext ctx = new AnnotationConfigApplicationContext(SystemTestConfig.class);
    // everything wires up across configuration classes...
    TransferService transferService = ctx.getBean(TransferService.class);
    transferService.transfer(100.00, "A123", "C456");
}
```

<!-- tabs:start -->

#### ** English **

Constructor injection in `@Configuration` classes is only supported as of Spring Framework 4.3. Note also that there is no need to specify `@Autowired` if the target bean defines only one constructor.
#### ** Chinese **

在`@Configuration`类中的构造函数注入仅在Spring Framework 4.3中支持。还请注意，如果目标Bean只定义了一个构造函数，则不需要指定`@Autowired`。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

**Fully-qualifying imported beans for ease of navigation** 
#### ** Chinese **

***完全合格的进口豆子，便于导航***。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

In the preceding scenario, using `@Autowired` works well and provides the desired modularity, but determining exactly where the autowired bean definitions are declared is still somewhat ambiguous. For example, as a developer looking at `ServiceConfig`, how do you know exactly where the `@Autowired AccountRepository` bean is declared? It is not explicit in the code, and this may be just fine. Remember that the [Spring Tools for Eclipse](https://spring.io/tools) provides tooling that can render graphs showing how everything is wired, which may be all you need. Also, your Java IDE can easily find all declarations and uses of the `AccountRepository` type and quickly show you the location of `@Bean` methods that return that type.
#### ** Chinese **

在前面的场景中，使用`@Autowired`效果很好，并且提供了所需的模块化，但是确定autowired bean定义的具体声明位置仍然有些模糊。例如，作为一个开发者，在查看`ServiceConfig`时，你如何知道`@Autowired AccountRepository` bean的具体声明位置？在代码中并没有明确说明，这可能就可以了。请记住，[Spring Tools for Eclipse](https://spring.io/tools)提供的工具可以渲染出显示所有事情是如何接线的图形，这可能就是你所需要的。另外，你的Java IDE可以很容易地找到`AccountRepository`类型的所有声明和使用，并快速显示出返回该类型的`@Bean`方法的位置。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

In cases where this ambiguity is not acceptable and you wish to have direct navigation from within your IDE from one `@Configuration` class to another, consider autowiring the configuration classes themselves. The following example shows how to do so:
#### ** Chinese **

如果这种模糊性是不能接受的，而且你希望在IDE中直接从一个`@Configuration`类到另一个<x>类的导航，那么可以考虑自动布线配置类本身。下面的例子显示了如何做到这一点。
<!-- tabs:end -->


```java
@Configuration
public class ServiceConfig {

    @Autowired
    private RepositoryConfig repositoryConfig;

    @Bean
    public TransferService transferService() {
        // navigate 'through' the config class to the @Bean method!
        return new TransferServiceImpl(repositoryConfig.accountRepository());
    }
}
```

<!-- tabs:start -->

#### ** English **

In the preceding situation, where `AccountRepository` is defined is completely explicit. However, `ServiceConfig` is now tightly coupled to `RepositoryConfig`. That is the tradeoff. This tight coupling can be somewhat mitigated by using interface-based or abstract class-based `@Configuration` classes. Consider the following example:
#### ** Chinese **

在前面的情况下，`AccountRepository`的定义是完全显式的。然而，`ServiceConfig`现在与`RepositoryConfig`紧密耦合。这就是权衡的结果。这种紧密耦合可以通过使用基于接口或抽象类的 `@Configuration`类来缓解。考虑一下下面的例子。
<!-- tabs:end -->


```java
@Configuration
public class ServiceConfig {

    @Autowired
    private RepositoryConfig repositoryConfig;

    @Bean
    public TransferService transferService() {
        return new TransferServiceImpl(repositoryConfig.accountRepository());
    }
}

@Configuration
public interface RepositoryConfig {

    @Bean
    AccountRepository accountRepository();
}

@Configuration
public class DefaultRepositoryConfig implements RepositoryConfig {

    @Bean
    public AccountRepository accountRepository() {
        return new JdbcAccountRepository(...);
    }
}

@Configuration
@Import({ServiceConfig.class, DefaultRepositoryConfig.class})  // import the concrete config!
public class SystemTestConfig {

    @Bean
    public DataSource dataSource() {
        // return DataSource
    }

}

public static void main(String[] args) {
    ApplicationContext ctx = new AnnotationConfigApplicationContext(SystemTestConfig.class);
    TransferService transferService = ctx.getBean(TransferService.class);
    transferService.transfer(100.00, "A123", "C456");
}
```

<!-- tabs:start -->

#### ** English **

Now `ServiceConfig` is loosely coupled with respect to the concrete `DefaultRepositoryConfig`, and built-in IDE tooling is still useful: You can easily get a type hierarchy of `RepositoryConfig` implementations. In this way, navigating `@Configuration` classes and their dependencies becomes no different than the usual process of navigating interface-based code.
#### ** Chinese **

现在，`ServiceConfig`与具体的`DefaultRepositoryConfig`松散地耦合在一起了，内置的IDE工具仍然有用。你可以很容易地获得`RepositoryConfig`实现的类型层次结构。这样一来，导航`@Configuration`类和它们的依赖关系就和通常导航基于接口的代码的过程没有什么区别。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

If you want to influence the startup creation order of certain beans, consider declaring some of them as `@Lazy` (for creation on first access instead of on startup) or as `@DependsOn` certain other beans (making sure that specific other beans are created before the current bean, beyond what the latter’s direct dependencies imply).
#### ** Chinese **

如果你想影响某些Bean的启动创建顺序，可以考虑将其中一些Bean声明为`@Lazy`（用于在第一次访问时创建，而不是在启动时创建），或者声明为`@DependsOn`某些其他Bean（确保特定的其他Bean在当前Bean之前创建，而不是后者的直接依赖关系所暗示的那样）。
<!-- tabs:end -->


### **Conditionally Include** **`@Configuration`** ** Classes or** **`@Bean`** ** Methods** 

<!-- tabs:start -->

#### ** English **

It is often useful to conditionally enable or disable a complete `@Configuration` class or even individual `@Bean` methods, based on some arbitrary system state. One common example of this is to use the `@Profile` annotation to activate beans only when a specific profile has been enabled in the Spring `Environment` (see [Bean Definition Profiles](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-definition-profiles) for details).
#### ** Chinese **

基于一些任意的系统状态，有条件地启用或禁用一个完整的 `@Configuration`类，甚至是单个的 `@Bean`方法，通常是非常有用的。其中一个常见的例子是使用 `@Profile` 注解，只有在 Spring `Environment` 中启用了特定的配置文件时，才会激活 Bean（详情请参见 [Bean Definition Profiles](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-definition-profiles)）。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The `@Profile` annotation is actually implemented by using a much more flexible annotation called [`@Conditional`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/context/annotation/Conditional.html). The `@Conditional` annotation indicates specific `org.springframework.context.annotation.Condition` implementations that should be consulted before a `@Bean` is registered.
#### ** Chinese **

`@Profile`注解实际上是通过使用一个更灵活的注解[`@Conditional`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/context/annotation/Conditional.html)来实现的。`@Conditional` 注解指示了特定的 `org.springframework.context.annotation.Condition`实现，在注册一个`@Bean`之前，应该先参考这些实现。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Implementations of the `Condition` interface provide a `matches(…​)` method that returns `true` or `false`. For example, the following listing shows the actual `Condition` implementation used for `@Profile`:
#### ** Chinese **

`Condition`接口的实现提供了一个`matches(…​)`方法，该方法返回`true`或`false`。例如，下面的列表显示了用于`@Profile`的实际`Condition`实现。
<!-- tabs:end -->


```java
@Override
public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
    // Read the @Profile annotation attributes
    MultiValueMap<String, Object> attrs = metadata.getAllAnnotationAttributes(Profile.class.getName());
    if (attrs != null) {
        for (Object value : attrs.get("value")) {
            if (context.getEnvironment().acceptsProfiles(((String[]) value))) {
                return true;
            }
        }
        return false;
    }
    return true;
}
```

<!-- tabs:start -->

#### ** English **

See the [`@Conditional`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/context/annotation/Conditional.html) javadoc for more detail.
#### ** Chinese **

更多详情请参见[`@Conditional`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/context/annotation/Conditional.html) javadoc。
<!-- tabs:end -->


### **Combining Java and XML Configuration** 

<!-- tabs:start -->

#### ** English **

Spring’s `@Configuration` class support does not aim to be a 100% complete replacement for Spring XML. Some facilities, such as Spring XML namespaces, remain an ideal way to configure the container. In cases where XML is convenient or necessary, you have a choice: either instantiate the container in an “XML-centric” way by using, for example, `ClassPathXmlApplicationContext`, or instantiate it in a “Java-centric” way by using `AnnotationConfigApplicationContext` and the `@ImportResource` annotation to import XML as needed.
#### ** Chinese **

Spring的"`@Configuration` "类支持并不是为了100%完全取代Spring XML。一些设施，如Spring XML命名空间，仍然是配置容器的理想方式。在使用XML很方便或有必要的情况下，你有一个选择：或者通过使用`ClassPathXmlApplicationContext`以 "以XML为中心 "的方式实例化容器，或者通过使用`AnnotationConfigApplicationContext`和`@ImportResource`注释以 "以Java为中心 "的方式实例化容器，以根据需要导入XML。
<!-- tabs:end -->


### **XML-centric Use of** **`@Configuration`** ** Classes** 

<!-- tabs:start -->

#### ** English **

It may be preferable to bootstrap the Spring container from XML and include `@Configuration` classes in an ad-hoc fashion. For example, in a large existing codebase that uses Spring XML, it is easier to create `@Configuration` classes on an as-needed basis and include them from the existing XML files. Later in this section, we cover the options for using `@Configuration` classes in this kind of “XML-centric” situation.
#### ** Chinese **

从XML中引导Spring容器，并以临时的方式包含`@Configuration`类，可能是比较好的选择。例如，在使用 Spring XML 的大型现有代码库中，根据需要创建 `@Configuration` 类，并从现有的 XML 文件中包含这些类会更容易。在这一节的后面，我们将介绍在这种 "以 XML 为中心 "的情况下使用 `@Configuration` 类的选项。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

**Declaring** **`@Configuration`** ** classes as plain Spring** **`<bean/>`** ** elements** 
#### ** Chinese **

**声明** **`@Configuration`** ***类为纯Spring** **`<bean/>`** **元素*** 
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Remember that `@Configuration` classes are ultimately bean definitions in the container. In this series examples, we create a `@Configuration` class named `AppConfig` and include it within `system-test-config.xml` as a `<bean/>` definition. Because `<context:annotation-config/>` is switched on, the container recognizes the `@Configuration` annotation and processes the `@Bean` methods declared in `AppConfig` properly.
#### ** Chinese **

记住，`@Configuration`类最终是容器中的Bean定义。在本系列示例中，我们创建一个名为`@Configuration`的`@Configuration`类，并将其作为`ystem-test-config.xml`中的`<bean/>`定义包含在`system-test-config.xml`中。由于 `<context:annotation-config/>`被打开了，所以容器会识别出`@Configuration`注解，并正确处理在`AppConfig`中声明的`@Bean`方法。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following example shows an ordinary configuration class in Java:
#### ** Chinese **

下面的例子显示的是Java中的一个普通配置类。
<!-- tabs:end -->


```java
@Configuration
public class AppConfig {

    @Autowired
    private DataSource dataSource;

    @Bean
    public AccountRepository accountRepository() {
        return new JdbcAccountRepository(dataSource);
    }

    @Bean
    public TransferService transferService() {
        return new TransferService(accountRepository());
    }
}
```

<!-- tabs:start -->

#### ** English **

The following example shows part of a sample `system-test-config.xml` file:
#### ** Chinese **

下面的例子显示了一个示例 `system-test-config.xml`文件的一部分。
<!-- tabs:end -->


```xml
<beans>
    <!-- enable processing of annotations such as @Autowired and @Configuration -->
    <context:annotation-config/>
    <context:property-placeholder location="classpath:/com/acme/jdbc.properties"/>

    <bean class="com.acme.AppConfig"/>

    <bean class="org.springframework.jdbc.datasource.DriverManagerDataSource">
        <property name="url" value="${jdbc.url}"/>
        <property name="username" value="${jdbc.username}"/>
        <property name="password" value="${jdbc.password}"/>
    </bean>
</beans>
```

<!-- tabs:start -->

#### ** English **

The following example shows a possible `jdbc.properties` file:
#### ** Chinese **

下面的例子显示了一个可能的`jdbc.properties`文件。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

jdbc.url=jdbc:hsqldb:hsql://localhost/xdb
#### ** Chinese **

jdbc.url=jdbc:hsqldb:hsql://localhost/xdb
<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

jdbc.username=sa
#### ** Chinese **

jdbc.username=sa
<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

jdbc.password=
#### ** Chinese **

jdbc.password=
<!-- tabs:end -->


```java
public static void main(String[] args) {
    ApplicationContext ctx = new ClassPathXmlApplicationContext("classpath:/com/acme/system-test-config.xml");
    TransferService transferService = ctx.getBean(TransferService.class);
    // ...
}
```

<!-- tabs:start -->

#### ** English **

In `system-test-config.xml` file, the `AppConfig` `<bean/>` does not declare an `id` element. While it would be acceptable to do so, it is unnecessary, given that no other bean ever refers to it, and it is unlikely to be explicitly fetched from the container by name. Similarly, the `DataSource` bean is only ever autowired by type, so an explicit bean `id` is not strictly required.
#### ** Chinese **

在 `system-test-config.xml`文件中，`AppConfig` `<bean/>`没有声明一个`id`元素。虽然这样做是可以接受的，但考虑到没有其他的Bean引用过它，而且不太可能从容器中通过名称显式提取它，所以没有必要。同样的，`DataSource` bean只按类型自动触发，因此，显式 bean`id`并不是严格要求。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

**Using <context:component-scan/> to pick up** **`@Configuration`** ** classes** 
#### ** Chinese **

***使用<context:component-scan/>来拾取*** **`@Configuration`** **类*** 
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Because `@Configuration` is meta-annotated with `@Component`, `@Configuration`-annotated classes are automatically candidates for component scanning. Using the same scenario as describe in the previous example, we can redefine `system-test-config.xml` to take advantage of component-scanning. Note that, in this case, we need not explicitly declare `<context:annotation-config/>`, because `<context:component-scan/>` enables the same functionality.
#### ** Chinese **

因为 `@Configuration`是用`@Component`进行元注解的，所以`@Configuration`注解的类自动成为组件扫描的候选类。使用与上一个例子中描述的相同的场景，我们可以重新定义 `system-test-config.xml`来利用组件扫描的优势。注意，在这种情况下，我们不需要显式声明 `<context:annotation-config/>`，因为`<context:component-scan/>`实现了同样的功能。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following example shows the modified `system-test-config.xml` file:
#### ** Chinese **

下面的例子显示了修改后的`system-test-config.xml`文件。
<!-- tabs:end -->


```xml
<beans>
    <!-- picks up and registers AppConfig as a bean definition -->
    <context:component-scan base-package="com.acme"/>
    <context:property-placeholder location="classpath:/com/acme/jdbc.properties"/>

    <bean class="org.springframework.jdbc.datasource.DriverManagerDataSource">
        <property name="url" value="${jdbc.url}"/>
        <property name="username" value="${jdbc.username}"/>
        <property name="password" value="${jdbc.password}"/>
    </bean>
</beans>
```

### **`@Configuration`** ** Class-centric Use of XML with** **`@ImportResource`** 

<!-- tabs:start -->

#### ** English **

In applications where `@Configuration` classes are the primary mechanism for configuring the container, it is still likely necessary to use at least some XML. In these scenarios, you can use `@ImportResource` and define only as much XML as you need. Doing so achieves a “Java-centric” approach to configuring the container and keeps XML to a bare minimum. The following example (which includes a configuration class, an XML file that defines a bean, a properties file, and the `main` class) shows how to use the `@ImportResource` annotation to achieve “Java-centric” configuration that uses XML as needed:
#### ** Chinese **

在 `@Configuration`类是配置容器的主要机制的应用中，可能仍然需要至少使用一些XML。在这些场景中，您可以使用 `@ImportResource`，并且只定义所需的 XML。这样做可以实现 "以 Java 为中心 "的方法来配置容器，并将 XML 保持在最低限度。下面的示例（其中包括一个配置类、一个定义Bean的XML文件、一个属性文件和`main`类）展示了如何使用`@ImportResource`注解来实现 "以Java为中心 "的配置，并根据需要使用XML。
<!-- tabs:end -->


```java
@Configuration
@ImportResource("classpath:/com/acme/properties-config.xml")
public class AppConfig {

    @Value("${jdbc.url}")
    private String url;

    @Value("${jdbc.username}")
    private String username;

    @Value("${jdbc.password}")
    private String password;

    @Bean
    public DataSource dataSource() {
        return new DriverManagerDataSource(url, username, password);
    }
}
```

```java
properties-config.xml
<beans>
    <context:property-placeholder location="classpath:/com/acme/jdbc.properties"/>
</beans>
```

<!-- tabs:start -->

#### ** English **

jdbc.properties
#### ** Chinese **

jdbc.properties
<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

jdbc.url=jdbc:hsqldb:hsql://localhost/xdb
#### ** Chinese **

jdbc.url=jdbc:hsqldb:hsql://localhost/xdb
<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

jdbc.username=sa
#### ** Chinese **

jdbc.username=sa
<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

jdbc.password=
#### ** Chinese **

jdbc.password=
<!-- tabs:end -->


```java
public static void main(String[] args) {
    ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class);
    TransferService transferService = ctx.getBean(TransferService.class);
    // ...
}
```


[下一章](Spring-Framework-5.2.6.RELEASE/Core%20Technologies/1.13.%20Environment%20Abstraction.md)


[回目录](Spring-Framework-5.2.6.RELEASE/summary.md)

[回首页](/README)
