# 2. Resources


<!-- tabs:start -->

#### ** English **

This chapter covers how Spring handles resources and how you can work with resources in Spring. It includes the following topics:
#### ** Chinese **

本章涵盖了Spring如何处理资源以及如何在Spring中使用资源。它包括以下主题。
<!-- tabs:end -->


### **2.1. Introduction** 

<!-- tabs:start -->

#### ** English **

Java’s standard `java.net.URL` class and standard handlers for various URL prefixes, unfortunately, are not quite adequate enough for all access to low-level resources. For example, there is no standardized `URL` implementation that may be used to access a resource that needs to be obtained from the classpath or relative to a `ServletContext`. While it is possible to register new handlers for specialized `URL` prefixes (similar to existing handlers for prefixes such as `http:`), this is generally quite complicated, and the `URL` interface still lacks some desirable functionality, such as a method to check for the existence of the resource being pointed to.
#### ** Chinese **

不幸的是，Java的标准`java.net.URL`类和各种URL前缀的标准处理程序，对于所有的低级资源的访问还不够充分。例如，没有一个标准化的`URL`实现可以用来访问需要从classpath或相对于`ServletContext`获取的资源。虽然可以为专门的`URL`前缀注册新的处理程序（类似于`http:`等前缀的现有处理程序），但这通常相当复杂，而且`URL`接口仍然缺乏一些理想的功能，例如检查被指向的资源是否存在的方法。
<!-- tabs:end -->


### **2.2. The Resource Interface** 

<!-- tabs:start -->

#### ** English **

Spring’s `Resource` interface is meant to be a more capable interface for abstracting access to low-level resources. The following listing shows the `Resource` interface definition:
#### ** Chinese **

Spring的`Resource`接口是为了成为一个更有能力的接口，用于抽象访问低级资源。下面的列表显示了`Resource`接口的定义。
<!-- tabs:end -->


```java
public interface Resource extends InputStreamSource {

    boolean exists();

    boolean isOpen();

    URL getURL() throws IOException;

    File getFile() throws IOException;

    Resource createRelative(String relativePath) throws IOException;

    String getFilename();

    String getDescription();
}
```

<!-- tabs:start -->

#### ** English **

As the definition of the `Resource` interface shows, it extends the `InputStreamSource` interface. The following listing shows the definition of the `InputStreamSource` interface:
#### ** Chinese **

正如`Resource`接口的定义所示，它扩展了`InputStreamSource`接口。下面的列表显示了`InputStreamSource`接口的定义。
<!-- tabs:end -->


```java
public interface InputStreamSource {

    InputStream getInputStream() throws IOException;
}
```

<!-- tabs:start -->

#### ** English **

Some of the most important methods from the `Resource` interface are:
#### ** Chinese **

`Resource`接口中的一些最重要的方法是。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

- [Introduction](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#resources-introduction)

- [The Resource Interface](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#resources-resource)

- [Built-in Resource Implementations](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#resources-implementations)

- [The ](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#resources-resourceloader)[`ResourceLoader`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#resources-resourceloader)

- [The ](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#resources-resourceloaderaware)[`ResourceLoaderAware`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#resources-resourceloaderaware)[ interface](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#resources-resourceloaderaware)

- [Resources as Dependencies](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#resources-as-dependencies)

- [Application Contexts and Resource Paths](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#resources-app-ctx)

- `getInputStream()`: Locates and opens the resource, returning an `InputStream` for reading from the resource. It is expected that each invocation returns a fresh `InputStream`. It is the responsibility of the caller to close the stream.

- `exists()`: Returns a `boolean` indicating whether this resource actually exists in physical form.

- `isOpen()`: Returns a `boolean` indicating whether this resource represents a handle with an open stream. If `true`, the `InputStream` cannot be read multiple times and must be read once only and then closed to avoid resource leaks. Returns `false` for all usual resource implementations, with the exception of `InputStreamResource`.

- `getDescription()`: Returns a description for this resource, to be used for error output when working with the resource. This is often the fully qualified file name or the actual URL of the resource.

#### ** Chinese **

- [导言](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#resources-introduction)

- [The Resource Interface](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#resources-resource)

- [内置资源实现](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#resources-implementations)

- [The](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#resources-resourceloader)[`ResourceLoader`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#resources-resourceloader)

- [The](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#resources-resourceloaderaware)[`ResourceLoaderAware`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#resources-resourceloaderaware)[ 接口](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#resources-resourceloaderaware)

- [资源即依附关系](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#resources-as-dependencies)

- [应用情境和资源路径](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#resources-app-ctx)

- `getInputStream()`。定位并打开资源，返回一个`InputStream`用于从资源中读取。预计每次调用都会返回一个新的`InputStream`。关闭流是调用者的责任。

- `exists()`。返回一个`boolean`，表示该资源是否以物理形式实际存在。

- `isOpen()`：返回一个`boolean`，表示该资源是否以物理形式存在。返回一个`boolean`，表示该资源是否代表一个具有开放流的句柄。如果`true`，`InputStream`不能被多次读取，必须只读取一次，然后关闭以避免资源泄漏。除了`InputStreamResource`之外，返回`false`对所有通常的资源实现来说都是false

- `getDescription()`。返回该资源的描述，用于在使用该资源时输出错误。这通常是完全限定的文件名或资源的实际URL。

<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

Other methods let you obtain an actual `URL` or `File` object representing the resource (if the underlying implementation is compatible and supports that functionality).
#### ** Chinese **

其他方法可以让你获得一个实际的`URL`或`File`对象，代表资源（如果底层实现兼容并支持该功能）。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Spring itself uses the `Resource` abstraction extensively, as an argument type in many method signatures when a resource is needed. Other methods in some Spring APIs (such as the constructors to various `ApplicationContext` implementations) take a `String` which in unadorned or simple form is used to create a `Resource` appropriate to that context implementation or, via special prefixes on the `String` path, let the caller specify that a specific `Resource` implementation must be created and used.
#### ** Chinese **

当需要资源时，Spring本身就广泛使用了`Resource`抽象，作为许多方法签名中的参数类型。一些Spring API中的其他方法（例如各种`ApplicationContext`实现的构造函数）会采用一个`String`，它以不加修饰或简单的形式被用来创建一个适合于该上下文实现的`Resource`，或者通过`String`路径上的特殊前缀，让调用者指定必须创建和使用特定的`Resource`实现。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

While the `Resource` interface is used a lot with Spring and by Spring, it is actually very useful to use as a general utility class by itself in your own code, for access to resources, even when your code does not know or care about any other parts of Spring. While this couples your code to Spring, it really only couples it to this small set of utility classes, which serve as a more capable replacement for `URL` and can be considered equivalent to any other library you would use for this purpose.
#### ** Chinese **

虽然`Resource`接口在Spring中和Spring中使用得很多，但实际上，它本身作为一个通用的实用程序类在你的代码中使用是非常有用的，用于访问资源，即使你的代码不知道或不关心Spring的任何其他部分。虽然这可以将你的代码与Spring耦合，但它实际上只是将它与这一小组实用类耦合，它可以作为`URL`的一个更有能力的替代类，并且可以认为它与你为此目的而使用的任何其他库相当。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The `Resource` abstraction does not replace functionality. It wraps it where possible. For example, a `UrlResource` wraps a URL and uses the wrapped `URL` to do its work.
#### ** Chinese **

`Resource`抽象并不取代功能。它在可能的情况下对其进行了封装。例如，`UrlResource`封装了一个URL，并使用封装的`URL`来完成它的工作。
<!-- tabs:end -->


### **2.3. Built-in Resource Implementations** 

<!-- tabs:start -->

#### ** English **

Spring includes the following `Resource` implementations:
#### ** Chinese **

Spring 包括以下 `Resource`实现。
<!-- tabs:end -->


### **2.3.1.** **`UrlResource`** 

<!-- tabs:start -->

#### ** English **

`UrlResource` wraps a `java.net.URL` and can be used to access any object that is normally accessible with a URL, such as files, an HTTP target, an FTP target, and others. All URLs have a standardized `String` representation, such that appropriate standardized prefixes are used to indicate one URL type from another. This includes `file:` for accessing filesystem paths, `http:` for accessing resources through the HTTP protocol, `ftp:` for accessing resources through FTP, and others.
#### ** Chinese **

`UrlResource`封装了一个`java.net.URL`，可以用来访问任何通常用URL访问的对象，如文件、HTTP目标、FTP目标等。所有的URL都有一个标准化的`String`表示，这样，适当的标准化前缀可以用来表示一种URL类型与另一种URL类型。这包括`file:`用于访问文件系统路径，`http:`用于通过HTTP协议访问资源，`ftp:`用于通过FTP访问资源，以及其他。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

A `UrlResource` is created by Java code by explicitly using the `UrlResource` constructor but is often created implicitly when you call an API method that takes a `String` argument meant to represent a path. For the latter case, a JavaBeans `PropertyEditor` ultimately decides which type of `Resource` to create. If the path string contains well-known (to it, that is) prefix (such as `classpath:`), it creates an appropriate specialized `Resource` for that prefix. However, if it does not recognize the prefix, it assume the string is a standard URL string and creates a `UrlResource`.
#### ** Chinese **

`UrlResource`是由Java代码通过显式使用`UrlResource`构造函数创建的，但通常是在调用API方法时隐式创建的，该方法需要一个`String`参数来表示路径。对于后一种情况，JavaBeans `PropertyEditor`最终决定创建哪种类型的`Resource`。如果路径字符串包含已知的（对它来说，也就是）前缀（如`classpath:`），它将为该前缀创建一个适当的专门的`Resource`。但是，如果它不识别这个前缀，它将假定该字符串是一个标准的URL字符串，并创建一个`UrlResource`。
<!-- tabs:end -->


### **2.3.2.** **`ClassPathResource`** 

<!-- tabs:start -->

#### ** English **

This class represents a resource that should be obtained from the classpath. It uses either the thread context class loader, a given class loader, or a given class for loading resources.
#### ** Chinese **

这个类代表了一个应该从classpath中获取的资源。它使用线程上下文类加载器、给定类加载器或给定类加载资源。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

This `Resource` implementation supports resolution as `java.io.File` if the class path resource resides in the file system but not for classpath resources that reside in a jar and have not been expanded (by the servlet engine or whatever the environment is) to the filesystem. To address this, the various `Resource` implementations always support resolution as a `java.net.URL`.
#### ** Chinese **

这个`Resource`实现支持以`java.io.File`的形式解析，如果类路径资源驻留在文件系统中，但对于驻留在jar中的classpath资源，则不支持（由servlet引擎或其他环境）扩展到文件系统中。为了解决这个问题，各种`Resource`实现总是支持以`java.net.URL`的形式解析。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

A `ClassPathResource` is created by Java code by explicitly using the `ClassPathResource` constructor but is often created implicitly when you call an API method that takes a `String` argument meant to represent a path. For the latter case, a JavaBeans `PropertyEditor` recognizes the special prefix, `classpath:`, on the string path and creates a `ClassPathResource` in that case.
#### ** Chinese **

`ClassPathResource`是由Java代码通过显式使用`ClassPathResource`构造函数创建的，但通常是在调用API方法时隐式创建的，该方法接收了一个用于表示路径的`String`参数。对于后一种情况，JavaBeans `PropertyEditor`会识别字符串路径上的特殊前缀`classpath:`，并在这种情况下创建一个`ClassPathResource`。
<!-- tabs:end -->


### **2.3.3.** **`FileSystemResource`** 

<!-- tabs:start -->

#### ** English **

This is a `Resource` implementation for `java.io.File` and `java.nio.file.Path` handles. It supports resolution as a `File` and as a `URL`.
#### ** Chinese **

这是一个`Resource`实现，用于`java.io.File`和`java.nio.file.Path`句柄。它支持以`File`和`URL`的形式解析。
<!-- tabs:end -->


### **2.3.4.** **`ServletContextResource`** 

<!-- tabs:start -->

#### ** English **

This is a `Resource` implementation for `ServletContext` resources that interprets relative paths within the relevant web application’s root directory.
#### ** Chinese **

这是为`ServletContext`资源实现的`Resource`，它解释了相关Web应用程序根目录内的相对路径。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

It always supports stream access and URL access but allows `java.io.File` access only when the web application archive is expanded and the resource is physically on the filesystem. Whether or not it is expanded and on the filesystem or accessed directly from the JAR or somewhere else like a database (which is conceivable) is actually dependent on the Servlet container.
#### ** Chinese **

它始终支持流访问和URL访问，但只有当Web应用存档被展开并且资源实际在文件系统上时，才允许`java.io.File`访问。它是否被展开并在文件系统中，还是直接从JAR或其他地方如数据库（可以想象）访问，实际上取决于Servlet容器。
<!-- tabs:end -->


### **2.3.5.** **`InputStreamResource`** 

<!-- tabs:start -->

#### ** English **

An `InputStreamResource` is a `Resource` implementation for a given `InputStream`. It should be used only if no specific `Resource` implementation is applicable. In particular, prefer `ByteArrayResource` or any of the file-based `Resource` implementations where possible.
#### ** Chinese **

`InputStreamResource`是给定`InputStream`的`Resource`实现。只有当没有特定的 `Resource`实现时，才应该使用它。特别是，如果可能的话，最好使用 `ByteArrayResource` 或任何基于文件的 `Resource` 实现。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

In contrast to other `Resource` implementations, this is a descriptor for an already-opened resource. Therefore, it returns `true` from `isOpen()`. Do not use it if you need to keep the resource descriptor somewhere or if you need to read a stream multiple times.
#### ** Chinese **

与其他`Resource`实现不同，这是一个已经打开的资源的描述符。因此，它从 `isOpen()`返回 `true`。如果你需要将资源描述符保存在某个地方，或者需要多次读取一个流，请不要使用它。
<!-- tabs:end -->


### **2.3.6.** **`ByteArrayResource`** 

<!-- tabs:start -->

#### ** English **

This is a `Resource` implementation for a given byte array. It creates a `ByteArrayInputStream` for the given byte array.
#### ** Chinese **

这是一个`Resource`对给定的字节数组的实现。它为给定的字节数组创建一个`ByteArrayInputStream`。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

It is useful for loading content from any given byte array without having to resort to a single-use `InputStreamResource`.
#### ** Chinese **

它对于从任何给定的字节数组中加载内容是非常有用的，而不必求助于单一使用的`InputStreamResource`。
<!-- tabs:end -->


### **2.4. The** **`ResourceLoader`** 

<!-- tabs:start -->

#### ** English **

The `ResourceLoader` interface is meant to be implemented by objects that can return (that is, load) `Resource` instances. The following listing shows the `ResourceLoader` interface definition:
#### ** Chinese **

`ResourceLoader`接口是由能够返回（即加载）`Resource`实例的对象来实现的。下面的列表显示了`ResourceLoader`接口的定义。
<!-- tabs:end -->


```java
public interface ResourceLoader {

    Resource getResource(String location);
}
```

<!-- tabs:start -->

#### ** English **

All application contexts implement the `ResourceLoader` interface. Therefore, all application contexts may be used to obtain `Resource` instances.
#### ** Chinese **

所有的应用程序上下文都实现了`ResourceLoader`接口。因此，所有的应用程序上下文都可以用来获取`Resource`实例。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

When you call `getResource()` on a specific application context, and the location path specified doesn’t have a specific prefix, you get back a `Resource` type that is appropriate to that particular application context. For example, assume the following snippet of code was executed against a `ClassPathXmlApplicationContext` instance:
#### ** Chinese **

当你在特定的应用程序上下文中调用 `getResource()`，而指定的位置路径没有特定的前缀时，你会得到一个适合于特定应用程序上下文的`Resource`类型。例如，假设下面的代码片段是针对一个`ClassPathXmlApplicationContext`实例执行的。
<!-- tabs:end -->


```java
Resource template = ctx.getResource("some/resource/path/myTemplate.txt");
```

<!-- tabs:start -->

#### ** English **

Against a `ClassPathXmlApplicationContext`, that code returns a `ClassPathResource`. If the same method were executed against a `FileSystemXmlApplicationContext` instance, it would return a `FileSystemResource`. For a `WebApplicationContext`, it would return a `ServletContextResource`. It would similarly return appropriate objects for each context.
#### ** Chinese **

针对`ClassPathXmlApplicationContext`，该代码将返回一个`ClassPathResource`。如果对`FileSystemXmlApplicationContext`实例执行同样的方法，则会返回一个`FileSystemResource`。对于`WebApplicationContext`，它将返回一个`ServletContextResource`。同样，它将为每个上下文返回适当的对象。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

As a result, you can load resources in a fashion appropriate to the particular application context.
#### ** Chinese **

因此，您可以以适合特定应用环境的方式加载资源。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

On the other hand, you may also force `ClassPathResource` to be used, regardless of the application context type, by specifying the special `classpath:` prefix, as the following example shows:
#### ** Chinese **

另一方面，你也可以通过指定特殊的`classpath:`前缀来强制使用`ClassPathResource`，而不考虑应用程序上下文类型，如下例所示。
<!-- tabs:end -->


```java
Resource template = ctx.getResource("classpath:some/resource/path/myTemplate.txt");
```

<!-- tabs:start -->

#### ** English **

Similarly, you can force a `UrlResource` to be used by specifying any of the standard `java.net.URL` prefixes. The following pair of examples use the `file` and `http` prefixes:
#### ** Chinese **

同样，你可以通过指定任何一个标准的`java.net.URL`前缀来强制使用`UrlResource`。下面的一对示例使用了`file`和`http`前缀。
<!-- tabs:end -->


```java
Resource template = ctx.getResource("file:///some/resource/path/myTemplate.txt");
```

```java
Resource template = ctx.getResource("https://myhost.com/resource/path/myTemplate.txt");
```

<!-- tabs:start -->

#### ** English **

The following table summarizes the strategy for converting `String` objects to `Resource` objects:
#### ** Chinese **

下表总结了将`String`对象转换为`Resource`对象的策略。
<!-- tabs:end -->


Prefix | Example | Explanation 
-|-|-
classpath: | classpath:com/myapp/config.xml | Loaded from the classpath. 
file: | file:///data/config.xml | Loaded as a URL from the filesystem. See also FileSystemResource Caveats. 
http: | https://myserver/logo.png | Loaded as a URL. 
(none) | /data/config.xml | Depends on the underlying ApplicationContext. 


### **2.5. The** **`ResourceLoaderAware`** ** interface** 


<!-- tabs:start -->

#### ** English **

The `ResourceLoaderAware` interface is a special callback interface which identifies components that expect to be provided with a `ResourceLoader` reference. The following listing shows the definition of the `ResourceLoaderAware` interface:
#### ** Chinese **

`ResourceLoaderAware`接口是一个特殊的回调接口，它标识了期望被提供`ResourceLoader`引用的组件。下面的列表显示了`ResourceLoaderAware`接口的定义。
<!-- tabs:end -->


```java
public interface ResourceLoaderAware {

    void setResourceLoader(ResourceLoader resourceLoader);
}
```

<!-- tabs:start -->

#### ** English **

When a class implements `ResourceLoaderAware` and is deployed into an application context (as a Spring-managed bean), it is recognized as `ResourceLoaderAware` by the application context. The application context then invokes `setResourceLoader(ResourceLoader)`, supplying itself as the argument (remember, all application contexts in Spring implement the `ResourceLoader` interface).
#### ** Chinese **

当一个类实现了`ResourceLoaderAware`并部署到应用上下文中（作为Spring管理的Bean）时，它被应用上下文识别为`ResourceLoaderAware`。然后，应用程序上下文会调用 `setResourceLoader(ResourceLoader)`，并提供自己作为参数（记住，Spring中的所有应用程序上下文都实现了`ResourceLoader`接口）。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Since an `ApplicationContext` is a `ResourceLoader`, the bean could also implement the `ApplicationContextAware` interface and use the supplied application context directly to load resources. However, in general, it is better to use the specialized `ResourceLoader` interface if that is all you need. The code would be coupled only to the resource loading interface (which can be considered a utility interface) and not to the whole Spring `ApplicationContext` interface.
#### ** Chinese **

由于`ApplicationContext`是一个`ResourceLoader`，所以Bean也可以实现`ApplicationContextAware`接口，并直接使用所提供的应用上下文加载资源。不过，一般来说，如果你需要的只是这个，最好使用专门的`ResourceLoader`接口。该代码将只耦合到资源加载接口（它可以被认为是一个实用程序接口），而不是整个Spring `ApplicationContext`接口。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

In application components, you may also rely upon autowiring of the `ResourceLoader` as an alternative to implementing the `ResourceLoaderAware` interface. The “traditional” `constructor` and `byType` autowiring modes (as described in [Autowiring Collaborators](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-autowire)) are capable of providing a `ResourceLoader` for either a constructor argument or a setter method parameter, respectively. For more flexibility (including the ability to autowire fields and multiple parameter methods), consider using the annotation-based autowiring features. In that case, the `ResourceLoader` is autowired into a field, constructor argument, or method parameter that expects the `ResourceLoader` type as long as the field, constructor, or method in question carries the `@Autowired` annotation. For more information, see [Using ](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-autowired-annotation)[`@Autowired`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-autowired-annotation).
#### ** Chinese **

在应用程序组件中，你也可以依赖`ResourceLoader`的自动布线，作为实现`ResourceLoaderAware`接口的替代方案。传统的" `constructor`和`byType`自动布线模式（如[Autowiring Collaborators](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-autowire)中描述的那样）能够分别为构造函数参数或设置器方法参数提供一个`ResourceLoader`。如果想获得更多的灵活性（包括自动触发字段和多个参数方法的能力），可以考虑使用基于注解的自动触发功能。在这种情况下，`ResourceLoader`会被自动连接到一个字段、构造函数参数或方法参数中，只要该字段、构造函数或方法携带了`@Autowired`注解，就会被自动连接到期望有`ResourceLoader`类型的字段、构造函数或方法参数中。有关更多信息，请参阅[使用](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-autowired-annotation)[`@Autowired`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-autowired-annotation)。
<!-- tabs:end -->


### **2.6. Resources as Dependencies** 

<!-- tabs:start -->

#### ** English **

If the bean itself is going to determine and supply the resource path through some sort of dynamic process, it probably makes sense for the bean to use the `ResourceLoader` interface to load resources. For example, consider the loading of a template of some sort, where the specific resource that is needed depends on the role of the user. If the resources are static, it makes sense to eliminate the use of the `ResourceLoader` interface completely, have the bean expose the `Resource` properties it needs, and expect them to be injected into it.
#### ** Chinese **

如果Bean本身要通过某种动态过程来决定和提供资源路径，那么Bean使用`ResourceLoader`接口来加载资源可能是有意义的。例如，考虑加载某种类型的模板，其中所需要的具体资源取决于用户的角色。如果资源是静态的，那么完全不使用`ResourceLoader`接口，让Bean暴露出它所需要的`Resource`属性，并期望将它们注入到它的属性中是有意义的。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

What makes it trivial to then inject these properties is that all application contexts register and use a special JavaBeans `PropertyEditor`, which can convert `String` paths to `Resource` objects. So, if `myBean` has a template property of type `Resource`, it can be configured with a simple string for that resource, as the following example shows:
#### ** Chinese **

然后注入这些属性是一件很简单的事情，因为所有的应用程序上下文都会注册并使用一个特殊的JavaBeans `PropertyEditor`，它可以将`String`路径转换为`Resource`对象。因此，如果`myBean`有一个类型为`Resource`的模板属性，就可以为该资源配置一个简单的字符串，如下例所示。
<!-- tabs:end -->


```xml
<bean id="myBean" class="...">
    <property name="template" value="some/resource/path/myTemplate.txt"/>
</bean>
```

<!-- tabs:start -->

#### ** English **

Note that the resource path has no prefix. Consequently, because the application context itself is going to be used as the `ResourceLoader`, the resource itself is loaded through a `ClassPathResource`, a `FileSystemResource`, or a `ServletContextResource`, depending on the exact type of the context.
#### ** Chinese **

注意，资源路径没有前缀。因此，由于应用程序上下文本身将被用作 `ResourceLoader`，所以资源本身是通过 `ClassPathResource`、`FileSystemResource`或`ServletContextResource`来加载的，这取决于上下文的确切类型。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

If you need to force a specific `Resource` type to be used, you can use a prefix. The following two examples show how to force a `ClassPathResource` and a `UrlResource` (the latter being used to access a filesystem file):
#### ** Chinese **

如果需要强制使用特定的`Resource`类型，可以使用前缀。下面两个例子显示了如何强制使用`ClassPathResource`和`UrlResource`（后者用于访问文件系统文件）。
<!-- tabs:end -->


```xml
<property name="template" value="classpath:some/resource/path/myTemplate.txt">
```

```xml
<property name="template" value="file:///some/resource/path/myTemplate.txt"/>
```

### **2.7. Application Contexts and Resource Paths** 

<!-- tabs:start -->

#### ** English **

This section covers how to create application contexts with resources, including shortcuts that work with XML, how to use wildcards, and other details.
#### ** Chinese **

本节涵盖了如何使用资源创建应用程序上下文，包括使用XML的快捷方式、如何使用通配符等细节。
<!-- tabs:end -->


### **2.7.1. Constructing Application Contexts** 

<!-- tabs:start -->

#### ** English **

An application context constructor (for a specific application context type) generally takes a string or array of strings as the location paths of the resources, such as XML files that make up the definition of the context.
#### ** Chinese **

一个应用上下文构造器（针对特定的应用上下文类型）一般取一个字符串或字符串数组作为资源的位置路径，例如构成上下文定义的XML文件。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

When such a location path does not have a prefix, the specific `Resource` type built from that path and used to load the bean definitions depends on and is appropriate to the specific application context. For example, consider the following example, which creates a `ClassPathXmlApplicationContext`:
#### ** Chinese **

当这样的位置路径没有前缀时，由该路径建立并用于加载Bean定义的特定`Resource`类型取决于并适合于特定的应用上下文。例如，考虑下面的例子，它创建了一个`ClassPathXmlApplicationContext`。
<!-- tabs:end -->


```java
ApplicationContext ctx = new ClassPathXmlApplicationContext("conf/appContext.xml");
```

<!-- tabs:start -->

#### ** English **

The bean definitions are loaded from the classpath, because a `ClassPathResource` is used. However, consider the following example, which creates a `FileSystemXmlApplicationContext`:
#### ** Chinese **

因为使用了`ClassPathResource`，所以Bean定义是从classpath中加载的。然而，考虑下面的例子，它创建了一个`FileSystemXmlApplicationContext`。
<!-- tabs:end -->


```java
ApplicationContext ctx =
    new FileSystemXmlApplicationContext("conf/appContext.xml");
```

<!-- tabs:start -->

#### ** English **

Now the bean definition is loaded from a filesystem location (in this case, relative to the current working directory).
#### ** Chinese **

现在，Bean定义从文件系统位置（在本例中，相对于当前工作目录）加载。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Note that the use of the special classpath prefix or a standard URL prefix on the location path overrides the default type of `Resource` created to load the definition. Consider the following example:
#### ** Chinese **

请注意，在位置路径上使用特殊的classpath前缀或标准的URL前缀会覆盖为加载定义而创建的`Resource`的默认类型。请考虑下面的例子。
<!-- tabs:end -->


```java
ApplicationContext ctx =
    new FileSystemXmlApplicationContext("classpath:conf/appContext.xml");
```

<!-- tabs:start -->

#### ** English **

Using `FileSystemXmlApplicationContext` loads the bean definitions from the classpath. However, it is still a `FileSystemXmlApplicationContext`. If it is subsequently used as a `ResourceLoader`, any unprefixed paths are still treated as filesystem paths.
#### ** Chinese **

使用`FileSystemXmlApplicationContext`从classpath中加载Bean定义。但是，它仍然是一个`FileSystemXmlApplicationContext`。如果它随后被用作 `ResourceLoader`，那么任何未加注解的路径仍被视为文件系统路径。
<!-- tabs:end -->


### **Constructing** **`ClassPathXmlApplicationContext`** ** Instances — Shortcuts** 

<!-- tabs:start -->

#### ** English **

The `ClassPathXmlApplicationContext` exposes a number of constructors to enable convenient instantiation. The basic idea is that you can supply merely a string array that contains only the filenames of the XML files themselves (without the leading path information) and also supplies a `Class`. The `ClassPathXmlApplicationContext` then derives the path information from the supplied class.
#### ** Chinese **

`ClassPathXmlApplicationContext`提供了许多构造函数，以方便实例化。其基本思想是，你可以只提供一个字符串数组，该数组只包含XML文件本身的文件名（没有前导路径信息），同时还提供一个`Class`。`ClassPathXmlApplicationContext`然后从提供的类中派生出路径信息。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Consider the following directory layout:
#### ** Chinese **

考虑一下下面的目录布局。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

com/ foo/ services.xml daos.xml MessengerService.class
#### ** Chinese **

com/ foo/ services.xml daos.xml MessengerService.class
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following example shows how a `ClassPathXmlApplicationContext` instance composed of the beans defined in files named `services.xml` and `daos.xml` (which are on the classpath) can be instantiated:
#### ** Chinese **

下面的示例显示了如何实例化一个`ClassPathXmlApplicationContext`实例，该实例由在名为`services.xml`和`daos.xml`（在classpath上）的文件中定义的bean组成。
<!-- tabs:end -->


```java
ApplicationContext ctx = new ClassPathXmlApplicationContext(
    new String[] {"services.xml", "daos.xml"}, MessengerService.class);
```

<!-- tabs:start -->

#### ** English **

See the [`ClassPathXmlApplicationContext`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/jca/context/SpringContextResourceAdapter.html) javadoc for details on the various constructors.
#### ** Chinese **

有关各种构造函数的详细信息，请参阅[`ClassPathXmlApplicationContext`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/jca/context/SpringContextResourceAdapter.html)javadoc。
<!-- tabs:end -->


### **2.7.2. Wildcards in Application Context Constructor Resource Paths** 

<!-- tabs:start -->

#### ** English **

The resource paths in application context constructor values may be simple paths (as shown earlier), each of which has a one-to-one mapping to a target `Resource` or, alternately, may contain the special "classpath*:" prefix or internal Ant-style regular expressions (matched by using Spring’s `PathMatcher` utility). Both of the latter are effectively wildcards.
#### ** Chinese **

应用程序上下文构造函数值中的资源路径可以是简单的路径（如前文所示），每个路径都有一个与目标`Resource`的一对一映射，或者，也可以包含特殊的 "classpath*: "前缀或内部Ant样式的正则表达式（通过使用Spring的`PathMatcher`工具进行匹配）。后者都是有效的通配符。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

One use for this mechanism is when you need to do component-style application assembly. All components can 'publish' context definition fragments to a well-known location path, and, when the final application context is created using the same path prefixed with `classpath*:`, all component fragments are automatically picked up.
#### ** Chinese **

这种机制的一个用途是当你需要进行组件式的应用程序组装时。所有组件都可以将上下文定义片段 "发布 "到一个已知的位置路径上，当最终的应用上下文使用前缀为`classpath*:`的相同路径创建时，所有的组件片段都会被自动拾取。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Note that this wildcarding is specific to the use of resource paths in application context constructors (or when you use the `PathMatcher` utility class hierarchy directly) and is resolved at construction time. It has nothing to do with the `Resource` type itself. You cannot use the `classpath*:` prefix to construct an actual `Resource`, as a resource points to just one resource at a time.
#### ** Chinese **

请注意，这个通配符是在应用程序上下文构造器中使用资源路径（或者直接使用`PathMatcher`实用程序类层次结构时）特有的，并在构造时解决。它与`Resource`类型本身没有任何关系。您不能使用`classpath*:`前缀来构造一个实际的`Resource`，因为一个资源每次只指向一个资源。
<!-- tabs:end -->


### **Ant-style Patterns** 

<!-- tabs:start -->

#### ** English **

Path locations can contain Ant-style patterns, as the following example shows:
#### ** Chinese **

路径位置可以包含Ant风格的模式，如下例所示。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

/WEB-INF/*-context.xml
#### ** Chinese **

/WEB-INF/*-context.xml
<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

com/mycompany/**/applicationContext.xml
#### ** Chinese **

com/mycompany/**/applicationContext.xml
<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

file:C:/some/path/*-context.xml
#### ** Chinese **

file:C:/some/path/*-context.xml
<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

classpath:com/mycompany/**/applicationContext.xml
#### ** Chinese **

classpath:com/mycompany/**/applicationContext.xml
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

When the path location contains an Ant-style pattern, the resolver follows a more complex procedure to try to resolve the wildcard. It produces a `Resource` for the path up to the last non-wildcard segment and obtains a URL from it. If this URL is not a `jar:` URL or container-specific variant (such as `zip:` in WebLogic, `wsjar` in WebSphere, and so on), a `java.io.File` is obtained from it and used to resolve the wildcard by traversing the filesystem. In the case of a jar URL, the resolver either gets a `java.net.JarURLConnection` from it or manually parses the jar URL and then traverses the contents of the jar file to resolve the wildcards.
#### ** Chinese **

当路径位置包含 Ant 风格的模式时，解析器会遵循一个更复杂的过程来尝试解析通配符。它为路径生成一个 `Resource`，直到最后一个非通配符段，并从中获取一个 URL。如果该 URL 不是 `jar:` URL 或特定于容器的变体（如 WebLogic 中的 `zip:`、WebSphere 中的 `wsjar` 等），则会从它那里获得一个 `java.io.File`，并通过遍历文件系统来解析通配符。如果是 jar URL，解析器要么从它那里获得一个 `java.net.JarURLConnection`，要么手动解析 jar URL，然后遍历 jar 文件的内容来解析通配符。
<!-- tabs:end -->


### **Implications on Portability** 

<!-- tabs:start -->

#### ** English **

If the specified path is already a file URL (either implicitly because the base `ResourceLoader` is a filesystem one or explicitly), wildcarding is guaranteed to work in a completely portable fashion.
#### ** Chinese **

如果指定的路径已经是一个文件 URL（或者因为基础 `ResourceLoader`是一个文件系统的隐式路径，或者是显式路径），那么通配符可以保证以完全可移植的方式工作。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

If the specified path is a classpath location, the resolver must obtain the last non-wildcard path segment URL by making a `Classloader.getResource()` call. Since this is just a node of the path (not the file at the end), it is actually undefined (in the `ClassLoader` javadoc) exactly what sort of a URL is returned in this case. In practice, it is always a `java.io.File` representing the directory (where the classpath resource resolves to a filesystem location) or a jar URL of some sort (where the classpath resource resolves to a jar location). Still, there is a portability concern on this operation.
#### ** Chinese **

如果指定的路径是 classpath 位置，解析器必须通过调用 `Classloader.getResource()` 来获取最后一个非野生符的路径段 URL。由于这只是路径中的一个节点（而不是最后的文件），所以实际上，在 `ClassLoader` javadoc 中并没有定义在这种情况下返回什么样的 URL。在实践中，它总是一个`java.io.File`，代表目录（classpath资源解析到文件系统位置）或jar URL（classpath资源解析到jar位置）。但是，这个操作有一个可移植性的问题。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

If a jar URL is obtained for the last non-wildcard segment, the resolver must be able to get a `java.net.JarURLConnection` from it or manually parse the jar URL, to be able to walk the contents of the jar and resolve the wildcard. This does work in most environments but fails in others, and we strongly recommend that the wildcard resolution of resources coming from jars be thoroughly tested in your specific environment before you rely on it.
#### ** Chinese **

如果获得了最后一个非通配符段的jar URL，解析器必须能够从中获得一个`java.net.JarURLConnection`，或者手动解析jar URL，才能够走jar的内容并解析通配符。这在大多数环境中确实有效，但在其他环境中却失败了，我们强烈建议在依赖它之前，在你的特定环境中对来自jar的资源的通配符解析进行彻底的测试。
<!-- tabs:end -->


### **The** **`classpath*:`** ** Prefix** 

<!-- tabs:start -->

#### ** English **

When constructing an XML-based application context, a location string may use the special `classpath*:` prefix, as the following example shows:
#### ** Chinese **

在构建基于 XML 的应用程序上下文时，位置字符串可以使用特殊的 `classpath*:` 前缀，如下例所示。
<!-- tabs:end -->


```java
ApplicationContext ctx =
    new ClassPathXmlApplicationContext("classpath*:conf/appContext.xml");
```

<!-- tabs:start -->

#### ** English **

This special prefix specifies that all classpath resources that match the given name must be obtained (internally, this essentially happens through a call to `ClassLoader.getResources(…​)`) and then merged to form the final application context definition.
#### ** Chinese **

这个特殊的前缀规定，必须获得所有与给定名称相匹配的classpath资源（在内部，这基本上是通过调用`ClassLoader.getResources(…​)`来实现的），然后合并形成最终的应用上下文定义。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The wildcard classpath relies on the `getResources()` method of the underlying classloader. As most application servers nowadays supply their own classloader implementation, the behavior might differ, especially when dealing with jar files. A simple test to check if `classpath*` works is to use the classloader to load a file from within a jar on the classpath: `getClass().getClassLoader().getResources("<someFileInsideTheJar>")`. Try this test with files that have the same name but are placed inside two different locations. In case an inappropriate result is returned, check the application server documentation for settings that might affect the classloader behavior.
#### ** Chinese **

通配符classpath依赖于底层classloader的`getResources()`方法。由于现在大多数的应用程序服务器都提供了自己的classloader实现，所以行为可能会有所不同，特别是在处理jar文件时。检查`classpath*`是否工作的一个简单测试是使用classloader从classpath上的jar中加载一个文件。 `getClass().getClassLoader().getResources("<someFileInsideTheJar>")`。试试这个测试，如果文件的名称相同，但放在两个不同的位置，那么就可以试试这个测试。如果返回的结果不合适，请检查应用程序服务器文档中可能会影响类加载器行为的设置。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can also combine the `classpath*:` prefix with a `PathMatcher` pattern in the rest of the location path (for example, `classpath*:META-INF/*-beans.xml`). In this case, the resolution strategy is fairly simple: A `ClassLoader.getResources()` call is used on the last non-wildcard path segment to get all the matching resources in the class loader hierarchy and then, off each resource, the same `PathMatcher` resolution strategy described earlier is used for the wildcard subpath.
#### ** Chinese **

你也可以将`classpath*:`前缀与位置路径的其余部分（例如，`classpath*:META-INF/*-beans.xml`）中的`classpath*:`前缀与`PathMatcher`模式结合起来。在这种情况下，解析策略相当简单。`ClassLoader.getResources()`在最后一个非通配符路径段上使用一个`ClassLoader.getResources()`调用，以获取类加载器层次结构中的所有匹配资源，然后，在每个资源之外，对通配符子路径使用与前面描述的相同的`PathMatcher`解析策略。
<!-- tabs:end -->


### **Other Notes Relating to Wildcards** 

<!-- tabs:start -->

#### ** English **

Note that `classpath*:`, when combined with Ant-style patterns, only works reliably with at least one root directory before the pattern starts, unless the actual target files reside in the file system. This means that a pattern such as `classpath*:*.xml` might not retrieve files from the root of jar files but rather only from the root of expanded directories.
#### ** Chinese **

请注意，当`classpath*:`与Ant风格的模式结合起来时，除非实际目标文件位于文件系统中，否则在模式启动之前，只有在至少一个根目录下才能可靠地工作。这意味着像`classpath*:*.xml`这样的模式可能不会从jar文件的根目录中检索文件，而只能从扩展目录的根目录中检索文件。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Spring’s ability to retrieve classpath entries originates from the JDK’s `ClassLoader.getResources()` method, which only returns file system locations for an empty string (indicating potential roots to search). Spring evaluates `URLClassLoader` runtime configuration and the `java.class.path` manifest in jar files as well, but this is not guaranteed to lead to portable behavior.
#### ** Chinese **

Spring 检索classpath条目的能力源于JDK的`ClassLoader.getResources()`方法，该方法只返回空字符串的文件系统位置（表示要搜索的潜在根）。Spring 也会评估 `URLClassLoader` 运行时配置和 jar 文件中的 `java.class.path` manifest，但这并不保证会导致可移植行为。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The scanning of classpath packages requires the presence of corresponding directory entries in the classpath. When you build JARs with Ant, do not activate the files-only switch of the JAR task. Also, classpath directories may not get exposed based on security policies in some environments — for example, stand-alone applications on JDK 1.7.0_45 and higher (which requires 'Trusted-Library' to be set up in your manifests. See [https://stackoverflow.com/questions/19394570/java-jre-7u45-breaks-classloader-getresources](https://stackoverflow.com/questions/19394570/java-jre-7u45-breaks-classloader-getresources)).
#### ** Chinese **

扫描classpath包需要在classpath中存在相应的目录项。当你用Ant构建JAR时，不要激活JAR任务中的仅有文件开关。另外，在某些环境中，classpath目录可能不会因为安全策略而暴露--例如，在JDK 1.7.0_45及更高版本的独立应用程序（这需要在你的清单中设置 "Trusted-Library"。参见[https://stackoverflow.com/questions/19394570/java-jre-7u45-breaks-classloader-getresources](https://stackoverflow.com/questions/19394570/java-jre-7u45-breaks-classloader-getresources)）。)
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

On JDK 9’s module path (Jigsaw), Spring’s classpath scanning generally works as expected. Putting resources into a dedicated directory is highly recommendable here as well, avoiding the aforementioned portability problems with searching the jar file root level.
#### ** Chinese **

在JDK 9的模块路径（Jigsaw）上，Spring的classpath扫描一般都能正常工作。这里也强烈推荐把资源放到一个专用目录中，这样可以避免前面提到的搜索jar文件根级的可移植性问题。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Ant-style patterns with `classpath:` resources are not guaranteed to find matching resources if the root package to search is available in multiple class path locations. Consider the following example of a resource location:
#### ** Chinese **

如果要搜索的根包在多个类的路径位置都有，则无法保证找到匹配的资源，而蚂蚁式的模式有`classpath:`资源，则无法保证找到匹配的资源。考虑一下下面这个资源位置的例子。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

com/mycompany/package1/service-context.xml
#### ** Chinese **

com/mycompany/package1/service-context.xml
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Now consider an Ant-style path that someone might use to try to find that file:
#### ** Chinese **

现在考虑一个蚂蚁式的路径，有人可能会用它来找这个文件。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

classpath:com/mycompany/**/service-context.xml
#### ** Chinese **

classpath:com/mycompany/**/service-context.xml
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Such a resource may be in only one location, but when a path such as the preceding example is used to try to resolve it, the resolver works off the (first) URL returned by `getResource("com/mycompany");`. If this base package node exists in multiple classloader locations, the actual end resource may not be there. Therefore, in such a case you should prefer using `classpath*:` with the same Ant-style pattern, which searches all class path locations that contain the root package.
#### ** Chinese **

这样的资源可能只存在于一个位置，但当使用像前面的例子这样的路径来尝试解析它时，解析器会根据 `getResource("com/mycompany");`返回的(第一个)URL来工作。如果这个基本包节点存在于多个classloader位置，实际的终端资源可能不在那里。因此，在这种情况下，你最好使用`classpath*:`，它可以搜索所有包含根包的类路径位置。
<!-- tabs:end -->


### **2.7.3.** **`FileSystemResource`** ** Caveats** 

<!-- tabs:start -->

#### ** English **

A `FileSystemResource` that is not attached to a `FileSystemApplicationContext` (that is, when a `FileSystemApplicationContext` is not the actual `ResourceLoader`) treats absolute and relative paths as you would expect. Relative paths are relative to the current working directory, while absolute paths are relative to the root of the filesystem.
#### ** Chinese **

没有附加到`FileSystemResource`的`FileSystemResource`（也就是说，当`FileSystemApplicationContext`不是实际的`ResourceLoader`时），会按照您所期望的那样处理绝对路径和相对路径。相对路径是相对于当前工作目录，而绝对路径是相对于文件系统的根目录。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

For backwards compatibility (historical) reasons however, this changes when the `FileSystemApplicationContext` is the `ResourceLoader`. The `FileSystemApplicationContext` forces all attached `FileSystemResource` instances to treat all location paths as relative, whether they start with a leading slash or not. In practice, this means the following examples are equivalent:
#### ** Chinese **

但是，由于向后兼容性（历史原因），当 `FileSystemApplicationContext`是 `ResourceLoader`时，这种情况会发生变化。`FileSystemApplicationContext`强制所有附加的`FileSystemResource`实例将所有位置路径视为相对路径，无论它们是否以前导斜线开头。在实践中，这意味着下面的例子是等价的。
<!-- tabs:end -->


```java
ApplicationContext ctx =
    new FileSystemXmlApplicationContext("conf/context.xml");
```

```java
ApplicationContext ctx =
    new FileSystemXmlApplicationContext("/conf/context.xml");
```

<!-- tabs:start -->

#### ** English **

The following examples are also equivalent (even though it would make sense for them to be different, as one case is relative and the other absolute):
#### ** Chinese **

下面的例子也是等价的（尽管它们的意义是不同的，因为一个是相对的，另一个是绝对的）。
<!-- tabs:end -->


```java
FileSystemXmlApplicationContext ctx = ...;
ctx.getResource("some/resource/path/myTemplate.txt");
```

```java
FileSystemXmlApplicationContext ctx = ...;
ctx.getResource("/some/resource/path/myTemplate.txt");
```

<!-- tabs:start -->

#### ** English **

In practice, if you need true absolute filesystem paths, you should avoid using absolute paths with `FileSystemResource` or `FileSystemXmlApplicationContext` and force the use of a `UrlResource` by using the `file:` URL prefix. The following examples show how to do so:
#### ** Chinese **

在实践中，如果您需要真正的绝对文件系统路径，应该避免使用带有`FileSystemResource`或`FileSystemXmlApplicationContext`的绝对路径，并通过使用`file:`URL前缀强制使用`UrlResource`。下面的例子显示了如何做到这一点。
<!-- tabs:end -->


```java
// actual context type doesn't matter, the Resource will always be UrlResource
ctx.getResource("file:///some/resource/path/myTemplate.txt");
```

```java
// force this FileSystemXmlApplicationContext to load its definition via a UrlResource
ApplicationContext ctx =
    new FileSystemXmlApplicationContext("file:///conf/context.xml");
```


[下一章](Spring-Framework-5.2.6.RELEASE/Core%20Technologies/3.%20Validation,%20Data%20Binding,%20and%20Type%20Conversion.md)


[回目录](Spring-Framework-5.2.6.RELEASE/summary.md)

[回首页](/README)
