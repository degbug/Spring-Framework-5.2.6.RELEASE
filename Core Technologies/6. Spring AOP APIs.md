# 6. Spring AOP APIs

<!-- tabs:start -->

#### ** English **

The previous chapter described the Spring’s support for AOP with @AspectJ and schema-based aspect definitions. In this chapter, we discuss the lower-level Spring AOP APIs. For common applications, we recommend the use of Spring AOP with AspectJ pointcuts as described in the previous chapter.
#### ** Chinese **

上一章介绍了Spring通过@AspectJ和基于模式的方面定义对AOP的支持。在这一章中，我们将讨论Spring的底层AOP API。对于常见的应用，我们推荐使用Spring AOP与AspectJ点捷方式，如上一章所述。
<!-- tabs:end -->


### **6.1. Pointcut API in Spring** 

<!-- tabs:start -->

#### ** English **

This section describes how Spring handles the crucial pointcut concept.
#### ** Chinese **

本节将介绍Spring如何处理关键的点切概念。
<!-- tabs:end -->


### **6.1.1. Concepts** 

<!-- tabs:start -->

#### ** English **

Spring’s pointcut model enables pointcut reuse independent of advice types. You can target different advice with the same pointcut.
#### ** Chinese **

Spring的点切口模型使点切口的重用与建议类型无关。您可以用相同的点切口针对不同的建议。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The `org.springframework.aop.Pointcut` interface is the central interface, used to target advices to particular classes and methods. The complete interface follows:
#### ** Chinese **

`org.springframework.aop.Pointcut`接口是中心接口，用于向特定的类和方法发出建议。下面是完整的接口。
<!-- tabs:end -->


```java
public interface Pointcut {

    ClassFilter getClassFilter();

    MethodMatcher getMethodMatcher();

}
```

<!-- tabs:start -->

#### ** English **

Splitting the `Pointcut` interface into two parts allows reuse of class and method matching parts and fine-grained composition operations (such as performing a “union” with another method matcher).
#### ** Chinese **

将`Pointcut`接口拆分成两部分，可以重复使用类和方法匹配部分以及细粒度的组合操作（如与另一个方法匹配器执行 "联合"）。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The `ClassFilter` interface is used to restrict the pointcut to a given set of target classes. If the `matches()` method always returns true, all target classes are matched. The following listing shows the `ClassFilter` interface definition:
#### ** Chinese **

`ClassFilter`接口用于将点捷径限制在给定的目标类集合中。如果`matches()`方法总是返回true，则所有目标类都被匹配。下面的列表显示了`ClassFilter`接口的定义。
<!-- tabs:end -->


```java
public interface ClassFilter {

    boolean matches(Class clazz);
}
```

<!-- tabs:start -->

#### ** English **

The `MethodMatcher` interface is normally more important. The complete interface follows:
#### ** Chinese **

`MethodMatcher`接口通常比较重要。下面是完整的接口。
<!-- tabs:end -->


```java
public interface MethodMatcher {

    boolean matches(Method m, Class targetClass);

    boolean isRuntime();

    boolean matches(Method m, Class targetClass, Object[] args);
}
```

<!-- tabs:start -->

#### ** English **

The `matches(Method, Class)` method is used to test whether this pointcut ever matches a given method on a target class. This evaluation can be performed when an AOP proxy is created to avoid the need for a test on every method invocation. If the two-argument `matches` method returns `true` for a given method, and the `isRuntime()` method for the MethodMatcher returns `true`, the three-argument matches method is invoked on every method invocation. This lets a pointcut look at the arguments passed to the method invocation immediately before the target advice is to execute.
#### ** Chinese **

`matches(Method, Class)`方法用于测试这个点切口是否曾经匹配过目标类上的给定方法。这个评估可以在创建 AOP 代理时执行，以避免在每次调用方法时都需要进行测试。如果双参数 `matches`方法返回`true`，而MethodMatcher的`isRuntime()`方法返回`true`，那么在每次调用方法时都会调用三参数匹配方法。这让点切方法可以在目标建议执行前立即查看传递给方法调用的参数。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Most `MethodMatcher` implementations are static, meaning that their `isRuntime()` method returns `false`. In this case, the three-argument `matches` method is never invoked.
#### ** Chinese **

大多数`MethodMatcher`实现都是静态的，这意味着它们的`isRuntime()`方法返回`false`。在这种情况下，三个参数的`matches`方法永远不会被调用。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

If possible, try to make pointcuts static, allowing the AOP framework to cache the results of pointcut evaluation when an AOP proxy is created.
#### ** Chinese **

如果可能的话，尽量让点切方式成为静态的，这样可以让AOP框架在创建AOP代理时缓存点切方式的评估结果。
<!-- tabs:end -->


### **6.1.2. Operations on Pointcuts** 

<!-- tabs:start -->

#### ** English **

Spring supports operations (notably, union and intersection) on pointcuts.
#### ** Chinese **

Spring支持点切线上的操作（主要是联合和交集）。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Union means the methods that either pointcut matches. Intersection means the methods that both pointcuts match. Union is usually more useful. You can compose pointcuts by using the static methods in the `org.springframework.aop.support.Pointcuts` class or by using the `ComposablePointcut` class in the same package. However, using AspectJ pointcut expressions is usually a simpler approach.
#### ** Chinese **

联合是指两个点切口中的任何一个点切口匹配的方法。交集是指两个点切线都匹配的方法。联合通常更有用。你可以通过使用`org.springframework.aop.support.Pointcuts`类中的静态方法，或者使用同一包中的`ComposablePointcut`类来组成点切方式。不过，使用AspectJ的点切方式表达式通常是一个比较简单的方法。
<!-- tabs:end -->


### **6.1.3. AspectJ Expression Pointcuts** 

<!-- tabs:start -->

#### ** English **

Since 2.0, the most important type of pointcut used by Spring is `org.springframework.aop.aspectj.AspectJExpressionPointcut`. This is a pointcut that uses an AspectJ-supplied library to parse an AspectJ pointcut expression string.
#### ** Chinese **

自2.0以来，Spring使用的最重要的点切方式类型是`org.springframework.aop.aspectj.AspectJExpressionPointcut`。这是一种点切方式，它使用AspectJ提供的库来解析AspectJ点切表达式字符串。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

See the [previous chapter](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#aop) for a discussion of supported AspectJ pointcut primitives.
#### ** Chinese **

有关支持的AspectJ点切基元的讨论，请参阅[上一章](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#aop)。
<!-- tabs:end -->


### **6.1.4. Convenience Pointcut Implementations** 

<!-- tabs:start -->

#### ** English **

Spring provides several convenient pointcut implementations. You can use some of them directly. Others are intended to be subclassed in application-specific pointcuts.
#### ** Chinese **

Spring提供了几个方便的点捷径实现。你可以直接使用其中的一些。其他的则是为了在特定于应用程序的点捷径中被子类化。
<!-- tabs:end -->


### **Static Pointcuts** 

<!-- tabs:start -->

#### ** English **

Static pointcuts are based on the method and the target class and cannot take into account the method’s arguments. Static pointcuts suffice — and are best — for most usages. Spring can evaluate a static pointcut only once, when a method is first invoked. After that, there is no need to evaluate the pointcut again with each method invocation.
#### ** Chinese **

静态点捷径是基于方法和目标类，不能考虑到方法的参数。静态点捷径对于大多数的使用来说，静态点捷径已经足够了，而且是最好的。Spring只能在第一次调用方法时对静态点切方式进行一次评估。在这之后，每次调用方法时都不需要再对点cut进行评估。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The rest of this section describes some of the static pointcut implementations that are included with Spring.
#### ** Chinese **

本节的其余部分介绍了Spring中包含的一些静态点切口实现。
<!-- tabs:end -->


### **Regular Expression Pointcuts** 

<!-- tabs:start -->

#### ** English **

One obvious way to specify static pointcuts is regular expressions. Several AOP frameworks besides Spring make this possible. `org.springframework.aop.support.JdkRegexpMethodPointcut` is a generic regular expression pointcut that uses the regular expression support in the JDK.
#### ** Chinese **

指定静态点捷径的一个明显的方法是正则表达式。除了Spring之外，有几个AOP框架都能做到这一点。 `org.springframework.aop.support.JdkRegexpMethodPointcut`是一个通用的正则表达式点切方式，它使用JDK中的正则表达式支持。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

With the `JdkRegexpMethodPointcut` class, you can provide a list of pattern strings. If any of these is a match, the pointcut evaluates to `true`. (So, the result is effectively the union of these pointcuts.)
#### ** Chinese **

使用`JdkRegexpMethodPointcut`类，你可以提供一个模式字符串列表。如果其中任何一个是匹配的，那么这个点切方式就会值为`true`。(所以，结果实际上就是这些点切方法的联合。)
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following example shows how to use `JdkRegexpMethodPointcut`:
#### ** Chinese **

下面的例子显示了如何使用`JdkRegexpMethodPointcut`。
<!-- tabs:end -->


```xml
<bean id="settersAndAbsquatulatePointcut"
        class="org.springframework.aop.support.JdkRegexpMethodPointcut">
    <property name="patterns">
        <list>
            <value>.*set.*</value>
            <value>.*absquatulate</value>
        </list>
    </property>
</bean>
```

<!-- tabs:start -->

#### ** English **

Spring provides a convenience class named `RegexpMethodPointcutAdvisor`, which lets us also reference an `Advice` (remember that an `Advice` can be an interceptor, before advice, throws advice, and others). Behind the scenes, Spring uses a `JdkRegexpMethodPointcut`. Using `RegexpMethodPointcutAdvisor` simplifies wiring, as the one bean encapsulates both pointcut and advice, as the following example shows:
#### ** Chinese **

Spring提供了一个名为`RegexpMethodPointcutAdvisor的方便类`，它让我们也可以引用一个`Advice`（记住，`Advice`可以是拦截器、建议前、抛出建议等）。在幕后，Spring使用一个`JdkRegexpMethodPointcut`。使用`RegexpMethodPointcutAdvisor`简化了布线，因为一个bean同时封装了pointcut和advice，如下例所示。
<!-- tabs:end -->


```xml
<bean id="settersAndAbsquatulateAdvisor"
        class="org.springframework.aop.support.RegexpMethodPointcutAdvisor">
    <property name="advice">
        <ref bean="beanNameOfAopAllianceInterceptor"/>
    </property>
    <property name="patterns">
        <list>
            <value>.*set.*</value>
            <value>.*absquatulate</value>
        </list>
    </property>
</bean>
```

<!-- tabs:start -->

#### ** English **

You can use `RegexpMethodPointcutAdvisor` with any `Advice` type.
#### ** Chinese **

您可以将`RegexpMethodPointcutAdvisor`与任何`Advice`类型一起使用。
<!-- tabs:end -->


### **Attribute-driven Pointcuts** 

<!-- tabs:start -->

#### ** English **

An important type of static pointcut is a metadata-driven pointcut. This uses the values of metadata attributes (typically, source-level metadata).
#### ** Chinese **

静态点切方式的一个重要类型是元数据驱动的点切方式。它使用元数据属性的值（通常是源级元数据）。
<!-- tabs:end -->


### **Dynamic pointcuts** 

<!-- tabs:start -->

#### ** English **

Dynamic pointcuts are costlier to evaluate than static pointcuts. They take into account method arguments as well as static information. This means that they must be evaluated with every method invocation and that the result cannot be cached, as arguments will vary.
#### ** Chinese **

动态点捷径的评估成本比静态点捷径高。它们既考虑到了方法参数，也考虑到了静态信息。这意味着它们必须在每次调用方法时都要进行评估，而且由于参数会有所不同，所以不能缓存结果。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The main example is the `control flow` pointcut.
#### ** Chinese **

主要的例子是`control flow`点切法。
<!-- tabs:end -->


### **Control Flow Pointcuts** 

<!-- tabs:start -->

#### ** English **

Spring control flow pointcuts are conceptually similar to AspectJ `cflow` pointcuts, although less powerful. (There is currently no way to specify that a pointcut executes below a join point matched by another pointcut.) A control flow pointcut matches the current call stack. For example, it might fire if the join point was invoked by a method in the `com.mycompany.web` package or by the `SomeCaller` class. Control flow pointcuts are specified by using the `org.springframework.aop.support.ControlFlowPointcut` class.
#### ** Chinese **

Spring 控件流点切方法在概念上类似于 AspectJ `cflow`点切方法，尽管功能没有那么强大。(目前没有办法指定一个点切入点在另一个点切入点匹配的连接点以下执行)。一个控制流点cut与当前调用栈匹配。例如，如果该连接点被 `com.mycompany.web`包中的方法或`SomeCaller`类中的方法调用，那么它可能会被触发。控制流点cut可以通过使用`org.springframework.aop.support.ControlFlowPointcut`类指定。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Control flow pointcuts are significantly more expensive to evaluate at runtime than even other dynamic pointcuts. In Java 1.4, the cost is about five times that of other dynamic pointcuts.
#### ** Chinese **

控制流点切方法在运行时的评估成本甚至比其他动态点切方法要高得多。在Java 1.4中，成本是其他动态点切方法的5倍左右。
<!-- tabs:end -->


### **6.1.5. Pointcut Superclasses** 

<!-- tabs:start -->

#### ** English **

Spring provides useful pointcut superclasses to help you to implement your own pointcuts.
#### ** Chinese **

Spring提供了有用的点切方法超级类，帮助你实现自己的点切方法。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Because static pointcuts are most useful, you should probably subclass `StaticMethodMatcherPointcut`. This requires implementing only one abstract method (although you can override other methods to customize behavior). The following example shows how to subclass `StaticMethodMatcherPointcut`:
#### ** Chinese **

因为静态点切方法最有用，所以你可能应该子类`StaticMethodMatcherPointcut`。这只需要实现一个抽象方法（尽管你可以覆盖其他方法来定制行为）。下面的例子显示了如何子类`StaticMethodMatcherPointcut`。
<!-- tabs:end -->


```java
class TestStaticPointcut extends StaticMethodMatcherPointcut {

    public boolean matches(Method m, Class targetClass) {
        // return true if custom criteria match
    }
}
```

<!-- tabs:start -->

#### ** English **

There are also superclasses for dynamic pointcuts. You can use custom pointcuts with any advice type.
#### ** Chinese **

动态点切方式也有超级类。你可以使用任何建议类型的自定义点捷径。
<!-- tabs:end -->


### **6.1.6. Custom Pointcuts** 

<!-- tabs:start -->

#### ** English **

Because pointcuts in Spring AOP are Java classes rather than language features (as in AspectJ), you can declare custom pointcuts, whether static or dynamic. Custom pointcuts in Spring can be arbitrarily complex. However, we recommend using the AspectJ pointcut expression language, if you can.
#### ** Chinese **

因为Spring AOP中的点切口是Java类而不是语言特性（如AspectJ），所以可以声明自定义点切口，无论是静态的还是动态的。在Spring中的自定义点捷径可以是任意复杂的。但是，如果可以的话，我们建议使用AspectJ的点切方式表达语言。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Later versions of Spring may offer support for “semantic pointcuts” as offered by JAC — for example, “all methods that change instance variables in the target object.”
#### ** Chinese **

Spring的后期版本可能会提供对JAC提供的 "语义点捷径 "的支持--例如，"改变目标对象中的实例变量的所有方法。"
<!-- tabs:end -->


### **6.2. Advice API in Spring** 

<!-- tabs:start -->

#### ** English **

Now we can examine how Spring AOP handles advice.
#### ** Chinese **

现在我们可以研究一下Spring AOP是如何处理建议的。
<!-- tabs:end -->


### **6.2.1. Advice Lifecycles** 

<!-- tabs:start -->

#### ** English **

Each advice is a Spring bean. An advice instance can be shared across all advised objects or be unique to each advised object. This corresponds to per-class or per-instance advice.
#### ** Chinese **

每个建议是一个Spring Bean。一个建议实例可以在所有建议对象中共享，也可以对每个建议对象唯一。这对应于每个类或每个实例的建议。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Per-class advice is used most often. It is appropriate for generic advice, such as transaction advisors. These do not depend on the state of the proxied object or add new state. They merely act on the method and arguments.
#### ** Chinese **

每类咨询最常用的是按类咨询。它适用于通用建议，如事务顾问等。这些不依赖于代理对象的状态，也不添加新的状态。它们只是对方法和参数起作用。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Per-instance advice is appropriate for introductions, to support mixins. In this case, the advice adds state to the proxied object.
#### ** Chinese **

每个实例建议适合于引入，以支持混合体。在这种情况下，建议将状态添加到被测对象中。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can use a mix of shared and per-instance advice in the same AOP proxy.
#### ** Chinese **

你可以在同一个AOP代理中使用共享和按实例建议混合使用。
<!-- tabs:end -->


### **6.2.2. Advice Types in Spring** 

<!-- tabs:start -->

#### ** English **

Spring provides several advice types and is extensible to support arbitrary advice types. This section describes the basic concepts and standard advice types.
#### ** Chinese **

Spring提供了几种建议类型，并可扩展以支持任意的建议类型。本节介绍了基本概念和标准建议类型。
<!-- tabs:end -->


### **Interception Around Advice** 

<!-- tabs:start -->

#### ** English **

The most fundamental advice type in Spring is interception around advice.
#### ** Chinese **

春天里最基本的建议类型是围绕建议的拦截。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Spring is compliant with the AOP `Alliance` interface for around advice that uses method interception. Classes that implement `MethodInterceptor` and that implement around advice should also implement the following interface:
#### ** Chinese **

Spring 符合 AOP `Alliance` 接口，用于使用方法拦截的 around advice。实现了`MethodInterceptor`并实现了包围建议的类也应该实现以下接口。
<!-- tabs:end -->


```java
public interface MethodInterceptor extends Interceptor {

    Object invoke(MethodInvocation invocation) throws Throwable;
}
```

<!-- tabs:start -->

#### ** English **

The `MethodInvocation` argument to the `invoke()` method exposes the method being invoked, the target join point, the AOP proxy, and the arguments to the method. The `invoke()` method should return the invocation’s result: the return value of the join point.
#### ** Chinese **

`invoke()`方法的`MethodInvocation`参数会显示被调用的方法、目标连接点、AOP代理和方法的参数。`invoke()`方法应该返回调用的结果：连接点的返回值。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following example shows a simple `MethodInterceptor` implementation:
#### ** Chinese **

下面的例子显示了一个简单的`MethodInterceptor`实现。
<!-- tabs:end -->


```java
public class DebugInterceptor implements MethodInterceptor {

    public Object invoke(MethodInvocation invocation) throws Throwable {
        System.out.println("Before: invocation=[" + invocation + "]");
        Object rval = invocation.proceed();
        System.out.println("Invocation returned");
        return rval;
    }
}
```

<!-- tabs:start -->

#### ** English **

Note the call to the `proceed()` method of `MethodInvocation`. This proceeds down the interceptor chain towards the join point. Most interceptors invoke this method and return its return value. However, a `MethodInterceptor`, like any around advice, can return a different value or throw an exception rather than invoke the proceed method. However, you do not want to do this without good reason.
#### ** Chinese **

请注意对`MethodInvocation`的`proceed()`方法的调用。这个方法会沿着拦截器链向着连接点前进。大多数拦截器都会调用这个方法并返回其返回值。但是，`MethodInterceptor`，就像任何周围的建议一样，可以返回一个不同的值或抛出一个异常，而不是调用 proceed 方法。但是，如果没有充分的理由，你不希望这样做。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

`MethodInterceptor` implementations offer interoperability with other AOP Alliance-compliant AOP implementations. The other advice types discussed in the remainder of this section implement common AOP concepts but in a Spring-specific way. While there is an advantage in using the most specific advice type, stick with `MethodInterceptor` around advice if you are likely to want to run the aspect in another AOP framework. Note that pointcuts are not currently interoperable between frameworks, and the AOP Alliance does not currently define pointcut interfaces.
#### ** Chinese **

`MethodInterceptor`实现提供了与其他符合AOP联盟的AOP实现的互操作性。本节其余部分讨论的其他建议类型实现了常见的AOP概念，但以Spring特有的方式实现。虽然使用最特定的建议类型有其优势，但如果你可能想在另一个AOP框架中运行该方面，请坚持使用`MethodInterceptor`。请注意，点捷径目前在不同的框架之间并不能互操作，AOP联盟目前也没有定义点捷径接口。
<!-- tabs:end -->


### **Before Advice** 

<!-- tabs:start -->

#### ** English **

A simpler advice type is a before advice. This does not need a `MethodInvocation` object, since it is called only before entering the method.
#### ** Chinese **

一个更简单的建议类型是before advice。这不需要`MethodInvocation`对象，因为它只在进入方法之前被调用。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The main advantage of a before advice is that there is no need to invoke the `proceed()` method and, therefore, no possibility of inadvertently failing to proceed down the interceptor chain.
#### ** Chinese **

之前建议的主要优点是，不需要调用`proceed()`方法，因此，不可能因为疏忽而导致拦截器链下行失败。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following listing shows the `MethodBeforeAdvice` interface:
#### ** Chinese **

下面列出了`MethodBeforeAdvice`接口。
<!-- tabs:end -->


```java
public interface MethodBeforeAdvice extends BeforeAdvice {

    void before(Method m, Object[] args, Object target) throws Throwable;
}
```

<!-- tabs:start -->

#### ** English **

(Spring’s API design would allow for field before advice, although the usual objects apply to field interception and it is unlikely for Spring to ever implement it.)
#### ** Chinese **

(Spring的API设计将允许在建议前进行字段拦截，尽管通常的对象适用于字段拦截，Spring不太可能实现)。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Note that the return type is `void`. Before advice can insert custom behavior before the join point executes but cannot change the return value. If a before advice throws an exception, it aborts further execution of the interceptor chain. The exception propagates back up the interceptor chain. If it is unchecked or on the signature of the invoked method, it is passed directly to the client. Otherwise, it is wrapped in an unchecked exception by the AOP proxy.
#### ** Chinese **

注意，返回类型为`void`。before advice可以在连接点执行前插入自定义行为，但不能改变返回值。如果前建议抛出一个异常，它将中止拦截器链的进一步执行。异常会在拦截器链中向上传播。如果它没有被选中或在被调用的方法的签名上，它将直接传递给客户端。否则，它将被AOP代理包装成一个未选中的异常。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following example shows a before advice in Spring, which counts all method invocations:
#### ** Chinese **

下面的例子显示了Spring中的一个前建议，它计算了所有的方法调用。
<!-- tabs:end -->


```java
public class CountingBeforeAdvice implements MethodBeforeAdvice {

    private int count;

    public void before(Method m, Object[] args, Object target) throws Throwable {
        ++count;
    }

    public int getCount() {
        return count;
    }
}
```

<!-- tabs:start -->

#### ** English **

Before advice can be used with any pointcut.
#### ** Chinese **

在建议之前，可以使用任何一个点切法。
<!-- tabs:end -->


### **Throws Advice** 

<!-- tabs:start -->

#### ** English **

Throws advice is invoked after the return of the join point if the join point threw an exception. Spring offers typed throws advice. Note that this means that the `org.springframework.aop.ThrowsAdvice` interface does not contain any methods. It is a tag interface identifying that the given object implements one or more typed throws advice methods. These should be in the following form:
#### ** Chinese **

如果连接点抛出了异常，那么Throws建议会在连接点返回后被调用。Spring提供了类型化的Throws建议。注意，这意味着`org.springframework.aop.ThrowsAdvice`接口不包含任何方法。它是一个标记接口，标识给定对象实现了一个或多个类型化的throws建议方法。这些方法应该采用以下形式。
<!-- tabs:end -->


```java
afterThrowing([Method, args, target], subclassOfThrowable)
```

<!-- tabs:start -->

#### ** English **

Only the last argument is required. The method signatures may have either one or four arguments, depending on whether the advice method is interested in the method and arguments. The next two listing show classes that are examples of throws advice.
#### ** Chinese **

只有最后一个参数是必需的。方法签名可以有一个或四个参数，这取决于建议方法是否对该方法和参数感兴趣。下面的两个列表显示的类是抛出建议的例子。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following advice is invoked if a `RemoteException` is thrown (including from subclasses):
#### ** Chinese **

如果抛出`RemoteException`（包括来自子类），会调用以下建议。
<!-- tabs:end -->


```java
public class RemoteThrowsAdvice implements ThrowsAdvice {

    public void afterThrowing(RemoteException ex) throws Throwable {
        // Do something with remote exception
    }
}
```

<!-- tabs:start -->

#### ** English **

Unlike the preceding advice, the next example declares four arguments, so that it has access to the invoked method, method arguments, and target object. The following advice is invoked if a `ServletException` is thrown:
#### ** Chinese **

与前面的建议不同，下面的例子声明了四个参数，这样它就可以访问被调用的方法、方法参数和目标对象。如果抛出一个`ServletException`，就会调用下面的建议。
<!-- tabs:end -->


```java
public class ServletThrowsAdviceWithArguments implements ThrowsAdvice {

    public void afterThrowing(Method m, Object[] args, Object target, ServletException ex) {
        // Do something with all arguments
    }
}
```

<!-- tabs:start -->

#### ** English **

The final example illustrates how these two methods could be used in a single class that handles both `RemoteException` and `ServletException`. Any number of throws advice methods can be combined in a single class. The following listing shows the final example:
#### ** Chinese **

最后一个例子说明了这两个方法如何在单个类中使用，该类可以同时处理`RemoteException`和`ServletException`。任何数量的抛出建议方法都可以在一个类中组合起来。下面的列表显示了最终的例子。
<!-- tabs:end -->


```java
public static class CombinedThrowsAdvice implements ThrowsAdvice {

    public void afterThrowing(RemoteException ex) throws Throwable {
        // Do something with remote exception
    }

    public void afterThrowing(Method m, Object[] args, Object target, ServletException ex) {
        // Do something with all arguments
    }
}
```

<!-- tabs:start -->

#### ** English **

If a throws-advice method throws an exception itself, it overrides the original exception (that is, it changes the exception thrown to the user). The overriding exception is typically a RuntimeException, which is compatible with any method signature. However, if a throws-advice method throws a checked exception, it must match the declared exceptions of the target method and is, hence, to some degree coupled to specific target method signatures. *Do not throw an undeclared checked exception that is incompatible with the target method’s signature!*
#### ** Chinese **

如果一个throws-advice方法本身就会抛出一个异常，那么它就会覆盖原来的异常（也就是说，它改变了向用户抛出的异常）。覆盖的异常通常是RuntimeException，它与任何方法签名兼容。但是，如果一个throws-advice方法抛出一个检查过的异常，那么它必须与目标方法的声明异常相匹配，因此，在一定程度上与特定的目标方法签名耦合。 *不要抛出一个与目标方法的签名不兼容的未声明的检查异常！*。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Throws advice can be used with any pointcut.
#### ** Chinese **

抛掷建议可以用任何一个点切法。
<!-- tabs:end -->


### **After Returning Advice** 

<!-- tabs:start -->

#### ** English **

An after returning advice in Spring must implement the `org.springframework.aop.AfterReturningAdvice` interface, which the following listing shows:
#### ** Chinese **

Spring中的afterReturningAdvice必须实现`org.springframework.aop.AfterReturningAdvice`接口，下面的列表显示了这个接口。
<!-- tabs:end -->


```java
public interface AfterReturningAdvice extends Advice {

    void afterReturning(Object returnValue, Method m, Object[] args, Object target)
            throws Throwable;
}
```

<!-- tabs:start -->

#### ** English **

An after returning advice has access to the return value (which it cannot modify), the invoked method, the method’s arguments, and the target.
#### ** Chinese **

一个返回后的建议可以访问返回值（它不能修改）、被调用的方法、方法的参数和目标。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following after returning advice counts all successful method invocations that have not thrown exceptions:
#### ** Chinese **

在返回建议后，下面的内容会统计所有没有抛出异常的成功方法调用。
<!-- tabs:end -->


```java
public class CountingAfterReturningAdvice implements AfterReturningAdvice {

    private int count;

    public void afterReturning(Object returnValue, Method m, Object[] args, Object target)
            throws Throwable {
        ++count;
    }

    public int getCount() {
        return count;
    }
}
```

<!-- tabs:start -->

#### ** English **

This advice does not change the execution path. If it throws an exception, it is thrown up the interceptor chain instead of the return value.
#### ** Chinese **

这个建议不会改变执行路径。如果它抛出一个异常，则会向上抛出拦截器链而不是返回值。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

After returning advice can be used with any pointcut.
#### ** Chinese **

归来后的建议可以用任何一个点切法。
<!-- tabs:end -->


### **Introduction Advice** 

<!-- tabs:start -->

#### ** English **

Spring treats introduction advice as a special kind of interception advice.
#### ** Chinese **

春天把介绍性建议作为一种特殊的拦截性建议。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Introduction requires an `IntroductionAdvisor` and an `IntroductionInterceptor` that implement the following interface:
#### ** Chinese **

介绍需要一个`IntroductionAdvisor`和一个`IntroductionInterceptor`，这两个接口实现以下接口。
<!-- tabs:end -->


```java
public interface IntroductionInterceptor extends MethodInterceptor {

    boolean implementsInterface(Class intf);
}
```

<!-- tabs:start -->

#### ** English **

The `invoke()` method inherited from the AOP Alliance `MethodInterceptor` interface must implement the introduction. That is, if the invoked method is on an introduced interface, the introduction interceptor is responsible for handling the method call — it cannot invoke `proceed()`.
#### ** Chinese **

继承自AOP联盟`MethodInterceptor`接口的`invoke()`方法必须实现引入。也就是说，如果被调用的方法是在一个引入的接口上，那么引入拦截器负责处理方法调用--它不能调用`proceed()`。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Introduction advice cannot be used with any pointcut, as it applies only at the class, rather than the method, level. You can only use introduction advice with the `IntroductionAdvisor`, which has the following methods:
#### ** Chinese **

导入建议不能与任何点cut一起使用，因为它只适用于类而不是方法层面。你只能在`IntroductionAdvisor`中使用介绍建议，它有以下方法。
<!-- tabs:end -->


```java
public interface IntroductionAdvisor extends Advisor, IntroductionInfo {

    ClassFilter getClassFilter();

    void validateInterfaces() throws IllegalArgumentException;
}

public interface IntroductionInfo {

    Class<?>[] getInterfaces();
}
```

<!-- tabs:start -->

#### ** English **

There is no `MethodMatcher` and, hence, no `Pointcut` associated with introduction advice. Only class filtering is logical.
#### ** Chinese **

没有`MethodMatcher`，因此，没有`Pointcut`与引入建议相关联。只有类过滤才是合乎逻辑的。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The `getInterfaces()` method returns the interfaces introduced by this advisor.
#### ** Chinese **

`getInterfaces()`方法返回由该顾问引入的接口。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The `validateInterfaces()` method is used internally to see whether or not the introduced interfaces can be implemented by the configured `IntroductionInterceptor`.
#### ** Chinese **

`validateInterfaces()`方法在内部用于查看引入的接口是否可以被配置的`IntroductionInterceptor`实现。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Consider an example from the Spring test suite and suppose we want to introduce the following interface to one or more objects:
#### ** Chinese **

考虑一下Spring测试套件中的一个例子，假设我们想为一个或多个对象引入以下接口。
<!-- tabs:end -->


```java
public interface Lockable {
    void lock();
    void unlock();
    boolean locked();
}
```

<!-- tabs:start -->

#### ** English **

This illustrates a mixin. We want to be able to cast advised objects to `Lockable`, whatever their type and call lock and unlock methods. If we call the `lock()` method, we want all setter methods to throw a `LockedException`. Thus, we can add an aspect that provides the ability to make objects immutable without them having any knowledge of it: a good example of AOP.
#### ** Chinese **

这说明了一个混合体。我们希望能够将被建议的对象抛出`Lockable`，不管它们的类型如何，并调用锁定和解锁方法。如果我们调用`lock()`方法，我们希望所有的setter方法都抛出一个`LockedException`。因此，我们可以增加一个方面，提供了使对象在没有任何知识的情况下成为不可变的能力：AOP的一个很好的例子。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

First, we need an `IntroductionInterceptor` that does the heavy lifting. In this case, we extend the `org.springframework.aop.support.DelegatingIntroductionInterceptor` convenience class. We could implement `IntroductionInterceptor` directly, but using `DelegatingIntroductionInterceptor` is best for most cases.
#### ** Chinese **

首先，我们需要一个`IntroductionInterceptor`来完成重任。在这种情况下，我们扩展了`org.springframework.aop.support.DelegatingIntroductionInterceptor`方便类。我们可以直接实现`IntroductionInterceptor`，但在大多数情况下，使用`DelegatingIntroductionInterceptor`是最好的选择。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The `DelegatingIntroductionInterceptor` is designed to delegate an introduction to an actual implementation of the introduced interfaces, concealing the use of interception to do so. You can set the delegate to any object using a constructor argument. The default delegate (when the no-argument constructor is used) is `this`. Thus, in the next example, the delegate is the `LockMixin` subclass of `DelegatingIntroductionInterceptor`. Given a delegate (by default, itself), a `DelegatingIntroductionInterceptor` instance looks for all interfaces implemented by the delegate (other than `IntroductionInterceptor`) and supports introductions against any of them. Subclasses such as `LockMixin` can call the `suppressInterface(Class intf)` method to suppress interfaces that should not be exposed. However, no matter how many interfaces an `IntroductionInterceptor` is prepared to support, the `IntroductionAdvisor` used controls which interfaces are actually exposed. An introduced interface conceals any implementation of the same interface by the target.
#### ** Chinese **

`DelegatingIntroductionInterceptor`是为了将引入的接口的实际实现委派给引入的接口，隐藏使用拦截来实现。你可以使用构造函数参数将委托介绍设置为任何对象。默认的委托（当使用无参数构造函数时）是`this`。因此，在下一个例子中，代表对象是`LockMixin`的`DelegatingIntroductionInterceptor`子类。给定一个委托器（默认情况下是本身），`DelegatingIntroductionInterceptor`实例会查找委托器实现的所有接口（除了`IntroductionInterceptor`之外），并支持针对其中任何一个接口的引入。像`LockMixin`这样的子类可以调用`suppressInterface(Class intf)`方法来抑制不应该暴露的接口。然而，无论`IntroductionInterceptor`准备支持多少个接口，所使用的`IntroductionAdvisor`都会控制哪些接口实际暴露。一个被引入的接口隐藏了目标对同一接口的任何实现。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Thus, `LockMixin` extends `DelegatingIntroductionInterceptor` and implements `Lockable` itself. The superclass automatically picks up that `Lockable` can be supported for introduction, so we do not need to specify that. We could introduce any number of interfaces in this way.
#### ** Chinese **

因此，`LockMixin`扩展了`DelegatingIntroductionInterceptor`并实现了`Lockable`本身。超级类会自动接收到`Lockable`可以支持引入，所以我们不需要指定。我们可以用这种方式引入任意数量的接口。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Note the use of the `locked` instance variable. This effectively adds additional state to that held in the target object.
#### ** Chinese **

注意使用了`locked`实例变量。这有效地增加了目标对象中的附加状态。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following example shows the example `LockMixin` class:
#### ** Chinese **

下面的示例显示了`LockMixin`类。
<!-- tabs:end -->


```java
public class LockMixin extends DelegatingIntroductionInterceptor implements Lockable {

    private boolean locked;

    public void lock() {
        this.locked = true;
    }

    public void unlock() {
        this.locked = false;
    }

    public boolean locked() {
        return this.locked;
    }

    public Object invoke(MethodInvocation invocation) throws Throwable {
        if (locked() && invocation.getMethod().getName().indexOf("set") == 0) {
            throw new LockedException();
        }
        return super.invoke(invocation);
    }

}
```

<!-- tabs:start -->

#### ** English **

Often, you need not override the `invoke()` method. The `DelegatingIntroductionInterceptor` implementation (which calls the `delegate` method if the method is introduced, otherwise proceeds towards the join point) usually suffices. In the present case, we need to add a check: no setter method can be invoked if in locked mode.
#### ** Chinese **

通常情况下，你不需要覆盖`invoke()`方法。`DelegatingIntroductionInterceptor`的实现（如果方法被引入，则调用`delegate`方法，否则向连接点前进）通常就足够了。在本例中，我们需要添加一个检查：如果处于锁定模式，则不能调用任何setter方法。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The required introduction only needs to hold a distinct `LockMixin` instance and specify the introduced interfaces (in this case, only `Lockable`). A more complex example might take a reference to the introduction interceptor (which would be defined as a prototype). In this case, there is no configuration relevant for a `LockMixin`, so we create it by using `new`. The following example shows our `LockMixinAdvisor` class:
#### ** Chinese **

所需的引入只需要持有一个独立的`LockMixin`实例，并指定引入的接口（在这种情况下，只需要`Lockable`）。一个更复杂的例子可能是引用引入拦截器（将被定义为原型）。在这种情况下，没有与`LockMixin`相关的配置，所以我们使用`new`来创建它。下面的例子显示了我们的 `LockMixinAdvisor`类。
<!-- tabs:end -->


```java
public class LockMixinAdvisor extends DefaultIntroductionAdvisor {

    public LockMixinAdvisor() {
        super(new LockMixin(), Lockable.class);
    }
}
```

<!-- tabs:start -->

#### ** English **

We can apply this advisor very simply, because it requires no configuration. (However, it is impossible to use an `IntroductionInterceptor` without an `IntroductionAdvisor`.) As usual with introductions, the advisor must be per-instance, as it is stateful. We need a different instance of `LockMixinAdvisor`, and hence `LockMixin`, for each advised object. The advisor comprises part of the advised object’s state.
#### ** Chinese **

我们可以非常简单地应用这个顾问，因为它不需要配置。(然而，如果没有`IntroductionInterceptor`，就不可能使用`IntroductionAdvisor`。) 和通常的介绍一样，顾问必须是每个实例，因为它是有状态的。我们需要一个不同的`LockMixinAdvisor`实例，因此，对于每个被告知的对象，我们需要`LockMixin`。该顾问包含了被建议对象的部分状态。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

We can apply this advisor programmatically by using the `Advised.addAdvisor()` method or (the recommended way) in XML configuration, as any other advisor. All proxy creation choices discussed below, including “auto proxy creators,” correctly handle introductions and stateful mixins.
#### ** Chinese **

我们可以通过使用`Advised.addAdvisor()`方法或（推荐的方式）在XML配置中的`Advised.addAdvisor()`方法，像其他任何顾问一样，以程序化方式应用此顾问。下面讨论的所有代理创建选择，包括 "自动代理创建器"，都能正确地处理引入和有状态的混合器。
<!-- tabs:end -->


### **6.3. The Advisor API in Spring** 

<!-- tabs:start -->

#### ** English **

In Spring, an Advisor is an aspect that contains only a single advice object associated with a pointcut expression.
#### ** Chinese **

在Spring中，Advisor是一个方面，它只包含一个与点切表达式关联的单一建议对象。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Apart from the special case of introductions, any advisor can be used with any advice. `org.springframework.aop.support.DefaultPointcutAdvisor` is the most commonly used advisor class. It can be used with a `MethodInterceptor`, `BeforeAdvice`, or `ThrowsAdvice`.
#### ** Chinese **

除了介绍类的特殊情况外，任何顾问类都可以使用任何建议。 `org.springframework.aop.support.DefaultPointcutAdvisor`是最常用的顾问类。它可以和`MethodInterceptor`、`BeforeAdvice`或`ThrowsAdvice`一起使用。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

It is possible to mix advisor and advice types in Spring in the same AOP proxy. For example, you could use an interception around advice, throws advice, and before advice in one proxy configuration. Spring automatically creates the necessary interceptor chain.
#### ** Chinese **

在Spring中，可以在同一个AOP代理中混合使用顾问和建议类型。例如，你可以在一个代理配置中使用围绕建议、抛出建议和建议前的拦截。Spring会自动创建必要的拦截器链。
<!-- tabs:end -->


### **6.4. Using the** **`ProxyFactoryBean`** ** to Create AOP Proxies** 

<!-- tabs:start -->

#### ** English **

If you use the Spring IoC container (an `ApplicationContext` or `BeanFactory`) for your business objects (and you should be!), you want to use one of Spring’s AOP `FactoryBean` implementations. (Remember that a factory bean introduces a layer of indirection, letting it create objects of a different type.)
#### ** Chinese **

如果你使用Spring IoC容器（`ApplicationContext`或`BeanFactory`）来实现你的业务对象（你应该这样做！），你希望使用Spring的AOP `FactoryBean`实现之一。(请记住，工厂Bean引入了一层隐性，让它创建不同类型的对象。)
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The Spring AOP support also uses factory beans under the covers.
#### ** Chinese **

春天的AOP支持也采用了厂豆下盖的方式来支持。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The basic way to create an AOP proxy in Spring is to use the `org.springframework.aop.framework.ProxyFactoryBean`. This gives complete control over the pointcuts, any advice that applies, and their ordering. However, there are simpler options that are preferable if you do not need such control.
#### ** Chinese **

在Spring中创建一个AOP代理的基本方法是使用`org.springframework.aop.framework.ProxyFactoryBean`。这样就可以完全控制点捷径、任何适用的建议以及它们的顺序。但是，如果你不需要这样的控制，还有更简单的选项。
<!-- tabs:end -->


### **6.4.1. Basics** 

<!-- tabs:start -->

#### ** English **

The `ProxyFactoryBean`, like other Spring `FactoryBean` implementations, introduces a level of indirection. If you define a `ProxyFactoryBean` named `foo`, objects that reference `foo` do not see the `ProxyFactoryBean` instance itself but an object created by the implementation of the `getObject()` method in the `ProxyFactoryBean` . This method creates an AOP proxy that wraps a target object.
#### ** Chinese **

`ProxyFactoryBean`和其他Spring `FactoryBean`实现一样，引入了一个层次的隐性。如果定义了一个名为 `ProxyFactoryBean`的 `ProxyFactoryBean`，那么引用 `foo`的对象不会看到 `ProxyFactoryBean`实例本身，而是在 `ProxyFactoryBean`中的 `getObject()`方法的实现创建的对象。这个方法创建了一个AOP代理，它可以封装一个目标对象。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

One of the most important benefits of using a `ProxyFactoryBean` or another IoC-aware class to create AOP proxies is that advices and pointcuts can also be managed by IoC. This is a powerful feature, enabling certain approaches that are hard to achieve with other AOP frameworks. For example, an advice may itself reference application objects (besides the target, which should be available in any AOP framework), benefiting from all the pluggability provided by Dependency Injection.
#### ** Chinese **

使用`ProxyFactoryBean`或另一个IoC感知类来创建AOP代理的一个最重要的好处是，建议和点捷径也可以由IoC管理。这是一个强大的功能，可以实现其他AOP框架难以实现的某些方法。例如，一个建议本身可以引用应用对象（除了目标之外，在任何AOP框架中都应该是可用的），受益于Dependency Injection提供的所有可插拔性。
<!-- tabs:end -->


### **6.4.2. JavaBean Properties** 

<!-- tabs:start -->

#### ** English **

In common with most `FactoryBean` implementations provided with Spring, the `ProxyFactoryBean` class is itself a JavaBean. Its properties are used to:
#### ** Chinese **

与Spring提供的大多数`FactoryBean`实现一样，`ProxyFactoryBean`类本身就是一个JavaBean。它的属性用于。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

- Specify the target you want to proxy.

- Specify whether to use CGLIB (described later and see also [JDK- and CGLIB-based proxies](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#aop-pfb-proxy-types)).

#### ** Chinese **

- 指定你要代理的目标。

- 指定是否使用CGLIB（后面会介绍，请参见[基于JDK和CGLIB的代理](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#aop-pfb-proxy-types)）。

<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

Some key properties are inherited from `org.springframework.aop.framework.ProxyConfig` (the superclass for all AOP proxy factories in Spring). These key properties include the following:
#### ** Chinese **

一些关键属性是从 `org.springframework.aop.framework.ProxyConfig`（Spring中所有AOP代理工厂的超级类）继承的。这些关键属性包括以下内容。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

- `proxyTargetClass`: `true` if the target class is to be proxied, rather than the target class’s interfaces. If this property value is set to `true`, then CGLIB proxies are created (but see also [JDK- and CGLIB-based proxies](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#aop-pfb-proxy-types)).

- `optimize`: Controls whether or not aggressive optimizations are applied to proxies created through CGLIB. You should not blithely use this setting unless you fully understand how the relevant AOP proxy handles optimization. This is currently used only for CGLIB proxies. It has no effect with JDK dynamic proxies.

- `frozen`: If a proxy configuration is `frozen`, changes to the configuration are no longer allowed. This is useful both as a slight optimization and for those cases when you do not want callers to be able to manipulate the proxy (through the `Advised` interface) after the proxy has been created. The default value of this property is `false`, so changes (such as adding additional advice) are allowed.

- `exposeProxy`: Determines whether or not the current proxy should be exposed in a `ThreadLocal` so that it can be accessed by the target. If a target needs to obtain the proxy and the `exposeProxy` property is set to `true`, the target can use the `AopContext.currentProxy()` method.

#### ** Chinese **

- `proxyTargetClass`。 `true`：如果目标类要被代理，而不是目标类的接口。如果这个属性值被设置为`true`，那么CGLIB代理就会被创建（但也可以参考[基于JDK和CGLIB的代理](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#aop-pfb-proxy-types)）。

- `optimize`。控制是否对通过 CGLIB 创建的代理进行积极的优化。除非完全了解相关的 AOP 代理如何处理优化，否则不应随意使用此设置。目前，该设置仅用于 CGLIB 代理。它对JDK动态代理没有影响。

- `frozen`：如果代理配置被`frozen`，则不再允许更改配置。这既可以作为一种轻微的优化，也可以用于在代理创建后不希望调用者（通过 `Advised` 接口）操纵代理的情况。这个属性的默认值是 `false`，所以允许更改（例如添加额外的建议）。

- `exposeProxy`。决定当前代理是否应该在`ThreadLocal`中暴露，以便目标可以访问它。如果目标需要获取代理，并且`exposeProxy`属性被设置为`true`，那么目标可以使用`AopContext.currentProxy()`方法。

<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

Other properties specific to `ProxyFactoryBean` include the following:
#### ** Chinese **

针对`ProxyFactoryBean`的其他属性包括以下内容。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

- `proxyInterfaces`: An array of `String` interface names. If this is not supplied, a CGLIB proxy for the target class is used (but see also [JDK- and CGLIB-based proxies](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#aop-pfb-proxy-types)).

- `interceptorNames`: A `String` array of `Advisor`, interceptor, or other advice names to apply. Ordering is significant, on a first come-first served basis. That is to say that the first interceptor in the list is the first to be able to intercept the invocation.
#### ** Chinese **

- `proxyInterfaces`。`String`接口名称的数组。如果没有提供这一点，则使用目标类的 CGLIB 代理（但也可以参考 [JDK- 和 CGLIB-based proxies](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#aop-pfb-proxy-types)）。

- `interceptorNames`。一个`String`数组，包含要应用的`Advisor`、拦截器或其他建议名称。顺序是有意义的，按先到先得的原则。也就是说，列表中的第一个拦截器是第一个能够拦截调用的。
<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

  - The names are bean names in the current factory, including bean names from ancestor factories. You cannot mention bean references here, since doing so results in the `ProxyFactoryBean` ignoring the singleton setting of the advice.
#### ** Chinese **

  - 这些名称是当前工厂中的bean名，包括来自祖先工厂的bean名。你不能在这里提到bean引用，因为这样做会导致`ProxyFactoryBean`忽略建议中的单子设置。
<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

  - You can append an interceptor name with an asterisk (`*`). Doing so results in the application of all advisor beans with names that start with the part before the asterisk to be applied. You can find an example of using this feature in [Using “Global” Advisors](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#aop-global-advisors).
#### ** Chinese **

  - 你可以用星号(`*`)附加一个拦截器名称。这样做的结果是应用所有以星号前的部分开头的名字作为名字的顾问豆。你可以在[使用 "全局 "顾问](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#aop-global-advisors)中找到一个使用此功能的例子。
<!-- tabs:end -->


### **6.4.3. JDK- and CGLIB-based proxies** 

<!-- tabs:start -->

#### ** English **

This section serves as the definitive documentation on how the `ProxyFactoryBean` chooses to create either a JDK-based proxy or a CGLIB-based proxy for a particular target object (which is to be proxied).
#### ** Chinese **

本节是关于`ProxyFactoryBean`如何选择创建基于JDK的代理或基于CGLIB的代理来创建特定目标对象（被代理的对象）的最终文档。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The behavior of the `ProxyFactoryBean` with regard to creating JDK- or CGLIB-based proxies changed between versions 1.2.x and 2.0 of Spring. The `ProxyFactoryBean` now exhibits similar semantics with regard to auto-detecting interfaces as those of the `TransactionProxyFactoryBean` class.
#### ** Chinese **

在Spring的1.2.x和2.0版本之间，`ProxyFactoryBean`在创建基于JDK或CGLIB的代理方面的行为发生了变化。`ProxyFactoryBean`现在在自动检测接口方面表现出与`TransactionProxyFactoryBean`类类似的语义。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

If the class of a target object that is to be proxied (hereafter simply referred to as the target class) does not implement any interfaces, a CGLIB-based proxy is created. This is the easiest scenario, because JDK proxies are interface-based, and no interfaces means JDK proxying is not even possible. You can plug in the target bean and specify the list of interceptors by setting the `interceptorNames` property. Note that a CGLIB-based proxy is created even if the `proxyTargetClass` property of the `ProxyFactoryBean` has been set to `false`. (Doing so makes no sense and is best removed from the bean definition, because it is, at best, redundant, and, at worst confusing.)
#### ** Chinese **

如果要被代理的目标对象的类（以下简称为目标类）没有实现任何接口，就会创建一个基于CGLIB的代理。这是最简单的情况，因为JDK的代理是基于接口的，没有接口就意味着JDK的代理根本无法实现。你可以插入目标Bean，通过设置`interceptorNames`属性指定拦截器列表。请注意，即使`ProxyFactoryBean`的`proxyTargetClass`属性被设置为`false`，也会创建一个基于CGLIB的代理。(这样做没有任何意义，最好从Bean定义中删除，因为这样做充其量是多余的，最坏的情况下也是混乱的。)
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

If the target class implements one (or more) interfaces, the type of proxy that is created depends on the configuration of the `ProxyFactoryBean`.
#### ** Chinese **

如果目标类实现了一个（或多个）接口，那么创建的代理类型取决于`ProxyFactoryBean`的配置。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

If the `proxyTargetClass` property of the `ProxyFactoryBean` has been set to `true`, a CGLIB-based proxy is created. This makes sense and is in keeping with the principle of least surprise. Even if the `proxyInterfaces` property of the `ProxyFactoryBean` has been set to one or more fully qualified interface names, the fact that the `proxyTargetClass` property is set to `true` causes CGLIB-based proxying to be in effect.
#### ** Chinese **

如果`ProxyFactoryBean`的`proxyTargetClass`属性被设置为`true`，就会创建一个基于CGLIB的代理。这是有道理的，也符合最小意外的原则。即使`ProxyFactoryBean`的`proxyInterfaces`属性被设置为一个或多个完全限定的接口名，但`proxyTargetClass`属性被设置为`true`这一事实也会导致基于CGLIB的代理生效。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

If the `proxyInterfaces` property of the `ProxyFactoryBean` has been set to one or more fully qualified interface names, a JDK-based proxy is created. The created proxy implements all of the interfaces that were specified in the `proxyInterfaces` property. If the target class happens to implement a whole lot more interfaces than those specified in the `proxyInterfaces` property, that is all well and good, but those additional interfaces are not implemented by the returned proxy.
#### ** Chinese **

如果`ProxyFactoryBean`的`proxyInterfaces`属性被设置为一个或多个完全限定的接口名，则会创建一个基于JDK的代理。创建的代理实现了在`proxyInterfaces`属性中指定的所有接口。如果目标类刚好实现了比 `proxyInterfaces` 属性中指定的接口多得多的接口，这很好，但这些额外的接口不会被返回的代理实现。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

If the `proxyInterfaces` property of the `ProxyFactoryBean` has not been set, but the target class does implement one (or more) interfaces, the `ProxyFactoryBean` auto-detects the fact that the target class does actually implement at least one interface, and a JDK-based proxy is created. The interfaces that are actually proxied are all of the interfaces that the target class implements. In effect, this is the same as supplying a list of each and every interface that the target class implements to the `proxyInterfaces` property. However, it is significantly less work and less prone to typographical errors.
#### ** Chinese **

如果`ProxyFactoryBean`的`proxyInterfaces`属性没有被设置，但目标类确实实现了一个（或多个）接口，那么`ProxyFactoryBean`会自动检测到目标类实际实现了至少一个接口，并创建一个基于JDK的代理。实际被代理的接口是目标类实现的所有接口。实际上，这就相当于向`proxyInterfaces`属性提供了目标类实现的每一个接口的列表。不过，这样做的工作量要小得多，而且不容易出现排版错误。
<!-- tabs:end -->


### **6.4.4. Proxying Interfaces** 

<!-- tabs:start -->

#### ** English **

Consider a simple example of `ProxyFactoryBean` in action. This example involves:
#### ** Chinese **

考虑一下`ProxyFactoryBean`的一个简单例子。这个例子涉及到以下内容
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

- singleton: Whether or not the factory should return a single object, no matter how often the `getObject()` method is called. Several `FactoryBean` implementations offer such a method. The default value is `true`. If you want to use stateful advice - for example, for stateful mixins - use prototype advices along with a singleton value of `false`.

- A target bean that is proxied. This is the `personTarget` bean definition in the example.

- An `Advisor` and an `Interceptor` used to provide advice.

- An AOP proxy bean definition to specify the target object (the `personTarget` bean), the interfaces to proxy, and the advices to apply.

#### ** Chinese **

- 单一对象。无论`getObject()`方法被调用多少次，工厂是否应该返回一个单一对象。一些`FactoryBean`实现提供了这样一个方法。默认值是`true`。如果你想使用有状态的建议--例如，对于有状态的mixins来说--使用prototype建议和单子值`false`。

- 一个目标Bean，它是被proxied的目标Bean。这是示例中的`personTarget` bean的定义。

- 一个`Advisor`和一个`Interceptor`用于提供建议。

- 一个 AOP proxy bean 定义用于指定目标对象（`personTarget` bean）、要代理的接口以及要应用的建议。

<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

The following listing shows the example:
#### ** Chinese **

下面列举的例子。
<!-- tabs:end -->


```xml
<bean id="personTarget" class="com.mycompany.PersonImpl">
    <property name="name" value="Tony"/>
    <property name="age" value="51"/>
</bean>

<bean id="myAdvisor" class="com.mycompany.MyAdvisor">
    <property name="someProperty" value="Custom string property value"/>
</bean>

<bean id="debugInterceptor" class="org.springframework.aop.interceptor.DebugInterceptor">
</bean>

<bean id="person"
    class="org.springframework.aop.framework.ProxyFactoryBean">
    <property name="proxyInterfaces" value="com.mycompany.Person"/>

    <property name="target" ref="personTarget"/>
    <property name="interceptorNames">
        <list>
            <value>myAdvisor</value>
            <value>debugInterceptor</value>
        </list>
    </property>
</bean>
```

<!-- tabs:start -->

#### ** English **

Note that the `interceptorNames` property takes a list of `String`, which holds the bean names of the interceptors or advisors in the current factory. You can use advisors, interceptors, before, after returning, and throws advice objects. The ordering of advisors is significant.
#### ** Chinese **

注意，`interceptorNames`属性取一个`String`的列表，它持有当前工厂中的拦截器或顾问的bean名。你可以使用顾问、拦截器、返回前、返回后和抛出建议对象。顾问对象的排序是有意义的。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You might be wondering why the list does not hold bean references. The reason for this is that, if the singleton property of the `ProxyFactoryBean` is set to `false`, it must be able to return independent proxy instances. If any of the advisors is itself a prototype, an independent instance would need to be returned, so it is necessary to be able to obtain an instance of the prototype from the factory. Holding a reference is not sufficient.
#### ** Chinese **

你可能会疑惑，为什么列表中没有持有Bean引用。原因在于，如果`ProxyFactoryBean`的单子属性被设置为`false`，那么它必须能够返回独立的代理实例。如果任何一个顾问本身就是一个原型，就需要返回一个独立的实例，所以必须能够从工厂中获得一个原型的实例。仅仅持有一个引用是不够的。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The `person` bean definition shown earlier can be used in place of a `Person` implementation, as follows:
#### ** Chinese **

前面显示的`person` bean定义可以用来代替`Person`的实现，如下所示。
<!-- tabs:end -->


```java
Person person = (Person) factory.getBean("person");
```

<!-- tabs:start -->

#### ** English **

Other beans in the same IoC context can express a strongly typed dependency on it, as with an ordinary Java object. The following example shows how to do so:
#### ** Chinese **

同一IoC上下文中的其他Bean可以像普通的Java对象一样，表达对它的强类型依赖。下面的例子显示了如何做到这一点。
<!-- tabs:end -->


```xml
<bean id="personUser" class="com.mycompany.PersonUser">
    <property name="person"><ref bean="person"/></property>
</bean>
```

<!-- tabs:start -->

#### ** English **

The `PersonUser` class in this example exposes a property of type `Person`. As far as it is concerned, the AOP proxy can be used transparently in place of a “real” person implementation. However, its class would be a dynamic proxy class. It would be possible to cast it to the `Advised` interface (discussed later).
#### ** Chinese **

这个例子中的`PersonUser`类公开了一个类型为`Person`的属性。就它而言，AOP代理可以透明地代替 "真正的 "人的实现。但是，它的类将是一个动态的代理类。可以将其投射到`Advised`接口（后面会讨论）。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can conceal the distinction between target and proxy by using an anonymous inner bean. Only the `ProxyFactoryBean` definition is different. The advice is included only for completeness. The following example shows how to use an anonymous inner bean:
#### ** Chinese **

你可以通过使用一个匿名内部Bean来掩盖目标和代理的区别。只有`ProxyFactoryBean`定义不同。这里的建议仅仅是为了完整地包含在里面。下面的例子显示了如何使用匿名内部Bean。
<!-- tabs:end -->


```xml
<bean id="myAdvisor" class="com.mycompany.MyAdvisor">
    <property name="someProperty" value="Custom string property value"/>
</bean>

<bean id="debugInterceptor" class="org.springframework.aop.interceptor.DebugInterceptor"/>

<bean id="person" class="org.springframework.aop.framework.ProxyFactoryBean">
    <property name="proxyInterfaces" value="com.mycompany.Person"/>
    <!-- Use inner bean, not local reference to target -->
    <property name="target">
        <bean class="com.mycompany.PersonImpl">
            <property name="name" value="Tony"/>
            <property name="age" value="51"/>
        </bean>
    </property>
    <property name="interceptorNames">
        <list>
            <value>myAdvisor</value>
            <value>debugInterceptor</value>
        </list>
    </property>
</bean>
```

<!-- tabs:start -->

#### ** English **

Using an anonymous inner bean has the advantage that there is only one object of type `Person`. This is useful if we want to prevent users of the application context from obtaining a reference to the un-advised object or need to avoid any ambiguity with Spring IoC autowiring. There is also, arguably, an advantage in that the `ProxyFactoryBean` definition is self-contained. However, there are times when being able to obtain the un-advised target from the factory might actually be an advantage (for example, in certain test scenarios).
#### ** Chinese **

使用匿名内部Bean的好处是只有一个`Person`类型的对象。如果我们想防止应用上下文的用户获取到未授权的对象的引用，或者需要避免Spring IoC自动布线的模糊性，这一点是非常有用的。可以说，还有一个优势，那就是`ProxyFactoryBean`定义是自带的。然而，有时，能够从工厂中获取未被推荐的目标可能是一个优势（例如，在某些测试场景中）。
<!-- tabs:end -->


### **6.4.5. Proxying Classes** 

<!-- tabs:start -->

#### ** English **

What if you need to proxy a class, rather than one or more interfaces?
#### ** Chinese **

如果你需要代理一个类，而不是一个或多个接口呢？
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Imagine that in our earlier example, there was no `Person` interface. We needed to advise a class called `Person` that did not implement any business interface. In this case, you can configure Spring to use CGLIB proxying rather than dynamic proxies. To do so, set the `proxyTargetClass` property on the `ProxyFactoryBean` shown earlier to `true`. While it is best to program to interfaces rather than classes, the ability to advise classes that do not implement interfaces can be useful when working with legacy code. (In general, Spring is not prescriptive. While it makes it easy to apply good practices, it avoids forcing a particular approach.)
#### ** Chinese **

想象一下，在我们前面的例子中，没有`Person`接口。我们需要给一个名为`Person`的类提供建议，这个类没有实现任何业务接口。在这种情况下，你可以配置Spring使用CGLIB代理，而不是动态代理。要这样做，请将前面显示的`ProxyFactoryBean`上的`proxyTargetClass`属性设置为`true`。虽然最好是按照接口而不是类来编程，但在处理遗留代码时，对不实现接口的类提供建议的能力会很有用。总的来说，Spring并没有规定性）。虽然它使良好的实践很容易应用，但它避免了强行采用特定的方法。)
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

If you want to, you can force the use of CGLIB in any case, even if you do have interfaces.
#### ** Chinese **

如果你愿意，你可以在任何情况下强制使用CGLIB，即使你确实有接口也可以。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

CGLIB proxying works by generating a subclass of the target class at runtime. Spring configures this generated subclass to delegate method calls to the original target. The subclass is used to implement the Decorator pattern, weaving in the advice.
#### ** Chinese **

CGLIB代理的工作原理是在运行时生成一个目标类的子类。Spring配置这个生成的子类，将方法调用委托给原始目标类。这个子类被用来实现Decorator模式，在建议中编织。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

CGLIB proxying should generally be transparent to users. However, there are some issues to consider:
#### ** Chinese **

一般来说，CGLIB的代理制对用户来说应该是透明的。但是，有一些问题需要考虑。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

- `Final` methods cannot be advised, as they cannot be overridden.

- There is no need to add CGLIB to your classpath. As of Spring 3.2, CGLIB is repackaged and included in the spring-core JAR. In other words, CGLIB-based AOP works “out of the box”, as do JDK dynamic proxies.

#### ** Chinese **

- `Final`方法不能建议使用，因为它们不能被覆盖。

- 没有必要将CGLIB添加到你的classpath中。从Spring 3.2开始，CGLIB被重新打包并包含在spring-core JAR中。换句话说，基于 CGLIB 的 AOP 可以 "开箱即用"，JDK 的动态代理也是如此。

<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

There is little performance difference between CGLIB proxying and dynamic proxies. Performance should not be a decisive consideration in this case.
#### ** Chinese **

CGLIB代理和动态代理在性能上没有什么区别。在这种情况下，性能不应成为决定性的考虑因素。
<!-- tabs:end -->


### **6.4.6. Using “Global” Advisors** 

<!-- tabs:start -->

#### ** English **

By appending an asterisk to an interceptor name, all advisors with bean names that match the part before the asterisk are added to the advisor chain. This can come in handy if you need to add a standard set of “global” advisors. The following example defines two global advisors:
#### ** Chinese **

通过在拦截器名称中添加星号，所有与星号前的部分匹配的豆名的顾问都会被添加到顾问链中。如果你需要添加一个标准的 "全局 "顾问集，这可以派上用场。下面的例子定义了两个全局顾问。
<!-- tabs:end -->


```xml
<bean id="proxy" class="org.springframework.aop.framework.ProxyFactoryBean">
    <property name="target" ref="service"/>
    <property name="interceptorNames">
        <list>
            <value>global*</value>
        </list>
    </property>
</bean>

<bean id="global_debug" class="org.springframework.aop.interceptor.DebugInterceptor"/>
<bean id="global_performance" class="org.springframework.aop.interceptor.PerformanceMonitorInterceptor"/>
```

### **6.5. Concise Proxy Definitions** 

<!-- tabs:start -->

#### ** English **

Especially when defining transactional proxies, you may end up with many similar proxy definitions. The use of parent and child bean definitions, along with inner bean definitions, can result in much cleaner and more concise proxy definitions.
#### ** Chinese **

特别是在定义事务性代理时，你可能会有很多类似的代理定义。使用父bean和子bean定义以及内部bean定义，可以使代理定义更加简洁明了。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

First, we create a parent, template, bean definition for the proxy, as follows:
#### ** Chinese **

首先，我们为代理创建一个父、模板、Bean的定义，具体如下。
<!-- tabs:end -->


```xml
<bean id="txProxyTemplate" abstract="true"
        class="org.springframework.transaction.interceptor.TransactionProxyFactoryBean">
    <property name="transactionManager" ref="transactionManager"/>
    <property name="transactionAttributes">
        <props>
            <prop key="*">PROPAGATION_REQUIRED</prop>
        </props>
    </property>
</bean>
```

<!-- tabs:start -->

#### ** English **

This is never instantiated itself, so it can actually be incomplete. Then, each proxy that needs to be created is a child bean definition, which wraps the target of the proxy as an inner bean definition, since the target is never used on its own anyway. The following example shows such a child bean:
#### ** Chinese **

这一点本身从来没有实例化过，所以实际上可以是不完整的。然后，每个需要创建的代理都是一个子bean定义，它将代理的目标作为一个内部的bean定义包裹起来，因为反正目标从来不会自己使用。下面的例子显示了这样一个子Bean。
<!-- tabs:end -->


```xml
<bean id="myService" parent="txProxyTemplate">
    <property name="target">
        <bean class="org.springframework.samples.MyServiceImpl">
        </bean>
    </property>
</bean>
```

<!-- tabs:start -->

#### ** English **

You can override properties from the parent template. In the following example, we override the transaction propagation settings:
#### ** Chinese **

你可以覆盖父模板中的属性。在下面的例子中，我们覆盖了事务传播设置。
<!-- tabs:end -->


```xml
<bean id="mySpecialService" parent="txProxyTemplate">
    <property name="target">
        <bean class="org.springframework.samples.MySpecialServiceImpl">
        </bean>
    </property>
    <property name="transactionAttributes">
        <props>
            <prop key="get*">PROPAGATION_REQUIRED,readOnly</prop>
            <prop key="find*">PROPAGATION_REQUIRED,readOnly</prop>
            <prop key="load*">PROPAGATION_REQUIRED,readOnly</prop>
            <prop key="store*">PROPAGATION_REQUIRED</prop>
        </props>
    </property>
</bean>
```

<!-- tabs:start -->

#### ** English **

Note that in the parent bean example, we explicitly marked the parent bean definition as being abstract by setting the `abstract` attribute to `true`, as described [previously](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-child-bean-definitions), so that it may not actually ever be instantiated. Application contexts (but not simple bean factories), by default, pre-instantiate all singletons. Therefore, it is important (at least for singleton beans) that, if you have a (parent) bean definition that you intend to use only as a template, and this definition specifies a class, you must make sure to set the `abstract` attribute to `true`. Otherwise, the application context actually tries to pre-instantiate it.
#### ** Chinese **

注意，在父bean的例子中，我们通过将`abstract`属性设置为`true`，显式地将父bean定义标记为抽象的，正如[前文](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-child-bean-definitions)所描述的那样，这样，它可能永远不会被实例化。应用程序上下文（但不是简单的Bean工厂），默认情况下，会对所有的单子进行预实例化。因此，重要的是（至少对于单子类Bean来说），如果你有一个（父类）Bean定义，而你只打算将其作为模板使用，并且这个定义指定了一个类，你必须确保将`abstract`属性设置为`true`。否则，应用程序上下文实际上会试图对其进行预实例化。
<!-- tabs:end -->


### **6.6. Creating AOP Proxies Programmatically with the** **`ProxyFactory`** 

<!-- tabs:start -->

#### ** English **

It is easy to create AOP proxies programmatically with Spring. This lets you use Spring AOP without dependency on Spring IoC.
#### ** Chinese **

使用Spring很容易用程序化方式创建AOP代理。这让你可以在不依赖Spring IoC的情况下使用Spring AOP。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The interfaces implemented by the target object are automatically proxied. The following listing shows creation of a proxy for a target object, with one interceptor and one advisor:
#### ** Chinese **

目标对象实现的接口自动被代理。下面的列表显示了为目标对象创建一个代理，有一个拦截器和一个顾问。
<!-- tabs:end -->


```java
ProxyFactory factory = new ProxyFactory(myBusinessInterfaceImpl);
factory.addAdvice(myMethodInterceptor);
factory.addAdvisor(myAdvisor);
MyBusinessInterface tb = (MyBusinessInterface) factory.getProxy();
```

<!-- tabs:start -->

#### ** English **

The first step is to construct an object of type `org.springframework.aop.framework.ProxyFactory`. You can create this with a target object, as in the preceding example, or specify the interfaces to be proxied in an alternate constructor.
#### ** Chinese **

第一步是构造一个类型为`org.springframework.aop.framework.ProxyFactory`的对象。你可以像前面的例子一样，用目标对象来创建，或者在另一个构造函数中指定要被代理的接口。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can add advices (with interceptors as a specialized kind of advice), advisors, or both and manipulate them for the life of the `ProxyFactory`. If you add an `IntroductionInterceptionAroundAdvisor`, you can cause the proxy to implement additional interfaces.
#### ** Chinese **

你可以添加劝告（用拦截器作为一种专门的劝告）、劝告器，或者同时添加劝告，并在`ProxyFactory`的生命中操纵它们。如果你添加了`IntroductionInterceptionAroundAdvisor`，你可以导致代理实现额外的接口。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

There are also convenience methods on `ProxyFactory` (inherited from `AdvisedSupport`) that let you add other advice types, such as before and throws advice. `AdvisedSupport` is the superclass of both `ProxyFactory` and `ProxyFactoryBean`.
#### ** Chinese **

`ProxyFactory`（继承自`AdvisedSupport`）上也有一些方便的方法，可以让你添加其他的建议类型，例如之前和抛出建议。 `AdvisedSupport`是`ProxyFactory`和`ProxyFactoryBean`的超级类。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Integrating AOP proxy creation with the IoC framework is best practice in most applications. We recommend that you externalize configuration from Java code with AOP, as you should in general.
#### ** Chinese **

将 AOP 代理创建与 IoC 框架集成是大多数应用程序的最佳实践。我们建议您将Java代码中的配置与AOP一起外部化，一般情况下，您应该这样做。
<!-- tabs:end -->


### **6.7. Manipulating Advised Objects** 

<!-- tabs:start -->

#### ** English **

However you create AOP proxies, you can manipulate them BY using the `org.springframework.aop.framework.Advised` interface. Any AOP proxy can be cast to this interface, no matter which other interfaces it implements. This interface includes the following methods:
#### ** Chinese **

无论你如何创建AOP代理，你都可以通过使用`org.springframework.aop.framework.Advised`接口来操作它们。任何AOP代理都可以被投射到这个接口上，不管它实现了哪些其他接口。这个接口包括以下方法。
<!-- tabs:end -->


```java
Advisor[] getAdvisors();

void addAdvice(Advice advice) throws AopConfigException;

void addAdvice(int pos, Advice advice) throws AopConfigException;

void addAdvisor(Advisor advisor) throws AopConfigException;

void addAdvisor(int pos, Advisor advisor) throws AopConfigException;

int indexOf(Advisor advisor);

boolean removeAdvisor(Advisor advisor) throws AopConfigException;

void removeAdvisor(int index) throws AopConfigException;

boolean replaceAdvisor(Advisor a, Advisor b) throws AopConfigException;

boolean isFrozen();
```

<!-- tabs:start -->

#### ** English **

The `getAdvisors()` method returns an `Advisor` for every advisor, interceptor, or other advice type that has been added to the factory. If you added an `Advisor`, the returned advisor at this index is the object that you added. If you added an interceptor or other advice type, Spring wrapped this in an advisor with a pointcut that always returns `true`. Thus, if you added a `MethodInterceptor`, the advisor returned for this index is a `DefaultPointcutAdvisor` that returns your `MethodInterceptor` and a pointcut that matches all classes and methods.
#### ** Chinese **

`getAdvisors()`方法会返回一个`Advisor`，用于添加到工厂的每个顾问、拦截器或其他建议类型。如果您添加了一个 `Advisor`，那么在这个索引处返回的顾问就是您添加的对象。如果您添加了一个拦截器或其他建议类型，Spring会将其封装在一个总是返回`true`的点方法的顾问中。因此，如果您添加了 `MethodInterceptor`，那么为这个索引返回的顾问是一个`DefaultPointcutAdvisor`，它返回您的`MethodInterceptor`和一个与所有类和方法相匹配的点切口。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The `addAdvisor()` methods can be used to add any `Advisor`. Usually, the advisor holding pointcut and advice is the generic `DefaultPointcutAdvisor`, which you can use with any advice or pointcut (but not for introductions).
#### ** Chinese **

`addAdvisor()`方法可以用来添加任何`Advisor`。通常，持有点cut和建议的Advisor是通用的`DefaultPointcutAdvisor`，你可以使用任何建议或点cut（但不能用于介绍）。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

By default, it is possible to add or remove advisors or interceptors even once a proxy has been created. The only restriction is that it is impossible to add or remove an introduction advisor, as existing proxies from the factory do not show the interface change. (You can obtain a new proxy from the factory to avoid this problem.)
#### ** Chinese **

默认情况下，即使在创建了代理之后，也可以添加或删除顾问或拦截器。唯一的限制是无法添加或删除引入顾问，因为现有的代理工厂中的代理不会显示接口变化。(你可以从工厂获得一个新的代理来避免这个问题)。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following example shows casting an AOP proxy to the `Advised` interface and examining and manipulating its advice:
#### ** Chinese **

下面的例子显示了向`Advised`界面铸造一个AOP代理，并检查和操作其建议。
<!-- tabs:end -->


```java
Advised advised = (Advised) myObject;
Advisor[] advisors = advised.getAdvisors();
int oldAdvisorCount = advisors.length;
System.out.println(oldAdvisorCount + " advisors");

// Add an advice like an interceptor without a pointcut
// Will match all proxied methods
// Can use for interceptors, before, after returning or throws advice
advised.addAdvice(new DebugInterceptor());

// Add selective advice using a pointcut
advised.addAdvisor(new DefaultPointcutAdvisor(mySpecialPointcut, myAdvice));

assertEquals("Added two advisors", oldAdvisorCount + 2, advised.getAdvisors().length);
```

<!-- tabs:start -->

#### ** English **

It is questionable whether it is advisable (no pun intended) to modify advice on a business object in production, although there are, no doubt, legitimate usage cases. However, it can be very useful in development (for example, in tests). We have sometimes found it very useful to be able to add test code in the form of an interceptor or other advice, getting inside a method invocation that we want to test. (For example, the advice can get inside a transaction created for that method, perhaps to run SQL to check that a database was correctly updated, before marking the transaction for roll back.)
#### ** Chinese **

在生产中修改业务对象的建议是否可取（不是双关语）是值得商榷的，尽管毫无疑问，有合法的用例。但是，在开发中（例如，在测试中），它可以非常有用。我们有时会发现，以拦截器或其他建议的形式添加测试代码，进入到我们要测试的方法调用内部，是非常有用的。(例如，建议可以进入到为该方法创建的事务中，也许是为了运行SQL来检查数据库是否正确更新了，然后再标记事务回滚)。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Depending on how you created the proxy, you can usually set a `frozen` flag. In that case, the `Advised` `isFrozen()` method returns `true`, and any attempts to modify advice through addition or removal results in an `AopConfigException`. The ability to freeze the state of an advised object is useful in some cases (for example, to prevent calling code removing a security interceptor).
#### ** Chinese **

根据您创建代理的方式，您通常可以设置一个 `frozen` 标志。在这种情况下，`Advised` `isFrozen()`方法会返回`true`，而任何通过添加或删除来修改建议的尝试都会导致`AopConfigException`。冻结建议对象的状态的能力在某些情况下很有用（例如，防止调用代码删除安全拦截器）。
<!-- tabs:end -->


### **6.8. Using the "auto-proxy" facility** 

<!-- tabs:start -->

#### ** English **

So far, we have considered explicit creation of AOP proxies by using a `ProxyFactoryBean` or similar factory bean.
#### ** Chinese **

到目前为止，我们已经考虑了通过使用`ProxyFactoryBean`或类似的工厂豆来显式创建AOP代理。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Spring also lets us use “auto-proxy” bean definitions, which can automatically proxy selected bean definitions. This is built on Spring’s “bean post processor” infrastructure, which enables modification of any bean definition as the container loads.
#### ** Chinese **

Spring还允许我们使用 "自动代理 "Bean定义，它可以自动代理选定的Bean定义。这是建立在Spring的 "bean后处理器 "基础架构上的，它可以在容器加载时修改任何bean定义。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

In this model, you set up some special bean definitions in your XML bean definition file to configure the auto-proxy infrastructure. This lets you declare the targets eligible for auto-proxying. You need not use `ProxyFactoryBean`.
#### ** Chinese **

在这个模型中，你在你的XML bean定义文件中设置了一些特殊的bean定义来配置自动代理基础设施。这让你可以声明有资格进行自动代理的目标。你不需要使用`ProxyFactoryBean`。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

There are two ways to do this:
#### ** Chinese **

有两种方法可以做到这一点。
<!-- tabs:end -->


### **6.8.1. Auto-proxy Bean Definitions** 

<!-- tabs:start -->

#### ** English **

This section covers the auto-proxy creators provided by the `org.springframework.aop.framework.autoproxy` package.
#### ** Chinese **

本节涵盖了由`org.springframework.aop.framework.autoproxy`包提供的自动代理创建器。
<!-- tabs:end -->


### **`BeanNameAutoProxyCreator`** 

<!-- tabs:start -->

#### ** English **

The `BeanNameAutoProxyCreator` class is a `BeanPostProcessor` that automatically creates AOP proxies for beans with names that match literal values or wildcards. The following example shows how to create a `BeanNameAutoProxyCreator` bean:
#### ** Chinese **

`BeanNameAutoProxyCreator`类是一个`BeanPostProcessor`类，它可以自动为具有匹配字面值或通配符的bean创建AOP代理。下面的例子显示了如何创建一个`BeanNameAutoProxyCreator` bean。
<!-- tabs:end -->


```xml
<bean class="org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator">
    <property name="beanNames" value="jdk*,onlyJdk"/>
    <property name="interceptorNames">
        <list>
            <value>myInterceptor</value>
        </list>
    </property>
</bean>
```

<!-- tabs:start -->

#### ** English **

As with `ProxyFactoryBean`, there is an `interceptorNames` property rather than a list of interceptors, to allow correct behavior for prototype advisors. Named “interceptors” can be advisors or any advice type.
#### ** Chinese **

与`ProxyFactoryBean`一样，有一个`interceptorNames`属性，而不是一个拦截器列表，以允许原型顾问的正确行为。命名的 "拦截器 "可以是顾问或任何建议类型。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

As with auto-proxying in general, the main point of using `BeanNameAutoProxyCreator` is to apply the same configuration consistently to multiple objects, with minimal volume of configuration. It is a popular choice for applying declarative transactions to multiple objects.
#### ** Chinese **

与一般的自动代理一样，使用`BeanNameAutoProxyCreator`的主要目的是将相同的配置一致地应用到多个对象上，并将配置量降到最低。它是将声明性事务应用于多个对象的流行选择。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Bean definitions whose names match, such as `jdkMyBean` and `onlyJdk` in the preceding example, are plain old bean definitions with the target class. An AOP proxy is automatically created by the `BeanNameAutoProxyCreator`. The same advice is applied to all matching beans. Note that, if advisors are used (rather than the interceptor in the preceding example), the pointcuts may apply differently to different beans.
#### ** Chinese **

名称匹配的Bean定义，例如前面例子中的`jdkMyBean`和`onlyJdk`，都是目标类的普通Bean定义。一个AOP代理是由`BeanNameAutoProxyCreator`自动创建的。同样的建议被应用于所有匹配的Bean。请注意，如果使用了顾问（而不是前面的例子中的拦截器），那么点捷径可能会对不同的Bean有不同的应用。
<!-- tabs:end -->


### **`DefaultAdvisorAutoProxyCreator`** 

<!-- tabs:start -->

#### ** English **

A more general and extremely powerful auto-proxy creator is `DefaultAdvisorAutoProxyCreator`. This automagically applies eligible advisors in the current context, without the need to include specific bean names in the auto-proxy advisor’s bean definition. It offers the same merit of consistent configuration and avoidance of duplication as `BeanNameAutoProxyCreator`.
#### ** Chinese **

一个更通用且功能极其强大的自动代理创建器是`DefaultAdvisorAutoProxyCreator`。它可以在当前上下文中自动应用符合条件的顾问，而不需要在自动代理顾问的Bean定义中包含特定的Bean名。它具有与 `BeanNameAutoProxyCreator`相同的优点，即配置一致和避免重复。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Using this mechanism involves:
#### ** Chinese **

使用这一机制涉及：
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

- By using an auto-proxy creator that refers to specific beans in the current context.

- A special case of auto-proxy creation that deserves to be considered separately: auto-proxy creation driven by source-level metadata attributes.

- Specifying a `DefaultAdvisorAutoProxyCreator` bean definition.

- Specifying any number of advisors in the same or related contexts. Note that these must be advisors, not interceptors or other advices. This is necessary, because there must be a pointcut to evaluate, to check the eligibility of each advice to candidate bean definitions.

#### ** Chinese **

- 通过使用自动代理创建器，在当前上下文中引用特定的Bean。

- 一个值得单独考虑的自动代理创建的特殊情况：由源级元数据属性驱动的自动代理创建。

- 指定一个`DefaultAdvisorAutoProxyCreator` bean定义。

- 在相同或相关的上下文中指定任意数量的顾问。注意，这些必须是顾问，而不是拦截器或其他顾问。这是必要的，因为必须要有一个指向性的评价，以检查每个顾问对候选Bean定义的资格。

<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

The `DefaultAdvisorAutoProxyCreator` automatically evaluates the pointcut contained in each advisor, to see what (if any) advice it should apply to each business object (such as `businessObject1` and `businessObject2` in the example).
#### ** Chinese **

`DefaultAdvisorAutoProxyCreator`会自动评估每个顾问中包含的点cut，以查看它应该对每个业务对象（例如示例中的`businessObject1`和`businessObject2`）应用什么（如果有的话）建议。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

This means that any number of advisors can be applied automatically to each business object. If no pointcut in any of the advisors matches any method in a business object, the object is not proxied. As bean definitions are added for new business objects, they are automatically proxied if necessary.
#### ** Chinese **

这意味着可以将任意数量的顾问自动应用于每个业务对象。如果任何一个顾问中的点切口都不与业务对象中的任何方法匹配，那么该对象就不会被代理。随着新业务对象的bean定义被添加到新的业务对象中，如果需要的话，就会自动进行proxied。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Auto-proxying in general has the advantage of making it impossible for callers or dependencies to obtain an un-advised object. Calling `getBean("businessObject1")` on this `ApplicationContext` returns an AOP proxy, not the target business object. (The “inner bean” idiom shown earlier also offers this benefit.)
#### ** Chinese **

一般情况下，自动代理的好处是使调用者或依赖对象无法获得一个未授权的对象。在这个`ApplicationContext`上调用`getBean("businessObject1")`会返回一个AOP代理，而不是目标业务对象。(前面显示的 "内部Bean "成语也有这个好处。)
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following example creates a `DefaultAdvisorAutoProxyCreator` bean and the other elements discussed in this section:
#### ** Chinese **

下面的示例创建了一个`DefaultAdvisorAutoProxyCreator` Bean和本节中讨论的其他元素。
<!-- tabs:end -->


```xml
<bean class="org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator"/>

<bean class="org.springframework.transaction.interceptor.TransactionAttributeSourceAdvisor">
    <property name="transactionInterceptor" ref="transactionInterceptor"/>
</bean>

<bean id="customAdvisor" class="com.mycompany.MyAdvisor"/>

<bean id="businessObject1" class="com.mycompany.BusinessObject1">
    <!-- Properties omitted -->
</bean>

<bean id="businessObject2" class="com.mycompany.BusinessObject2"/>
```

<!-- tabs:start -->

#### ** English **

The `DefaultAdvisorAutoProxyCreator` is very useful if you want to apply the same advice consistently to many business objects. Once the infrastructure definitions are in place, you can add new business objects without including specific proxy configuration. You can also easily drop in additional aspects (for example, tracing or performance monitoring aspects) with minimal change to configuration.
#### ** Chinese **

`DefaultAdvisorAutoProxyCreator`如果您想将相同的建议一致地应用到许多业务对象上，那么这个</x>非常有用。一旦基础架构定义到位，您可以添加新的业务对象，而不需要包括特定的代理配置。您还可以轻松地添加其他方面（例如，跟踪或性能监控方面），只需对配置进行最小的更改。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The `DefaultAdvisorAutoProxyCreator` offers support for filtering (by using a naming convention so that only certain advisors are evaluated, which allows the use of multiple, differently configured, AdvisorAutoProxyCreators in the same factory) and ordering. Advisors can implement the `org.springframework.core.Ordered` interface to ensure correct ordering if this is an issue. The `TransactionAttributeSourceAdvisor` used in the preceding example has a configurable order value. The default setting is unordered.
#### ** Chinese **

`DefaultAdvisorAutoProxyCreator`提供了对过滤（通过使用一个命名公约，以便只评估某些顾问，这允许在同一个工厂中使用多个不同配置的AdvisorAutoProxyCreator）和排序的支持。顾问们可以实现`org.springframework.core.Ordered`接口来确保正确的排序，如果这是一个问题。前面例子中使用的`TransactionAttributeSourceAdvisor`有一个可配置的顺序值。默认设置为无序。
<!-- tabs:end -->


### **6.9. Using** **`TargetSource`** ** Implementations** 

<!-- tabs:start -->

#### ** English **

Spring offers the concept of a `TargetSource`, expressed in the `org.springframework.aop.TargetSource` interface. This interface is responsible for returning the “target object” that implements the join point. The `TargetSource` implementation is asked for a target instance each time the AOP proxy handles a method invocation.
#### ** Chinese **

Spring提供了一个`TargetSource`的概念，用`org.springframework.aop.TargetSource`接口表示。这个接口负责返回实现连接点的 "目标对象"。`TargetSource`每次AOP代理处理一个方法调用时，都会要求`TargetSource`实现一个目标实例。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Developers who use Spring AOP do not normally need to work directly with `TargetSource` implementations, but this provides a powerful means of supporting pooling, hot swappable, and other sophisticated targets. For example, a pooling `TargetSource` can return a different target instance for each invocation, by using a pool to manage instances.
#### ** Chinese **

使用Spring AOP的开发人员通常不需要直接使用`TargetSource`实现，但这为支持池化、热插拔和其他复杂的目标提供了强大的手段。例如，池化的`TargetSource`可以通过使用池来管理实例，为每次调用返回不同的目标实例。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

If you do not specify a `TargetSource`, a default implementation is used to wrap a local object. The same target is returned for each invocation (as you would expect).
#### ** Chinese **

如果没有指定`TargetSource`，则使用默认的实现来封装一个本地对象。每次调用都会返回相同的目标（正如你所期望的那样）。
<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

The rest of this section describes the standard target sources provided with Spring and how you can use them.
#### ** Chinese **

本节的其余部分介绍了Spring提供的标准目标源，以及如何使用它们。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

When using a custom target source, your target will usually need to be a prototype rather than a singleton bean definition. This allows Spring to create a new target instance when required.
#### ** Chinese **

当使用自定义目标源时，你的目标通常需要是一个原型，而不是一个单子bean定义。这允许Spring在需要时创建一个新的目标实例。
<!-- tabs:end -->


### **6.9.1. Hot-swappable Target Sources** 

<!-- tabs:start -->

#### ** English **

The `org.springframework.aop.target.HotSwappableTargetSource` exists to let the target of an AOP proxy be switched while letting callers keep their references to it.
#### ** Chinese **

`org.springframework.aop.target.HotSwappableTargetSource`的存在是为了让AOP代理的目标被切换，同时让调用者保留对它的引用。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Changing the target source’s target takes effect immediately. The `HotSwappableTargetSource` is thread-safe.
#### ** Chinese **

改变目标源的目标会立即生效。`HotSwappableTargetSource`是线程安全的。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can change the target by using the `swap()` method on HotSwappableTargetSource, as the follow example shows:
#### ** Chinese **

你可以通过使用HotSwappableTargetSource上的`swap()`方法来改变目标，如下例所示。
<!-- tabs:end -->


```java
HotSwappableTargetSource swapper = (HotSwappableTargetSource) beanFactory.getBean("swapper");
Object oldTarget = swapper.swap(newTarget);
```

<!-- tabs:start -->

#### ** English **

The following example shows the required XML definitions:
#### ** Chinese **

下面的例子显示了所需的XML定义。
<!-- tabs:end -->


```xml
<bean id="initialTarget" class="mycompany.OldTarget"/>

<bean id="swapper" class="org.springframework.aop.target.HotSwappableTargetSource">
    <constructor-arg ref="initialTarget"/>
</bean>

<bean id="swappable" class="org.springframework.aop.framework.ProxyFactoryBean">
    <property name="targetSource" ref="swapper"/>
</bean>
```

<!-- tabs:start -->

#### ** English **

The preceding `swap()` call changes the target of the swappable bean. Clients that hold a reference to that bean are unaware of the change but immediately start hitting the new target.
#### ** Chinese **

前面的`swap()`调用改变了可交换Bean的目标。持有对该Bean的引用的客户端并没有意识到这一变化，但会立即开始攻击新的目标。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Although this example does not add any advice (it is not necessary to add advice to use a `TargetSource`), any `TargetSource` can be used in conjunction with arbitrary advice.
#### ** Chinese **

虽然这个例子没有添加任何建议（使用`TargetSource`不需要添加建议），但任何`TargetSource`都可以和任意建议一起使用。
<!-- tabs:end -->


### **6.9.2. Pooling Target Sources** 

<!-- tabs:start -->

#### ** English **

Using a pooling target source provides a similar programming model to stateless session EJBs, in which a pool of identical instances is maintained, with method invocations going to free objects in the pool.
#### ** Chinese **

使用池化目标源提供了一个类似于无状态会话EJB的编程模型，在这个模型中，一个相同的实例池被维护，方法调用将释放池中的对象。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

A crucial difference between Spring pooling and SLSB pooling is that Spring pooling can be applied to any POJO. As with Spring in general, this service can be applied in a non-invasive way.
#### ** Chinese **

Spring pooling和SLSB pooling的一个重要区别是，Spring pooling可以应用于任何POJO。就像Spring一般，这项服务可以以非侵入性的方式应用于任何POJO。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Spring provides support for Commons Pool 2.2, which provides a fairly efficient pooling implementation. You need the `commons-pool` Jar on your application’s classpath to use this feature. You can also subclass `org.springframework.aop.target.AbstractPoolingTargetSource` to support any other pooling API.
#### ** Chinese **

Spring提供了对Commons Pool 2.2的支持，它提供了相当有效的池化实现。你需要在应用程序的classpath上的`commons-pool` Jar来使用这个功能。你也可以子类`org.springframework.aop.target.AbstractPoolingTargetSource`来支持任何其他池化API。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Commons Pool 1.5+ is also supported but is deprecated as of Spring Framework 4.2.
#### ** Chinese **

Commons Pool 1.5 也支持，但从Spring Framework 4.2开始，Commons Pool 1.5 已经被淘汰。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following listing shows an example configuration:
#### ** Chinese **

下面列出了一个配置的例子。
<!-- tabs:end -->


```xml
<bean id="businessObjectTarget" class="com.mycompany.MyBusinessObject"
        scope="prototype">
    ... properties omitted
</bean>

<bean id="poolTargetSource" class="org.springframework.aop.target.CommonsPool2TargetSource">
    <property name="targetBeanName" value="businessObjectTarget"/>
    <property name="maxSize" value="25"/>
</bean>

<bean id="businessObject" class="org.springframework.aop.framework.ProxyFactoryBean">
    <property name="targetSource" ref="poolTargetSource"/>
    <property name="interceptorNames" value="myInterceptor"/>
</bean>
```

<!-- tabs:start -->

#### ** English **

Note that the target object (`businessObjectTarget` in the preceding example) must be a prototype. This lets the `PoolingTargetSource` implementation create new instances of the target to grow the pool as necessary. See the [javadoc of ](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframeworkaop/target/AbstractPoolingTargetSource.html)[`AbstractPoolingTargetSource`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframeworkaop/target/AbstractPoolingTargetSource.html) and the concrete subclass you wish to use for information about its properties. `maxSize` is the most basic and is always guaranteed to be present.
#### ** Chinese **

注意，目标对象（`businessObjectTarget`中的`businessObjectTarget`）必须是一个原型。这让 `PoolingTargetSource`实现可以根据需要创建目标的新实例来增长池。有关其属性的信息，请参见](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframeworkaop/target/AbstractPoolingTargetSource.html)[`AbstractPoolingTargetSource`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframeworkaop/target/AbstractPoolingTargetSource.html)的[javadoc](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframeworkaop/target/AbstractPoolingTargetSource.html)和你希望使用的具体子类。 `maxSize`是最基本的，并且总是保证存在。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

In this case, `myInterceptor` is the name of an interceptor that would need to be defined in the same IoC context. However, you need not specify interceptors to use pooling. If you want only pooling and no other advice, do not set the `interceptorNames` property at all.
#### ** Chinese **

在这种情况下，`myInterceptor`是需要在同一IoC上下文中定义的拦截器的名称。但是，您不需要指定拦截器来使用池化。如果您只想要池化而不需要其他建议，请完全不要设置`interceptorNames`属性。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can configure Spring to be able to cast any pooled object to the `org.springframework.aop.target.PoolingConfig` interface, which exposes information about the configuration and current size of the pool through an introduction. You need to define an advisor similar to the following:
#### ** Chinese **

您可以将Spring配置为能够将任何池对象投向`org.springframework.aop.target.PoolingConfig`接口，该接口通过一个介绍来公开池的配置和当前池的大小信息。你需要定义一个类似于下面的顾问。
<!-- tabs:end -->


```xml
<bean id="poolConfigAdvisor" class="org.springframework.beans.factory.config.MethodInvokingFactoryBean">
    <property name="targetObject" ref="poolTargetSource"/>
    <property name="targetMethod" value="getPoolingConfigMixin"/>
</bean>
```

<!-- tabs:start -->

#### ** English **

This advisor is obtained by calling a convenience method on the `AbstractPoolingTargetSource` class, hence the use of `MethodInvokingFactoryBean`. This advisor’s name (`poolConfigAdvisor`, here) must be in the list of interceptors names in the `ProxyFactoryBean` that exposes the pooled object.
#### ** Chinese **

这个顾问通过调用`AbstractPoolingTargetSource`类上的方便方法获得，因此使用了`MethodInvokingFactoryBean`。这个顾问的名字（`poolConfigAdvisor`，这里）必须在暴露池对象的`ProxyFactoryBean`中的拦截器名称列表中。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The cast is defined as follows:
#### ** Chinese **

铸造的定义如下：
<!-- tabs:end -->


```java
PoolingConfig conf = (PoolingConfig) beanFactory.getBean("businessObject");
System.out.println("Max pool size is " + conf.getMaxSize());
```

<!-- tabs:start -->

#### ** English **

Pooling stateless service objects is not usually necessary. We do not believe it should be the default choice, as most stateless objects are naturally thread safe, and instance pooling is problematic if resources are cached.
#### ** Chinese **

通常不需要对无状态服务对象进行池化。我们认为这不应该是默认的选择，因为大多数无状态对象自然是线程安全的，如果资源被缓存，实例池化就会有问题。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Simpler pooling is available by using auto-proxying. You can set the `TargetSource` implementations used by any auto-proxy creator.
#### ** Chinese **

通过使用自动代理，可以实现更简单的池化。您可以设置任何自动代理创建者使用的`TargetSource`实现。
<!-- tabs:end -->


### **6.9.3. Prototype Target Sources** 

<!-- tabs:start -->

#### ** English **

Setting up a “prototype” target source is similar to setting up a pooling `TargetSource`. In this case, a new instance of the target is created on every method invocation. Although the cost of creating a new object is not high in a modern JVM, the cost of wiring up the new object (satisfying its IoC dependencies) may be more expensive. Thus, you should not use this approach without very good reason.
#### ** Chinese **

设置 "原型 "目标源类似于设置池化`TargetSource`。在这种情况下，每次方法调用时都会创建一个新的目标实例。虽然在现代的JVM中，创建一个新对象的成本并不高，但是为新对象布线（满足其IoC依赖性）的成本可能会更高。因此，没有非常充分的理由，你不应该使用这种方法。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

To do this, you could modify the `poolTargetSource` definition shown earlier as follows (we also changed the name, for clarity):
#### ** Chinese **

要做到这一点，你可以修改`poolTargetSource`的定义，如下所示（为了清楚起见，我们还修改了名称）。
<!-- tabs:end -->


```xml
<bean id="prototypeTargetSource" class="org.springframework.aop.target.PrototypeTargetSource">
    <property name="targetBeanName" ref="businessObjectTarget"/>
</bean>
```

<!-- tabs:start -->

#### ** English **

The only property is the name of the target bean. Inheritance is used in the `TargetSource` implementations to ensure consistent naming. As with the pooling target source, the target bean must be a prototype bean definition.
#### ** Chinese **

唯一的属性是目标Bean的名称。在`TargetSource`实现中使用了继承，以确保命名的一致性。与池化目标源一样，目标Bean必须是一个原型Bean定义。
<!-- tabs:end -->


### **6.9.4.** **`ThreadLocal`** ** Target Sources** 

<!-- tabs:start -->

#### ** English **

`ThreadLocal` target sources are useful if you need an object to be created for each incoming request (per thread that is). The concept of a `ThreadLocal` provides a JDK-wide facility to transparently store a resource alongside a thread. Setting up a `ThreadLocalTargetSource` is pretty much the same as was explained for the other types of target source, as the following example shows:
#### ** Chinese **

`ThreadLocal`目标源在你需要为每个传入的请求（每个线程）创建一个对象时非常有用。`ThreadLocal`的概念提供了一个JDK范围内的设施，可以在线程旁边透明地存储资源。设置 `ThreadLocalTargetSource`的方法与其他类型的目标源的设置基本相同，如下例所示。
<!-- tabs:end -->


```xml
<bean id="threadlocalTargetSource" class="org.springframework.aop.target.ThreadLocalTargetSource">
    <property name="targetBeanName" value="businessObjectTarget"/>
</bean>
```

<!-- tabs:start -->

#### ** English **

`ThreadLocal` instances come with serious issues (potentially resulting in memory leaks) when incorrectly using them in multi-threaded and multi-classloader environments. You should always consider wrapping a threadlocal in some other class and never directly use the `ThreadLocal` itself (except in the wrapper class). Also, you should always remember to correctly set and unset (where the latter simply involves a call to `ThreadLocal.set(null)`) the resource local to the thread. Unsetting should be done in any case, since not unsetting it might result in problematic behavior. Spring’s `ThreadLocal` support does this for you and should always be considered in favor of using `ThreadLocal` instances without other proper handling code.
#### ** Chinese **

`ThreadLocal`实例在多线程和多类加载器环境中错误地使用它们会带来严重的问题（可能导致内存泄漏）。您应该始终考虑将线程local封装在其他类中，千万不要直接使用`ThreadLocal`本身（除了在封装类中）。另外，你应该始终记得正确设置和取消设置（后者只需要调用`ThreadLocal.set(null)`）线程的本地资源。在任何情况下都应该取消设置，因为不取消设置可能会导致有问题的行为。Spring的`ThreadLocal`支持为您做了这一点，并且应该始终考虑使用`ThreadLocal`实例而不使用其他适当的处理代码。
<!-- tabs:end -->


### **6.10. Defining New Advice Types** 

<!-- tabs:start -->

#### ** English **

Spring AOP is designed to be extensible. While the interception implementation strategy is presently used internally, it is possible to support arbitrary advice types in addition to the interception around advice, before, throws advice, and after returning advice.
#### ** Chinese **

Spring AOP的设计是可扩展的。虽然目前内部使用的是拦截实现策略，但除了围绕建议的拦截，还可以支持任意的建议类型，在建议前、抛出建议、返回建议后的拦截。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The `org.springframework.aop.framework.adapter` package is an SPI package that lets support for new custom advice types be added without changing the core framework. The only constraint on a custom `Advice` type is that it must implement the `org.aopalliance.aop.Advice` marker interface.
#### ** Chinese **

`org.springframework.aop.framework.adapter`包是一个SPI包，它可以在不改变核心框架的情况下支持新的自定义建议类型。对自定义`Advice`类型的唯一限制是它必须实现`org.aopalliance.aop.Advice`标记接口。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

See the [`org.springframework.aop.framework.adapter`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/aop/framework/adapter/package-frame.html) javadoc for further information.
#### ** Chinese **

更多信息，请参阅 [`org.springframework.aop.framework.adapter`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/aop/framework/adapter/package-frame.html) javadoc。
<!-- tabs:end -->



[下一章](Spring-Framework-5.2.6.RELEASE/Core%20Technologies/7.%20Null-safety.md)


[回目录](Spring-Framework-5.2.6.RELEASE/summary.md)

[回首页](/README)
