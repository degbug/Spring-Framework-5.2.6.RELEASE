# 3. Validation, Data Binding, and Type Conversion

<!-- tabs:start -->

#### ** English **

There are pros and cons for considering validation as business logic, and Spring offers a design for validation (and data binding) that does not exclude either one of them. Specifically, validation should not be tied to the web tier and should be easy to localize, and it should be possible to plug in any available validator. Considering these concerns, Spring provides a `Validator` contract that is both basic and eminently usable in every layer of an application.
#### ** Chinese **

将验证作为业务逻辑来考虑，有利有弊，Spring提供的验证（和数据绑定）设计不排除其中任何一个。具体来说，验证不应该被绑定到web层，并且应该很容易本地化，而且应该可以插入任何可用的验证器。考虑到这些问题，Spring提供了一个`Validator`合约，它既基本又非常适用于应用程序的每一层。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Data binding is useful for letting user input be dynamically bound to the domain model of an application (or whatever objects you use to process user input). Spring provides the aptly named `DataBinder` to do exactly that. The `Validator` and the `DataBinder` make up the `validation` package, which is primarily used in but not limited to the web layer.
#### ** Chinese **

数据绑定对于让用户输入动态绑定到应用程序的域模型（或任何你用来处理用户输入的对象）是非常有用的。Spring提供了名为`DataBinder`的数据绑定器</x>来实现这个功能。`Validator`和`DataBinder`组成了`validation`包，它主要用于但不限于web层。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The `BeanWrapper` is a fundamental concept in the Spring Framework and is used in a lot of places. However, you probably do not need to use the `BeanWrapper` directly. Because this is reference documentation, however, we felt that some explanation might be in order. We explain the `BeanWrapper` in this chapter, since, if you are going to use it at all, you are most likely do so when trying to bind data to objects.
#### ** Chinese **

`BeanWrapper`是Spring框架中的一个基本概念，在很多地方都有使用。但是，你可能不需要直接使用`BeanWrapper`。但是，由于这是参考文档，我们觉得有必要做一些解释。我们在本章中解释了`BeanWrapper`，因为如果你要使用它，你很可能是在试图将数据绑定到对象时使用它。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Spring’s `DataBinder` and the lower-level `BeanWrapper` both use `PropertyEditorSupport` implementations to parse and format property values. The `PropertyEditor` and `PropertyEditorSupport` types are part of the JavaBeans specification and are also explained in this chapter. Spring 3 introduced a `core.convert` package that provides a general type conversion facility, as well as a higher-level “format” package for formatting UI field values. You can use these packages as simpler alternatives to `PropertyEditorSupport` implementations. They are also discussed in this chapter.
#### ** Chinese **

Spring的`DataBinder`和底层的`BeanWrapper`都使用`PropertyEditorSupport`实现来解析和格式化属性值。`PropertyEditor`和`PropertyEditorSupport`类型是JavaBeans规范的一部分，本章也将对其进行解释。Spring 3引入了一个`core.convert`包，它提供了一个通用的类型转换工具，以及一个更高级别的 "格式化 "包，用于格式化UI字段值。你可以使用这些包作为 `PropertyEditorSupport`实现的更简单的替代品。本章中也会讨论这些包。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Spring supports Java Bean Validation through setup infrastructure and an adaptor to Spring’s own `Validator` contract. Applications can enable Bean Validation once globally, as described in [Java Bean Validation](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#validation-beanvalidation), and use it exclusively for all validation needs. In the web layer, applications can further register controller-local Spring `Validator` instances per `DataBinder`, as described in [Configuring a ](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#validation-binder)[`DataBinder`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#validation-binder), which can be useful for plugging in custom validation logic.
#### ** Chinese **

Spring通过设置基础设施和Spring自己的`Validator`合约的适配器支持Java Bean验证。如[Java Bean Validation](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#validation-beanvalidation)中所述，应用程序可以全局启用一次Bean Validation，并将其专门用于所有验证需求。在 Web 层中，应用程序可以进一步注册控制器本地的 Spring `Validator`实例，如 [Configuring a ](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#validation-binder)[`DataBinder`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#validation-binder)中描述的那样，这对于插入自定义验证逻辑非常有用。
<!-- tabs:end -->


### **3.1. Validation by Using Spring’s Validator Interface** 

<!-- tabs:start -->

#### ** English **

Spring features a `Validator` interface that you can use to validate objects. The `Validator` interface works by using an `Errors` object so that, while validating, validators can report validation failures to the `Errors` object.
#### ** Chinese **

Spring提供了一个`Validator`接口，可以用来验证对象。`Validator`接口通过使用`Errors`对象来工作，这样，在验证时，验证器可以将验证失败报告给`Errors`对象。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Consider the following example of a small data object:
#### ** Chinese **

考虑一下下面这个小数据对象的例子。
<!-- tabs:end -->


```java
public class Person {

    private String name;
    private int age;

    // the usual getters and setters...
}
```

<!-- tabs:start -->

#### ** English **

The next example provides validation behavior for the `Person` class by implementing the following two methods of the `org.springframework.validation.Validator` interface:
#### ** Chinese **

下一个示例通过实现`org.springframework.validation.Validator`接口的以下两个方法，为`Person`类提供了验证行为。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

- `supports(Class)`: Can this `Validator` validate instances of the supplied `Class`?

- `validate(Object, org.springframework.validation.Errors)`: Validates the given object and, in case of validation errors, registers those with the given `Errors` object.

#### ** Chinese **

- `supports(Class)`。这个`Validator`能否验证所提供的`Class`的实例？

- `validate(Object, org.springframework.validation.Errors)`: 验证给定对象，并在此情况下，对给定对象进行验证。验证给定对象，如果出现验证错误，则将这些错误注册到给定的`Errors`对象中。

<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

Implementing a `Validator` is fairly straightforward, especially when you know of the `ValidationUtils` helper class that the Spring Framework also provides. The following example implements `Validator` for `Person` instances:
#### ** Chinese **

实现 `Validator`相当简单，特别是当你知道Spring框架也提供了`ValidationUtils`帮助类时，实现`Validator`就更简单了。下面的示例为`Person`实例实现了`Validator`。
<!-- tabs:end -->


```java
public class PersonValidator implements Validator {

    /**
     * This Validator validates only Person instances
     */
    public boolean supports(Class clazz) {
        return Person.class.equals(clazz);
    }

    public void validate(Object obj, Errors e) {
        ValidationUtils.rejectIfEmpty(e, "name", "name.empty");
        Person p = (Person) obj;
        if (p.getAge() < 0) {
            e.rejectValue("age", "negativevalue");
        } else if (p.getAge() > 110) {
            e.rejectValue("age", "too.darn.old");
        }
    }
}
```

<!-- tabs:start -->

#### ** English **

The `static` `rejectIfEmpty(..)` method on the `ValidationUtils` class is used to reject the `name` property if it is `null` or the empty string. Have a look at the [`ValidationUtils`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/validation/ValidationUtils.html) javadoc to see what functionality it provides besides the example shown previously.
#### ** Chinese **

 `ValidationUtils`类上的`static` `rejectIfEmpty(..)`方法用于拒绝`name`属性，如果它是`null`或空字符串，则拒绝它。请查看 [`ValidationUtils`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/validation/ValidationUtils.html) javadoc，看看除了前面的例子外，它还提供了哪些功能。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

While it is certainly possible to implement a single `Validator` class to validate each of the nested objects in a rich object, it may be better to encapsulate the validation logic for each nested class of object in its own `Validator` implementation. A simple example of a “rich” object would be a `Customer` that is composed of two `String` properties (a first and a second name) and a complex `Address` object. `Address` objects may be used independently of `Customer` objects, so a distinct `AddressValidator` has been implemented. If you want your `CustomerValidator` to reuse the logic contained within the `AddressValidator` class without resorting to copy-and-paste, you can dependency-inject or instantiate an `AddressValidator` within your `CustomerValidator`, as the following example shows:
#### ** Chinese **

虽然当然可以实现一个单独的`Validator`类来验证富对象中的每个嵌套对象，但最好是将每个嵌套类的对象的验证逻辑封装在自己的`Validator`实现中。一个简单的 "丰富 "对象的例子是由两个`String`属性（第一个和第二个名字）和一个复杂的`Address`对象组成的`Customer`。 `Address`对象可以独立于`Customer`对象使用，因此已经实现了一个独立的`AddressValidator`。如果你想让你的 `CustomerValidator`重用 `AddressValidator`类中包含的逻辑，而不需要复制粘贴，你可以在你的`CustomerValidator`中依赖注入或实例化一个`AddressValidator`，如下图所示。
<!-- tabs:end -->


```java
public class CustomerValidator implements Validator {

    private final Validator addressValidator;

    public CustomerValidator(Validator addressValidator) {
        if (addressValidator == null) {
            throw new IllegalArgumentException("The supplied [Validator] is " +
                "required and must not be null.");
        }
        if (!addressValidator.supports(Address.class)) {
            throw new IllegalArgumentException("The supplied [Validator] must " +
                "support the validation of [Address] instances.");
        }
        this.addressValidator = addressValidator;
    }

    /**
     * This Validator validates Customer instances, and any subclasses of Customer too
     */
    public boolean supports(Class clazz) {
        return Customer.class.isAssignableFrom(clazz);
    }

    public void validate(Object target, Errors errors) {
        ValidationUtils.rejectIfEmptyOrWhitespace(errors, "firstName", "field.required");
        ValidationUtils.rejectIfEmptyOrWhitespace(errors, "surname", "field.required");
        Customer customer = (Customer) target;
        try {
            errors.pushNestedPath("address");
            ValidationUtils.invokeValidator(this.addressValidator, customer.getAddress(), errors);
        } finally {
            errors.popNestedPath();
        }
    }
}
```

<!-- tabs:start -->

#### ** English **

Validation errors are reported to the `Errors` object passed to the validator. In the case of Spring Web MVC, you can use the `<spring:bind/>` tag to inspect the error messages, but you can also inspect the `Errors` object yourself. More information about the methods it offers can be found in the [javadoc](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframeworkvalidation/Errors.html).
#### ** Chinese **

验证错误被报告到传递给验证器的`Errors`对象。在Spring Web MVC中，你可以使用`<spring:bind/>`标记来检查错误信息，但你也可以自己检查`Errors`对象。关于它提供的方法的更多信息可以在[javadoc](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframeworkvalidation/Errors.html)中找到。
<!-- tabs:end -->


### **3.2. Resolving Codes to Error Messages** 

<!-- tabs:start -->

#### ** English **

We covered databinding and validation. This section covers outputting messages that correspond to validation errors. In the example shown in the [preceding section](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#validator), we rejected the `name` and `age` fields. If we want to output the error messages by using a `MessageSource`, we can do so using the error code we provide when rejecting the field ('name' and 'age' in this case). When you call (either directly, or indirectly, by using, for example, the `ValidationUtils` class) `rejectValue` or one of the other `reject` methods from the `Errors` interface, the underlying implementation not only registers the code you passed in but also registers a number of additional error codes. The `MessageCodesResolver` determines which error codes the `Errors` interface registers. By default, the `DefaultMessageCodesResolver` is used, which (for example) not only registers a message with the code you gave but also registers messages that include the field name you passed to the reject method. So, if you reject a field by using `rejectValue("age", "too.darn.old")`, apart from the `too.darn.old` code, Spring also registers `too.darn.old.age` and `too.darn.old.age.int` (the first includes the field name and the second includes the type of the field). This is done as a convenience to aid developers when targeting error messages.
#### ** Chinese **

我们涵盖了数据库绑定和验证。本节涉及到输出对应于验证错误的消息。在[上节](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#validator)所示的例子中，我们拒绝了`name`和`age`字段。如果我们想通过使用`MessageSource`来输出错误信息，我们可以使用我们在拒绝字段时提供的错误代码（本例中的name和age）来实现。当你调用（直接或间接地，例如使用`ValidationUtils`类）`rejectValue`或其他`Errors`接口中的一个`reject`方法时，底层实现不仅会注册你传递的代码，而且还会注册一些额外的错误代码。`MessageCodesResolver`决定了`Errors`接口注册哪些错误代码。默认情况下，会使用`DefaultMessageCodesResolver`，它（例如）不仅会注册一个带有你所给的代码的消息，而且还会注册包含你传递给拒绝方法的字段名的消息。因此，如果你使用`rejectValue("age", "too.darn.old")`来拒绝一个字段，除了`too.darn.old`代码外，Spring还注册了`too.darn.old.age`和`too.darn.old.age.int`（前者包括字段名，后者包括字段类型）。这样做是为了方便开发者在针对错误信息时提供帮助。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

More information on the `MessageCodesResolver` and the default strategy can be found in the javadoc of [`MessageCodesResolver`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/validation/MessageCodesResolver.html) and [`DefaultMessageCodesResolver`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/validation/DefaultMessageCodesResolver.html), respectively.
#### ** Chinese **

关于`MessageCodesResolver`和默认策略的更多信息，可以在[`MessageCodesResolver`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/validation/MessageCodesResolver.html)和[`DefaultMessageCodesResolver`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/validation/DefaultMessageCodesResolver.html)的javadoc中找到。
<!-- tabs:end -->


### **3.3. Bean Manipulation and the** **`BeanWrapper`** 

<!-- tabs:start -->

#### ** English **

The `org.springframework.beans` package adheres to the JavaBeans standard. A JavaBean is a class with a default no-argument constructor and that follows a naming convention where (for example) a property named `bingoMadness` would have a setter method `setBingoMadness(..)` and a getter method `getBingoMadness()`. For more information about JavaBeans and the specification, see [javabeans](https://docs.oracle.com/javase/8/docs/api/java/beans/package-summary.html).
#### ** Chinese **

`org.springframework.beans`包遵循JavaBean标准。JavaBean是一个具有默认无参数构造函数的类，它遵循一个命名惯例，其中（例如）一个名为`bingoMadness`的属性将有一个setter方法`setBingoMadness(..)`和一个getter方法`getBingoMadness()`。有关JavaBeans和规范的更多信息，请参阅[javabeans](https://docs.oracle.com/javase/8/docs/api/java/beans/package-summary.html)。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

One quite important class in the beans package is the `BeanWrapper` interface and its corresponding implementation (`BeanWrapperImpl`). As quoted from the javadoc, the `BeanWrapper` offers functionality to set and get property values (individually or in bulk), get property descriptors, and query properties to determine if they are readable or writable. Also, the `BeanWrapper` offers support for nested properties, enabling the setting of properties on sub-properties to an unlimited depth. The `BeanWrapper` also supports the ability to add standard JavaBeans `PropertyChangeListeners` and `VetoableChangeListeners`, without the need for supporting code in the target class. Last but not least, the `BeanWrapper` provides support for setting indexed properties. The `BeanWrapper` usually is not used by application code directly but is used by the `DataBinder` and the `BeanFactory`.
#### ** Chinese **

beans包中一个相当重要的类是`BeanWrapper`接口及其相应的实现（`BeanWrapperImpl`）。正如从javadoc中引用的那样，`BeanWrapper`提供了设置和获取属性值（单独或批量）、获取属性描述符，以及查询属性以确定它们是否可读或可写的功能。此外，`BeanWrapper`还提供了对嵌套属性的支持，可以对子属性的属性进行无限深度的设置。`BeanWrapper`还支持添加标准的JavaBeans `PropertyChangeListeners`和`VetoableChangeListeners`，无需在目标类中支持代码。最后，`BeanWrapper`提供了对设置索引属性的支持。`BeanWrapper`通常不会被应用程序代码直接使用，而是被`DataBinder`和`BeanFactory`使用。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The way the `BeanWrapper` works is partly indicated by its name: it wraps a bean to perform actions on that bean, such as setting and retrieving properties.
#### ** Chinese **

`BeanWrapper`的工作方式在一定程度上由它的名字来说明：它包装一个bean来执行对该bean的操作，例如设置和检索属性。
<!-- tabs:end -->


### **3.3.1. Setting and Getting Basic and Nested Properties** 

<!-- tabs:start -->

#### ** English **

Setting and getting properties is done through the `setPropertyValue` and `getPropertyValue` overloaded method variants of `BeanWrapper`. See their Javadoc for details. The below table shows some examples of these conventions:
#### ** Chinese **

设置和获取属性是通过`BeanWrapper`的`setPropertyValue`和`getPropertyValue`的重载方法变体来完成的。详情请看它们的Javadoc。下表显示了这些约定的一些例子。
<!-- tabs:end -->


Expression | Explanation 
-|-
name | Indicates the property name that corresponds to the getName() or isName() and setName(..) methods. 
account.name | Indicates the nested property name of the property account that corresponds to (for example) the getAccount().setName() or getAccount().getName() methods. 
account[2] | Indicates the third element of the indexed property account. Indexed properties can be of type array, list, or other naturally ordered collection. 
account[COMPANYNAME] | Indicates the value of the map entry indexed by the COMPANYNAME key of the account Map property. 


<!-- tabs:start -->

#### ** English **

(This next section is not vitally important to you if you do not plan to work with the `BeanWrapper` directly. If you use only the `DataBinder` and the `BeanFactory` and their default implementations, you should skip ahead to the [section on ](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-beans-conversion)[`PropertyEditors`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-beans-conversion).)
#### ** Chinese **

如果你不打算直接使用 `BeanWrapper`，那么下一节对你来说并不重要。如果你只使用`DataBinder`和`BeanFactory`以及它们的默认实现，你应该提前跳到[关于](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-beans-conversion)[`PropertyEditors`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-beans-conversion)的部分。)
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following two example classes use the `BeanWrapper` to get and set properties:
#### ** Chinese **

下面两个示例类使用`BeanWrapper`来获取和设置属性。
<!-- tabs:end -->


```java
public class Company {

    private String name;
    private Employee managingDirector;

    public String getName() {
        return this.name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Employee getManagingDirector() {
        return this.managingDirector;
    }

    public void setManagingDirector(Employee managingDirector) {
        this.managingDirector = managingDirector;
    }
}
```

```java
public class Employee {

    private String name;

    private float salary;

    public String getName() {
        return this.name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public float getSalary() {
        return salary;
    }

    public void setSalary(float salary) {
        this.salary = salary;
    }
}
```

<!-- tabs:start -->

#### ** English **

The following code snippets show some examples of how to retrieve and manipulate some of the properties of instantiated `Companies` and `Employees`:
#### ** Chinese **

下面的代码片段显示了如何检索和操作实例化的`Companies`和`Employees`的一些属性的示例。
<!-- tabs:end -->


```java
BeanWrapper company = new BeanWrapperImpl(new Company());
// setting the company name..
company.setPropertyValue("name", "Some Company Inc.");
// ... can also be done like this:
PropertyValue value = new PropertyValue("name", "Some Company Inc.");
company.setPropertyValue(value);

// ok, let's create the director and tie it to the company:
BeanWrapper jim = new BeanWrapperImpl(new Employee());
jim.setPropertyValue("name", "Jim Stravinsky");
company.setPropertyValue("managingDirector", jim.getWrappedInstance());

// retrieving the salary of the managingDirector through the company
Float salary = (Float) company.getPropertyValue("managingDirector.salary");
```

### **3.3.2. Built-in** **`PropertyEditor`** ** Implementations** 

<!-- tabs:start -->

#### ** English **

Spring uses the concept of a `PropertyEditor` to effect the conversion between an `Object` and a `String`. It can be handy to represent properties in a different way than the object itself. For example, a `Date` can be represented in a human readable way (as the `String`: `'2007-14-09'`), while we can still convert the human readable form back to the original date (or, even better, convert any date entered in a human readable form back to `Date` objects). This behavior can be achieved by registering custom editors of type `java.beans.PropertyEditor`. Registering custom editors on a `BeanWrapper` or, alternatively, in a specific IoC container (as mentioned in the previous chapter), gives it the knowledge of how to convert properties to the desired type. For more about `PropertyEditor`, see [the javadoc of the ](https://docs.oracle.com/javase/8/docs/api/java/beans/package-summary.html)[`java.beans`](https://docs.oracle.com/javase/8/docs/api/java/beans/package-summary.html)[ package from Oracle](https://docs.oracle.com/javase/8/docs/api/java/beans/package-summary.html).
#### ** Chinese **

Spring使用`PropertyEditor`的概念来实现`Object`和`String`之间的转换。用不同于对象本身的方式来表示属性可以很方便。例如，`日期`可以用人可读的方式表示（作为`String`：`'2007-14-09'`），而我们仍然可以将人可读的形式转换回原始日期（或者更好的是，将在人可读的形式中输入的任何日期转换回`Date`对象）。这种行为可以通过注册类型为`java.beans.PropertyEditor`的自定义编辑器来实现。在`BeanWrapper`上注册自定义编辑器，或者在特定的IoC容器中注册自定义编辑器（如上一章中提到的那样），使其了解如何将属性转换为所需类型。关于`PropertyEditor`的更多信息，请参见[来自Oracle的javadoc](https://docs.oracle.com/javase/8/docs/api/java/beans/package-summary.html)[`java.beans`](https://docs.oracle.com/javase/8/docs/api/java/beans/package-summary.html)[包的javadoc](https://docs.oracle.com/javase/8/docs/api/java/beans/package-summary.html)。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

A couple of examples where property editing is used in Spring:
#### ** Chinese **

在Spring中使用属性编辑的几个例子。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

- Setting properties on beans is done by using `PropertyEditor` implementations. When you use `String` as the value of a property of some bean that you declare in an XML file, Spring (if the setter of the corresponding property has a `Class` parameter) uses `ClassEditor` to try to resolve the parameter to a `Class` object.

- Parsing HTTP request parameters in Spring’s MVC framework is done by using all kinds of `PropertyEditor` implementations that you can manually bind in all subclasses of the `CommandController`.

#### ** Chinese **

- 在Bean上设置属性是通过使用`PropertyEditor`实现来完成的。当你使用`String`作为你在XML文件中声明的某个bean的属性值时，Spring（如果对应的属性的设置器有一个`Class`参数）会使用`ClassEditor`来尝试将该参数解析为一个`Class`对象。

- 在Spring的MVC框架中，解析HTTP请求参数是通过使用各种`PropertyEditor`实现来完成的，你可以在`CommandController`的所有子类中手动绑定。

<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

Spring has a number of built-in `PropertyEditor` implementations to make life easy. They are all located in the `org.springframework.beans.propertyeditors` package. Most, (but not all, as indicated in the following table) are, by default, registered by `BeanWrapperImpl`. Where the property editor is configurable in some fashion, you can still register your own variant to override the default one. The following table describes the various `PropertyEditor` implementations that Spring provides:
#### ** Chinese **

Spring有许多内置的`PropertyEditor`实现，使生活更加方便。它们都位于`org.springframework.beans.propertyeditors`包中。大多数（但不是全部，如下表所示）默认情况下都是由`BeanWrapperImpl`注册的。在属性编辑器以某种方式配置的地方，你仍然可以注册自己的变体来覆盖默认的变体。下表描述了Spring提供的各种`PropertyEditor`实现。
<!-- tabs:end -->


Class | Explanation 
-|-
ByteArrayPropertyEditor | Editor for byte arrays. Converts strings to their corresponding byte representations. Registered by default by BeanWrapperImpl. 
ClassEditor | Parses Strings that represent classes to actual classes and vice-versa. When a class is not found, an IllegalArgumentException is thrown. By default, registered by BeanWrapperImpl. 
CustomBooleanEditor | Customizable property editor for Boolean properties. By default, registered by BeanWrapperImpl but can be overridden by registering a custom instance of it as a custom editor. 
CustomCollectionEditor | Property editor for collections, converting any source Collection to a given target Collection type. 
CustomDateEditor | Customizable property editor for java.util.Date, supporting a custom DateFormat. NOT registered by default. Must be user-registered with the appropriate format as needed. 
CustomNumberEditor | Customizable property editor for any Number subclass, such as Integer, Long, Float, or Double. By default, registered by BeanWrapperImpl but can be overridden by registering a custom instance of it as a custom editor. 
FileEditor | Resolves strings to java.io.File objects. By default, registered by BeanWrapperImpl. 
InputStreamEditor | One-way property editor that can take a string and produce (through an intermediate ResourceEditor and Resource) an InputStream so that InputStream properties may be directly set as strings. Note that the default usage does not close the InputStream for you. By default, registered by BeanWrapperImpl. 
LocaleEditor | Can resolve strings to Locale objects and vice-versa (the string format is [country][variant], same as the toString() method of Locale). By default, registered by BeanWrapperImpl. 
PatternEditor | Can resolve strings to java.util.regex.Pattern objects and vice-versa. 
PropertiesEditor | Can convert strings (formatted with the format defined in the javadoc of the java.util.Properties class) to Properties objects. By default, registered by BeanWrapperImpl. 
StringTrimmerEditor | Property editor that trims strings. Optionally allows transforming an empty string into a null value. NOT registered by default — must be user-registered. 
URLEditor | Can resolve a string representation of a URL to an actual URL object. By default, registered by BeanWrapperImpl. 


<!-- tabs:start -->

#### ** English **

Spring uses the `java.beans.PropertyEditorManager` to set the search path for property editors that might be needed. The search path also includes `sun.bean.editors`, which includes `PropertyEditor` implementations for types such as `Font`, `Color`, and most of the primitive types. Note also that the standard JavaBeans infrastructure automatically discovers `PropertyEditor` classes (without you having to register them explicitly) if they are in the same package as the class they handle and have the same name as that class, with `Editor` appended. For example, one could have the following class and package structure, which would be sufficient for the `SomethingEditor` class to be recognized and used as the `PropertyEditor` for `Something`-typed properties.
#### ** Chinese **

Spring 使用 `java.beans.PropertyEditorManager`来设置可能需要的属性编辑器的搜索路径。搜索路径还包括`sun.bean.editors`，其中包括`PropertyEditor`对`Font`、`Color`等类型的实现，以及大多数基元类型。另外，请注意，如果`PropertyEditor`类与所处理的类在同一个包中，并且与该类有相同的名称，并附加了`Editor`，那么标准的JavaBeans基础架构就会自动识别出`PropertyEditor`类（无需显式注册）。例如，我们可以有以下的类和包结构，这样就足够让`SomethingEditor`类被识别并作为`PropertyEditor`用于`Something`类型的属性。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

com chank pop Something SomethingEditor // the PropertyEditor for the Something class
#### ** Chinese **

com chank pop Something Something SomethingEditor /// Something类的属性编辑器
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Note that you can also use the standard `BeanInfo` JavaBeans mechanism here as well (described to some extent [here](https://docs.oracle.com/javase/tutorial/javabeans/advanced/customization.html)). The following example use the `BeanInfo` mechanism to explicitly register one or more `PropertyEditor` instances with the properties of an associated class:
#### ** Chinese **

请注意，你也可以在这里使用标准的 `BeanInfo` JavaBeans 机制（在一定程度上描述了[这里](https://docs.oracle.com/javase/tutorial/javabeans/advanced/customization.html)）。下面的示例使用 `BeanInfo`机制来显式地注册一个或多个 `PropertyEditor`实例，并将其与关联类的属性关联起来。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

com chank pop Something SomethingBeanInfo // the BeanInfo for the Something class
#### ** Chinese **

com chank pop Something Something SomethingBeanInfo /// Something类的BeanInfo
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following Java source code for the referenced `SomethingBeanInfo` class associates a `CustomNumberEditor` with the `age` property of the `Something` class:
#### ** Chinese **

下面是引用的`SomethingBeanInfo`类的Java源代码，它将一个`CustomNumberEditor`与`Something`类的`age`属性关联起来。
<!-- tabs:end -->


```java
public class SomethingBeanInfo extends SimpleBeanInfo {

    public PropertyDescriptor[] getPropertyDescriptors() {
        try {
            final PropertyEditor numberPE = new CustomNumberEditor(Integer.class, true);
            PropertyDescriptor ageDescriptor = new PropertyDescriptor("age", Something.class) {
                public PropertyEditor createPropertyEditor(Object bean) {
                    return numberPE;
                };
            };
            return new PropertyDescriptor[] { ageDescriptor };
        }
        catch (IntrospectionException ex) {
            throw new Error(ex.toString());
        }
    }
}
```

### **Registering Additional Custom** **`PropertyEditor`** ** Implementations** 

<!-- tabs:start -->

#### ** English **

When setting bean properties as string values, a Spring IoC container ultimately uses standard JavaBeans `PropertyEditor` implementations to convert these strings to the complex type of the property. Spring pre-registers a number of custom `PropertyEditor` implementations (for example, to convert a class name expressed as a string into a `Class` object). Additionally, Java’s standard JavaBeans `PropertyEditor` lookup mechanism lets a `PropertyEditor` for a class be named appropriately and placed in the same package as the class for which it provides support, so that it can be found automatically.
#### ** Chinese **

当将Bean属性设置为字符串值时，Spring IoC容器最终使用标准的JavaBeans `PropertyEditor`实现来将这些字符串转换为属性的复杂类型。Spring 预先注册了许多自定义的 `PropertyEditor`实现（例如，将以字符串表示的类名转换为`Class`对象）。此外，Java的标准JavaBeans `PropertyEditor`查找机制可以让类的`PropertyEditor`被适当地命名，并与它所支持的类放在同一个包中，这样就可以自动找到它。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

If there is a need to register other custom `PropertyEditors`, several mechanisms are available. The most manual approach, which is not normally convenient or recommended, is to use the `registerCustomEditor()` method of the `ConfigurableBeanFactory` interface, assuming you have a `BeanFactory` reference. Another (slightly more convenient) mechanism is to use a special bean factory post-processor called `CustomEditorConfigurer`. Although you can use bean factory post-processors with `BeanFactory` implementations, the `CustomEditorConfigurer` has a nested property setup, so we strongly recommend that you use it with the `ApplicationContext`, where you can deploy it in similar fashion to any other bean and where it can be automatically detected and applied.
#### ** Chinese **

如果需要注册其他的自定义`PropertyEditors`，有几种机制可以使用。最手动的方法是使用`ConfigurableBeanFactory`接口中的`registerCustomEditor()`方法，假设你有一个`BeanFactory`引用，那么通常不方便，也不推荐使用这种方法。另一种（稍微方便一点的）机制是使用一个特殊的bean工厂后处理程序，名为`CustomEditorConfigurer`。虽然你可以用`BeanFactory`实现的Bean工厂后置处理程序，但`CustomEditorConfigurer`有一个嵌套的属性设置，所以我们强烈建议你把它和`ApplicationContext`一起使用，在这里你可以用类似于其他任何Bean的方式部署它，并且可以自动检测和应用它。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Note that all bean factories and application contexts automatically use a number of built-in property editors, through their use a `BeanWrapper` to handle property conversions. The standard property editors that the `BeanWrapper` registers are listed in the [previous section](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-beans-conversion). Additionally, `ApplicationContexts` also override or add additional editors to handle resource lookups in a manner appropriate to the specific application context type.
#### ** Chinese **

注意，所有的Bean工厂和应用程序上下文都会自动使用一些内置的属性编辑器，通过使用`BeanWrapper`来处理属性转换。`BeanWrapper`所注册的标准属性编辑器在[上一节](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-beans-conversion)中列出。此外，`ApplicationContexts`还可以覆盖或添加额外的编辑器，以便以适合特定应用上下文类型的方式处理资源查找。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Standard JavaBeans `PropertyEditor` instances are used to convert property values expressed as strings to the actual complex type of the property. You can use `CustomEditorConfigurer`, a bean factory post-processor, to conveniently add support for additional `PropertyEditor` instances to an `ApplicationContext`.
#### ** Chinese **

标准的JavaBeans `PropertyEditor`实例用于将以字符串表示的属性值转换为属性的实际复杂类型。您可以使用`CustomEditorConfigurer`，这是一个bean工厂后处理程序，可以方便地将额外的`PropertyEditor`实例支持添加到`ApplicationContext`中。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Consider the following example, which defines a user class called `ExoticType` and another class called `DependsOnExoticType`, which needs `ExoticType` set as a property:
#### ** Chinese **

考虑下面的例子，它定义了一个名为`ExoticType`的用户类和另一个名为`DependsOnExoticType`的类，需要将`ExoticType`设置为属性。
<!-- tabs:end -->


```java
package example;

public class ExoticType {

    private String name;

    public ExoticType(String name) {
        this.name = name;
    }
}

public class DependsOnExoticType {

    private ExoticType type;

    public void setType(ExoticType type) {
        this.type = type;
    }
}
```

<!-- tabs:start -->

#### ** English **

When things are properly set up, we want to be able to assign the type property as a string, which a `PropertyEditor` converts into an actual `ExoticType` instance. The following bean definition shows how to set up this relationship:
#### ** Chinese **

当事情被正确设置好后，我们希望能够将类型属性分配为字符串，`PropertyEditor`将其转换为实际的`ExoticType`实例。下面的Bean定义展示了如何设置这种关系。
<!-- tabs:end -->


```xml
<bean id="sample" class="example.DependsOnExoticType">
    <property name="type" value="aNameForExoticType"/>
</bean>
```

<!-- tabs:start -->

#### ** English **

The `PropertyEditor` implementation could look similar to the following:
#### ** Chinese **

`PropertyEditor`的实现可能看起来类似于以下内容。
<!-- tabs:end -->


```java
// converts string representation to ExoticType object
package example;

public class ExoticTypeEditor extends PropertyEditorSupport {

    public void setAsText(String text) {
        setValue(new ExoticType(text.toUpperCase()));
    }
}
```

<!-- tabs:start -->

#### ** English **

Finally, the following example shows how to use `CustomEditorConfigurer` to register the new `PropertyEditor` with the `ApplicationContext`, which will then be able to use it as needed:
#### ** Chinese **

最后，下面的例子显示了如何使用`CustomEditorConfigurer`向`ApplicationContext`注册新的`PropertyEditor`，然后它将能够根据需要使用它。
<!-- tabs:end -->


```xml
<bean class="org.springframework.beans.factory.config.CustomEditorConfigurer">
    <property name="customEditors">
        <map>
            <entry key="example.ExoticType" value="example.ExoticTypeEditor"/>
        </map>
    </property>
</bean>
```

### **Using** **`PropertyEditorRegistrar`** 

<!-- tabs:start -->

#### ** English **

Another mechanism for registering property editors with the Spring container is to create and use a `PropertyEditorRegistrar`. This interface is particularly useful when you need to use the same set of property editors in several different situations. You can write a corresponding registrar and reuse it in each case. `PropertyEditorRegistrar` instances work in conjunction with an interface called `PropertyEditorRegistry`, an interface that is implemented by the Spring `BeanWrapper` (and `DataBinder`). `PropertyEditorRegistrar` instances are particularly convenient when used in conjunction with `CustomEditorConfigurer` (described [here](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-beans-conversion-customeditor-registration)), which exposes a property called `setPropertyEditorRegistrars(..)`. `PropertyEditorRegistrar` instances added to a `CustomEditorConfigurer` in this fashion can easily be shared with `DataBinder` and Spring MVC controllers. Furthermore, it avoids the need for synchronization on custom editors: A `PropertyEditorRegistrar` is expected to create fresh `PropertyEditor` instances for each bean creation attempt.
#### ** Chinese **

用Spring容器注册属性编辑器的另一种机制是创建并使用`PropertyEditorRegistrar`。当你需要在几种不同的情况下使用同一组属性编辑器时，这个接口特别有用。你可以编写一个相应的注册器，并在每种情况下重用它。 `PropertyEditorRegistrar`实例与一个名为`PropertyEditorRegistry`的接口一起工作，该接口由Spring `BeanWrapper`（和`DataBinder`）实现。 `PropertyEditorRegistrar`实例在与`CustomEditorConfigurer`（在这里[https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-beans-conversion-customeditor-registration]）一起使用时特别方便，因为它公开了一个名为`setPropertyEditorRegistrars(..)`.的属性。 `PropertyEditorRegistrar`以这种方式添加到`CustomEditorConfigurer`的实例可以很容易地与`DataBinder`和Spring MVC控制器共享。此外，它还避免了自定义编辑器上的同步需求。`PropertyEditorRegistrar`会在每次Bean创建尝试中创建新的`PropertyEditor`实例。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following example shows how to create your own `PropertyEditorRegistrar` implementation:
#### ** Chinese **

下面的示例显示了如何创建自己的`PropertyEditorRegistrar`实现。
<!-- tabs:end -->


```java
package com.foo.editors.spring;

public final class CustomPropertyEditorRegistrar implements PropertyEditorRegistrar {

    public void registerCustomEditors(PropertyEditorRegistry registry) {

        // it is expected that new PropertyEditor instances are created
        registry.registerCustomEditor(ExoticType.class, new ExoticTypeEditor());

        // you could register as many custom property editors as are required here...
    }
}
```

<!-- tabs:start -->

#### ** English **

See also the `org.springframework.beans.support.ResourceEditorRegistrar` for an example `PropertyEditorRegistrar` implementation. Notice how in its implementation of the `registerCustomEditors(..)` method ,it creates new instances of each property editor.
#### ** Chinese **

参见`org.springframework.beans.support.ResourceEditorRegistrar`中的例子`PropertyEditorRegistrar`实现。注意在它的`registerCustomEditors(..)`方法的实现中，它是如何创建每个属性编辑器的新实例的。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The next example shows how to configure a `CustomEditorConfigurer` and inject an instance of our `CustomPropertyEditorRegistrar` into it:
#### ** Chinese **

下面的例子显示了如何配置一个`CustomEditorConfigurer`并将我们的`CustomPropertyEditorRegistrar`的实例注入其中。
<!-- tabs:end -->


```xml
<bean class="org.springframework.beans.factory.config.CustomEditorConfigurer">
    <property name="propertyEditorRegistrars">
        <list>
            <ref bean="customPropertyEditorRegistrar"/>
        </list>
    </property>
</bean>

<bean id="customPropertyEditorRegistrar"
    class="com.foo.editors.spring.CustomPropertyEditorRegistrar"/>
```

<!-- tabs:start -->

#### ** English **

Finally (and in a bit of a departure from the focus of this chapter for those of you using [Spring’s MVC web framework](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc)), using `PropertyEditorRegistrars` in conjunction with data-binding `Controllers` (such as `SimpleFormController`) can be very convenient. The following example uses a `PropertyEditorRegistrar` in the implementation of an `initBinder(..)` method:
#### ** Chinese **

最后（对于那些使用[Spring的MVC web框架](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc)的用户来说，这与本章的重点有点偏离），使用`PropertyEditorRegistrars`与数据绑定的`Controllers`（如`SimpleFormController`）结合使用会非常方便。下面的示例在`initBinder(..)`方法的实现中使用了一个`PropertyEditorRegistrar`。
<!-- tabs:end -->


```java
public final class RegisterUserController extends SimpleFormController {

    private final PropertyEditorRegistrar customPropertyEditorRegistrar;

    public RegisterUserController(PropertyEditorRegistrar propertyEditorRegistrar) {
        this.customPropertyEditorRegistrar = propertyEditorRegistrar;
    }

    protected void initBinder(HttpServletRequest request,
            ServletRequestDataBinder binder) throws Exception {
        this.customPropertyEditorRegistrar.registerCustomEditors(binder);
    }

    // other methods to do with registering a User
}
```

<!-- tabs:start -->

#### ** English **

This style of `PropertyEditor` registration can lead to concise code (the implementation of `initBinder(..)` is only one line long) and lets common `PropertyEditor` registration code be encapsulated in a class and then shared amongst as many `Controllers` as needed.
#### ** Chinese **

这种风格的`PropertyEditor`注册可以带来简洁的代码（`initBinder(..)`的实现只有一行长），并且可以将常用的`PropertyEditor`注册代码封装在一个类中，然后在需要的`Controllers`中共享。
<!-- tabs:end -->


### **3.4. Spring Type Conversion** 

<!-- tabs:start -->

#### ** English **

Spring 3 introduced a `core.convert` package that provides a general type conversion system. The system defines an SPI to implement type conversion logic and an API to perform type conversions at runtime. Within a Spring container, you can use this system as an alternative to `PropertyEditor` implementations to convert externalized bean property value strings to the required property types. You can also use the public API anywhere in your application where type conversion is needed.
#### ** Chinese **

Spring 3引入了一个`core.convert`包，提供了一个通用的类型转换系统。该系统定义了一个SPI来实现类型转换逻辑，以及一个在运行时执行类型转换的API。在Spring容器内，您可以使用该系统作为`PropertyEditor`实现的替代方案，将外部化的bean属性值字符串转换为所需的属性类型。你也可以在你的应用程序中任何需要类型转换的地方使用公共API。
<!-- tabs:end -->


### **3.4.1. Converter SPI** 

<!-- tabs:start -->

#### ** English **

The SPI to implement type conversion logic is simple and strongly typed, as the following interface definition shows:
#### ** Chinese **

SPI实现类型转换逻辑简单，类型化强，如下接口定义所示。
<!-- tabs:end -->


```java
package org.springframework.core.convert.converter;

public interface Converter<S, T> {

    T convert(S source);
}
```

<!-- tabs:start -->

#### ** English **

To create your own converter, implement the `Converter` interface and parameterize `S` as the type you are converting from and `T` as the type you are converting to. You can also transparently apply such a converter if a collection or array of `S` needs to be converted to an array or collection of `T`, provided that a delegating array or collection converter has been registered as well (which `DefaultConversionService` does by default).
#### ** Chinese **

要创建自己的转换器，请实现`Converter`接口，并将`S`作为你要转换的类型，将`T`作为你要转换的类型的参数化。如果需要将 `S`的集合或数组转换为`T`的数组或集合，你也可以透明地应用这样的转换器，前提是你也注册了一个委托数组或集合转换器（`DefaultConversionService`默认情况下是这样做的）。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

For each call to `convert(S)`, the source argument is guaranteed to not be null. Your `Converter` may throw any unchecked exception if conversion fails. Specifically, it should throw an `IllegalArgumentException` to report an invalid source value. Take care to ensure that your `Converter` implementation is thread-safe.
#### ** Chinese **

对于每次调用 `convert(S)`，保证源参数不为空。如果转换失败，你的`Converter`可能会抛出任何未选中的异常。具体来说，它应该抛出一个`IllegalArgumentException`来报告一个无效的源值。请注意确保您的 `Converter`实现是线程安全的。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Several converter implementations are provided in the `core.convert.support` package as a convenience. These include converters from strings to numbers and other common types. The following listing shows the `StringToInteger` class, which is a typical `Converter` implementation:
#### ** Chinese **

在`core.convert.support`包中提供了几个转换器实现，作为一种方便。其中包括从字符串到数字和其他常见类型的转换器。下面列出了`StringToInteger`类，这是一个典型的`Converter`实现。
<!-- tabs:end -->


```java
package org.springframework.core.convert.support;

final class StringToInteger implements Converter<String, Integer> {

    public Integer convert(String source) {
        return Integer.valueOf(source);
    }
}
```

### **3.4.2. Using** **`ConverterFactory`** 

<!-- tabs:start -->

#### ** English **

When you need to centralize the conversion logic for an entire class hierarchy (for example, when converting from `String` to `Enum` objects), you can implement `ConverterFactory`, as the following example shows:
#### ** Chinese **

当你需要对整个类的层次结构进行集中转换逻辑时（例如，当从`String`转换为`Enum`对象时），你可以实现`ConverterFactory`，如下例所示。
<!-- tabs:end -->


```java
package org.springframework.core.convert.converter;

public interface ConverterFactory<S, R> {

    <T extends R> Converter<S, T> getConverter(Class<T> targetType);
}
```

<!-- tabs:start -->

#### ** English **

Parameterize S to be the type you are converting from and R to be the base type defining the *range* of classes you can convert to. Then implement `getConverter(Class<T>)`, where T is a subclass of R.
#### ** Chinese **

参数化S为你要转换的类型，R为基本类型，定义可以转换的类的*范围。然后实现 `getConverter(Class<T>)`，其中T是R的一个子类。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Consider the `StringToEnumConverterFactory` as an example:
#### ** Chinese **

以`StringToEnumConverterFactory`为例。
<!-- tabs:end -->


```java
package org.springframework.core.convert.support;

final class StringToEnumConverterFactory implements ConverterFactory<String, Enum> {

    public <T extends Enum> Converter<String, T> getConverter(Class<T> targetType) {
        return new StringToEnumConverter(targetType);
    }

    private final class StringToEnumConverter<T extends Enum> implements Converter<String, T> {

        private Class<T> enumType;

        public StringToEnumConverter(Class<T> enumType) {
            this.enumType = enumType;
        }

        public T convert(String source) {
            return (T) Enum.valueOf(this.enumType, source.trim());
        }
    }
}
```

### **3.4.3. Using** **`GenericConverter`** 

<!-- tabs:start -->

#### ** English **

When you require a sophisticated `Converter` implementation, consider using the `GenericConverter` interface. With a more flexible but less strongly typed signature than `Converter`, a `GenericConverter` supports converting between multiple source and target types. In addition, a `GenericConverter` makes available source and target field context that you can use when you implement your conversion logic. Such context lets a type conversion be driven by a field annotation or by generic information declared on a field signature. The following listing shows the interface definition of `GenericConverter`:
#### ** Chinese **

当您需要一个复杂的`Converter`实现时，请考虑使用`GenericConverter`接口。与 `Converter`相比，`GenericConverter`具有更灵活但类型化程度较低的签名，支持在多个源类型和目标类型之间进行转换。此外，`GenericConverter`还提供了源和目标字段上下文，当你实现转换逻辑时，可以使用这些上下文。这种上下文可以让类型转换由字段注解或字段签名上声明的通用信息驱动。下面的列表显示了`GenericConverter`的接口定义。
<!-- tabs:end -->


```java
package org.springframework.core.convert.converter;

public interface GenericConverter {

    public Set<ConvertiblePair> getConvertibleTypes();

    Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType);
}
```

<!-- tabs:start -->

#### ** English **

To implement a `GenericConverter`, have `getConvertibleTypes()` return the supported source→target type pairs. Then implement `convert(Object, TypeDescriptor, TypeDescriptor)` to contain your conversion logic. The source `TypeDescriptor` provides access to the source field that holds the value being converted. The target `TypeDescriptor` provides access to the target field where the converted value is to be set.
#### ** Chinese **

要实现`GenericConverter`，请让`getConvertibleTypes()`返回支持的源类型对→目标类型对。然后实现`convert(Object, TypeDescriptor, TypeDescriptor)`来包含你的转换逻辑。源 `TypeDescriptor`提供了对持有要转换的值的源字段的访问。目标 `TypeDescriptor`提供了对目标字段的访问权限，该字段将在其中设置转换后的值。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

A good example of a `GenericConverter` is a converter that converts between a Java array and a collection. Such an `ArrayToCollectionConverter` introspects the field that declares the target collection type to resolve the collection’s element type. This lets each element in the source array be converted to the collection element type before the collection is set on the target field.
#### ** Chinese **

`GenericConverter`的一个很好的例子是一个在Java数组和集合之间进行转换的转换器。这样的`ArrayToCollectionConverter`会检查声明目标集合类型的字段，以解析集合的元素类型。这样可以让源数组中的每个元素在集合被设置在目标字段上之前，就被转换为集合的元素类型。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Because `GenericConverter` is a more complex SPI interface, you should use it only when you need it. Favor `Converter` or `ConverterFactory` for basic type conversion needs.
#### ** Chinese **

因为 `GenericConverter`是一个比较复杂的SPI接口，所以你应该只在需要的时候使用它。对于基本的类型转换需求，请使用`Converter`或`ConverterFactory`。
<!-- tabs:end -->


### **Using** **`ConditionalGenericConverter`** 

<!-- tabs:start -->

#### ** English **

Sometimes, you want a `Converter` to run only if a specific condition holds true. For example, you might want to run a `Converter` only if a specific annotation is present on the target field, or you might want to run a `Converter` only if a specific method (such as a `static valueOf` method) is defined on the target class. `ConditionalGenericConverter` is the union of the `GenericConverter` and `ConditionalConverter` interfaces that lets you define such custom matching criteria:
#### ** Chinese **

有时，您想让 `Converter`只在特定条件为真的情况下运行。例如，您可能希望只在目标字段上有特定的注解时才运行`Converter`，或者只在目标类上定义了特定的方法（如`static valueOf`方法）时才运行`Converter`。 `ConditionalGenericConverter`是`GenericConverter`和`ConditionalConverter`接口的结合体，可以让你定义这样的自定义匹配条件。
<!-- tabs:end -->


```java
public interface ConditionalConverter {

    boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType);
}

public interface ConditionalGenericConverter extends GenericConverter, ConditionalConverter {
}
```

<!-- tabs:start -->

#### ** English **

A good example of a `ConditionalGenericConverter` is an `EntityConverter` that converts between a persistent entity identifier and an entity reference. Such an `EntityConverter` might match only if the target entity type declares a static finder method (for example, `findAccount(Long)`). You might perform such a finder method check in the implementation of `matches(TypeDescriptor, TypeDescriptor)`.
#### ** Chinese **

`ConditionalGenericConverter`的一个很好的例子是`EntityConverter`，它可以在持久化实体标识符和实体引用之间进行转换。这样的 `EntityConverter`可能只在目标实体类型声明了静态查找器方法（例如，`findAccount(Long)`）的情况下才会匹配。你可以在`matches(TypeDescriptor, TypeDescriptor)`的实现中执行这样的查找器方法检查。
<!-- tabs:end -->


### **3.4.4. The** **`ConversionService`** ** API** 

<!-- tabs:start -->

#### ** English **

`ConversionService` defines a unified API for executing type conversion logic at runtime. Converters are often executed behind the following facade interface:
#### ** Chinese **

`ConversionService`定义了一个统一的API，用于在运行时执行类型转换逻辑。转换器通常在下面的门面接口后面执行。
<!-- tabs:end -->


```java
package org.springframework.core.convert;

public interface ConversionService {

    boolean canConvert(Class<?> sourceType, Class<?> targetType);

    <T> T convert(Object source, Class<T> targetType);

    boolean canConvert(TypeDescriptor sourceType, TypeDescriptor targetType);

    Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType);

}
```

<!-- tabs:start -->

#### ** English **

Most `ConversionService` implementations also implement `ConverterRegistry`, which provides an SPI for registering converters. Internally, a `ConversionService` implementation delegates to its registered converters to carry out type conversion logic.
#### ** Chinese **

大多数 `ConversionService`实现也实现了`ConverterRegistry`，它提供了一个用于注册转换器的SPI。在内部，`ConversionService`实现会委托给其注册的转换器来执行类型转换逻辑。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

A robust `ConversionService` implementation is provided in the `core.convert.support` package. `GenericConversionService` is the general-purpose implementation suitable for use in most environments. `ConversionServiceFactory` provides a convenient factory for creating common `ConversionService` configurations.
#### ** Chinese **

`core.convert.support`包中提供了一个强大的`ConversionService`实现。 `GenericConversionService`是适用于大多数环境的通用实现。 `ConversionServiceFactory`提供了一个方便的工厂，用于创建常用的`ConversionService`配置。
<!-- tabs:end -->


### **3.4.5. Configuring a** **`ConversionService`** 

<!-- tabs:start -->

#### ** English **

A `ConversionService` is a stateless object designed to be instantiated at application startup and then shared between multiple threads. In a Spring application, you typically configure a `ConversionService` instance for each Spring container (or `ApplicationContext`). Spring picks up that `ConversionService` and uses it whenever a type conversion needs to be performed by the framework. You can also inject this `ConversionService` into any of your beans and invoke it directly.
#### ** Chinese **

`ConversionService`是一个无状态对象，旨在在应用程序启动时被实例化，然后在多个线程之间共享。在 Spring 应用程序中，您通常为每个 Spring 容器（或 `ApplicationContext`）配置一个 `ConversionService`实例。每当需要框架执行类型转换时，Spring就会接收该 `ConversionService`并使用它。你也可以将这个`ConversionService`注入到你的任何Bean中并直接调用它。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

If no `ConversionService` is registered with Spring, the original `PropertyEditor`-based system is used.
#### ** Chinese **

如果没有向Spring注册`ConversionService`，则使用原始的基于`PropertyEditor`的系统。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

To register a default `ConversionService` with Spring, add the following bean definition with an `id` of `conversionService`:
#### ** Chinese **

要在Spring中注册一个默认的`ConversionService`，请添加下面的Bean定义，其中`id`为`conversionService`。
<!-- tabs:end -->


```xml
<bean id="conversionService"
    class="org.springframework.context.support.ConversionServiceFactoryBean"/>
```

<!-- tabs:start -->

#### ** English **

A default `ConversionService` can convert between strings, numbers, enums, collections, maps, and other common types. To supplement or override the default converters with your own custom converters, set the `converters` property. Property values can implement any of the `Converter`, `ConverterFactory`, or `GenericConverter` interfaces.
#### ** Chinese **

默认的`ConversionService`可以在字符串、数字、枚举、集合、映射和其他常见类型之间进行转换。要用自己的自定义转换器补充或覆盖默认转换器，请设置`converters`属性。属性值可以实现`Converter`、`ConverterFactory`或`GenericConverter`接口中的任何一个。
<!-- tabs:end -->


```xml
<bean id="conversionService"
        class="org.springframework.context.support.ConversionServiceFactoryBean">
    <property name="converters">
        <set>
            <bean class="example.MyCustomConverter"/>
        </set>
    </property>
</bean>
```

<!-- tabs:start -->

#### ** English **

It is also common to use a `ConversionService` within a Spring MVC application. See [Conversion and Formatting](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-config-conversion) in the Spring MVC chapter.
#### ** Chinese **

在Spring MVC应用程序中使用`ConversionService`也很常见。参见Spring MVC章节中的[转换和格式化](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-config-conversion)。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

In certain situations, you may wish to apply formatting during conversion. See [The ](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#format-FormatterRegistry-SPI)[`FormatterRegistry`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#format-FormatterRegistry-SPI)[ SPI](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#format-FormatterRegistry-SPI) for details on using `FormattingConversionServiceFactoryBean`.
#### ** Chinese **

在某些情况下，您可能希望在转换过程中应用格式化。有关使用`FormattingConversionServiceFactoryBean`的详细信息，请参阅[The](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#format-FormatterRegistry-SPI)[`FormatterRegistry`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#format-FormatterRegistry-SPI)[ SPI](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#format-FormatterRegistry-SPI)。
<!-- tabs:end -->


### **3.4.6. Using a** **`ConversionService`** ** Programmatically** 

<!-- tabs:start -->

#### ** English **

To work with a `ConversionService` instance programmatically, you can inject a reference to it like you would for any other bean. The following example shows how to do so:
#### ** Chinese **

要在程序上使用`ConversionService`实例，你可以像对其他bean一样注入一个引用。下面的例子显示了如何做到这一点。
<!-- tabs:end -->


```java
@Service
public class MyService {

    public MyService(ConversionService conversionService) {
        this.conversionService = conversionService;
    }

    public void doIt() {
        this.conversionService.convert(...)
    }
}
```

<!-- tabs:start -->

#### ** English **

For most use cases, you can use the `convert` method that specifies the `targetType`, but it does not work with more complex types, such as a collection of a parameterized element. For example, if you want to convert a `List` of `Integer` to a `List` of `String` programmatically, you need to provide a formal definition of the source and target types.
#### ** Chinese **

对于大多数用例，您可以使用指定`convert`方法，该方法可以指定`targetType`，但对于更复杂的类型，例如参数化元素的集合，它就不能使用。例如，如果你想将`List`的`Integer`转换为`String`的`List`，你需要提供一个正式的源类型和目标类型的定义。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Fortunately, `TypeDescriptor` provides various options to make doing so straightforward, as the following example shows:
#### ** Chinese **

幸运的是，`TypeDescriptor`提供了各种选项，让我们可以直接进行这样的操作，如下例所示。
<!-- tabs:end -->


```java
DefaultConversionService cs = new DefaultConversionService();

List<Integer> input = ...
cs.convert(input,
    TypeDescriptor.forObject(input), // List<Integer> type descriptor
    TypeDescriptor.collection(List.class, TypeDescriptor.valueOf(String.class)));
```

<!-- tabs:start -->

#### ** English **

Note that `DefaultConversionService` automatically registers converters that are appropriate for most environments. This includes collection converters, scalar converters, and basic `Object`-to-`String` converters. You can register the same converters with any `ConverterRegistry` by using the static `addDefaultConverters` method on the `DefaultConversionService` class.
#### ** Chinese **

注意，`DefaultConversionService`会自动注册适合大多数环境的转换器。这包括集合转换器、标量转换器和基本的`Object`到`String`转换器。你可以通过使用`DefaultConversionService`类上的静态`addDefaultConverters`方法来注册相同的`ConverterRegistry`转换器。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Converters for value types are reused for arrays and collections, so there is no need to create a specific converter to convert from a `Collection` of `S` to a `Collection` of `T`, assuming that standard collection handling is appropriate.
#### ** Chinese **

值类型的转换器可以重用于数组和集合，因此不需要创建一个特定的转换器来从`Collection`的`S`转换为`Collection`的`T`，假设标准的集合处理方式是合适的，那么就不需要创建一个特定的转换器来转换。
<!-- tabs:end -->


### **3.5. Spring Field Formatting** 

<!-- tabs:start -->

#### ** English **

As discussed in the previous section, [`core.convert`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#core-convert) is a general-purpose type conversion system. It provides a unified `ConversionService` API as well as a strongly typed `Converter` SPI for implementing conversion logic from one type to another. A Spring container uses this system to bind bean property values. In addition, both the Spring Expression Language (SpEL) and `DataBinder` use this system to bind field values. For example, when SpEL needs to coerce a `Short` to a `Long` to complete an `expression.setValue(Object bean, Object value)` attempt, the `core.convert` system performs the coercion.
#### ** Chinese **

正如上一节所讨论的那样，[`core.convertition`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#core-convert)是一个通用的类型转换系统。它提供了一个统一的`ConversionService` API以及一个强类型化的`Converter` SPI，用于实现从一种类型到另一种类型的转换逻辑。一个Spring容器使用这个系统来绑定Bean属性值。此外，Spring表达式语言（SpEL）和`DataBinder`都使用这个系统来绑定字段值。例如，当 SpEL 需要将 `Short` 绑定到 `Long` 以完成 `expression.setValue(Object bean, Object value)` 尝试时，`core.convert` 系统会执行强制执行。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Now consider the type conversion requirements of a typical client environment, such as a web or desktop application. In such environments, you typically convert from `String` to support the client postback process, as well as back to `String` to support the view rendering process. In addition, you often need to localize `String` values. The more general `core.convert` `Converter` SPI does not address such formatting requirements directly. To directly address them, Spring 3 introduced a convenient `Formatter` SPI that provides a simple and robust alternative to `PropertyEditor` implementations for client environments.
#### ** Chinese **

现在考虑一下典型的客户端环境的类型转换需求，例如web或桌面应用程序。在这样的环境中，您通常需要从`String`转换为支持客户端的后置回传过程，同时也需要返回到`String`来支持视图渲染过程。此外，你经常需要对`String`值进行本地化。而更通用的`core.convert` `Converter` SPI并没有直接解决这样的格式化需求。为了直接解决这些问题，Spring 3引入了一个方便的`Formatter` SPI，它为客户端环境提供了一个简单而稳健的替代`PropertyEditor`实现。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

In general, you can use the `Converter` SPI when you need to implement general-purpose type conversion logic — for example, for converting between a `java.util.Date` and a `Long`. You can use the `Formatter` SPI when you work in a client environment (such as a web application) and need to parse and print localized field values. The `ConversionService` provides a unified type conversion API for both SPIs.
#### ** Chinese **

一般来说，当您需要实现通用类型转换逻辑时，可以使用 `Converter` SPI - 例如，用于在 `java.util.Date`和`Long`之间进行转换。当您在客户端环境（如 Web 应用程序）中工作并需要解析和打印本地化字段值时，可以使用 `Formatter` SPI。`ConversionService`为这两种SPI提供了统一的类型转换API。
<!-- tabs:end -->


### **3.5.1. The** **`Formatter`** ** SPI** 

<!-- tabs:start -->

#### ** English **

The `Formatter` SPI to implement field formatting logic is simple and strongly typed. The following listing shows the `Formatter` interface definition:
#### ** Chinese **

`Formatter` SPI实现字段格式化逻辑的`Formatter`接口简单而强类型化。下面列出了`Formatter`接口的定义。
<!-- tabs:end -->


```java
package org.springframework.format;

public interface Formatter<T> extends Printer<T>, Parser<T> {
}
```

<!-- tabs:start -->

#### ** English **

`Formatter` extends from the `Printer` and `Parser` building-block interfaces. The following listing shows the definitions of those two interfaces:
#### ** Chinese **

`Formatter`是从`Printer`和`Parser`构建块接口扩展出来的。下面的列表显示了这两个接口的定义。
<!-- tabs:end -->


```java
public interface Printer<T> {

    String print(T fieldValue, Locale locale);
}
```

```java
import java.text.ParseException;

public interface Parser<T> {

    T parse(String clientValue, Locale locale) throws ParseException;
}
```

<!-- tabs:start -->

#### ** English **

To create your own `Formatter`, implement the `Formatter` interface shown earlier. Parameterize `T` to be the type of object you wish to format — for example, `java.util.Date`. Implement the `print()` operation to print an instance of `T` for display in the client locale. Implement the `parse()` operation to parse an instance of `T` from the formatted representation returned from the client locale. Your `Formatter` should throw a `ParseException` or an `IllegalArgumentException` if a parse attempt fails. Take care to ensure that your `Formatter` implementation is thread-safe.
#### ** Chinese **

要创建自己的`Formatter`，请实现前面显示的`Formatter`接口。将 `T`参数化为您希望格式化的对象类型 - 例如，`java.util.Date`。实现`print()`操作，以打印一个`T`的实例，以便在客户端本地显示。执行 `parse()`操作，从客户端本地语言返回的格式化表示中解析一个`T`实例。如果解析尝试失败，您的 `Formatter`应该抛出一个 `ParseException`或 `IllegalArgumentException`。请注意确保您的 `Formatter` 实现是线程安全的。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The `format` subpackages provide several `Formatter` implementations as a convenience. The `number` package provides `NumberStyleFormatter`, `CurrencyStyleFormatter`, and `PercentStyleFormatter` to format `Number` objects that use a `java.text.NumberFormat`. The `datetime` package provides a `DateFormatter` to format `java.util.Date` objects with a `java.text.DateFormat`. The `datetime.joda` package provides comprehensive datetime formatting support based on the [Joda-Time library](https://www.joda.org/joda-time/).
#### ** Chinese **

`format`子包提供了多个`Formatter`实现，作为一种方便。`number`包提供了`NumberStyleFormatter`、`CurrencyStyleFormatter`和`PercentStyleFormatter`，用于格式化使用`java.text.NumberFormat`对象的`Number`对象。`datetime`包提供了一个`DateFormatter`，用于使用`java.text.DateFormat`格式化`java.util.Date`对象。`datetime.joda`包提供了基于[Joda-Time库](https://www.joda.org/joda-time/)的全面的日期时间格式化支持。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following `DateFormatter` is an example `Formatter` implementation:
#### ** Chinese **

以下 `DateFormatter`是一个例子`Formatter`的实现。
<!-- tabs:end -->


```java
package org.springframework.format.datetime;

public final class DateFormatter implements Formatter<Date> {

    private String pattern;

    public DateFormatter(String pattern) {
        this.pattern = pattern;
    }

    public String print(Date date, Locale locale) {
        if (date == null) {
            return "";
        }
        return getDateFormat(locale).format(date);
    }

    public Date parse(String formatted, Locale locale) throws ParseException {
        if (formatted.length() == 0) {
            return null;
        }
        return getDateFormat(locale).parse(formatted);
    }

    protected DateFormat getDateFormat(Locale locale) {
        DateFormat dateFormat = new SimpleDateFormat(this.pattern, locale);
        dateFormat.setLenient(false);
        return dateFormat;
    }
}
```

<!-- tabs:start -->

#### ** English **

The Spring team welcomes community-driven `Formatter` contributions. See [GitHub Issues](https://github.com/spring-projects/spring-framework/issues) to contribute.
#### ** Chinese **

Spring 团队欢迎社区驱动的`Formatter`贡献。请参见[GitHub问题](https://github.com/spring-projects/spring-framework/issues)来贡献。
<!-- tabs:end -->


### **3.5.2. Annotation-driven Formatting** 

<!-- tabs:start -->

#### ** English **

Field formatting can be configured by field type or annotation. To bind an annotation to a `Formatter`, implement `AnnotationFormatterFactory`. The following listing shows the definition of the `AnnotationFormatterFactory` interface:
#### ** Chinese **

字段格式化可以通过字段类型或注解配置。要将注解绑定到`Formatter`，请实现`AnnotationFormatterFactory`。下面的列表显示了`AnnotationFormatterFactory`接口的定义。
<!-- tabs:end -->


```java
package org.springframework.format;

public interface AnnotationFormatterFactory<A extends Annotation> {

    Set<Class<?>> getFieldTypes();

    Printer<?> getPrinter(A annotation, Class<?> fieldType);

    Parser<?> getParser(A annotation, Class<?> fieldType);
}
```

<!-- tabs:start -->

#### ** English **

To create an implementation: . Parameterize A to be the field `annotationType` with which you wish to associate formatting logic — for example `org.springframework.format.annotation.DateTimeFormat`. . Have `getFieldTypes()` return the types of fields on which the annotation can be used. . Have `getPrinter()` return a `Printer` to print the value of an annotated field. . Have `getParser()` return a `Parser` to parse a `clientValue` for an annotated field.
#### ** Chinese **

要创建一个实现： . 将A参数化为您希望与之关联格式化逻辑的字段`annotationType` - 例如`org.springframework.format.annotation.DateTimeFormat`。 让 `getFieldTypes()`返回可以使用注解的字段类型。. 让 `getPrinter()`返回一个`Printer`，用于打印注解字段的值。. 让 `getParser()`返回一个`Parser`来解析注解字段的`clientValue`。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following example `AnnotationFormatterFactory` implementation binds the `@NumberFormat` annotation to a formatter to let a number style or pattern be specified:
#### ** Chinese **

下面的示例 `AnnotationFormatterFactory`实现将`@NumberFormat`注解绑定到formatter中，以便指定数字样式或模式。
<!-- tabs:end -->


```java
public final class NumberFormatAnnotationFormatterFactory
        implements AnnotationFormatterFactory<NumberFormat> {

    public Set<Class<?>> getFieldTypes() {
        return new HashSet<Class<?>>(asList(new Class<?>[] {
            Short.class, Integer.class, Long.class, Float.class,
            Double.class, BigDecimal.class, BigInteger.class }));
    }

    public Printer<Number> getPrinter(NumberFormat annotation, Class<?> fieldType) {
        return configureFormatterFrom(annotation, fieldType);
    }

    public Parser<Number> getParser(NumberFormat annotation, Class<?> fieldType) {
        return configureFormatterFrom(annotation, fieldType);
    }

    private Formatter<Number> configureFormatterFrom(NumberFormat annotation, Class<?> fieldType) {
        if (!annotation.pattern().isEmpty()) {
            return new NumberStyleFormatter(annotation.pattern());
        } else {
            Style style = annotation.style();
            if (style == Style.PERCENT) {
                return new PercentStyleFormatter();
            } else if (style == Style.CURRENCY) {
                return new CurrencyStyleFormatter();
            } else {
                return new NumberStyleFormatter();
            }
        }
    }
}
```

<!-- tabs:start -->

#### ** English **

To trigger formatting, you can annotate fields with @NumberFormat, as the following example shows:
#### ** Chinese **

为了触发格式化，你可以用@NumberFormat注解字段，如下例所示。
<!-- tabs:end -->


```java
public class MyModel {

    @NumberFormat(style=Style.CURRENCY)
    private BigDecimal decimal;
}
```

### **Format Annotation API** 

<!-- tabs:start -->

#### ** English **

A portable format annotation API exists in the `org.springframework.format.annotation` package. You can use `@NumberFormat` to format `Number` fields such as `Double` and `Long`, and `@DateTimeFormat` to format `java.util.Date`, `java.util.Calendar`, `Long` (for millisecond timestamps) as well as JSR-310 `java.time` and Joda-Time value types.
#### ** Chinese **

`org.springframework.format.annotation`包中存在一个可移植的格式注释API。你可以使用`@NumberFormat`来格式化`Number`字段，如`Double`和`Long`，以及`@DateTimeFormat`来格式化`java.util.Date`、`java.util.Calendar`、`Long`（用于毫秒时间戳）以及JSR-310`java.time`和Joda-Time值类型。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following example uses `@DateTimeFormat` to format a `java.util.Date` as an ISO Date (yyyy-MM-dd):
#### ** Chinese **

下面的示例使用 `@DateTimeFormat`将`java.util.Date`格式化为ISO日期（yyyyyy-MM-dd）。
<!-- tabs:end -->


```java
public class MyModel {

    @DateTimeFormat(iso=ISO.DATE)
    private Date date;
}
```

### **3.5.3. The** **`FormatterRegistry`** ** SPI** 

<!-- tabs:start -->

#### ** English **

The `FormatterRegistry` is an SPI for registering formatters and converters. `FormattingConversionService` is an implementation of `FormatterRegistry` suitable for most environments. You can programmatically or declaratively configure this variant as a Spring bean, e.g. by using `FormattingConversionServiceFactoryBean`. Because this implementation also implements `ConversionService`, you can directly configure it for use with Spring’s `DataBinder` and the Spring Expression Language (SpEL).
#### ** Chinese **

`FormatterRegistry`是一个用于注册格式化器和转换器的SPI。 `FormattingConversionService`是`FormatterRegistry`的一个实现，适用于大多数环境。您可以通过编程或声明方式将此变体配置为Spring Bean，例如，使用`FormattingConversionServiceFactoryBean`。由于该实现也实现了`ConversionService`，因此您可以直接将其配置为与Spring的`DataBinder`和Spring表达式语言（SpEL）一起使用。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following listing shows the `FormatterRegistry` SPI:
#### ** Chinese **

下面的列表显示了`FormatterRegistry` SPI。
<!-- tabs:end -->


```java
package org.springframework.format;

public interface FormatterRegistry extends ConverterRegistry {

    void addFormatterForFieldType(Class<?> fieldType, Printer<?> printer, Parser<?> parser);

    void addFormatterForFieldType(Class<?> fieldType, Formatter<?> formatter);

    void addFormatterForFieldType(Formatter<?> formatter);

    void addFormatterForAnnotation(AnnotationFormatterFactory<?> factory);
}
```

<!-- tabs:start -->

#### ** English **

As shown in the preceding listing, you can register formatters by field type or by annotation.
#### ** Chinese **

如前面的列表所示，你可以按字段类型或按注解注册表单。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The `FormatterRegistry` SPI lets you configure formatting rules centrally, instead of duplicating such configuration across your controllers. For example, you might want to enforce that all date fields are formatted a certain way or that fields with a specific annotation are formatted in a certain way. With a shared `FormatterRegistry`, you define these rules once, and they are applied whenever formatting is needed.
#### ** Chinese **

`FormatterRegistry` SPI 允许您集中配置格式化规则，而不是在控制器中重复配置。例如，您可能想强制要求所有日期字段以特定的方式进行格式化，或者要求具有特定注解的字段以特定的方式进行格式化。使用共享的`FormatterRegistry`，您只需定义一次这些规则，并且在需要格式化时，这些规则就会被应用。
<!-- tabs:end -->


### **3.5.4. The** **`FormatterRegistrar`** ** SPI** 

<!-- tabs:start -->

#### ** English **

`FormatterRegistrar` is an SPI for registering formatters and converters through the FormatterRegistry. The following listing shows its interface definition:
#### ** Chinese **

`FormatterRegistrar`是一个SPI，用于通过FormatterRegistry注册格式化器和转换器。下面的列表显示了它的接口定义。
<!-- tabs:end -->


```java
package org.springframework.format;

public interface FormatterRegistrar {

    void registerFormatters(FormatterRegistry registry);
}
```

<!-- tabs:start -->

#### ** English **

A `FormatterRegistrar` is useful when registering multiple related converters and formatters for a given formatting category, such as date formatting. It can also be useful where declarative registration is insufficient — for example, when a formatter needs to be indexed under a specific field type different from its own `<T>` or when registering a `Printer`/`Parser` pair. The next section provides more information on converter and formatter registration.
#### ** Chinese **

`FormatterRegistrar`在为一个给定的格式化类别（如日期格式化）注册多个相关的转换器和格式化器时非常有用。它也可以在声明性注册不足的情况下派上用场--例如，当一个格式化器需要在不同于其自身的`<T>`的特定字段类型下进行索引，或者注册一个`Printer`/`Parser`对时，它也很有用。下一节将提供关于转换器和格式化器注册的更多信息。
<!-- tabs:end -->


### **3.5.5. Configuring Formatting in Spring MVC** 

<!-- tabs:start -->

#### ** English **

See [Conversion and Formatting](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-config-conversion) in the Spring MVC chapter.
#### ** Chinese **

参见Spring MVC章节中的[转换和格式化](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-config-conversion)。
<!-- tabs:end -->


### **3.6. Configuring a Global Date and Time Format** 

<!-- tabs:start -->

#### ** English **

By default, date and time fields not annotated with `@DateTimeFormat` are converted from strings by using the `DateFormat.SHORT` style. If you prefer, you can change this by defining your own global format.
#### ** Chinese **

默认情况下，没有用`@DateTimeFormat`注解的日期和时间字段会通过使用`DateFormat.SHORT`样式从字符串转换。如果你愿意，你可以通过定义你自己的全局格式来改变。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

To do that, ensure that Spring does not register default formatters. Instead, register formatters manually with the help of:
#### ** Chinese **

要做到这一点，请确保Spring不注册默认的窗体。取而代之的是，使用以下方法手动注册表单格式。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

- `org.springframework.format.datetime.standard.DateTimeFormatterRegistrar`

- `org.springframework.format.datetime.DateFormatterRegistrar`, or `org.springframework.format.datetime.joda.JodaTimeFormatterRegistrar` for Joda-Time.

#### ** Chinese **

- `org.springframework.format.datetime.standard.DateTimeFormatterRegistrar`

- `org.springframework.format.datetime.DateFormatterRegistrar`, or `org.springframework.format.datetime.joda.JodaTimeFormatterRegistrar` for Joda-Time.

<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

For example, the following Java configuration registers a global `yyyyMMdd` format:
#### ** Chinese **

例如，下面的Java配置注册一个全局`yyyyMMdd`格式。
<!-- tabs:end -->


```java
@Configuration
public class AppConfig {

    @Bean
    public FormattingConversionService conversionService() {

        // Use the DefaultFormattingConversionService but do not register defaults
        DefaultFormattingConversionService conversionService = new DefaultFormattingConversionService(false);

        // Ensure @NumberFormat is still supported
        conversionService.addFormatterForFieldAnnotation(new NumberFormatAnnotationFormatterFactory());

        // Register JSR-310 date conversion with a specific global format
        DateTimeFormatterRegistrar registrar = new DateTimeFormatterRegistrar();
        registrar.setDateFormatter(DateTimeFormatter.ofPattern("yyyyMMdd"));
        registrar.registerFormatters(conversionService);

        // Register date conversion with a specific global format
        DateFormatterRegistrar registrar = new DateFormatterRegistrar();
        registrar.setFormatter(new DateFormatter("yyyyMMdd"));
        registrar.registerFormatters(conversionService);

        return conversionService;
    }
}
```

<!-- tabs:start -->

#### ** English **

If you prefer XML-based configuration, you can use a `FormattingConversionServiceFactoryBean`. The following example shows how to do so (this time using Joda Time):
#### ** Chinese **

如果你喜欢基于XML的配置，你可以使用`FormattingConversionServiceFactoryBean`。下面的例子显示了如何做到这一点（这次使用Joda Time）。
<!-- tabs:end -->


```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd>

    <bean id="conversionService" class="org.springframework.format.support.FormattingConversionServiceFactoryBean">
        <property name="registerDefaultFormatters" value="false" />
        <property name="formatters">
            <set>
                <bean class="org.springframework.format.number.NumberFormatAnnotationFormatterFactory" />
            </set>
        </property>
        <property name="formatterRegistrars">
            <set>
                <bean class="org.springframework.format.datetime.joda.JodaTimeFormatterRegistrar">
                    <property name="dateFormatter">
                        <bean class="org.springframework.format.datetime.joda.DateTimeFormatterFactoryBean">
                            <property name="pattern" value="yyyyMMdd"/>
                        </bean>
                    </property>
                </bean>
            </set>
        </property>
    </bean>
</beans>
```

<!-- tabs:start -->

#### ** English **

Note there are extra considerations when configuring date and time formats in web applications. Please see [WebMVC Conversion and Formatting](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-config-conversion) or [WebFlux Conversion and Formatting](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-config-conversion).
#### ** Chinese **

请注意，在Web应用程序中配置日期和时间格式时，有一些额外的注意事项。请参见 [WebMVC 转换和格式化](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-config-conversion)或 [WebFlux 转换和格式化](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web-reactive.html#webflux-config-conversion)。
<!-- tabs:end -->


### **3.7. Java Bean Validation** 

<!-- tabs:start -->

#### ** English **

The Spring Framework provides support for the [Java Bean Validation](https://beanvalidation.org/) API.
#### ** Chinese **

Spring框架提供了对[Java Bean Validation](https://beanvalidation.org/)API的支持。
<!-- tabs:end -->


### **3.7.1. Overview of Bean Validation** 

<!-- tabs:start -->

#### ** English **

Bean Validation provides a common way of validation through constraint declaration and metadata for Java applications. To use it, you annotate domain model properties with declarative validation constraints which are then enforced by the runtime. There are built-in constraints, and you can also define your own custom constraints.
#### ** Chinese **

Bean Validation通过约束声明和元数据为Java应用程序提供了一种常见的验证方式。要使用它，你可以用声明式验证约束来注解域模型属性，然后由运行时强制执行。有内置的约束，你也可以定义你自己的自定义约束。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Consider the following example, which shows a simple `PersonForm` model with two properties:
#### ** Chinese **

考虑一下下面的例子，它显示了一个简单的`PersonForm`模型，有两个属性。
<!-- tabs:end -->


```java
public class PersonForm {
    private String name;
    private int age;
}
```

<!-- tabs:start -->

#### ** English **

Bean Validation lets you declare constraints as the following example shows:
#### ** Chinese **

如下面的例子所示，Bean Validation允许你声明约束。
<!-- tabs:end -->


```java
public class PersonForm {

    @NotNull
    @Size(max=64)
    private String name;

    @Min(0)
    private int age;
}
```

<!-- tabs:start -->

#### ** English **

A Bean Validation validator then validates instances of this class based on the declared constraints. See [Bean Validation](https://beanvalidation.org/) for general information about the API. See the [Hibernate Validator](https://hibernate.org/validator/) documentation for specific constraints. To learn how to set up a bean validation provider as a Spring bean, keep reading.
#### ** Chinese **

然后一个Bean Validation验证器根据声明的约束来验证这个类的实例。有关 API 的一般信息，请参阅 [Bean Validation](https://beanvalidation.org/)。关于具体约束，请参阅[Hibernate Validator](https://hibernate.org/validator/)文档。要了解如何将Bean验证提供者设置为Spring Bean，请继续阅读。
<!-- tabs:end -->


### **3.7.2. Configuring a Bean Validation Provider** 

<!-- tabs:start -->

#### ** English **

Spring provides full support for the Bean Validation API including the bootstrapping of a Bean Validation provider as a Spring bean. This lets you inject a `javax.validation.ValidatorFactory` or `javax.validation.Validator` wherever validation is needed in your application.
#### ** Chinese **

Spring提供了对Bean Validation API的全面支持，包括将Bean Validation提供者作为Spring bean进行引导。这让你可以在应用程序中需要验证的地方注入一个`javax.validation.ValidatorFactory`或`javax.validation.Validator`。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can use the `LocalValidatorFactoryBean` to configure a default Validator as a Spring bean, as the following example shows:
#### ** Chinese **

你可以使用`LocalValidatorFactoryBean`来配置一个默认的Validator作为Spring Bean，如下图所示。
<!-- tabs:end -->


```java
import org.springframework.validation.beanvalidation.LocalValidatorFactoryBean;

@Configuration

public class AppConfig {

    @Bean
    public LocalValidatorFactoryBean validator() {
        return new LocalValidatorFactoryBean;
    }
}
```

<!-- tabs:start -->

#### ** English **

The basic configuration in the preceding example triggers bean validation to initialize by using its default bootstrap mechanism. A Bean Validation provider, such as the Hibernate Validator, is expected to be present in the classpath and is automatically detected.
#### ** Chinese **

前面例子中的基本配置通过使用其默认的bootstrap机制触发Bean验证初始化。在classpath中会出现一个Bean验证提供者，比如Hibernate验证器，并自动检测到。
<!-- tabs:end -->


### **Injecting a Validator** 

<!-- tabs:start -->

#### ** English **

`LocalValidatorFactoryBean` implements both `javax.validation.ValidatorFactory` and `javax.validation.Validator`, as well as Spring’s `org.springframework.validation.Validator`. You can inject a reference to either of these interfaces into beans that need to invoke validation logic.
#### ** Chinese **

`LocalValidatorFactoryBean`同时实现了`javax.validation.ValidatorFactory`和`javax.validation.Validator`，以及Spring的`org.springframework.validation.Validator`。你可以将这些接口的引用注入到需要调用验证逻辑的Bean中。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can inject a reference to `javax.validation.Validator` if you prefer to work with the Bean Validation API directly, as the following example shows:
#### ** Chinese **

如果你喜欢直接使用Bean Validation API，你可以注入一个引用到`javax.validation.Validator`，如下例所示。
<!-- tabs:end -->


```java
import javax.validation.Validator;

@Service
public class MyService {

    @Autowired
    private Validator validator;
}
```

<!-- tabs:start -->

#### ** English **

You can inject a reference to `org.springframework.validation.Validator` if your bean requires the Spring Validation API, as the following example shows:
#### ** Chinese **

如果你的Bean需要Spring Validation API，可以注入一个引用到`org.springframework.validation.Validator`，如下例所示。
<!-- tabs:end -->


```java
import org.springframework.validation.Validator;

@Service
public class MyService {

    @Autowired
    private Validator validator;
}
```

### **Configuring Custom Constraints** 

<!-- tabs:start -->

#### ** English **

Each bean validation constraint consists of two parts:
#### ** Chinese **

每个豆子验证约束由两部分组成。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

- A `@Constraint` annotation that declares the constraint and its configurable properties.

- An implementation of the `javax.validation.ConstraintValidator` interface that implements the constraint’s behavior.

#### ** Chinese **

- 一个`@Constraint`注解，声明约束及其可配置的属性。

- `javax.validation.ConstraintValidator`接口的实现，它实现了约束的行为。

<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

To associate a declaration with an implementation, each `@Constraint` annotation references a corresponding `ConstraintValidator` implementation class. At runtime, a `ConstraintValidatorFactory` instantiates the referenced implementation when the constraint annotation is encountered in your domain model.
#### ** Chinese **

为了将声明与实现关联起来，每个 `@Constraint`注解都会引用一个相应的 `ConstraintValidator`实现类。在运行时，当您的域模型中遇到约束注解时，`ConstraintValidatorFactory`会实例化引用的实现。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

By default, the `LocalValidatorFactoryBean` configures a `SpringConstraintValidatorFactory` that uses Spring to create `ConstraintValidator` instances. This lets your custom `ConstraintValidators` benefit from dependency injection like any other Spring bean.
#### ** Chinese **

默认情况下，`LocalValidatorFactoryBean`配置了一个`SpringConstraintValidatorFactory`，它使用Spring来创建`ConstraintValidator`实例。这让您的自定义 `ConstraintValidators`可以像其他Spring Bean一样从依赖注入中受益。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following example shows a custom `@Constraint` declaration followed by an associated `ConstraintValidator` implementation that uses Spring for dependency injection:
#### ** Chinese **

下面的示例显示了一个自定义的 `@Constraint`声明，然后是一个关联的 `ConstraintValidator`实现，该实现使用Spring进行依赖注入。
<!-- tabs:end -->


```java
@Target({ElementType.METHOD, ElementType.FIELD})
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy=MyConstraintValidator.class)
public @interface MyConstraint {
}
```

```java
import javax.validation.ConstraintValidator;

public class MyConstraintValidator implements ConstraintValidator {

    @Autowired;
    private Foo aDependency;

    // ...
}
```

<!-- tabs:start -->

#### ** English **

As the preceding example shows, a `ConstraintValidator` implementation can have its dependencies `@Autowired` as any other Spring bean.
#### ** Chinese **

正如前面的例子所示，`ConstraintValidator`实现可以像其他Spring Bean一样，拥有其依赖关系`@Autowired`。
<!-- tabs:end -->


### **Spring-driven Method Validation** 

<!-- tabs:start -->

#### ** English **

You can integrate the method validation feature supported by Bean Validation 1.1 (and, as a custom extension, also by Hibernate Validator 4.3) into a Spring context through a `MethodValidationPostProcessor` bean definition:
#### ** Chinese **

您可以通过`MethodValidationPostProcessor` bean定义，将Bean Validation 1.1（作为自定义扩展，Hibernate Validator 4.3也支持）支持的方法验证功能集成到Spring上下文中。
<!-- tabs:end -->


```java
import org.springframework.validation.beanvalidation.MethodValidationPostProcessor;

@Configuration

public class AppConfig {

    @Bean
    public MethodValidationPostProcessor validationPostProcessor() {
        return new MethodValidationPostProcessor;
    }
}
```

<!-- tabs:start -->

#### ** English **

To be eligible for Spring-driven method validation, all target classes need to be annotated with Spring’s `@Validated` annotation, which can optionally also declare the validation groups to use. See [`MethodValidationPostProcessor`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/validation/beanvalidation/MethodValidationPostProcessor.html) for setup details with the Hibernate Validator and Bean Validation 1.1 providers.
#### ** Chinese **

为了有资格使用Spring驱动的方法验证，所有目标类都需要用Spring的`@Validated`注解，该注解也可以选择声明要使用的验证组。有关 Hibernate Validator 和 Bean Validation 1.1 提供者的设置细节，请参阅 [`MethodValidationPostProcessor`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/validation/beanvalidation/MethodValidationPostProcessor.html)。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Method validation relies on [AOP Proxies](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#aop-introduction-proxies) around the target classes, either JDK dynamic proxies for methods on interfaces or CGLIB proxies. There are certain limitations with the use of proxies, some of which are described in [Understanding AOP Proxies](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#aop-understanding-aop-proxies). In addition remember to always use methods and accessors on proxied classes; direct field access will not work.
#### ** Chinese **

方法验证依赖于目标类周围的[AOP代理](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#aop-introduction-proxies)，可以是JDK的动态代理，也可以是接口上的方法的JDK动态代理，或者是CGLIB代理。使用代理的时候有一定的限制，其中一些限制在[理解AOP代理](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#aop-understanding-aop-proxies)中描述。此外，请记住在代理类上始终使用方法和访问器；直接的字段访问将不起作用。
<!-- tabs:end -->


### **Additional Configuration Options** 

<!-- tabs:start -->

#### ** English **

The default `LocalValidatorFactoryBean` configuration suffices for most cases. There are a number of configuration options for various Bean Validation constructs, from message interpolation to traversal resolution. See the [`LocalValidatorFactoryBean`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/validation/beanvalidation/LocalValidatorFactoryBean.html) javadoc for more information on these options.
#### ** Chinese **

默认的`LocalValidatorFactoryBean`配置已经足够适用于大多数情况。对于各种Bean验证构造，从消息插值到遍历解析，有很多配置选项。有关这些选项的更多信息，请参阅 [`LocalValidatorFactoryBean`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/validation/beanvalidation/LocalValidatorFactoryBean.html) javadoc。
<!-- tabs:end -->


### **3.7.3. Configuring a** **`DataBinder`** 

<!-- tabs:start -->

#### ** English **

Since Spring 3, you can configure a `DataBinder` instance with a `Validator`. Once configured, you can invoke the `Validator` by calling `binder.validate()`. Any validation `Errors` are automatically added to the binder’s `BindingResult`.
#### ** Chinese **

从Spring 3开始，您可以用`Validator`配置一个`DataBinder`实例。配置好后，您可以通过调用 `binder.validate()`来调用 `binder.validator`。任何验证`Errors`都会自动添加到binder的`BindingResult`中。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following example shows how to use a `DataBinder` programmatically to invoke validation logic after binding to a target object:
#### ** Chinese **

下面的例子显示了如何在绑定到目标对象后，通过编程使用`DataBinder`来调用验证逻辑。
<!-- tabs:end -->


```java
Foo target = new Foo();
DataBinder binder = new DataBinder(target);
binder.setValidator(new FooValidator());

// bind to the target object
binder.bind(propertyValues);

// validate the target object
binder.validate();

// get BindingResult that includes any validation errors
BindingResult results = binder.getBindingResult();
```

<!-- tabs:start -->

#### ** English **

You can also configure a `DataBinder` with multiple `Validator` instances through `dataBinder.addValidators` and `dataBinder.replaceValidators`. This is useful when combining globally configured bean validation with a Spring `Validator` configured locally on a DataBinder instance. See [Spring MVC Validation Configuration](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-config-validation).
#### ** Chinese **

您还可以通过`dataBinder.addValidators`和`dataBinder.replaceValidators`来配置一个`DataBinder`，并通过`dataBinder.addValidators`和`dataBinder.replaceValidators`来配置多个`Validator`实例。这在将全局配置的Bean验证与DataBinder实例上本地配置的Spring `Validator`结合起来时非常有用。参见[Spring MVC验证配置](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-config-validation)。
<!-- tabs:end -->


### **3.7.4. Spring MVC 3 Validation** 

<!-- tabs:start -->

#### ** English **

See [Validation](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-config-validation) in the Spring MVC chapter.
#### ** Chinese **

参见Spring MVC章节中的【验证】(https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-config-validation)。
<!-- tabs:end -->



[下一章](Spring-Framework-5.2.6.RELEASE/Core%20Technologies/4.%20Spring%20Expression%20Language%20(SpEL).md)


[回目录](Spring-Framework-5.2.6.RELEASE/summary.md)

[回首页](/README)
