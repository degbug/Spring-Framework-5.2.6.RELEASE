# 4. Spring Expression Language (SpEL)

<!-- tabs:start -->

#### ** English **

The Spring Expression Language (“SpEL” for short) is a powerful expression language that supports querying and manipulating an object graph at runtime. The language syntax is similar to Unified EL but offers additional features, most notably method invocation and basic string templating functionality.
#### ** Chinese **

Spring表达式语言（简称 "SpEL"）是一种强大的表达式语言，支持在运行时查询和操作对象图。该语言的语法类似于Unified EL，但提供了额外的功能，最主要的是方法调用和基本的字符串模板化功能。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

While there are several other Java expression languages available — OGNL, MVEL, and JBoss EL, to name a few — the Spring Expression Language was created to provide the Spring community with a single well supported expression language that can be used across all the products in the Spring portfolio. Its language features are driven by the requirements of the projects in the Spring portfolio, including tooling requirements for code completion support within the [Spring Tools for Eclipse](https://spring.io/tools). That said, SpEL is based on a technology-agnostic API that lets other expression language implementations be integrated, should the need arise.
#### ** Chinese **

虽然还有其他几种Java表达式语言可用--OGNL、MVEL和JBoss EL等，但Spring表达式语言的创建是为了给Spring社区提供一种单一的表达式语言，它可以在Spring组合中的所有产品中使用。它的语言特性是由Spring组合中的项目需求驱动的，包括[Spring Tools for Eclipse](https://spring.io/tools)内支持代码完成的工具化需求。尽管如此，SpEL基于一个技术无关的API，如果需要的话，它可以整合其他表达式语言实现。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

While SpEL serves as the foundation for expression evaluation within the Spring portfolio, it is not directly tied to Spring and can be used independently. To be self contained, many of the examples in this chapter use SpEL as if it were an independent expression language. This requires creating a few bootstrapping infrastructure classes, such as the parser. Most Spring users need not deal with this infrastructure and can, instead, author only expression strings for evaluation. An example of this typical use is the integration of SpEL into creating XML or annotation-based bean definitions, as shown in [Expression support for defining bean definitions](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#expressions-beandef).
#### ** Chinese **

虽然SpEL作为Spring组合中表达式评估的基础，但它并不直接与Spring绑定，可以独立使用。为了自成一体，本章中的许多示例都将SpEL当作独立的表达式语言来使用。这需要创建一些bootstrapping基础架构类，比如解析器。大多数Spring的用户不需要处理这些基础架构，而是可以只编写表达式字符串进行评估。这种典型使用的一个例子是将SpEL集成到创建XML或基于注解的bean定义中，如[Expression support for defining bean definitions](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#expressions-beandef)所示。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

This chapter covers the features of the expression language, its API, and its language syntax. In several places, `Inventor` and `Society` classes are used as the target objects for expression evaluation. These class declarations and the data used to populate them are listed at the end of the chapter.
#### ** Chinese **

本章介绍了表达式语言的特点、API和语言语法。在一些地方，`Inventor`和`Society`类被用作表达式评价的目标对象。这些类声明和用于填充它们的数据在本章末尾列出。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The expression language supports the following functionality:
#### ** Chinese **

该表达式语言支持以下功能：
<!-- tabs:end -->


### **4.1. Evaluation** 

<!-- tabs:start -->

#### ** English **

This section introduces the simple use of SpEL interfaces and its expression language. The complete language reference can be found in [Language Reference](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#expressions-language-ref).
#### ** Chinese **

本节介绍了SpEL接口的简单使用及其表达语言。完整的语言参考资料可以在[语言参考](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#expressions-language-ref)中找到。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following code introduces the SpEL API to evaluate the literal string expression, `Hello World`.
#### ** Chinese **

下面的代码介绍了SpEL API来评价字面字符串表达式`Hello World`。
<!-- tabs:end -->


```java
ExpressionParser parser = new SpelExpressionParser();
Expression exp = parser.parseExpression("'Hello World'"); (1)
String message = (String) exp.getValue();

//(1) The value of the message variable is 'Hello World'.
```

<!-- tabs:start -->

#### ** English **

The SpEL classes and interfaces you are most likely to use are located in the `org.springframework.expression` package and its sub-packages, such as `spel.support`.
#### ** Chinese **

您最可能使用的 SpEL 类和接口位于 `org.springframework.expression`包及其子包中，如 `spel.support`。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The `ExpressionParser` interface is responsible for parsing an expression string. In the preceding example, the expression string is a string literal denoted by the surrounding single quotation marks. The `Expression` interface is responsible for evaluating the previously defined expression string. Two exceptions that can be thrown, `ParseException` and `EvaluationException`, when calling `parser.parseExpression` and `exp.getValue`, respectively.
#### ** Chinese **

`ExpressionParser`接口负责解析一个表达式字符串。在前面的例子中，表达式字符串是由周围的单引号表示的字符串字段。`Expression`接口负责评估之前定义的表达式字符串。当调用`parser.parseExpression`和`exp.getValue`时，会抛出两个异常，分别是`ParseException`和`EvaluationException`。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

SpEL supports a wide range of features, such as calling methods, accessing properties, and calling constructors.
#### ** Chinese **

SpEL支持多种功能，如调用方法、访问属性、调用构造函数等。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

In the following example of method invocation, we call the `concat` method on the string literal:
#### ** Chinese **

在下面的方法调用示例中，我们在字符串字段上调用`concat`方法。
<!-- tabs:end -->


```java
ExpressionParser parser = new SpelExpressionParser();
Expression exp = parser.parseExpression("'Hello World'.concat('!')"); (1)
String message = (String) exp.getValue();

//(1) The value of message is now 'Hello World!'.
```

<!-- tabs:start -->

#### ** English **

The following example of calling a JavaBean property calls the `String` property `Bytes`:
#### ** Chinese **

下面是调用JavaBean属性的示例，调用`String`属性`Bytes`。
<!-- tabs:end -->


```java
ExpressionParser parser = new SpelExpressionParser();

// invokes 'getBytes()'
Expression exp = parser.parseExpression("'Hello World'.bytes"); (1)
byte[] bytes = (byte[]) exp.getValue();

//(1) This line converts the literal to a byte array.
```

<!-- tabs:start -->

#### ** English **

SpEL also supports nested properties by using the standard dot notation (such as `prop1.prop2.prop3`) and also the corresponding setting of property values. Public fields may also be accessed.
#### ** Chinese **

SpEL还支持通过使用标准的点符号（如`prop1.prop2.prop3`）以及相应的属性值设置来支持嵌套属性。也可以访问公共字段。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following example shows how to use dot notation to get the length of a literal:
#### ** Chinese **

下面的例子显示了如何使用点符号来获取字面的长度。
<!-- tabs:end -->


```java
ExpressionParser parser = new SpelExpressionParser();

// invokes 'getBytes().length'
Expression exp = parser.parseExpression("'Hello World'.bytes.length"); (1)
int length = (Integer) exp.getValue();

//(1) 'Hello World'.bytes.length gives the length of the literal.
```

<!-- tabs:start -->

#### ** English **

The String’s constructor can be called instead of using a string literal, as the following example shows:
#### ** Chinese **

String的构造函数可以被调用，而不是使用字符串字段，如下例所示。
<!-- tabs:end -->


```java
ExpressionParser parser = new SpelExpressionParser();
Expression exp = parser.parseExpression("new String('hello world').toUpperCase()"); (1)
String message = exp.getValue(String.class);

//(1) Construct a new String from the literal and make it be upper case.
```

<!-- tabs:start -->

#### ** English **

Note the use of the generic method: `public <T> T getValue(Class<T> desiredResultType)`. Using this method removes the need to cast the value of the expression to the desired result type. An `EvaluationException` is thrown if the value cannot be cast to the type `T` or converted by using the registered type converter.
#### ** Chinese **

注意通用方法的使用。 `public <T> T getValue(Class<T> desiredResultType)`。使用这个方法就不需要将表达式的值投射到所需的结果类型。如果不能将值投射到类型`T`或使用注册的类型转换器进行转换，会抛出一个`EvaluationException`。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The more common usage of SpEL is to provide an expression string that is evaluated against a specific object instance (called the root object). The following example shows how to retrieve the `name` property from an instance of the `Inventor` class or create a boolean condition:
#### ** Chinese **

SpEL的更常见的用法是提供一个表达式字符串，该表达式字符串是针对一个特定对象实例（称为根对象）进行评价的。下面的示例显示了如何从`Inventor`类的实例中检索`name`属性或创建一个布尔条件。
<!-- tabs:end -->


```java
// Create and set a calendar
GregorianCalendar c = new GregorianCalendar();
c.set(1856, 7, 9);

// The constructor arguments are name, birthday, and nationality.
Inventor tesla = new Inventor("Nikola Tesla", c.getTime(), "Serbian");

ExpressionParser parser = new SpelExpressionParser();

Expression exp = parser.parseExpression("name"); // Parse name as an expression
String name = (String) exp.getValue(tesla);
// name == "Nikola Tesla"

exp = parser.parseExpression("name == 'Nikola Tesla'");
boolean result = exp.getValue(tesla, Boolean.class);
// result == true
```

### **4.1.1. Understanding** **`EvaluationContext`** 

<!-- tabs:start -->

#### ** English **

The `EvaluationContext` interface is used when evaluating an expression to resolve properties, methods, or fields and to help perform type conversion. Spring provides two implementations.
#### ** Chinese **

`EvaluationContext`接口用于评价一个表达式以解析属性、方法或字段时，并帮助执行类型转换。Spring 提供了两种实现。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

- Literal expressions

- Boolean and relational operators

- Regular expressions

- Class expressions

- Accessing properties, arrays, lists, and maps

- Method invocation

- Relational operators

- Assignment

- Calling constructors

- Bean references

- Array construction

- Inline lists

- Inline maps

- Ternary operator

- Variables

- User-defined functions

- Collection projection

- Collection selection

- Templated expressions

- `SimpleEvaluationContext`: Exposes a subset of essential SpEL language features and configuration options, for categories of expressions that do not require the full extent of the SpEL language syntax and should be meaningfully restricted. Examples include but are not limited to data binding expressions and property-based filters.

- `StandardEvaluationContext`: Exposes the full set of SpEL language features and configuration options. You can use it to specify a default root object and to configure every available evaluation-related strategy.

#### ** Chinese **

- 字面意义的表达方式

- 布尔运算器和关系运算器

- 正则表达式

- 类表达式

- 访问属性、数组、列表和地图

- 方法调用

- 关联运算符

- 任务

- 调用构造函数

- 豆类参考资料

- 阵列结构

- 内联清单

- 直列式地图

- 三元运算器

- 变量

- 用户定义的功能

- 收藏品投影

- 系列的选择

- Templated expressions

- `SimpleEvaluationContext`：揭示了SpEL语言的基本特性和配置选项的子集，用于不需要完全使用SpEL语言语法的表达式类别，并且应该有意义的限制。例子包括但不限于数据绑定表达式和基于属性的过滤器。

- `StandardEvaluationContext`：公开了SpEL语言的全部功能和配置选项。您可以用它来指定一个默认的根对象，并配置所有可用的评估相关策略。

<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

`SimpleEvaluationContext` is designed to support only a subset of the SpEL language syntax. It excludes Java type references, constructors, and bean references. It also requires you to explicitly choose the level of support for properties and methods in expressions. By default, the `create()` static factory method enables only read access to properties. You can also obtain a builder to configure the exact level of support needed, targeting one or some combination of the following:
#### ** Chinese **

`SimpleEvaluationContext`只支持SpEL语言语法的一个子集。它不包括Java类型引用、构造函数和Bean引用。它还要求你在表达式中明确选择对属性和方法的支持程度。默认情况下，`create()`静态工厂方法只支持对属性的读取访问。你也可以获得一个构建器来配置所需的确切支持级别，目标是以下的一个或一些组合。
<!-- tabs:end -->


### **Type Conversion** 

<!-- tabs:start -->

#### ** English **

By default, SpEL uses the conversion service available in Spring core (`org.springframework.core.convert.ConversionService`). This conversion service comes with many built-in converters for common conversions but is also fully extensible so that you can add custom conversions between types. Additionally, it is generics-aware. This means that, when you work with generic types in expressions, SpEL attempts conversions to maintain type correctness for any objects it encounters.
#### ** Chinese **

默认情况下，SpEL使用Spring core中的转换服务（`org.springframework.core.convert.ConversionService`）。这个转换服务自带了许多用于常见转换的内置转换器，但也是完全可扩展的，因此您可以在类型之间添加自定义转换。此外，它还具有通用性。这意味着，当你在表达式中使用通用类型时，SpEL会尝试进行转换，以保持它遇到的任何对象的类型正确性。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

What does this mean in practice? Suppose assignment, using `setValue()`, is being used to set a `List` property. The type of the property is actually `List<Boolean>`. SpEL recognizes that the elements of the list need to be converted to `Boolean` before being placed in it. The following example shows how to do so:
#### ** Chinese **

这在实践中意味着什么？假设使用`setValue()`的赋值，被用来设置一个`List`属性。该属性的类型实际上是`List<Boolean>`。SpEL 认识到列表中的元素在被放置在列表中之前需要转换为 `Boolean`。下面的例子显示了如何做到这一点。
<!-- tabs:end -->


```java
class Simple {
    public List<Boolean> booleanList = new ArrayList<Boolean>();
}

Simple simple = new Simple();
simple.booleanList.add(true);

EvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding().build();

// "false" is passed in here as a String. SpEL and the conversion service
// will recognize that it needs to be a Boolean and convert it accordingly.
parser.parseExpression("booleanList[0]").setValue(context, simple, "false");

// b is false
Boolean b = simple.booleanList.get(0);
```

### **4.1.2. Parser Configuration** 

<!-- tabs:start -->

#### ** English **

It is possible to configure the SpEL expression parser by using a parser configuration object (`org.springframework.expression.spel.SpelParserConfiguration`). The configuration object controls the behavior of some of the expression components. For example, if you index into an array or collection and the element at the specified index is `null`, you can automatically create the element. This is useful when using expressions made up of a chain of property references. If you index into an array or list and specifying an index that is beyond the end of the current size of the array or list, you can automatically grow the array or list to accommodate that index. The following example demonstrates how to automatically grow the list:
#### ** Chinese **

可以通过使用解析器配置对象(`org.springframework.expression.spel.SpelParserConfiguration`)来配置SpEL表达式解析器。该配置对象控制了一些表达式组件的行为。例如，如果你在数组或集合中做索引，而指定索引处的元素是`null`，你可以自动创建该元素。这在使用由属性引用链组成的表达式时非常有用。如果你在数组或列表中指定了一个索引，并且指定的索引超过了数组或列表的当前大小的末尾，你可以自动增长数组或列表以适应这个索引。下面的例子演示了如何自动增长列表。
<!-- tabs:end -->


```java
class Demo {
    public List<String> list;
}

// Turn on:
// - auto null reference initialization
// - auto collection growing
SpelParserConfiguration config = new SpelParserConfiguration(true,true);

ExpressionParser parser = new SpelExpressionParser(config);

Expression expression = parser.parseExpression("list[3]");

Demo demo = new Demo();

Object o = expression.getValue(demo);

// demo.list will now be a real collection of 4 entries
// Each entry is a new empty String
```

### **4.1.3. SpEL Compilation** 

<!-- tabs:start -->

#### ** English **

Spring Framework 4.1 includes a basic expression compiler. Expressions are usually interpreted, which provides a lot of dynamic flexibility during evaluation but does not provide optimum performance. For occasional expression usage, this is fine, but, when used by other components such as Spring Integration, performance can be very important, and there is no real need for the dynamism.
#### ** Chinese **

Spring Framework 4.1包含了一个基本的表达式编译器。表达式通常是解释的，这在评估过程中提供了很多动态灵活性，但并不能提供最佳性能。对于偶尔的表达式使用，这一点是没有问题的，但是，当被其他组件（如Spring Integration）使用时，性能可能会非常重要，并没有真正需要这种动态性。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The SpEL compiler is intended to address this need. During evaluation, the compiler generates a Java class that embodies the expression behavior at runtime and uses that class to achieve much faster expression evaluation. Due to the lack of typing around expressions, the compiler uses information gathered during the interpreted evaluations of an expression when performing compilation. For example, it does not know the type of a property reference purely from the expression, but during the first interpreted evaluation, it finds out what it is. Of course, basing compilation on such derived information can cause trouble later if the types of the various expression elements change over time. For this reason, compilation is best suited to expressions whose type information is not going to change on repeated evaluations.
#### ** Chinese **

SpEL编译器就是为了解决这一需求。在评估过程中，编译器会生成一个Java类，在运行时体现出表达式行为，并使用该类来实现更快的表达式评估。由于表达式周围缺乏类型化，编译器在执行编译时使用在表达式的解释评价过程中收集的信息。例如，它不能单纯地从表达式中知道一个属性引用的类型，但在第一次被解释的评价中，它就会发现它是什么类型。当然，在这种派生信息的基础上进行编译，如果各种表达式元素的类型随着时间的推移发生变化，会给以后的编译带来麻烦。因此，编译最适合于那些类型信息不会因重复的评价而改变的表达式。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Consider the following basic expression:
#### ** Chinese **

考虑以下基本表达方式：
<!-- tabs:end -->


```java
someArray[0].someProperty.someOtherProperty < 0.1
```

<!-- tabs:start -->

#### ** English **

Because the preceding expression involves array access, some property de-referencing, and numeric operations, the performance gain can be very noticeable. In an example micro benchmark run of 50000 iterations, it took 75ms to evaluate by using the interpreter and only 3ms using the compiled version of the expression.
#### ** Chinese **

因为前面的表达式涉及到数组访问、一些属性去引用和数字操作，所以性能提升非常明显。在一个50000次迭代的微观基准运行的例子中，使用解释器进行评估需要75ms，而使用编译版本的表达式只需要3ms。
<!-- tabs:end -->


### **Compiler Configuration** 

<!-- tabs:start -->

#### ** English **

The compiler is not turned on by default, but you can turn it on in either of two different ways. You can turn it on by using the parser configuration process ([discussed earlier](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#expressions-parser-configuration)) or by using a system property when SpEL usage is embedded inside another component. This section discusses both of these options.
#### ** Chinese **

编译器默认没有开启，但你可以通过两种不同的方式开启。你可以通过使用解析器配置过程([[前面讨论过的](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#expressions-parser-configuration))来打开它，或者当SpEL的使用被嵌入到其他组件中时，使用系统属性来打开它。本节将讨论这两种方法。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The compiler can operate in one of three modes, which are captured in the `org.springframework.expression.spel.SpelCompilerMode` enum. The modes are as follows:
#### ** Chinese **

编译器可以在三种模式中的一种模式下运行，这三种模式被捕捉在`org.springframework.expression.spel.SpelCompilerMode` enum中。这些模式如下。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

- Custom `PropertyAccessor` only (no reflection)

- Data binding properties for read-only access

- Data binding properties for read and write

- `OFF` (default): The compiler is switched off.

- `IMMEDIATE`: In immediate mode, the expressions are compiled as soon as possible. This is typically after the first interpreted evaluation. If the compiled expression fails (typically due to a type changing, as described earlier), the caller of the expression evaluation receives an exception.

- `MIXED`: In mixed mode, the expressions silently switch between interpreted and compiled mode over time. After some number of interpreted runs, they switch to compiled form and, if something goes wrong with the compiled form (such as a type changing, as described earlier), the expression automatically switches back to interpreted form again. Sometime later, it may generate another compiled form and switch to it. Basically, the exception that the user gets in `IMMEDIATE` mode is instead handled internally.

#### ** Chinese **

- 自定义`PropertyAccessor`仅有（无反射）。

- 只读访问的数据绑定属性

- 读和写的数据绑定属性

- `OFF`（默认）。编译器被关闭。

- `IMMEDIATE`：在即时模式下，表达式会尽快被编译。这通常是在第一次被解释的评价之后。如果编译后的表达式失败（通常是由于类型的改变，如前文所述），表达式评价的调用者会收到一个异常。

- `MIXED`：在混合模式下，表达式会随着时间的推移在解释模式和编译模式之间默默地切换。在运行了一定数量的解释模式后，它们会切换到编译形式，如果编译形式出了问题（如前面描述的类型改变），表达式会自动切换回解释模式。过了一段时间，它可能会生成另一个编译形式并切换到它。基本上，用户在`IMMEDIATE`模式下得到的异常基本上都会被内部处理。

<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

`IMMEDIATE` mode exists because `MIXED` mode could cause issues for expressions that have side effects. If a compiled expression blows up after partially succeeding, it may have already done something that has affected the state of the system. If this has happened, the caller may not want it to silently re-run in interpreted mode, since part of the expression may be running twice.
#### ** Chinese **

`IMMEDIATE`模式的存在，是因为`MIXED`模式可能会对有副作用的表达式造成问题。如果编译后的表达式在部分成功后爆炸，可能已经做了一些影响系统状态的事情。如果发生了这种情况，调用者可能不希望它在解释模式下静静地重新运行，因为部分表达式可能会运行两次。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

After selecting a mode, use the `SpelParserConfiguration` to configure the parser. The following example shows how to do so:
#### ** Chinese **

选择模式后，使用`SpelParserConfiguration`来配置解析器。下面的例子显示了如何进行配置。
<!-- tabs:end -->


```java
SpelParserConfiguration config = new SpelParserConfiguration(SpelCompilerMode.IMMEDIATE,
    this.getClass().getClassLoader());

SpelExpressionParser parser = new SpelExpressionParser(config);

Expression expr = parser.parseExpression("payload");

MyMessage message = new MyMessage();

Object payload = expr.getValue(message);
```

<!-- tabs:start -->

#### ** English **

When you specify the compiler mode, you can also specify a classloader (passing null is allowed). Compiled expressions are defined in a child classloader created under any that is supplied. It is important to ensure that, if a classloader is specified, it can see all the types involved in the expression evaluation process. If you do not specify a classloader, a default classloader is used (typically the context classloader for the thread that is running during expression evaluation).
#### ** Chinese **

当你指定编译器模式时，你还可以指定一个类加载器（允许传递null）。编译后的表达式被定义在任何提供的子类加载器下创建的子类加载器中。重要的是，如果指定了一个类加载器，必须确保它能看到表达式评估过程中涉及的所有类型。如果没有指定一个类加载器，则会使用一个默认的类加载器（通常是在表达式评估过程中运行的线程的上下文类加载器）。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The second way to configure the compiler is for use when SpEL is embedded inside some other component and it may not be possible to configure it through a configuration object. In these cases, it is possible to use a system property. You can set the `spring.expression.compiler.mode` property to one of the `SpelCompilerMode` enum values (`off`, `immediate`, or `mixed`).
#### ** Chinese **

第二种配置编译器的方法是当SpEL被嵌入到其他组件中，可能无法通过配置对象来配置时使用。在这种情况下，可以使用系统属性。您可以将 `spring.expression.compiler.mode` 属性设置为 `SpelCompilerMode` 枚举值（`off`、`immediate`或`mixed`）。
<!-- tabs:end -->


### **Compiler Limitations** 

<!-- tabs:start -->

#### ** English **

Since Spring Framework 4.1, the basic compilation framework is in place. However, the framework does not yet support compiling every kind of expression. The initial focus has been on the common expressions that are likely to be used in performance-critical contexts. The following kinds of expression cannot be compiled at the moment:
#### ** Chinese **

自Spring框架4.1以来，基本的编译框架已经具备了。然而，该框架还不支持编译每一种表达式。最初的重点是那些可能在性能关键的上下文中使用的常用表达式。以下几种表达式目前还不能被编译：
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

- Expressions involving assignment

- Expressions relying on the conversion service

- Expressions using custom resolvers or accessors

- Expressions using selection or projection

#### ** Chinese **

- 涉及转让的表达方式

- 依赖于转换服务的表达式

- 使用自定义解析器或访问器的表达式

- 使用选择或投影的表达式

<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

More types of expression will be compilable in the future.
#### ** Chinese **

将来会有更多的表达类型可以编纂。
<!-- tabs:end -->


### **4.2. Expressions in Bean Definitions** 

<!-- tabs:start -->

#### ** English **

You can use SpEL expressions with XML-based or annotation-based configuration metadata for defining `BeanDefinition` instances. In both cases, the syntax to define the expression is of the form `#{ <expression string> }`.
#### ** Chinese **

您可以使用SpEL表达式与基于XML或基于注解的配置元数据来定义`BeanDefinition`实例。在这两种情况下，定义表达式的语法形式为 `#{ <expression string> }`。
<!-- tabs:end -->


### **4.2.1. XML Configuration** 

<!-- tabs:start -->

#### ** English **

A property or constructor argument value can be set by using expressions, as the following example shows:
#### ** Chinese **

属性或构造函数参数值可以通过使用表达式进行设置，如下例所示。
<!-- tabs:end -->


```xml
<bean id="numberGuess" class="org.spring.samples.NumberGuess">
    <property name="randomNumber" value="#{ T(java.lang.Math).random() * 100.0 }"/>

    <!-- other properties -->
</bean>
```

<!-- tabs:start -->

#### ** English **

The `systemProperties` variable is predefined, so you can use it in your expressions, as the following example shows:
#### ** Chinese **

`systemProperties`变量是预定义的，所以你可以在表达式中使用它，如下例所示。
<!-- tabs:end -->


```xml
<bean id="taxCalculator" class="org.spring.samples.TaxCalculator">
    <property name="defaultLocale" value="#{ systemProperties['user.region'] }"/>

    <!-- other properties -->
</bean>
```

<!-- tabs:start -->

#### ** English **

Note that you do not have to prefix the predefined variable with the `#` symbol in this context.
#### ** Chinese **

注意，在这种情况下，你不需要用`#`符号作为预定义变量的前缀。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can also refer to other bean properties by name, as the following example shows:
#### ** Chinese **

你也可以通过名称来引用其他的Bean属性，如下例所示。
<!-- tabs:end -->


```xml
<bean id="numberGuess" class="org.spring.samples.NumberGuess">
    <property name="randomNumber" value="#{ T(java.lang.Math).random() * 100.0 }"/>

    <!-- other properties -->
</bean>

<bean id="shapeGuess" class="org.spring.samples.ShapeGuess">
    <property name="initialShapeSeed" value="#{ numberGuess.randomNumber }"/>

    <!-- other properties -->
</bean>
```

### **4.2.2. Annotation Configuration** 

<!-- tabs:start -->

#### ** English **

To specify a default value, you can place the `@Value` annotation on fields, methods, and method or constructor parameters.
#### ** Chinese **

要指定一个默认值，可以将 `@Value` 注解放在字段、方法和方法或构造函数参数上。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following example sets the default value of a field variable:
#### ** Chinese **

下面的示例设置了一个字段变量的默认值。
<!-- tabs:end -->


```java
public class FieldValueTestBean {

    @Value("#{ systemProperties['user.region'] }")
    private String defaultLocale;

    public void setDefaultLocale(String defaultLocale) {
        this.defaultLocale = defaultLocale;
    }

    public String getDefaultLocale() {
        return this.defaultLocale;
    }
}
```

<!-- tabs:start -->

#### ** English **

The following example shows the equivalent but on a property setter method:
#### ** Chinese **

下面的例子显示了一个属性设置器方法的等价物。
<!-- tabs:end -->


```java
public class PropertyValueTestBean {

    private String defaultLocale;

    @Value("#{ systemProperties['user.region'] }")
    public void setDefaultLocale(String defaultLocale) {
        this.defaultLocale = defaultLocale;
    }

    public String getDefaultLocale() {
        return this.defaultLocale;
    }
}
```

<!-- tabs:start -->

#### ** English **

Autowired methods and constructors can also use the `@Value` annotation, as the following examples show:
#### ** Chinese **

Autowired方法和构造函数也可以使用`@Value`注解，如下例所示。
<!-- tabs:end -->


```java
public class SimpleMovieLister {

    private MovieFinder movieFinder;
    private String defaultLocale;

    @Autowired
    public void configure(MovieFinder movieFinder,
            @Value("#{ systemProperties['user.region'] }") String defaultLocale) {
        this.movieFinder = movieFinder;
        this.defaultLocale = defaultLocale;
    }

    // ...
}
```

```java
public class MovieRecommender {

    private String defaultLocale;

    private CustomerPreferenceDao customerPreferenceDao;

    public MovieRecommender(CustomerPreferenceDao customerPreferenceDao,
            @Value("#{systemProperties['user.country']}") String defaultLocale) {
        this.customerPreferenceDao = customerPreferenceDao;
        this.defaultLocale = defaultLocale;
    }

    // ...
}
```

### **4.3. Language Reference** 

<!-- tabs:start -->

#### ** English **

This section describes how the Spring Expression Language works. It covers the following topics:
#### ** Chinese **

本节介绍了Spring表达式语言的工作原理。它包括以下主题。
<!-- tabs:end -->


### **4.3.1. Literal Expressions** 

<!-- tabs:start -->

#### ** English **

The types of literal expressions supported are strings, numeric values (int, real, hex), boolean, and null. Strings are delimited by single quotation marks. To put a single quotation mark itself in a string, use two single quotation mark characters.
#### ** Chinese **

支持的字面表达式类型有字符串、数字值（int、real、hex）、boolean和null。字符串由单引号分隔。要在字符串中放置一个单引号本身，请使用两个单引号字符。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following listing shows simple usage of literals. Typically, they are not used in isolation like this but, rather, as part of a more complex expression — for example, using a literal on one side of a logical comparison operator.
#### ** Chinese **

下面列出了一些简单的字面符号的使用方法。通常情况下，它们不是像这样单独使用，而是作为更复杂的表达式的一部分--例如，在逻辑比较运算符的一侧使用字面符号。
<!-- tabs:end -->


```java
ExpressionParser parser = new SpelExpressionParser();

// evals to "Hello World"
String helloWorld = (String) parser.parseExpression("'Hello World'").getValue();

double avogadrosNumber = (Double) parser.parseExpression("6.0221415E+23").getValue();

// evals to 2147483647
int maxValue = (Integer) parser.parseExpression("0x7FFFFFFF").getValue();

boolean trueValue = (Boolean) parser.parseExpression("true").getValue();

Object nullValue = parser.parseExpression("null").getValue();
```

<!-- tabs:start -->

#### ** English **

Numbers support the use of the negative sign, exponential notation, and decimal points. By default, real numbers are parsed by using Double.parseDouble().
#### ** Chinese **

数字支持使用负号、指数符号和小数点。默认情况下，实数是通过使用Double.parseDouble()来解析的。
<!-- tabs:end -->


### **4.3.2. Properties, Arrays, Lists, Maps, and Indexers** 

<!-- tabs:start -->

#### ** English **

Navigating with property references is easy. To do so, use a period to indicate a nested property value. The instances of the `Inventor` class, `pupin` and `tesla`, were populated with data listed in the [Classes used in the examples](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#expressions-example-classes) section. To navigate “down” and get Tesla’s year of birth and Pupin’s city of birth, we use the following expressions:
#### ** Chinese **

使用属性引用进行导航很容易。要做到这一点，使用句号来表示嵌套的属性值。`Inventor`类、`pupin`和`tesla`的实例都是用[示例中使用的类](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#expressions-example-classes)部分中列出的数据填充的。为了 "向下 "导航，得到Tesla的出生年份和Pupin的出生城市，我们使用以下表达式。
<!-- tabs:end -->


```java
// evals to 1856
int year = (Integer) parser.parseExpression("Birthdate.Year + 1900").getValue(context);

String city = (String) parser.parseExpression("placeOfBirth.City").getValue(context);
```

<!-- tabs:start -->

#### ** English **

Case insensitivity is allowed for the first letter of property names. The contents of arrays and lists are obtained by using square bracket notation, as the following example shows:
#### ** Chinese **

对于属性名称的第一个字母，允许大小写不敏感。如下面的例子所示，数组和列表的内容是通过使用方括号符号获得的。
<!-- tabs:end -->


```java
ExpressionParser parser = new SpelExpressionParser();
EvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding().build();

// Inventions Array

// evaluates to "Induction motor"
String invention = parser.parseExpression("inventions[3]").getValue(
        context, tesla, String.class);

// Members List

// evaluates to "Nikola Tesla"
String name = parser.parseExpression("Members[0].Name").getValue(
        context, ieee, String.class);

// List and Array navigation
// evaluates to "Wireless communication"
String invention = parser.parseExpression("Members[0].Inventions[6]").getValue(
        context, ieee, String.class);
```

<!-- tabs:start -->

#### ** English **

The contents of maps are obtained by specifying the literal key value within the brackets. In the following example, because keys for the `Officers` map are strings, we can specify string literals:
#### ** Chinese **

地图的内容通过在括号内指定字面键值来获得。在下面的例子中，由于`Officers`映射的键值是字符串，所以我们可以指定字符串的字面值。
<!-- tabs:end -->


```java
// Officer's Dictionary

Inventor pupin = parser.parseExpression("Officers['president']").getValue(
        societyContext, Inventor.class);

// evaluates to "Idvor"
String city = parser.parseExpression("Officers['president'].PlaceOfBirth.City").getValue(
        societyContext, String.class);

// setting values
parser.parseExpression("Officers['advisors'][0].PlaceOfBirth.Country").setValue(
        societyContext, "Croatia");
```

### **4.3.3. Inline Lists** 

<!-- tabs:start -->

#### ** English **

You can directly express lists in an expression by using `{}` notation.
#### ** Chinese **

你可以使用`{}`符号在表达式中直接表达列表。
<!-- tabs:end -->


```java
// evaluates to a Java list containing the four numbers
List numbers = (List) parser.parseExpression("{1,2,3,4}").getValue(context);

List listOfLists = (List) parser.parseExpression("{{'a','b'},{'x','y'}}").getValue(context);
```

<!-- tabs:start -->

#### ** English **

`{}` by itself means an empty list. For performance reasons, if the list is itself entirely composed of fixed literals, a constant list is created to represent the expression (rather than building a new list on each evaluation).
#### ** Chinese **

`{}`本身就意味着一个空列表。出于性能上的考虑，如果列表本身完全由固定的字形符组成，则创建一个常量列表来表示表达式（而不是在每次评价时建立一个新的列表）。
<!-- tabs:end -->


### **4.3.4. Inline Maps** 

<!-- tabs:start -->

#### ** English **

You can also directly express maps in an expression by using `{key:value}` notation. The following example shows how to do so:
#### ** Chinese **

你也可以通过使用`{key:value}`符号在表达式中直接表达映射。下面的例子说明了如何做到这一点。
<!-- tabs:end -->


```java
// evaluates to a Java map containing the two entries
Map inventorInfo = (Map) parser.parseExpression("{name:'Nikola',dob:'10-July-1856'}").getValue(context);

Map mapOfMaps = (Map) parser.parseExpression("{name:{first:'Nikola',last:'Tesla'},dob:{day:10,month:'July',year:1856}}").getValue(context);
```

<!-- tabs:start -->

#### ** English **

`{:}` by itself means an empty map. For performance reasons, if the map is itself composed of fixed literals or other nested constant structures (lists or maps), a constant map is created to represent the expression (rather than building a new map on each evaluation). Quoting of the map keys is optional. The examples above do not use quoted keys.
#### ** Chinese **

`{:}`本身就意味着一个空映射。出于性能上的考虑，如果映射本身是由固定的字形或其他嵌套的常量结构（列表或映射）组成，那么就会创建一个常量映射来表示表达式（而不是在每次评价时建立一个新的映射）。映射图键的引用是可选的。上面的例子不使用引号键。
<!-- tabs:end -->


### **4.3.5. Array Construction** 

<!-- tabs:start -->

#### ** English **

You can build arrays by using the familiar Java syntax, optionally supplying an initializer to have the array populated at construction time. The following example shows how to do so:
#### ** Chinese **

你可以通过使用熟悉的Java语法来构建数组，可以选择提供一个初始化器，以便在构建时填充数组。下面的例子显示了如何做到这一点。
<!-- tabs:end -->


```java
int[] numbers1 = (int[]) parser.parseExpression("new int[4]").getValue(context);

// Array with initializer
int[] numbers2 = (int[]) parser.parseExpression("new int[]{1,2,3}").getValue(context);

// Multi dimensional array
int[][] numbers3 = (int[][]) parser.parseExpression("new int[4][5]").getValue(context);
```

<!-- tabs:start -->

#### ** English **

You cannot currently supply an initializer when you construct multi-dimensional array.
#### ** Chinese **

当前，当你构造多维数组时，你不能提供一个初始化器。
<!-- tabs:end -->


### **4.3.6. Methods** 

<!-- tabs:start -->

#### ** English **

You can invoke methods by using typical Java programming syntax. You can also invoke methods on literals. Variable arguments are also supported. The following examples show how to invoke methods:
#### ** Chinese **

你可以使用典型的Java编程语法来调用方法。你也可以在字面符号上调用方法。也支持变量参数。下面的例子显示了如何调用方法。
<!-- tabs:end -->


```java
// string literal, evaluates to "bc"
String bc = parser.parseExpression("'abc'.substring(1, 3)").getValue(String.class);

// evaluates to true
boolean isMember = parser.parseExpression("isMember('Mihajlo Pupin')").getValue(
        societyContext, Boolean.class);
```

### **4.3.7. Operators** 

<!-- tabs:start -->

#### ** English **

The Spring Expression Language supports the following kinds of operators:
#### ** Chinese **

Spring表达式语言支持以下几种运算符。
<!-- tabs:end -->


### **Relational Operators** 

<!-- tabs:start -->

#### ** English **

The relational operators (equal, not equal, less than, less than or equal, greater than, and greater than or equal) are supported by using standard operator notation. The following listing shows a few examples of operators:
#### ** Chinese **

关系型运算符（等、不等、小于、小于、小于或等于、大于、大于、大于或等于）使用标准的运算符符号支持。下面列出了一些操作符的例子。
<!-- tabs:end -->


```java
// evaluates to true
boolean trueValue = parser.parseExpression("2 == 2").getValue(Boolean.class);

// evaluates to false
boolean falseValue = parser.parseExpression("2 < -5.0").getValue(Boolean.class);

// evaluates to true
boolean trueValue = parser.parseExpression("'black' < 'block'").getValue(Boolean.class);
```

<!-- tabs:start -->

#### ** English **

Greater-than and less-than comparisons against `null` follow a simple rule: `null` is treated as nothing (that is NOT as zero). As a consequence, any other value is always greater than `null` (`X > null` is always `true`) and no other value is ever less than nothing (`X < null` is always `false`).
#### ** Chinese **

对`null`的大于和小于比较遵循一个简单的规则。 `null`被视为无（即不是零）。因此，任何其他值总是大于`null` (`X > null`总是`true`)，而其他任何值都不会小于nothing (`X < null`总是`false`)。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

If you prefer numeric comparisons instead, avoid number-based `null` comparisons in favor of comparisons against zero (for example, `X > 0` or `X < 0`).
#### ** Chinese **

如果您更喜欢数字比较，请避免基于数字的`null`比较，而选择与零比较（例如，`X > 0`或`X < 0`）。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

In addition to the standard relational operators, SpEL supports the `instanceof` and regular expression-based `matches` operator. The following listing shows examples of both:
#### ** Chinese **

除了标准的关系运算符之外，SpEL还支持`instanceof`和基于正则表达式的`matches`运算符。下面的列表显示了这两种操作符的例子。
<!-- tabs:end -->


```java
// evaluates to false
boolean falseValue = parser.parseExpression(
        "'xyz' instanceof T(Integer)").getValue(Boolean.class);

// evaluates to true
boolean trueValue = parser.parseExpression(
        "'5.00' matches '^-?\\d+(\\.\\d{2})?$'").getValue(Boolean.class);

//evaluates to false
boolean falseValue = parser.parseExpression(
        "'5.0067' matches '^-?\\d+(\\.\\d{2})?$'").getValue(Boolean.class);
```

<!-- tabs:start -->

#### ** English **

Be careful with primitive types, as they are immediately boxed up to the wrapper type, so `1 instanceof T(int)` evaluates to `false` while `1 instanceof T(Integer)` evaluates to `true`, as expected.
#### ** Chinese **

对于基元类型要小心，因为它们会立即被包装器类型框起来，所以`1 instanceof T(int)`的1个实例T(int)</x>会评估为`false`，而`1 instanceof T(Integer)`的1个实例T(Integer)</x>会评估为`true`，这也是预期的。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Each symbolic operator can also be specified as a purely alphabetic equivalent. This avoids problems where the symbols used have special meaning for the document type in which the expression is embedded (such as in an XML document). The textual equivalents are:
#### ** Chinese **

每个符号运算符也可以被指定为纯字母等价物。这就避免了使用的符号对表达式所嵌入的文档类型有特殊意义的问题（例如在XML文档中）。文本的等价物是:
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

- [Literal Expressions](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#expressions-ref-literal)

- [Properties, Arrays, Lists, Maps, and Indexers](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#expressions-properties-arrays)

- [Inline Lists](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#expressions-inline-lists)

- [Inline Maps](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#expressions-inline-maps)

- [Array Construction](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#expressions-array-construction)

- [Methods](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#expressions-methods)

- [Operators](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#expressions-operators)

- [Types](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#expressions-types)

- [Constructors](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#expressions-constructors)

- [Variables](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#expressions-ref-variables)

- [Functions](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#expressions-ref-functions)

- [Bean References](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#expressions-bean-references)

- [Ternary Operator (If-Then-Else)](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#expressions-operator-ternary)

- [The Elvis Operator](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#expressions-operator-elvis)

- [Safe Navigation Operator](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#expressions-operator-safe-navigation)

- [Relational Operators](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#expressions-operators-relational)

- [Logical Operators](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#expressions-operators-logical)

- [Mathematical Operators](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#expressions-operators-mathematical)

- [The Assignment Operator](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#expressions-assignment)

- `lt` (`<`)

- `gt` (`>`)

- `le` (`<=`)

- `ge` (`>=`)

- `eq` (`==`)

- `ne` (`!=`)

- `div` (`/`)

- `mod` (`%`)

- `not` (`!`).

#### ** Chinese **

- [Literal Expressions](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#expressions-ref-literal)

- [Properties, Arrays, Lists, Maps, and Indexers](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#expressions-properties-arrays)

- [Inline Lists](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#expressions-inline-lists)

- [Inline Maps](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#expressions-inline-maps)

- [Array Construction](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#expressions-array-construction)

- [Methods](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#expressions-methods)

- [Operators](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#expressions-operators)

- [Types](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#expressions-types)

- [Constructors](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#expressions-constructors)

- [Variables](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#expressions-ref-variables)

- [Functions](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#expressions-ref-functions)

- [Bean References](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#expressions-bean-references)

- [Ternary Operator (If-Then-Else)](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#expressions-operator-ternary)

- [The Elvis Operator](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#expressions-operator-elvis)

- [Safe Navigation Operator](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#expressions-operator-safe-navigation)

- [Relational Operators](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#expressions-operators-relational)

- [Logical Operators](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#expressions-operators-logical)

- [Mathematical Operators](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#expressions-operators-mathematical)

- [The Assignment Operator](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#expressions-assignment)

- `lt` (`<`)

- `gt` (`>`)

- `le` (`<=`)

- `ge` (`>=`)

- `eq` (`==`)

- `ne` (`!=`)

- `div` (`/`)

- `mod` (`%`)

- `not` (`!`).

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

All of the textual operators are case-insensitive.
#### ** Chinese **

所有的文字运算符都不区分大小写。
<!-- tabs:end -->


### **Logical Operators** 

<!-- tabs:start -->

#### ** English **

SpEL supports the following logical operators:
#### ** Chinese **

SpEL支持以下逻辑运算符。
<!-- tabs:end -->


- `and` (`&&`)

- `or` (`||`)

- `not` (`!`)

<!-- tabs:start -->

#### ** English **

The following example shows how to use the logical operators
#### ** Chinese **

下面的例子显示了如何使用逻辑运算符的方法。
<!-- tabs:end -->


```java
// -- AND --

// evaluates to false
boolean falseValue = parser.parseExpression("true and false").getValue(Boolean.class);

// evaluates to true
String expression = "isMember('Nikola Tesla') and isMember('Mihajlo Pupin')";
boolean trueValue = parser.parseExpression(expression).getValue(societyContext, Boolean.class);

// -- OR --

// evaluates to true
boolean trueValue = parser.parseExpression("true or false").getValue(Boolean.class);

// evaluates to true
String expression = "isMember('Nikola Tesla') or isMember('Albert Einstein')";
boolean trueValue = parser.parseExpression(expression).getValue(societyContext, Boolean.class);

// -- NOT --

// evaluates to false
boolean falseValue = parser.parseExpression("!true").getValue(Boolean.class);

// -- AND and NOT --
String expression = "isMember('Nikola Tesla') and !isMember('Mihajlo Pupin')";
boolean falseValue = parser.parseExpression(expression).getValue(societyContext, Boolean.class);
```

### **Mathematical Operators** 

<!-- tabs:start -->

#### ** English **

You can use the addition operator on both numbers and strings. You can use the subtraction, multiplication, and division operators only on numbers. You can also use the modulus (%) and exponential power (^) operators. Standard operator precedence is enforced. The following example shows the mathematical operators in use:
#### ** Chinese **

你可以在数字和字符串上使用加法运算符。您可以在数字上使用减法、乘法和除法运算符。你也可以使用模数 (%) 和指数幂 (^) 运算符。标准运算符的优先级是强制执行的。下面的例子显示了使用中的数学运算符。

<!-- tabs:end -->


```java
// Addition
int two = parser.parseExpression("1 + 1").getValue(Integer.class);  // 2

String testString = parser.parseExpression(
        "'test' + ' ' + 'string'").getValue(String.class);  // 'test string'

// Subtraction
int four = parser.parseExpression("1 - -3").getValue(Integer.class);  // 4

double d = parser.parseExpression("1000.00 - 1e4").getValue(Double.class);  // -9000

// Multiplication
int six = parser.parseExpression("-2 * -3").getValue(Integer.class);  // 6

double twentyFour = parser.parseExpression("2.0 * 3e0 * 4").getValue(Double.class);  // 24.0

// Division
int minusTwo = parser.parseExpression("6 / -3").getValue(Integer.class);  // -2

double one = parser.parseExpression("8.0 / 4e0 / 2").getValue(Double.class);  // 1.0

// Modulus
int three = parser.parseExpression("7 % 4").getValue(Integer.class);  // 3

int one = parser.parseExpression("8 / 5 % 2").getValue(Integer.class);  // 1

// Operator precedence
int minusTwentyOne = parser.parseExpression("1+2-3*8").getValue(Integer.class);  // -21
```

### **The Assignment Operator** 


<!-- tabs:start -->

#### ** English **

To setting a property, use the assignment operator (`=`). This is typically done within a call to `setValue` but can also be done inside a call to `getValue`. The following listing shows both ways to use the assignment operator:
#### ** Chinese **

要设置一个属性，请使用赋值操作符(`=`)。这通常是在调用`setValue`中进行的，但也可以在调用`getValue`中进行。下面的列表显示了两种使用赋值操作符的方法。
<!-- tabs:end -->


```java
Inventor inventor = new Inventor();
EvaluationContext context = SimpleEvaluationContext.forReadWriteDataBinding().build();

parser.parseExpression("Name").setValue(context, inventor, "Aleksandar Seovic");

// alternatively
String aleks = parser.parseExpression(
        "Name = 'Aleksandar Seovic'").getValue(context, inventor, String.class);
```

### **4.3.8. Types** 

<!-- tabs:start -->

#### ** English **

You can use the special `T` operator to specify an instance of `java.lang.Class` (the type). Static methods are invoked by using this operator as well. The `StandardEvaluationContext` uses a `TypeLocator` to find types, and the `StandardTypeLocator` (which can be replaced) is built with an understanding of the `java.lang` package. This means that `T()` references to types within `java.lang` do not need to be fully qualified, but all other type references must be. The following example shows how to use the `T` operator:
#### ** Chinese **

你可以使用特殊的`T`操作符来指定一个`java.lang.Class`（类型）的实例。静态方法也可以通过使用这个操作符来调用。`StandardEvaluationContext`使用一个`TypeLocator`来查找类型，而`StandardTypeLocator`（可以被替换）是在理解`java.lang`包的基础上建立的。这意味着在`java.lang`中对类型的`T()`引用不需要完全限定，但所有其他类型的引用必须完全限定。下面的示例显示了如何使用 `T` 操作符。
<!-- tabs:end -->


```java
class dateClass = parser.parseExpression("T(java.util.Date)").getValue(Class.class);

Class stringClass = parser.parseExpression("T(String)").getValue(Class.class);

boolean trueValue = parser.parseExpression(
        "T(java.math.RoundingMode).CEILING < T(java.math.RoundingMode).FLOOR")
        .getValue(Boolean.class);
```

### **4.3.9. Constructors** 

<!-- tabs:start -->

#### ** English **

You can invoke constructors by using the `new` operator. You should use the fully qualified class name for all but the primitive types (`int`, `float`, and so on) and String. The following example shows how to use the `new` operator to invoke constructors:
#### ** Chinese **

你可以使用`new`操作符来调用构造函数。除了基元类型（`int`、`float`等）和String以外，你应该使用完全限定的类名。下面的例子显示了如何使用`new`操作符来调用构造函数。
<!-- tabs:end -->


```java
Inventor einstein = p.parseExpression(
        "new org.spring.samples.spel.inventor.Inventor('Albert Einstein', 'German')")
        .getValue(Inventor.class);

//create new inventor instance within add method of List
p.parseExpression(
        "Members.add(new org.spring.samples.spel.inventor.Inventor(
            'Albert Einstein', 'German'))").getValue(societyContext);
```

### **4.3.10. Variables** 

<!-- tabs:start -->

#### ** English **

You can reference variables in the expression by using the `#variableName` syntax. Variables are set by using the `setVariable` method on `EvaluationContext` implementations.
#### ** Chinese **

你可以使用`#variableName`语法在表达式中引用变量。变量通过使用`setVariable`方法在`EvaluationContext`实现中设置。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Valid variable names must be composed of one or more of the following supported characters.
#### ** Chinese **

有效的变量名称必须由以下一个或多个支持的字符组成。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

- letters: `A` to `Z` and `a` to `z`

- digits: `0` to `9`

- underscore: `_`

- dollar sign: `$`

#### ** Chinese **

- 字母。 `A`至`Z`和`a`至`z`

- 数字。 `0`至`9`。

- 下划线：`_` `_`

- 美元符号。 `$`

<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

The following example shows how to use variables.
#### ** Chinese **

下面的例子显示了如何使用变量。
<!-- tabs:end -->


```java
Inventor tesla = new Inventor("Nikola Tesla", "Serbian");

EvaluationContext context = SimpleEvaluationContext.forReadWriteDataBinding().build();
context.setVariable("newName", "Mike Tesla");

parser.parseExpression("Name = #newName").getValue(context, tesla);
System.out.println(tesla.getName())  // "Mike Tesla"
```

### **The** **`#this`** ** and** **`#root`** ** Variables** 

<!-- tabs:start -->

#### ** English **

The `#this` variable is always defined and refers to the current evaluation object (against which unqualified references are resolved). The `#root` variable is always defined and refers to the root context object. Although `#this` may vary as components of an expression are evaluated, `#root` always refers to the root. The following examples show how to use the `#this` and `#root` variables:
#### ** Chinese **

`#this`变量总是被定义，并指向当前评估对象（非限定引用被解析）。`#root`变量总是被定义，并指向根上下文对象。尽管`#this`可能会随着表达式的组件被评价的不同而变化，但`#root`总是指向根对象。下面的示例展示了如何使用`#this`和`#root`变量。
<!-- tabs:end -->


```java
// create an array of integers
List<Integer> primes = new ArrayList<Integer>();
primes.addAll(Arrays.asList(2,3,5,7,11,13,17));

// create parser and set variable 'primes' as the array of integers
ExpressionParser parser = new SpelExpressionParser();
EvaluationContext context = SimpleEvaluationContext.forReadOnlyDataAccess();
context.setVariable("primes", primes);

// all prime numbers > 10 from the list (using selection ?{...})
// evaluates to [11, 13, 17]
List<Integer> primesGreaterThanTen = (List<Integer>) parser.parseExpression(
        "#primes.?[#this>10]").getValue(context);
```

### **4.3.11. Functions** 

<!-- tabs:start -->

#### ** English **

You can extend SpEL by registering user-defined functions that can be called within the expression string. The function is registered through the `EvaluationContext`. The following example shows how to register a user-defined function:
#### ** Chinese **

你可以通过注册用户定义的函数来扩展SpEL，这些函数可以在表达式字符串中调用。该函数通过`EvaluationContext`注册。下面的例子显示了如何注册一个用户定义的函数。
<!-- tabs:end -->


```java
Method method = ...;

EvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding().build();
context.setVariable("myFunction", method);
```

<!-- tabs:start -->

#### ** English **

For example, consider the following utility method that reverses a string:
#### ** Chinese **

例如，考虑下面的实用方法，可以反转一个字符串。
<!-- tabs:end -->


```java
public abstract class StringUtils {

    public static String reverseString(String input) {
        StringBuilder backwards = new StringBuilder(input.length());
        for (int i = 0; i < input.length(); i++) {
            backwards.append(input.charAt(input.length() - 1 - i));
        }
        return backwards.toString();
    }
}
```

<!-- tabs:start -->

#### ** English **

You can then register and use the preceding method, as the following example shows:
#### ** Chinese **

然后可以注册并使用前面的方法，如下例所示。
<!-- tabs:end -->


```java
ExpressionParser parser = new SpelExpressionParser();

EvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding().build();
context.setVariable("reverseString",
        StringUtils.class.getDeclaredMethod("reverseString", String.class));

String helloWorldReversed = parser.parseExpression(
        "#reverseString('hello')").getValue(context, String.class);
```

### **4.3.12. Bean References** 

<!-- tabs:start -->

#### ** English **

If the evaluation context has been configured with a bean resolver, you can look up beans from an expression by using the `@` symbol. The following example shows how to do so:
#### ** Chinese **

如果评估上下文已配置了 bean resolver，则可以通过使用 `@`符号从表达式中查找 bean。下面的例子显示了如何做到这一点。
<!-- tabs:end -->


```java
ExpressionParser parser = new SpelExpressionParser();
StandardEvaluationContext context = new StandardEvaluationContext();
context.setBeanResolver(new MyBeanResolver());

// This will end up calling resolve(context,"something") on MyBeanResolver during evaluation
Object bean = parser.parseExpression("@something").getValue(context);
```

<!-- tabs:start -->

#### ** English **

To access a factory bean itself, you should instead prefix the bean name with an `&` symbol. The following example shows how to do so:
#### ** Chinese **

要访问一个工厂Bean本身，你应该在Bean名前加上`&`符号。下面的例子显示了如何做到这一点。
<!-- tabs:end -->


```java
ExpressionParser parser = new SpelExpressionParser();
StandardEvaluationContext context = new StandardEvaluationContext();
context.setBeanResolver(new MyBeanResolver());

// This will end up calling resolve(context,"&foo") on MyBeanResolver during evaluation
Object bean = parser.parseExpression("&foo").getValue(context);
```

### **4.3.13. Ternary Operator (If-Then-Else)** 

<!-- tabs:start -->

#### ** English **

You can use the ternary operator for performing if-then-else conditional logic inside the expression. The following listing shows a minimal example:
#### ** Chinese **

你可以在表达式中使用三元运算符来执行if-then-else条件逻辑。下面列出了一个最小的例子。
<!-- tabs:end -->


```java
String falseString = parser.parseExpression(
        "false ? 'trueExp' : 'falseExp'").getValue(String.class);
```

<!-- tabs:start -->

#### ** English **

In this case, the boolean `false` results in returning the string value `'falseExp'`. A more realistic example follows:
#### ** Chinese **

在这种情况下，布尔值`false`会返回字符串值`'falseExp'`。下面是一个更现实的例子。
<!-- tabs:end -->


```java
parser.parseExpression("Name").setValue(societyContext, "IEEE");
societyContext.setVariable("queryName", "Nikola Tesla");

expression = "isMember(#queryName)? #queryName + ' is a member of the ' " +
        "+ Name + ' Society' : #queryName + ' is not a member of the ' + Name + ' Society'";

String queryResultString = parser.parseExpression(expression)
        .getValue(societyContext, String.class);
// queryResultString = "Nikola Tesla is a member of the IEEE Society"
```

<!-- tabs:start -->

#### ** English **

See the next section on the Elvis operator for an even shorter syntax for the ternary operator.
#### ** Chinese **

有关三元运算符的更短的语法，请看下一节关于Elvis运算符的语法。
<!-- tabs:end -->


### **4.3.14. The Elvis Operator** 

<!-- tabs:start -->

#### ** English **

The Elvis operator is a shortening of the ternary operator syntax and is used in the [Groovy](http://www.groovy-lang.org/operators.html#_elvis_operator) language. With the ternary operator syntax, you usually have to repeat a variable twice, as the following example shows:
#### ** Chinese **

Elvis运算符是三元运算符语法的简称，在[Groovy](http://www.groovy-lang.org/operators.html#_elvis_operator)语言中使用。使用三元运算符语法，你通常需要重复使用两次变量，如下例所示。
<!-- tabs:end -->


```java
String name = "Elvis Presley";
String displayName = (name != null ? name : "Unknown");
```

<!-- tabs:start -->

#### ** English **

Instead, you can use the Elvis operator (named for the resemblance to Elvis' hair style). The following example shows how to use the Elvis operator:
#### ** Chinese **

相反，你可以使用Elvis操作符（因与猫王的发型相似而命名）。下面的例子说明了如何使用Elvis操作符。
<!-- tabs:end -->


```java
ExpressionParser parser = new SpelExpressionParser();

String name = parser.parseExpression("name?:'Unknown'").getValue(String.class);
System.out.println(name);  // 'Unknown'
```

<!-- tabs:start -->

#### ** English **

The following listing shows a more complex example:
#### ** Chinese **

下面列举了一个比较复杂的例子。
<!-- tabs:end -->


```java
ExpressionParser parser = new SpelExpressionParser();
EvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding().build();

Inventor tesla = new Inventor("Nikola Tesla", "Serbian");
String name = parser.parseExpression("Name?:'Elvis Presley'").getValue(context, tesla, String.class);
System.out.println(name);  // Nikola Tesla

tesla.setName(null);
name = parser.parseExpression("Name?:'Elvis Presley'").getValue(context, tesla, String.class);
System.out.println(name);  // Elvis Presley
```

<!-- tabs:start -->

#### ** English **

You can use the Elvis operator to apply default values in expressions. The following example shows how to use the Elvis operator in a `@Value` expression:
#### ** Chinese **

你可以使用Elvis操作符来应用表达式中的默认值。下面的例子显示了如何在`@Value`表达式中使用Elvis操作符。
<!-- tabs:end -->


```java
@Value("#{systemProperties['pop3.port'] ?: 25}")
```

<!-- tabs:start -->

#### ** English **

This will inject a system property `pop3.port` if it is defined or 25 if not.
#### ** Chinese **

如果定义了系统属性 `pop3.port`， 则将注入系统属性 `pop3.port`， 如果没有定义，则注入 25。
<!-- tabs:end -->


### **4.3.15. Safe Navigation Operator** 

<!-- tabs:start -->

#### ** English **

The safe navigation operator is used to avoid a `NullPointerException` and comes from the [Groovy](http://www.groovy-lang.org/operators.html#_safe_navigation_operator) language. Typically, when you have a reference to an object, you might need to verify that it is not null before accessing methods or properties of the object. To avoid this, the safe navigation operator returns null instead of throwing an exception. The following example shows how to use the safe navigation operator:
#### ** Chinese **

安全导航操作符用于避免出现`NullPointerException`，它来自于[Groovy](http://www.groovy-lang.org/operators.html#_safe_navigation_operator)语言。通常情况下，当你有一个对象的引用时，你可能需要在访问对象的方法或属性之前验证它不是null。为了避免这种情况，安全导航操作符会返回null而不是抛出异常。下面的例子显示了如何使用安全导航操作符。
<!-- tabs:end -->


```java
ExpressionParser parser = new SpelExpressionParser();
EvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding().build();

Inventor tesla = new Inventor("Nikola Tesla", "Serbian");
tesla.setPlaceOfBirth(new PlaceOfBirth("Smiljan"));

String city = parser.parseExpression("PlaceOfBirth?.City").getValue(context, tesla, String.class);
System.out.println(city);  // Smiljan

tesla.setPlaceOfBirth(null);
city = parser.parseExpression("PlaceOfBirth?.City").getValue(context, tesla, String.class);
System.out.println(city);  // null - does not throw NullPointerException!!!
```

### **4.3.16. Collection Selection** 

<!-- tabs:start -->

#### ** English **

Selection is a powerful expression language feature that lets you transform a source collection into another collection by selecting from its entries.
#### ** Chinese **

选择是一个强大的表达式语言功能，可以通过从源集合的条目中选择，将源集合转化为另一个集合。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Selection uses a syntax of `.?[selectionExpression]`. It filters the collection and returns a new collection that contain a subset of the original elements. For example, selection lets us easily get a list of Serbian inventors, as the following example shows:
#### ** Chinese **

Selection使用的语法是`.?[selectionExpression]`。它对集合进行过滤，并返回一个新的集合，其中包含原始元素的子集。例如，selection可以让我们轻松地获得一个塞尔维亚发明者的列表，如下例所示。
<!-- tabs:end -->


```java
List<Inventor> list = (List<Inventor>) parser.parseExpression(
        "Members.?[Nationality == 'Serbian']").getValue(societyContext);
```

<!-- tabs:start -->

#### ** English **

Selection is possible upon both lists and maps. For a list, the selection criteria is evaluated against each individual list element. Against a map, the selection criteria is evaluated against each map entry (objects of the Java type `Map.Entry`). Each map entry has its key and value accessible as properties for use in the selection.
#### ** Chinese **

在列表和地图上都可以进行选择。对于列表，选择标准是针对每个单独的列表元素进行评估。对于地图，选择标准是针对每个地图条目（Java类型`Map.Entry`的对象）进行评估。每个地图条目都有其键和值作为属性，可以在选择中使用。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following expression returns a new map that consists of those elements of the original map where the entry value is less than 27:
#### ** Chinese **

下面的表达式将返回一个新的地图，它由原始地图中条目值小于27的元素组成。
<!-- tabs:end -->


```java
Map newMap = parser.parseExpression("map.?[value<27]").getValue();
```

<!-- tabs:start -->

#### ** English **

In addition to returning all the selected elements, you can retrieve only the first or the last value. To obtain the first entry matching the selection, the syntax is `.^[selectionExpression]`. To obtain the last matching selection, the syntax is `.$[selectionExpression]`.
#### ** Chinese **

除了返回所有被选中的元素外，还可以只获取第一个或最后一个值。要获得与选区匹配的第一个条目，语法是`.^[selectionExpression]`。要获得最后一个匹配的选择，语法是`.$[selectionExpression]`。
<!-- tabs:end -->


### **4.3.17. Collection Projection** 

<!-- tabs:start -->

#### ** English **

Projection lets a collection drive the evaluation of a sub-expression, and the result is a new collection. The syntax for projection is `.![projectionExpression]`. For example, suppose we have a list of inventors but want the list of cities where they were born. Effectively, we want to evaluate 'placeOfBirth.city' for every entry in the inventor list. The following example uses projection to do so:
#### ** Chinese **

投射让一个集合驱动一个子表达式的评价，结果就是一个新的集合。投射的语法是 `.![projectionExpression]`。例如，假设我们有一个发明家的列表，但我们希望得到他们出生的城市列表。实际上，我们要对发明人列表中的每一个条目进行评估placeOfBirth.city。下面的例子使用了投影来实现这个目标。
<!-- tabs:end -->


```java
// returns ['Smiljan', 'Idvor' ]
List placesOfBirth = (List)parser.parseExpression("Members.![placeOfBirth.city]");
```

<!-- tabs:start -->

#### ** English **

You can also use a map to drive projection and, in this case, the projection expression is evaluated against each entry in the map (represented as a Java `Map.Entry`). The result of a projection across a map is a list that consists of the evaluation of the projection expression against each map entry.
#### ** Chinese **

你也可以使用地图来驱动投影，在这种情况下，投影表达式是针对地图中的每个条目（以Java `Map.Entry`表示）进行评价。在地图上进行投影的结果是一个列表，其中包含了对每个地图条目的投影表达式的评价。
<!-- tabs:end -->


### **4.3.18. Expression templating** 

<!-- tabs:start -->

#### ** English **

Expression templates allow mixing literal text with one or more evaluation blocks. Each evaluation block is delimited with prefix and suffix characters that you can define. A common choice is to use `#{ }` as the delimiters, as the following example shows:
#### ** Chinese **

表达式模板允许将字面文本与一个或多个评价块混合在一起。每个评价块都用你可以定义的前缀和后缀字符进行分隔。一个常见的选择是使用`#{ }`作为分隔符，如下例所示。
<!-- tabs:end -->


```java
String randomPhrase = parser.parseExpression(
        "random number is #{T(java.lang.Math).random()}",
        new TemplateParserContext()).getValue(String.class);

// evaluates to "random number is 0.7038186818312008"
```

<!-- tabs:start -->

#### ** English **

The string is evaluated by concatenating the literal text `'random number is '` with the result of evaluating the expression inside the `#{ }` delimiter (in this case, the result of calling that `random()` method). The second argument to the `parseExpression()` method is of the type `ParserContext`. The `ParserContext` interface is used to influence how the expression is parsed in order to support the expression templating functionality. The definition of `TemplateParserContext` follows:
#### ** Chinese **

通过将字面文本`'random number is '`与`#{ }`分界符内的表达式（在本例中，是调用该`random()`方法的结果）相连接，对该字符串进行评估。`parseExpression()`方法的第二个参数类型为`ParserContext`。`ParserContext`接口用于影响表达式的解析方式，以支持表达式模板化功能。`TemplateParserContext`的定义如下。
<!-- tabs:end -->


```java
public class TemplateParserContext implements ParserContext {

    public String getExpressionPrefix() {
        return "#{";
    }

    public String getExpressionSuffix() {
        return "}";
    }

    public boolean isTemplate() {
        return true;
    }
}
```

### **4.4. Classes Used in the Examples** 

<!-- tabs:start -->

#### ** English **

This section lists the classes used in the examples throughout this chapter.
#### ** Chinese **

本节列出了本章各例中使用的类目。
<!-- tabs:end -->


```java
package org.spring.samples.spel.inventor;

import java.util.Date;
import java.util.GregorianCalendar;

public class Inventor {

    private String name;
    private String nationality;
    private String[] inventions;
    private Date birthdate;
    private PlaceOfBirth placeOfBirth;

    public Inventor(String name, String nationality) {
        GregorianCalendar c= new GregorianCalendar();
        this.name = name;
        this.nationality = nationality;
        this.birthdate = c.getTime();
    }

    public Inventor(String name, Date birthdate, String nationality) {
        this.name = name;
        this.nationality = nationality;
        this.birthdate = birthdate;
    }

    public Inventor() {
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getNationality() {
        return nationality;
    }

    public void setNationality(String nationality) {
        this.nationality = nationality;
    }

    public Date getBirthdate() {
        return birthdate;
    }

    public void setBirthdate(Date birthdate) {
        this.birthdate = birthdate;
    }

    public PlaceOfBirth getPlaceOfBirth() {
        return placeOfBirth;
    }

    public void setPlaceOfBirth(PlaceOfBirth placeOfBirth) {
        this.placeOfBirth = placeOfBirth;
    }

    public void setInventions(String[] inventions) {
        this.inventions = inventions;
    }

    public String[] getInventions() {
        return inventions;
    }
}
```

```java
package org.spring.samples.spel.inventor;

public class PlaceOfBirth {

    private String city;
    private String country;

    public PlaceOfBirth(String city) {
        this.city=city;
    }

    public PlaceOfBirth(String city, String country) {
        this(city);
        this.country = country;
    }

    public String getCity() {
        return city;
    }

    public void setCity(String s) {
        this.city = s;
    }

    public String getCountry() {
        return country;
    }

    public void setCountry(String country) {
        this.country = country;
    }
}
```

```java
package org.spring.samples.spel.inventor;

import java.util.*;

public class Society {

    private String name;

    public static String Advisors = "advisors";
    public static String President = "president";

    private List<Inventor> members = new ArrayList<Inventor>();
    private Map officers = new HashMap();

    public List getMembers() {
        return members;
    }

    public Map getOfficers() {
        return officers;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public boolean isMember(String name) {
        for (Inventor inventor : members) {
            if (inventor.getName().equals(name)) {
                return true;
            }
        }
        return false;
    }
}
```


[下一章](Spring-Framework-5.2.6.RELEASE/Core%20Technologies/5.%20Aspect%20Oriented%20Programming%20with%20Spring.md)


[回目录](Spring-Framework-5.2.6.RELEASE/summary.md)

[回首页](/README)
