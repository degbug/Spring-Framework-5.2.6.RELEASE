
# 9. Appendix

### **9.1. XML Schemas** 

<!-- tabs:start -->

#### ** English **

This part of the appendix lists XML schemas related to the core container.
#### ** Chinese **

附录的这一部分列出了与核心容器相关的XML模式。
<!-- tabs:end -->


### **9.1.1. The** **`util`** ** Schema** 

<!-- tabs:start -->

#### ** English **

As the name implies, the `util` tags deal with common, utility configuration issues, such as configuring collections, referencing constants, and so forth. To use the tags in the `util` schema, you need to have the following preamble at the top of your Spring XML configuration file (the text in the snippet references the correct schema so that the tags in the `util` namespace are available to you):
#### ** Chinese **

顾名思义，`util`标记处理常见的实用程序配置问题，如配置集合、引用常量等。要使用 `util` 模式中的标记，您需要在 Spring XML 配置文件的顶部有以下前言（该片段中的文本引用了正确的模式，这样您就可以使用 `util`命名空间中的标记）。
<!-- tabs:end -->


```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:util="http://www.springframework.org/schema/util"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/util https://www.springframework.org/schema/util/spring-util.xsd">

        <!-- bean definitions here -->

</beans>
```

### **Using** **`<util:constant/>`** 

<!-- tabs:start -->

#### ** English **

Consider the following bean definition:
#### ** Chinese **

考虑以下豆子的定义。
<!-- tabs:end -->


```xml
<bean id="..." class="...">
    <property name="isolation">
        <bean id="java.sql.Connection.TRANSACTION_SERIALIZABLE"
                class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean" />
    </property>
</bean>
```

<!-- tabs:start -->

#### ** English **

The preceding configuration uses a Spring `FactoryBean` implementation (the `FieldRetrievingFactoryBean`) to set the value of the `isolation` property on a bean to the value of the `java.sql.Connection.TRANSACTION_SERIALIZABLE` constant. This is all well and good, but it is verbose and (unnecessarily) exposes Spring’s internal plumbing to the end user.
#### ** Chinese **

前面的配置使用了Spring `FactoryBean`实现（`FieldRetrievingFactoryBean`）来设置Bean上的`isolation`属性的值为`java.sql.Connection.TRANSACTION_SERIALIZABLE`常量的值。这一切都很好，但这是很好的，而且（不必要地）将Spring的内部管道暴露给最终用户。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following XML Schema-based version is more concise, clearly expresses the developer’s intent (“inject this constant value”), and it reads better:
#### ** Chinese **

下面基于XML Schema的版本更简洁，清晰地表达了开发者的意图（"注入这个常量值"），读起来更好。
<!-- tabs:end -->


```xml
<bean id="..." class="...">
    <property name="isolation">
        <util:constant static-field="java.sql.Connection.TRANSACTION_SERIALIZABLE"/>
    </property>
</bean>
```

### **Setting a Bean Property or Constructor Argument from a Field Value** 

<!-- tabs:start -->

#### ** English **

[`FieldRetrievingFactoryBean`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/beans/factory/config/FieldRetrievingFactoryBean.html) is a `FactoryBean` that retrieves a `static` or non-static field value. It is typically used for retrieving `public` `static` `final` constants, which may then be used to set a property value or constructor argument for another bean.
#### ** Chinese **

[`FieldRetrievingFactoryBean`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/beans/factory/config/FieldRetrievingFactoryBean.html)是一个`FactoryBean`，它可以检索一个`static`或非static字段值。它通常用于检索`public` `static` `static` `final` 常量，然后可以用来设置一个属性值或另一个Bean的构造函数参数。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following example shows how a `static` field is exposed, by using the [`staticField`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/beans/factory/config/FieldRetrievingFactoryBean.html#setStaticField(java.lang.String)) property:
#### ** Chinese **

下面的例子显示了如何通过使用[`staticField`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/beans/factory/config/FieldRetrievingFactoryBean.html#setStaticField(java.lang.String))属性来暴露一个`static`字段。
<!-- tabs:end -->


```xml
<bean id="myField"
        class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean">
    <property name="staticField" value="java.sql.Connection.TRANSACTION_SERIALIZABLE"/>
</bean>
```

<!-- tabs:start -->

#### ** English **

There is also a convenience usage form where the `static` field is specified as the bean name, as the following example shows:
#### ** Chinese **

还有一个方便使用的表单，其中`static`字段被指定为bean名，如下例所示。
<!-- tabs:end -->


```xml
<bean id="java.sql.Connection.TRANSACTION_SERIALIZABLE"
        class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean"/>
```

<!-- tabs:start -->

#### ** English **

This does mean that there is no longer any choice in what the bean `id` is (so any other bean that refers to it also has to use this longer name), but this form is very concise to define and very convenient to use as an inner bean since the `id` does not have to be specified for the bean reference, as the following example shows:
#### ** Chinese **

这确实意味着在bean `id`是什么的问题上不再有任何选择（因此任何其他的bean引用也必须使用这个较长的名称），但这种形式的定义非常简洁，而且作为内部的bean使用起来也非常方便，因为`id`不需要指定bean引用的id</x>，如下例所示。
<!-- tabs:end -->


```xml
<bean id="..." class="...">
    <property name="isolation">
        <bean id="java.sql.Connection.TRANSACTION_SERIALIZABLE"
                class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean" />
    </property>
</bean>
```

<!-- tabs:start -->

#### ** English **

You can also access a non-static (instance) field of another bean, as described in the API documentation for the [`FieldRetrievingFactoryBean`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/beans/factory/config/FieldRetrievingFactoryBean.html) class.
#### ** Chinese **

你也可以访问另一个Bean的非静态（实例）字段，如[`FieldRetrievingFactoryBean`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/beans/factory/config/FieldRetrievingFactoryBean.html)类的API文档中描述的那样。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Injecting enumeration values into beans as either property or constructor arguments is easy to do in Spring. You do not actually have to do anything or know anything about the Spring internals (or even about classes such as the `FieldRetrievingFactoryBean`). The following example enumeration shows how easy injecting an enum value is:
#### ** Chinese **

在Spring中，将枚举值作为属性或构造函数参数注入Bean中很容易做到。你实际上不需要做任何事情，也不需要了解Spring内部的任何东西（甚至不需要了解像`FieldRetrievingFactoryBean`这样的类）。下面的示例enumeration显示了注入一个enum值是多么容易。
<!-- tabs:end -->


```java
package javax.persistence;

public enum PersistenceContextType {

    TRANSACTION,
    EXTENDED
}
```

<!-- tabs:start -->

#### ** English **

Now consider the following setter of type `PersistenceContextType` and the corresponding bean definition:
#### ** Chinese **

现在考虑以下类型`PersistenceContextType`的setter和相应的bean定义。
<!-- tabs:end -->


```java
package example;

public class Client {

    private PersistenceContextType persistenceContextType;

    public void setPersistenceContextType(PersistenceContextType type) {
        this.persistenceContextType = type;
    }
}
```

```xml
<bean class="example.Client">
    <property name="persistenceContextType" value="TRANSACTION"/>
</bean>
```

### **Using** **`<util:property-path/>`** 

<!-- tabs:start -->

#### ** English **

Consider the following example:
#### ** Chinese **

请看下面的例子：
<!-- tabs:end -->


```xml
<!-- target bean to be referenced by name -->
<bean id="testBean" class="org.springframework.beans.TestBean" scope="prototype">
    <property name="age" value="10"/>
    <property name="spouse">
        <bean class="org.springframework.beans.TestBean">
            <property name="age" value="11"/>
        </bean>
    </property>
</bean>

<!-- results in 10, which is the value of property 'age' of bean 'testBean' -->
<bean id="testBean.age" class="org.springframework.beans.factory.config.PropertyPathFactoryBean"/>
```

<!-- tabs:start -->

#### ** English **

The preceding configuration uses a Spring `FactoryBean` implementation (the `PropertyPathFactoryBean`) to create a bean (of type `int`) called `testBean.age` that has a value equal to the `age` property of the `testBean` bean.
#### ** Chinese **

前面的配置使用Spring `FactoryBean`实现（`PropertyPathFactoryBean`）来创建一个名为`testBean.age`的Bean（类型为`int`），其值等于`testBean` bean的`age`属性。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Now consider the following example, which adds a `<util:property-path/>` element:
#### ** Chinese **

现在考虑一下下面的例子，它增加了一个`<util:property-path/>`元素。
<!-- tabs:end -->


```xml
<!-- target bean to be referenced by name -->
<bean id="testBean" class="org.springframework.beans.TestBean" scope="prototype">
    <property name="age" value="10"/>
    <property name="spouse">
        <bean class="org.springframework.beans.TestBean">
            <property name="age" value="11"/>
        </bean>
    </property>
</bean>

<!-- results in 10, which is the value of property 'age' of bean 'testBean' -->
<util:property-path id="name" path="testBean.age"/>
```

<!-- tabs:start -->

#### ** English **

The value of the `path` attribute of the `<property-path/>` element follows the form of `beanName.beanProperty`. In this case, it picks up the `age` property of the bean named `testBean`. The value of that `age` property is `10`.
#### ** Chinese **

`<property-path/>`元素中的`path`属性的值遵循`beanName.beanProperty`的形式。在这种情况下，它提取了名为`testBean`的Bean的`age`属性。该`age`属性的值是`10`。
<!-- tabs:end -->


### **Using** **`<util:property-path/>`** ** to Set a Bean Property or Constructor Argument** 

<!-- tabs:start -->

#### ** English **

`PropertyPathFactoryBean` is a `FactoryBean` that evaluates a property path on a given target object. The target object can be specified directly or by a bean name. You can then use this value in another bean definition as a property value or constructor argument.
#### ** Chinese **

`PropertyPathFactoryBean`是一个`FactoryBean`，用于评估给定目标对象上的属性路径。目标对象可以直接指定，也可以通过Bean名称来指定。然后你可以在另一个Bean定义中使用这个值作为属性值或构造函数参数。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following example shows a path being used against another bean, by name:
#### ** Chinese **

下面的例子显示了一个路径对另一个Bean使用的路径，按名称来看。
<!-- tabs:end -->


```xml
// target bean to be referenced by name
<bean id="person" class="org.springframework.beans.TestBean" scope="prototype">
    <property name="age" value="10"/>
    <property name="spouse">
        <bean class="org.springframework.beans.TestBean">
            <property name="age" value="11"/>
        </bean>
    </property>
</bean>

// results in 11, which is the value of property 'spouse.age' of bean 'person'
<bean id="theAge"
        class="org.springframework.beans.factory.config.PropertyPathFactoryBean">
    <property name="targetBeanName" value="person"/>
    <property name="propertyPath" value="spouse.age"/>
</bean>
```

<!-- tabs:start -->

#### ** English **

In the following example, a path is evaluated against an inner bean:
#### ** Chinese **

在下面的例子中，一个路径被评估为内部豆子。
<!-- tabs:end -->


```xml
<!-- results in 12, which is the value of property 'age' of the inner bean -->
<bean id="theAge"
        class="org.springframework.beans.factory.config.PropertyPathFactoryBean">
    <property name="targetObject">
        <bean class="org.springframework.beans.TestBean">
            <property name="age" value="12"/>
        </bean>
    </property>
    <property name="propertyPath" value="age"/>
</bean>
```

<!-- tabs:start -->

#### ** English **

There is also a shortcut form, where the bean name is the property path. The following example shows the shortcut form:
#### ** Chinese **

还有一种快捷方式形式，豆名就是属性路径。下面的例子显示了这个快捷形式。
<!-- tabs:end -->


```xml
<!-- results in 10, which is the value of property 'age' of bean 'person' -->
<bean id="person.age"
        class="org.springframework.beans.factory.config.PropertyPathFactoryBean"/>
```

<!-- tabs:start -->

#### ** English **

This form does mean that there is no choice in the name of the bean. Any reference to it also has to use the same `id`, which is the path. If used as an inner bean, there is no need to refer to it at all, as the following example shows:
#### ** Chinese **

这种形式确实意味着，豆子的名字没有选择的余地。任何对它的引用也必须使用相同的`id`，也就是路径。如果作为内部Bean使用，就完全没有必要引用它，如下例所示。
<!-- tabs:end -->


```xml
<bean id="..." class="...">
    <property name="age">
        <bean id="person.age"
                class="org.springframework.beans.factory.config.PropertyPathFactoryBean"/>
    </property>
</bean>
```

<!-- tabs:start -->

#### ** English **

You can specifically set the result type in the actual definition. This is not necessary for most use cases, but it can sometimes be useful. See the javadoc for more info on this feature.
#### ** Chinese **

你可以在实际定义中专门设置结果类型。这对大多数用例来说并不是必须的，但有时会很有用。关于此功能的更多信息，请参阅javadoc。
<!-- tabs:end -->


### **Using** **`<util:properties/>`** 

<!-- tabs:start -->

#### ** English **

Consider the following example:
#### ** Chinese **

请看下面的例子：
<!-- tabs:end -->


```xml
<!-- creates a java.util.Properties instance with values loaded from the supplied location -->
<bean id="jdbcConfiguration" class="org.springframework.beans.factory.config.PropertiesFactoryBean">
    <property name="location" value="classpath:com/foo/jdbc-production.properties"/>
</bean>
```

<!-- tabs:start -->

#### ** English **

The preceding configuration uses a Spring `FactoryBean` implementation (the `PropertiesFactoryBean`) to instantiate a `java.util.Properties` instance with values loaded from the supplied [`Resource`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#resources) location).
#### ** Chinese **

前面的配置使用 Spring `FactoryBean`实现（`PropertiesFactoryBean`）来实例化一个`java.util.Properties`实例，其值从提供的[`Resource`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#resources)位置加载。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following example uses a `util:properties` element to make a more concise representation:
#### ** Chinese **

下面的例子使用了`util:properties`元素来做一个更简洁的表示。
<!-- tabs:end -->


```xml
<!-- creates a java.util.Properties instance with values loaded from the supplied location -->
<util:properties id="jdbcConfiguration" location="classpath:com/foo/jdbc-production.properties"/>
```

### **Using** **`<util:list/>`** 

<!-- tabs:start -->

#### ** English **

Consider the following example:
#### ** Chinese **

请看下面的例子：
<!-- tabs:end -->


```xml
<!-- creates a java.util.List instance with values loaded from the supplied 'sourceList' -->
<bean id="emails" class="org.springframework.beans.factory.config.ListFactoryBean">
    <property name="sourceList">
        <list>
            <value>pechorin@hero.org</value>
            <value>raskolnikov@slums.org</value>
            <value>stavrogin@gov.org</value>
            <value>porfiry@gov.org</value>
        </list>
    </property>
</bean>
```

<!-- tabs:start -->

#### ** English **

The preceding configuration uses a Spring `FactoryBean` implementation (the `ListFactoryBean`) to create a `java.util.List` instance and initialize it with values taken from the supplied `sourceList`.
#### ** Chinese **

前面的配置使用Spring `FactoryBean`实现（`ListFactoryBean`）来创建一个`java.util.List`实例，并使用提供的`sourceList`中的值初始化它。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following example uses a `<util:list/>` element to make a more concise representation:
#### ** Chinese **

下面的例子使用了`<util:list/>`元素来做一个比较简洁的表示。
<!-- tabs:end -->


```xml
<!-- creates a java.util.List instance with the supplied values -->
<util:list id="emails">
    <value>pechorin@hero.org</value>
    <value>raskolnikov@slums.org</value>
    <value>stavrogin@gov.org</value>
    <value>porfiry@gov.org</value>
</util:list>
```

<!-- tabs:start -->

#### ** English **

You can also explicitly control the exact type of `List` that is instantiated and populated by using the `list-class` attribute on the `<util:list/>` element. For example, if we really need a `java.util.LinkedList` to be instantiated, we could use the following configuration:
#### ** Chinese **

你也可以通过使用`<util:list/>`元素上的`list-class`属性来显式控制被实例化和填充的`List`的确切类型。例如，如果我们真的需要一个`java.util.LinkedList`来实例化，我们可以使用下面的配置。
<!-- tabs:end -->


```xml
<util:list id="emails" list-class="java.util.LinkedList">
    <value>jackshaftoe@vagabond.org</value>
    <value>eliza@thinkingmanscrumpet.org</value>
    <value>vanhoek@pirate.org</value>
    <value>d'Arcachon@nemesis.org</value>
</util:list>
```

<!-- tabs:start -->

#### ** English **

If no `list-class` attribute is supplied, the container chooses a `List` implementation.
#### ** Chinese **

如果没有提供`list-class`属性，则容器选择一个`List`实现。
<!-- tabs:end -->


### **Using** **`<util:map/>`** 

<!-- tabs:start -->

#### ** English **

Consider the following example:
#### ** Chinese **

请看下面的例子：
<!-- tabs:end -->


```xml
<!-- creates a java.util.Map instance with values loaded from the supplied 'sourceMap' -->
<bean id="emails" class="org.springframework.beans.factory.config.MapFactoryBean">
    <property name="sourceMap">
        <map>
            <entry key="pechorin" value="pechorin@hero.org"/>
            <entry key="raskolnikov" value="raskolnikov@slums.org"/>
            <entry key="stavrogin" value="stavrogin@gov.org"/>
            <entry key="porfiry" value="porfiry@gov.org"/>
        </map>
    </property>
</bean>
```

<!-- tabs:start -->

#### ** English **

The preceding configuration uses a Spring `FactoryBean` implementation (the `MapFactoryBean`) to create a `java.util.Map` instance initialized with key-value pairs taken from the supplied `'sourceMap'`.
#### ** Chinese **

前面的配置使用 Spring `FactoryBean`实现（`MapFactoryBean`）来创建一个`java.util.Map`实例，该实例初始化时，key-value对取自提供的`'sourceMap'`。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following example uses a `<util:map/>` element to make a more concise representation:
#### ** Chinese **

下面的例子使用了一个`<util:map/>`元素来做一个更简洁的表示。
<!-- tabs:end -->


```xml
<!-- creates a java.util.Map instance with the supplied key-value pairs -->
<util:map id="emails">
    <entry key="pechorin" value="pechorin@hero.org"/>
    <entry key="raskolnikov" value="raskolnikov@slums.org"/>
    <entry key="stavrogin" value="stavrogin@gov.org"/>
    <entry key="porfiry" value="porfiry@gov.org"/>
</util:map>
```

<!-- tabs:start -->

#### ** English **

You can also explicitly control the exact type of `Map` that is instantiated and populated by using the `'map-class'` attribute on the `<util:map/>` element. For example, if we really need a `java.util.TreeMap` to be instantiated, we could use the following configuration:
#### ** Chinese **

您还可以通过在`<util:map/>`元素上使用`'map-class'`属性来显式控制被实例化和填充的`Map`的确切类型。例如，如果我们真的需要一个`java.util.TreeMap`来实例化，我们可以使用下面的配置。
<!-- tabs:end -->


```xml
<util:map id="emails" map-class="java.util.TreeMap">
    <entry key="pechorin" value="pechorin@hero.org"/>
    <entry key="raskolnikov" value="raskolnikov@slums.org"/>
    <entry key="stavrogin" value="stavrogin@gov.org"/>
    <entry key="porfiry" value="porfiry@gov.org"/>
</util:map>
```

<!-- tabs:start -->

#### ** English **

If no `'map-class'` attribute is supplied, the container chooses a `Map` implementation.
#### ** Chinese **

如果没有提供`'map-class'`属性，容器会选择一个`Map`实现。
<!-- tabs:end -->


### **Using** **`<util:set/>`** 

<!-- tabs:start -->

#### ** English **

Consider the following example:
#### ** Chinese **

请看下面的例子：
<!-- tabs:end -->


```xml
<!-- creates a java.util.Set instance with values loaded from the supplied 'sourceSet' -->
<bean id="emails" class="org.springframework.beans.factory.config.SetFactoryBean">
    <property name="sourceSet">
        <set>
            <value>pechorin@hero.org</value>
            <value>raskolnikov@slums.org</value>
            <value>stavrogin@gov.org</value>
            <value>porfiry@gov.org</value>
        </set>
    </property>
</bean>
```

<!-- tabs:start -->

#### ** English **

The preceding configuration uses a Spring `FactoryBean` implementation (the `SetFactoryBean`) to create a `java.util.Set` instance initialized with values taken from the supplied `sourceSet`.
#### ** Chinese **

前面的配置使用Spring `FactoryBean`实现（`SetFactoryBean`）来创建一个`java.util.Set`实例，初始化时的值取自提供的`sourceSet`。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following example uses a `<util:set/>` element to make a more concise representation:
#### ** Chinese **

下面的例子中使用了`<util:set/>`元素来做一个比较简洁的表示。
<!-- tabs:end -->


```xml
<!-- creates a java.util.Set instance with the supplied values -->
<util:set id="emails">
    <value>pechorin@hero.org</value>
    <value>raskolnikov@slums.org</value>
    <value>stavrogin@gov.org</value>
    <value>porfiry@gov.org</value>
</util:set>
```

<!-- tabs:start -->

#### ** English **

You can also explicitly control the exact type of `Set` that is instantiated and populated by using the `set-class` attribute on the `<util:set/>` element. For example, if we really need a `java.util.TreeSet` to be instantiated, we could use the following configuration:
#### ** Chinese **

您还可以通过使用`<util:set/>`元素上的`set-class`属性来显式控制被实例化和填充的`Set`的确切类型。例如，如果我们真的需要一个`java.util.TreeSet`来实例化，我们可以使用下面的配置。
<!-- tabs:end -->


```xml
<util:set id="emails" set-class="java.util.TreeSet">
    <value>pechorin@hero.org</value>
    <value>raskolnikov@slums.org</value>
    <value>stavrogin@gov.org</value>
    <value>porfiry@gov.org</value>
</util:set>
```

<!-- tabs:start -->

#### ** English **

If no `set-class` attribute is supplied, the container chooses a `Set` implementation.
#### ** Chinese **

如果没有提供`set-class`属性，则容器选择一个`Set`实现。
<!-- tabs:end -->


### **9.1.2. The** **`aop`** ** Schema** 

<!-- tabs:start -->

#### ** English **

The `aop` tags deal with configuring all things AOP in Spring, including Spring’s own proxy-based AOP framework and Spring’s integration with the AspectJ AOP framework. These tags are comprehensively covered in the chapter entitled [Aspect Oriented Programming with Spring](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#aop).
#### ** Chinese **

`aop`标签处理Spring中所有AOP的配置，包括Spring自己的基于代理的AOP框架和Spring与AspectJ AOP框架的集成。这些标记在题为[Aspect Oriented Programming with Spring](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#aop)的章节中全面介绍了这些标记。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

In the interest of completeness, to use the tags in the `aop` schema, you need to have the following preamble at the top of your Spring XML configuration file (the text in the snippet references the correct schema so that the tags in the `aop` namespace are available to you):
#### ** Chinese **

为了完整起见，要使用 `aop` 模式中的标记，您需要在您的 Spring XML 配置文件的顶部有以下前言（该代码段中的文本引用了正确的模式，这样您就可以使用 `aop` 命名空间中的标记）。
<!-- tabs:end -->


```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:aop="http://www.springframework.org/schema/aop"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd">

    <!-- bean definitions here -->

</beans>
```

### **9.1.3. The** **`context`** ** Schema** 

<!-- tabs:start -->

#### ** English **

The `context` tags deal with `ApplicationContext` configuration that relates to plumbing — that is, not usually beans that are important to an end-user but rather beans that do a lot of the “grunt” work in Spring, such as `BeanfactoryPostProcessors`. The following snippet references the correct schema so that the elements in the `context` namespace are available to you:
#### ** Chinese **

`context`标记处理与管道相关的`ApplicationContext`配置--也就是说，通常不是对终端用户很重要的Bean，而是在Spring中做很多 "粗活 "工作的Bean，比如`BeanfactoryPostProcessors`。下面的代码段引用了正确的模式，这样就可以使用`context`命名空间中的元素。
<!-- tabs:end -->


```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd">

    <!-- bean definitions here -->

</beans>
```

### **Using** **`<property-placeholder/>`** 

<!-- tabs:start -->

#### ** English **

This element activates the replacement of `${…​}` placeholders, which are resolved against a specified properties file (as a [Spring resource location](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#resources)). This element is a convenience mechanism that sets up a [`PropertySourcesPlaceholderConfigurer`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-placeholderconfigurer) for you. If you need more control over the specific `PropertySourcesPlaceholderConfigurer` setup, you can explicitly define it as a bean yourself.
#### ** Chinese **

这个元素可以激活替换`${…​}`占位符，这些占位符是根据指定的属性文件解析的（作为[Spring资源位置](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#resources)）。这个元素是一个方便机制，它为你设置了一个[`PropertySourcesPlaceholderConfigurer`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-placeholderconfigurer)。如果您需要对特定的 `PropertySourcesPlaceholderConfigurer`设置有更多的控制权，您可以自己显式地将其定义为Bean。
<!-- tabs:end -->


### **Using** **`<annotation-config/>`** 

<!-- tabs:start -->

#### ** English **

This element activates the Spring infrastructure to detect annotations in bean classes:
#### ** Chinese **

这个元素激活了Spring基础架构，以检测Bean类中的注解。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

- Spring’s [`@Configuration`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-metadata) model

- [`@Autowired`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-annotation-config)[/](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-annotation-config)[`@Inject`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-annotation-config) and `@Value`

- JSR-250’s `@Resource`, `@PostConstruct` and `@PreDestroy` (if available)

- JPA’s `@PersistenceContext` and `@PersistenceUnit` (if available)

- Spring’s [`@EventListener`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#context-functionality-events-annotation)

#### ** Chinese **

- Spring的 [`@Configuration`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-metadata) 模型

- [`@Autowired`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-annotation-config)[/](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-annotation-config)[`@Inject`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-annotation-config)和`@Value`

- JSR-250的`@Resource`、`@PostConstruct`和`@PreDestroy`（如果有的话）。

- JPA的`@PersistenceContext`和`@PersistenceUnit`（如果有的话）。

- Spring的[`@EventListener`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#context-functionality-events-annotation)

<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

Alternatively, you can choose to explicitly activate the individual `BeanPostProcessors` for those annotations.
#### ** Chinese **

或者，您可以选择为这些注解显式激活单个`BeanPostProcessors`。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

This element does not activate processing of Spring’s [`@Transactional`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/data-access.html#transaction-declarative-annotations) annotation; you can use the [`<tx:annotation-driven/>`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/data-access.html#tx-decl-explained) element for that purpose. Similarly, Spring’s [caching annotations](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#cache-annotations) need to be explicitly [enabled](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#cache-annotation-enable) as well.
#### ** Chinese **

这个元素不会激活Spring的[`@Transactional`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/data-access.html#transaction-declarative-annotations) 注解的处理；您可以使用[`<tx:annotation-driven/>`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/data-access.html#tx-decl-explained) 元素来实现这个目的。同样，Spring的[缓存注解](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#cache-annotations)也需要显式[启用](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#cache-annotation-enable)。
<!-- tabs:end -->


### **Using** **`<component-scan/>`** 

<!-- tabs:start -->

#### ** English **

This element is detailed in the section on [annotation-based container configuration](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-annotation-config).
#### ** Chinese **

这个元素在[基于注解的容器配置](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-annotation-config)一节中详细介绍。
<!-- tabs:end -->


### **Using** **`<load-time-weaver/>`** 

<!-- tabs:start -->

#### ** English **

This element is detailed in the section on [load-time weaving with AspectJ in the Spring Framework](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#aop-aj-ltw).
#### ** Chinese **

这个元素在[在Spring框架中使用AspectJ的加载时间编织](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#aop-aj-ltw)一节中有详细介绍。
<!-- tabs:end -->


### **Using** **`<spring-configured/>`** 

<!-- tabs:start -->

#### ** English **

This element is detailed in the section on [using AspectJ to dependency inject domain objects with Spring](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#aop-atconfigurable).
#### ** Chinese **

这个元素在[使用AspectJ用Spring依赖注入域对象](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#aop-atconfigurable)一节中有详细介绍。
<!-- tabs:end -->


### **Using** **`<mbean-export/>`** 

<!-- tabs:start -->

#### ** English **

This element is detailed in the section on [configuring annotation-based MBean export](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#jmx-context-mbeanexport).
#### ** Chinese **

该元素在[配置基于注解的MBean导出](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#jmx-context-mbeanexport)一节中详述。
<!-- tabs:end -->


### **9.1.4. The Beans Schema** 

<!-- tabs:start -->

#### ** English **

Last but not least, we have the elements in the `beans` schema. These elements have been in Spring since the very dawn of the framework. Examples of the various elements in the `beans` schema are not shown here because they are quite comprehensively covered in [dependencies and configuration in detail](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-properties-detailed) (and, indeed, in that entire [chapter](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans)).
#### ** Chinese **

最后，我们有`beans` schema中的元素。这些元素从框架诞生之初就已经在Spring中出现了。`beans`模式中的各种元素的例子不在这里展示，因为它们在[依赖和配置的详细内容](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-properties-detailed)中已经很全面地介绍了（事实上，在整个[章节](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans)中也有介绍）。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Note that you can add zero or more key-value pairs to `<bean/>` XML definitions. What, if anything, is done with this extra metadata is totally up to your own custom logic (and so is typically only of use if you write your own custom elements as described in the appendix entitled [XML Schema Authoring](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#xml-custom)).
#### ** Chinese **

注意，你可以为 `<bean/>` XML 定义添加零或更多的键值对。如果有什么事，如何处理这些额外的元数据，完全取决于你自己的自定义逻辑（所以通常只有当你按照附录[XML Schema Authoring](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#xml-custom)中描述的那样编写自己的自定义元素时才会有作用。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following example shows the `<meta/>` element in the context of a surrounding `<bean/>` (note that, without any logic to interpret it, the metadata is effectively useless as it stands).
#### ** Chinese **

下面的例子显示了`<meta/>`元素在周围`<bean/>`的上下文中的情况（注意，如果没有任何逻辑解释，元数据实际上是没有用的）。
<!-- tabs:end -->


```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="foo" class="x.y.Foo">
        <meta key="cacheName" value="foo"/> (1)
        <property name="name" value="Rick"/>
    </bean>

</beans>
```

<!-- tabs:start -->

#### ** English **

(1)This is the example `meta` element
#### ** Chinese **

(1)此为`meta`元素示例
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

In the case of the preceding example, you could assume that there is some logic that consumes the bean definition and sets up some caching infrastructure that uses the supplied metadata.
#### ** Chinese **

在前面的例子中，你可以假设有一些逻辑来消耗Bean定义并设置一些使用提供的元数据的缓存基础设施。
<!-- tabs:end -->


### **9.2. XML Schema Authoring** 

<!-- tabs:start -->

#### ** English **

Since version 2.0, Spring has featured a mechanism for adding schema-based extensions to the basic Spring XML format for defining and configuring beans. This section covers how to write your own custom XML bean definition parsers and integrate such parsers into the Spring IoC container.
#### ** Chinese **

自 2.0 版以来，Spring 已经有了一种机制，可以在基本的 Spring XML 格式中添加基于模式的扩展，用于定义和配置 bean。本节将介绍如何编写自己的自定义 XML bean 定义解析器，并将此类解析器集成到 Spring IoC 容器中。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

To facilitate authoring configuration files that use a schema-aware XML editor, Spring’s extensible XML configuration mechanism is based on XML Schema. If you are not familiar with Spring’s current XML configuration extensions that come with the standard Spring distribution, you should first read the appendix entitled [appendix.html](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/appendix.html#xsd-configuration).
#### ** Chinese **

为了方便编写使用模式感知的XML编辑器的配置文件，Spring的可扩展的XML配置机制是基于XML Schema。如果您不熟悉Spring标准Spring发行版中附带的当前XML配置扩展，您应该首先阅读标题为[appendix.html](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/appendix.html#xsd-configuration)的附录。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

To create new XML configuration extensions:
#### ** Chinese **

要创建新的XML配置扩展。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

[Author](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#xsd-custom-schema) an XML schema to describe your custom element(s).[Code](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#xsd-custom-namespacehandler) a custom `NamespaceHandler` implementation.[Code](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#xsd-custom-parser) one or more `BeanDefinitionParser` implementations (this is where the real work is done).[Register](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#xsd-custom-registration) your new artifacts with Spring.
#### ** Chinese **

[作者](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#xsd-custom-schema) 一个XML模式来描述你的自定义元素。[代码](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#xsd-custom-namespacehandler) 一个自定义的`NamespaceHandler`实现。[代码](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#xsd-custom-parser) 一个或多个`BeanDefinitionParser`实现（这才是真正的工作。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

For a unified example, we create an XML extension (a custom XML element) that lets us configure objects of the type `SimpleDateFormat` (from the `java.text` package). When we are done, we will be able to define bean definitions of type `SimpleDateFormat` as follows:
#### ** Chinese **

对于一个统一的例子，我们创建一个XML扩展（一个自定义的XML元素），让我们可以配置类型`SimpleDateFormat`的对象（来自`java.text`包）。当我们完成后，我们将能够定义类型`SimpleDateFormat`的bean定义如下。
<!-- tabs:end -->


```xml
<myns:dateformat id="dateFormat"
    pattern="yyyy-MM-dd HH:mm"
    lenient="true"/>
```

<!-- tabs:start -->

#### ** English **

(We include much more detailed examples follow later in this appendix. The intent of this first simple example is to walk you through the basic steps of making a custom extension.)
#### ** Chinese **

(我们在本附录后面会有更多详细的例子。这个第一个简单的例子的目的是要告诉你制作自定义扩展的基本步骤。)
<!-- tabs:end -->


### **9.2.1. Authoring the Schema** 

<!-- tabs:start -->

#### ** English **

Creating an XML configuration extension for use with Spring’s IoC container starts with authoring an XML Schema to describe the extension. For our example, we use the following schema to configure `SimpleDateFormat` objects:
#### ** Chinese **

创建用于Spring的IoC容器的XML配置扩展，首先要编写一个XML模式来描述扩展。在我们的例子中，我们使用以下模式来配置 `SimpleDateFormat`对象。
<!-- tabs:end -->


```xml
<!-- myns.xsd (inside package org/springframework/samples/xml) -->

<?xml version="1.0" encoding="UTF-8"?>
<xsd:schema xmlns="http://www.mycompany.example/schema/myns"
        xmlns:xsd="http://www.w3.org/2001/XMLSchema"
        xmlns:beans="http://www.springframework.org/schema/beans"
        targetNamespace="http://www.mycompany.example/schema/myns"
        elementFormDefault="qualified"
        attributeFormDefault="unqualified">

    <xsd:import namespace="http://www.springframework.org/schema/beans"/>

    <xsd:element name="dateformat">
        <xsd:complexType>
            <xsd:complexContent>
                <xsd:extension base="beans:identifiedType"> (1)
                    <xsd:attribute name="lenient" type="xsd:boolean"/>
                    <xsd:attribute name="pattern" type="xsd:string" use="required"/>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
</xsd:schema>
```

<!-- tabs:start -->

#### ** English **

(1)The indicated line contains an extension base for all identifiable tags (meaning they have an `id` attribute that we can use as the bean identifier in the container). We can use this attribute because we imported the Spring-provided `beans` namespace.
#### ** Chinese **

(1)指示行包含了所有可识别标记的扩展基础(意味着它们有一个`id`属性，我们可以在容器中使用该属性作为bean标识符)。我们之所以可以使用这个属性，是因为我们导入了Spring提供的`beans`命名空间。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The preceding schema lets us configure `SimpleDateFormat` objects directly in an XML application context file by using the `<myns:dateformat/>` element, as the following example shows:
#### ** Chinese **

前面的模式让我们可以通过使用`<myns:dateformat/>`元素直接在XML应用程序上下文文件中配置`SimpleDateFormat`对象，如下例所示。
<!-- tabs:end -->


```xml
<myns:dateformat id="dateFormat"
    pattern="yyyy-MM-dd HH:mm"
    lenient="true"/>
```

<!-- tabs:start -->

#### ** English **

Note that, after we have created the infrastructure classes, the preceding snippet of XML is essentially the same as the following XML snippet:
#### ** Chinese **

请注意，在我们创建了基础架构类之后，前面的XML片段与下面的XML片段基本相同。
<!-- tabs:end -->


```xml
<bean id="dateFormat" class="java.text.SimpleDateFormat">
    <constructor-arg value="yyyy-HH-dd HH:mm"/>
    <property name="lenient" value="true"/>
</bean>
```

<!-- tabs:start -->

#### ** English **

The second of the two preceding snippets creates a bean in the container (identified by the name `dateFormat` of type `SimpleDateFormat`) with a couple of properties set.
#### ** Chinese **

前面两个片段中的第二个片段在容器中创建了一个bean（由类型为`SimpleDateFormat`的名称`dateFormat`标识），并设置了一些属性。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The schema-based approach to creating configuration format allows for tight integration with an IDE that has a schema-aware XML editor. By using a properly authored schema, you can use autocompletion to let a user choose between several configuration options defined in the enumeration.
#### ** Chinese **

基于模式的创建配置格式的方法允许与具有模式感知的XML编辑器的IDE紧密集成。通过使用一个正确编写的模式，你可以使用自动完成，让用户在枚举中定义的几个配置选项中进行选择。
<!-- tabs:end -->


### **9.2.2. Coding a** **`NamespaceHandler`** 

<!-- tabs:start -->

#### ** English **

In addition to the schema, we need a `NamespaceHandler` to parse all elements of this specific namespace that Spring encounters while parsing configuration files. For this example, the `NamespaceHandler` should take care of the parsing of the `myns:dateformat` element.
#### ** Chinese **

除了模式之外，我们还需要一个`NamespaceHandler`来解析Spring在解析配置文件时遇到的这个特定命名空间的所有元素。在这个例子中，`NamespaceHandler`应该负责解析`myns:dateformat`元素。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The `NamespaceHandler` interface features three methods:
#### ** Chinese **

`NamespaceHandler`接口有三个方法。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

- `init()`: Allows for initialization of the `NamespaceHandler` and is called by Spring before the handler is used.

- `BeanDefinition parse(Element, ParserContext)`: Called when Spring encounters a top-level element (not nested inside a bean definition or a different namespace). This method can itself register bean definitions, return a bean definition, or both.

- `BeanDefinitionHolder decorate(Node, BeanDefinitionHolder, ParserContext)`: Called when Spring encounters an attribute or nested element of a different namespace. The decoration of one or more bean definitions is used (for example) with the [scopes that Spring supports](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-scopes). We start by highlighting a simple example, without using decoration, after which we show decoration in a somewhat more advanced example.

#### ** Chinese **

- `init()`。允许初始化`NamespaceHandler`，并在使用处理程序之前被Spring调用。

- `BeanDefinition parse(Element, ParserContext)`：允许Spring在使用处理程序之前调用。当Spring遇到一个顶层元素时调用（不是嵌套在bean定义或不同命名空间内的bean定义）。这个方法本身可以注册Bean定义，也可以返回一个Bean定义，或者两者都可以。

- `BeanDefinitionHolder decorate(Node, BeanDefinitionHolder, ParserContext)`。当Spring遇到不同命名空间的属性或嵌套元素时调用。一个或多个Bean定义的装饰（例如）使用[Spring支持的作用域](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-scopes)。我们首先强调了一个简单的例子，没有使用装饰，之后我们用一个更高级的例子来展示装饰。

<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

Although you can code your own `NamespaceHandler` for the entire namespace (and hence provide code that parses each and every element in the namespace), it is often the case that each top-level XML element in a Spring XML configuration file results in a single bean definition (as in our case, where a single `<myns:dateformat/>` element results in a single `SimpleDateFormat` bean definition). Spring features a number of convenience classes that support this scenario. In the following example, we use the `NamespaceHandlerSupport` class:
#### ** Chinese **

虽然你可以为整个命名空间编写自己的 `NamespaceHandler`（从而提供解析命名空间中的每一个元素的代码），但通常情况下，Spring XML 配置文件中的每个顶层 XML 元素都会产生一个单一的 Bean 定义（就像我们的例子一样，单个 `<myns:dateformat/>` 元素会产生一个单一的 `SimpleDateFormat` Bean 定义）。Spring有许多支持这种情况的方便类。在下面的例子中，我们使用了`NamespaceHandlerSupport`类。
<!-- tabs:end -->


```java
package org.springframework.samples.xml;

import org.springframework.beans.factory.xml.NamespaceHandlerSupport;

public class MyNamespaceHandler extends NamespaceHandlerSupport {

    public void init() {
        registerBeanDefinitionParser("dateformat", new SimpleDateFormatBeanDefinitionParser());
    }
}
```

<!-- tabs:start -->

#### ** English **

You may notice that there is not actually a whole lot of parsing logic in this class. Indeed, the `NamespaceHandlerSupport` class has a built-in notion of delegation. It supports the registration of any number of `BeanDefinitionParser` instances, to which it delegates to when it needs to parse an element in its namespace. This clean separation of concerns lets a `NamespaceHandler` handle the orchestration of the parsing of all of the custom elements in its namespace while delegating to `BeanDefinitionParsers` to do the grunt work of the XML parsing. This means that each `BeanDefinitionParser` contains only the logic for parsing a single custom element, as we can see in the next step.
#### ** Chinese **

你可能会注意到，这个类中其实并没有太多的解析逻辑。事实上，`NamespaceHandlerSupport`类有一个内置的委托代理概念。它支持注册任意数量的 `BeanDefinitionParser`实例，当它需要解析命名空间中的元素时，会委托给这些实例。这种干净的分离，让 `NamespaceHandler`在委托给 `BeanDefinitionParsers`进行 XML 解析的主要工作的同时，还可以处理其命名空间中所有自定义元素的解析。这意味着每个`BeanDefinitionParser`只包含解析单个自定义元素的逻辑，我们可以在下一步中看到。
<!-- tabs:end -->


### **9.2.3. Using** **`BeanDefinitionParser`** 

<!-- tabs:start -->

#### ** English **

A `BeanDefinitionParser` is used if the `NamespaceHandler` encounters an XML element of the type that has been mapped to the specific bean definition parser (`dateformat` in this case). In other words, the `BeanDefinitionParser` is responsible for parsing one distinct top-level XML element defined in the schema. In the parser, we' have access to the XML element (and thus to its subelements, too) so that we can parse our custom XML content, as you can see in the following example:
#### ** Chinese **

如果 "`NamespaceHandler` "遇到被映射到特定Bean定义解析器（此处为 "`dateformat`"）类型的XML元素，则使用 "`BeanDefinitionParser`"。换句话说，"`BeanDefinitionParser` "负责解析模式中定义的一个独特的顶层XML元素。在解析器中，我们可以访问这个XML元素（因此也可以访问它的子元素），这样我们就可以解析我们的自定义XML内容，就像下面的例子一样。
<!-- tabs:end -->


```java
package org.springframework.samples.xml;

import org.springframework.beans.factory.support.BeanDefinitionBuilder;
import org.springframework.beans.factory.xml.AbstractSingleBeanDefinitionParser;
import org.springframework.util.StringUtils;
import org.w3c.dom.Element;

import java.text.SimpleDateFormat;

public class SimpleDateFormatBeanDefinitionParser extends AbstractSingleBeanDefinitionParser { (1)

    protected Class getBeanClass(Element element) {
        return SimpleDateFormat.class; (2)
    }

    protected void doParse(Element element, BeanDefinitionBuilder bean) {
        // this will never be null since the schema explicitly requires that a value be supplied
        String pattern = element.getAttribute("pattern");
        bean.addConstructorArgValue(pattern);

        // this however is an optional property
        String lenient = element.getAttribute("lenient");
        if (StringUtils.hasText(lenient)) {
            bean.addPropertyValue("lenient", Boolean.valueOf(lenient));
        }
    }

}

//(1) We use the Spring-provided AbstractSingleBeanDefinitionParser to handle a lot of
the basic grunt work of creating a single BeanDefinition.
(2) We supply the AbstractSingleBeanDefinitionParser superclass with the type that our
single BeanDefinition represents.
```

<!-- tabs:start -->

#### ** English **

In this simple case, this is all that we need to do. The creation of our single `BeanDefinition` is handled by the `AbstractSingleBeanDefinitionParser` superclass, as is the extraction and setting of the bean definition’s unique identifier.
#### ** Chinese **

在这个简单的例子中，我们需要做的就是这些了。我们的单`BeanDefinition`的创建是由`AbstractSingleBeanDefinitionParser`超级类处理的，同样也是提取和设置Bean定义的唯一标识符。
<!-- tabs:end -->


### **9.2.4. Registering the Handler and the Schema** 

<!-- tabs:start -->

#### ** English **

The coding is finished. All that remains to be done is to make the Spring XML parsing infrastructure aware of our custom element. We do so by registering our custom `namespaceHandler` and custom XSD file in two special-purpose properties files. These properties files are both placed in a `META-INF` directory in your application and can, for example, be distributed alongside your binary classes in a JAR file. The Spring XML parsing infrastructure automatically picks up your new extension by consuming these special properties files, the formats of which are detailed in the next two sections.
#### ** Chinese **

编码已经完成了。剩下要做的就是让Spring XML解析基础设施知道我们的自定义元素。我们通过在两个特殊用途的属性文件中注册我们的自定义`namespaceHandler`和自定义XSD文件来实现。这些属性文件都放在应用程序中的 `META-INF` 目录中，并且可以在 JAR 文件中与二进制类一起分发。Spring XML 解析基础设施通过消耗这些特殊的属性文件来自动获取您的新扩展，其格式将在下面两节中详细介绍。
<!-- tabs:end -->


### **Writing** **`META-INF/spring.handlers`** 

<!-- tabs:start -->

#### ** English **

The properties file called `spring.handlers` contains a mapping of XML Schema URIs to namespace handler classes. For our example, we need to write the following:
#### ** Chinese **

这个名为`spring.handlers`的属性文件包含了XML Schema URIs到命名空间处理程序类的映射。对于我们的例子，我们需要写以下内容。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

http\://www.mycompany.example/schema/myns=org.springframework.samples.xml.MyNamespaceHandler
#### ** Chinese **

http：///www.mycompany.example/schema/myns=org.springframework.samples.xml.MyNamespaceHandler
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

(The `:` character is a valid delimiter in the Java properties format, so `:` character in the URI needs to be escaped with a backslash.)
#### ** Chinese **

(在Java属性格式中，`:`字符是一个有效的分隔符，所以URI中的`:`字符需要用反斜线转义)。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The first part (the key) of the key-value pair is the URI associated with your custom namespace extension and needs to exactly match exactly the value of the `targetNamespace` attribute, as specified in your custom XSD schema.
#### ** Chinese **

键-值对的第一部分（key）是与您的自定义命名空间扩展相关联的URI，需要与您的自定义XSD模式中指定的`targetNamespace`属性的值完全匹配。
<!-- tabs:end -->


### **Writing 'META-INF/spring.schemas'** 

<!-- tabs:start -->

#### ** English **

The properties file called `spring.schemas` contains a mapping of XML Schema locations (referred to, along with the schema declaration, in XML files that use the schema as part of the `xsi:schemaLocation` attribute) to classpath resources. This file is needed to prevent Spring from absolutely having to use a default `EntityResolver` that requires Internet access to retrieve the schema file. If you specify the mapping in this properties file, Spring searches for the schema (in this case, `myns.xsd` in the `org.springframework.samples.xml` package) on the classpath. The following snippet shows the line we need to add for our custom schema:
#### ** Chinese **

称为`spring.schemas`的属性文件包含了XML模式位置（在使用模式作为`xsi:schemaLocation`属性的XML文件中，与模式声明一起被称为）与classpath资源的映射。需要使用此文件，以防止Spring绝对必须使用默认的`EntityResolver`EntityResolver</x>来检索模式文件。如果您在此属性文件中指定了映射，Spring会在classpath上搜索模式（在本例中，在`org.springframework.samples.xml`包中的`myns.xsd`）。下面的片段显示了我们需要为自定义模式添加的行。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

http\://www.mycompany.example/schema/myns/myns.xsd=org/springframework/samples/xml/myns.xsd
#### ** Chinese **

http:///www.mycompany.example/schema/myns/myns.xsd=org/springframework/samples/xml/myns.xsd
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

(Remember that the `:` character must be escaped.)
#### ** Chinese **

(记住，`:`字符必须转义)。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You are encouraged to deploy your XSD file (or files) right alongside the `NamespaceHandler` and `BeanDefinitionParser` classes on the classpath.
#### ** Chinese **

鼓励您将您的XSD文件（或文件）与`NamespaceHandler`和`BeanDefinitionParser`类一起部署在classpath上。
<!-- tabs:end -->


### **9.2.5. Using a Custom Extension in Your Spring XML Configuration** 

<!-- tabs:start -->

#### ** English **

Using a custom extension that you yourself have implemented is no different from using one of the “custom” extensions that Spring provides. The following example uses the custom `<dateformat/>` element developed in the previous steps in a Spring XML configuration file:
#### ** Chinese **

使用您自己实现的自定义扩展与使用Spring提供的 "自定义 "扩展没有什么区别。下面的例子使用了在前面的步骤中开发的自定义 `<dateformat/>`元素在Spring XML配置文件中。
<!-- tabs:end -->


```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:myns="http://www.mycompany.example/schema/myns"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.mycompany.example/schema/myns http://www.mycompany.com/schema/myns/myns.xsd">

    <!-- as a top-level bean -->
    <myns:dateformat id="defaultDateFormat" pattern="yyyy-MM-dd HH:mm" lenient="true"/> (1)

    <bean id="jobDetailTemplate" abstract="true">
        <property name="dateFormat">
            <!-- as an inner bean -->
            <myns:dateformat pattern="HH:mm MM-dd-yyyy"/>
        </property>
    </bean>

</beans>
```

<!-- tabs:start -->

#### ** English **

(1)Our custom bean.
#### ** Chinese **

(1)我们的定制豆。
<!-- tabs:end -->


### **9.2.6. More Detailed Examples** 

<!-- tabs:start -->

#### ** English **

This section presents some more detailed examples of custom XML extensions.
#### ** Chinese **

本节介绍一些比较详细的自定义XML扩展的例子。
<!-- tabs:end -->


### **Nesting Custom Elements within Custom Elements** 

<!-- tabs:start -->

#### ** English **

The example presented in this section shows how you to write the various artifacts required to satisfy a target of the following configuration:
#### ** Chinese **

本节所介绍的例子，告诉你如何编写满足以下配置目标所需的各种神器。
<!-- tabs:end -->


```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:foo="http://www.foo.example/schema/component"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.foo.example/schema/component http://www.foo.example/schema/component/component.xsd">

    <foo:component id="bionic-family" name="Bionic-1">
        <foo:component name="Mother-1">
            <foo:component name="Karate-1"/>
            <foo:component name="Sport-1"/>
        </foo:component>
        <foo:component name="Rock-1"/>
    </foo:component>

</beans>
```

<!-- tabs:start -->

#### ** English **

The preceding configuration nests custom extensions within each other. The class that is actually configured by the `<foo:component/>` element is the `Component` class (shown in the next example). Notice how the `Component` class does not expose a setter method for the `components` property. This makes it hard (or rather impossible) to configure a bean definition for the `Component` class by using setter injection. The following listing shows the `Component` class:
#### ** Chinese **

前面的配置是将自定义扩展相互嵌套在一起。实际由`<foo:component/>`元素配置的类是`Component`类（在下一个示例中显示）。请注意，`Component`类没有为`components`属性公开一个设置器方法。这使得我们很难（或者说不可能）通过使用setter注入来为`Component`类配置一个bean定义。下面的列表显示了`Component`类。
<!-- tabs:end -->


```java
package com.foo;

import java.util.ArrayList;
import java.util.List;

public class Component {

    private String name;
    private List<Component> components = new ArrayList<Component> ();

    // mmm, there is no setter method for the 'components'
    public void addComponent(Component component) {
        this.components.add(component);
    }

    public List<Component> getComponents() {
        return components;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
```

<!-- tabs:start -->

#### ** English **

The typical solution to this issue is to create a custom `FactoryBean` that exposes a setter property for the `components` property. The following listing shows such a custom `FactoryBean`:
#### ** Chinese **

这个问题的典型解决方案是创建一个自定义的`FactoryBean`，为`components`属性暴露一个设置器属性。下面的列表显示了这样一个自定义的`FactoryBean`。
<!-- tabs:end -->


```java
package com.foo;

import org.springframework.beans.factory.FactoryBean;

import java.util.List;

public class ComponentFactoryBean implements FactoryBean<Component> {

    private Component parent;
    private List<Component> children;

    public void setParent(Component parent) {
        this.parent = parent;
    }

    public void setChildren(List<Component> children) {
        this.children = children;
    }

    public Component getObject() throws Exception {
        if (this.children != null && this.children.size() > 0) {
            for (Component child : children) {
                this.parent.addComponent(child);
            }
        }
        return this.parent;
    }

    public Class<Component> getObjectType() {
        return Component.class;
    }

    public boolean isSingleton() {
        return true;
    }
}
```

<!-- tabs:start -->

#### ** English **

This works nicely, but it exposes a lot of Spring plumbing to the end user. What we are going to do is write a custom extension that hides away all of this Spring plumbing. If we stick to [the steps described previously](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#xsd-custom-introduction), we start off by creating the XSD schema to define the structure of our custom tag, as the following listing shows:
#### ** Chinese **

这样做很好，但它向终端用户暴露了很多Spring的管道。我们要做的是写一个自定义的扩展，把所有的Spring管道隐藏起来。如果我们按照[前面描述的步骤](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#xsd-custom-introduction)，我们首先创建XSD模式来定义我们的自定义标记的结构，如下表所示。
<!-- tabs:end -->


```xml
<?xml version="1.0" encoding="UTF-8" standalone="no"?>

<xsd:schema xmlns="http://www.foo.example/schema/component"
        xmlns:xsd="http://www.w3.org/2001/XMLSchema"
        targetNamespace="http://www.foo.example/schema/component"
        elementFormDefault="qualified"
        attributeFormDefault="unqualified">

    <xsd:element name="component">
        <xsd:complexType>
            <xsd:choice minOccurs="0" maxOccurs="unbounded">
                <xsd:element ref="component"/>
            </xsd:choice>
            <xsd:attribute name="id" type="xsd:ID"/>
            <xsd:attribute name="name" use="required" type="xsd:string"/>
        </xsd:complexType>
    </xsd:element>

</xsd:schema>
```

<!-- tabs:start -->

#### ** English **

Again following [the process described earlier](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#xsd-custom-introduction), we then create a custom `NamespaceHandler`:
#### ** Chinese **

再次按照[前面描述的过程](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#xsd-custom-introduction)，然后我们创建一个自定义的`NamespaceHandler`。
<!-- tabs:end -->


```java
package com.foo;

import org.springframework.beans.factory.xml.NamespaceHandlerSupport;

public class ComponentNamespaceHandler extends NamespaceHandlerSupport {

    public void init() {
        registerBeanDefinitionParser("component", new ComponentBeanDefinitionParser());
    }
}
```

<!-- tabs:start -->

#### ** English **

Next up is the custom `BeanDefinitionParser`. Remember that we are creating a `BeanDefinition` that describes a `ComponentFactoryBean`. The following listing shows our custom `BeanDefinitionParser` implementation:
#### ** Chinese **

接下来是自定义的`BeanDefinitionParser`。记住，我们正在创建一个`BeanDefinition`来描述一个`ComponentFactoryBean`。下面的列表显示了我们的自定义`BeanDefinitionParser`实现。
<!-- tabs:end -->


```java
package com.foo;

import org.springframework.beans.factory.config.BeanDefinition;
import org.springframework.beans.factory.support.AbstractBeanDefinition;
import org.springframework.beans.factory.support.BeanDefinitionBuilder;
import org.springframework.beans.factory.support.ManagedList;
import org.springframework.beans.factory.xml.AbstractBeanDefinitionParser;
import org.springframework.beans.factory.xml.ParserContext;
import org.springframework.util.xml.DomUtils;
import org.w3c.dom.Element;

import java.util.List;

public class ComponentBeanDefinitionParser extends AbstractBeanDefinitionParser {

    protected AbstractBeanDefinition parseInternal(Element element, ParserContext parserContext) {
        return parseComponentElement(element);
    }

    private static AbstractBeanDefinition parseComponentElement(Element element) {
        BeanDefinitionBuilder factory = BeanDefinitionBuilder.rootBeanDefinition(ComponentFactoryBean.class);
        factory.addPropertyValue("parent", parseComponent(element));

        List<Element> childElements = DomUtils.getChildElementsByTagName(element, "component");
        if (childElements != null && childElements.size() > 0) {
            parseChildComponents(childElements, factory);
        }

        return factory.getBeanDefinition();
    }

    private static BeanDefinition parseComponent(Element element) {
        BeanDefinitionBuilder component = BeanDefinitionBuilder.rootBeanDefinition(Component.class);
        component.addPropertyValue("name", element.getAttribute("name"));
        return component.getBeanDefinition();
    }

    private static void parseChildComponents(List<Element> childElements, BeanDefinitionBuilder factory) {
        ManagedList<BeanDefinition> children = new ManagedList<BeanDefinition>(childElements.size());
        for (Element element : childElements) {
            children.add(parseComponentElement(element));
        }
        factory.addPropertyValue("children", children);
    }
}
```

<!-- tabs:start -->

#### ** English **

Finally, the various artifacts need to be registered with the Spring XML infrastructure, by modifying the `META-INF/spring.handlers` and `META-INF/spring.schemas` files, as follows:
#### ** Chinese **

最后，需要通过修改`META-INF/spring.handlers`和`META-INF/spring.schemas`文件，将各种工件注册到Spring XML基础架构中，具体如下。
<!-- tabs:end -->


# in 'META-INF/spring.handlers'
<!-- tabs:start -->

#### ** English **

http\://www.foo.example/schema/component=com.foo.ComponentNamespaceHandler
#### ** Chinese **

http：///www.foo.example/schema/component=com.foo.ComponentNamespaceHandler
<!-- tabs:end -->


# in 'META-INF/spring.schemas'
<!-- tabs:start -->

#### ** English **

http\://www.foo.example/schema/component/component.xsd=com/foo/component.xsd
#### ** Chinese **

http：///www.foo.example/schema/component/component.xsd=com/foo/component.xsd
<!-- tabs:end -->


### **Custom Attributes on “Normal” Elements** 

<!-- tabs:start -->

#### ** English **

Writing your own custom parser and the associated artifacts is not hard. However, it is sometimes not the right thing to do. Consider a scenario where you need to add metadata to already existing bean definitions. In this case, you certainly do not want to have to write your own entire custom extension. Rather, you merely want to add an additional attribute to the existing bean definition element.
#### ** Chinese **

编写自己的自定义解析器和相关的工件并不难。然而，有时并不是正确的做法。考虑一个场景：你需要将元数据添加到已经存在的bean定义中。在这种情况下，你当然不希望自己编写整个自定义扩展。相反，你只是想在现有的Bean定义元素中添加一个额外的属性。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

By way of another example, suppose that you define a bean definition for a service object that (unknown to it) accesses a clustered [JCache](https://jcp.org/en/jsr/detail?id=107), and you want to ensure that the named JCache instance is eagerly started within the surrounding cluster. The following listing shows such a definition:
#### ** Chinese **

通过另一个例子，假设你为一个服务对象定义了一个bean定义，该服务对象（未知的）访问了一个集群的[JCache](https://jcp.org/en/jsr/detail?id=107)，并且你想确保命名的JCache实例在周围的集群中急切地启动。下面的列表显示了这样一个定义。
<!-- tabs:end -->


```xml
<bean id="checkingAccountService" class="com.foo.DefaultCheckingAccountService"
        jcache:cache-name="checking.account">
    <!-- other dependencies here... -->
</bean>
```

<!-- tabs:start -->

#### ** English **

We can then create another `BeanDefinition` when the `'jcache:cache-name'` attribute is parsed. This `BeanDefinition` then initializes the named JCache for us. We can also modify the existing `BeanDefinition` for the `'checkingAccountService'` so that it has a dependency on this new JCache-initializing `BeanDefinition`. The following listing shows our `JCacheInitializer`:
#### ** Chinese **

然后我们可以在解析`'jcache:cache-name'`属性时创建另一个`BeanDefinition`。这个`BeanDefinition`然后为我们初始化命名的JCache。我们还可以修改现有的 `'checkingAccountService'`的 `BeanDefinition`，使其依赖于这个新的 JCache-initializing `BeanDefinition`。下面的列表显示了我们的`JCacheInitializer`。
<!-- tabs:end -->


```java
package com.foo;

public class JCacheInitializer {

    private String name;

    public JCacheInitializer(String name) {
        this.name = name;
    }

    public void initialize() {
        // lots of JCache API calls to initialize the named cache...
    }
}
```

<!-- tabs:start -->

#### ** English **

Now we can move onto the custom extension. First, we need to author the XSD schema that describes the custom attribute, as follows:
#### ** Chinese **

现在，我们可以进入自定义扩展了。首先，我们需要编写描述自定义属性的XSD模式，如下所示。
<!-- tabs:end -->


```xml
<?xml version="1.0" encoding="UTF-8" standalone="no"?>

<xsd:schema xmlns="http://www.foo.example/schema/jcache"
        xmlns:xsd="http://www.w3.org/2001/XMLSchema"
        targetNamespace="http://www.foo.example/schema/jcache"
        elementFormDefault="qualified">

    <xsd:attribute name="cache-name" type="xsd:string"/>

</xsd:schema>
```

<!-- tabs:start -->

#### ** English **

Next, we need to create the associated `NamespaceHandler`, as follows:
#### ** Chinese **

接下来，我们需要创建相关的`NamespaceHandler`，如下所示。
<!-- tabs:end -->


```java
package com.foo;

import org.springframework.beans.factory.xml.NamespaceHandlerSupport;

public class JCacheNamespaceHandler extends NamespaceHandlerSupport {

    public void init() {
        super.registerBeanDefinitionDecoratorForAttribute("cache-name",
            new JCacheInitializingBeanDefinitionDecorator());
    }

}
```

<!-- tabs:start -->

#### ** English **

Next, we need to create the parser. Note that, in this case, because we are going to parse an XML attribute, we write a `BeanDefinitionDecorator` rather than a `BeanDefinitionParser`. The following listing shows our `BeanDefinitionDecorator` implementation:
#### ** Chinese **

接下来，我们需要创建解析器。注意，在这种情况下，因为我们要解析一个XML属性，所以我们要写一个`BeanDefinitionDecorator`而不是`BeanDefinitionParser`。下面的列表显示了我们的 `BeanDefinitionDecorator`的实现。
<!-- tabs:end -->


```java
package com.foo;

import org.springframework.beans.factory.config.BeanDefinitionHolder;
import org.springframework.beans.factory.support.AbstractBeanDefinition;
import org.springframework.beans.factory.support.BeanDefinitionBuilder;
import org.springframework.beans.factory.xml.BeanDefinitionDecorator;
import org.springframework.beans.factory.xml.ParserContext;
import org.w3c.dom.Attr;
import org.w3c.dom.Node;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class JCacheInitializingBeanDefinitionDecorator implements BeanDefinitionDecorator {

    private static final String[] EMPTY_STRING_ARRAY = new String[0];

    public BeanDefinitionHolder decorate(Node source, BeanDefinitionHolder holder,
            ParserContext ctx) {
        String initializerBeanName = registerJCacheInitializer(source, ctx);
        createDependencyOnJCacheInitializer(holder, initializerBeanName);
        return holder;
    }

    private void createDependencyOnJCacheInitializer(BeanDefinitionHolder holder,
            String initializerBeanName) {
        AbstractBeanDefinition definition = ((AbstractBeanDefinition) holder.getBeanDefinition());
        String[] dependsOn = definition.getDependsOn();
        if (dependsOn == null) {
            dependsOn = new String[]{initializerBeanName};
        } else {
            List dependencies = new ArrayList(Arrays.asList(dependsOn));
            dependencies.add(initializerBeanName);
            dependsOn = (String[]) dependencies.toArray(EMPTY_STRING_ARRAY);
        }
        definition.setDependsOn(dependsOn);
    }

    private String registerJCacheInitializer(Node source, ParserContext ctx) {
        String cacheName = ((Attr) source).getValue();
        String beanName = cacheName + "-initializer";
        if (!ctx.getRegistry().containsBeanDefinition(beanName)) {
            BeanDefinitionBuilder initializer = BeanDefinitionBuilder.rootBeanDefinition(JCacheInitializer.class);
            initializer.addConstructorArg(cacheName);
            ctx.getRegistry().registerBeanDefinition(beanName, initializer.getBeanDefinition());
        }
        return beanName;
    }
}
```

<!-- tabs:start -->

#### ** English **

Finally, we need to register the various artifacts with the Spring XML infrastructure by modifying the `META-INF/spring.handlers` and `META-INF/spring.schemas` files, as follows:
#### ** Chinese **

最后，我们需要通过修改`META-INF/spring.handlers`和`META-INF/spring.schemas`文件，将各种工件注册到Spring XML基础架构中，具体如下。
<!-- tabs:end -->


# in 'META-INF/spring.handlers'
<!-- tabs:start -->

#### ** English **

http\://www.foo.example/schema/jcache=com.foo.JCacheNamespaceHandler
#### ** Chinese **

http：///www.foo.example/schema/jcache=com.foo.JCacheNamespaceHandler
<!-- tabs:end -->


# in 'META-INF/spring.schemas'
<!-- tabs:start -->

#### ** English **

http\://www.foo.example/schema/jcache/jcache.xsd=com/foo/jcache.xsd
#### ** Chinese **

http：///www.foo.example/schema/jcache/jcache.xsd=com/foo/jcache.xsd
<!-- tabs:end -->


[下一章](Spring-Framework-5.2.6.RELEASE/Testing/概述.md)

[回目录](Spring-Framework-5.2.6.RELEASE/summary.md)

[回首页](/README)
