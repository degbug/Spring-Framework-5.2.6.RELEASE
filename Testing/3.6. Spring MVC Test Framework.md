# 3.6. Spring MVC Test Framework

<!-- tabs:start -->

#### ** English **

The Spring MVC Test framework provides first class support for testing Spring MVC code with a fluent API that you can use with JUnit, TestNG, or any other testing framework. It is built on the [Servlet API mock objects](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/mock/web/package-summary.html) from the `spring-test` module and, hence, does not use a running Servlet container. It uses the `DispatcherServlet` to provide full Spring MVC runtime behavior and provides support for loading actual Spring configuration with the TestContext framework in addition to a standalone mode, in which you can manually instantiate controllers and test them one at a time.
#### ** Chinese **

Spring MVC测试框架为测试Spring MVC代码提供了一流的支持，它提供了流畅的API，你可以使用JUnit、TestNG或其他任何测试框架来测试Spring MVC代码。它建立在`spring-test`模块中的[Servlet API mock对象](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/mock/web/package-summary.html)上，因此，它不使用运行中的Servlet容器。它使用`DispatcherServlet`来提供完整的Spring MVC运行时行为，并提供了对TestContext框架加载实际的Spring配置的支持，此外还提供了独立模式，你可以手动实例化控制器，并一次一个一个地测试它们。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Spring MVC Test also provides client-side support for testing code that uses the `RestTemplate`. Client-side tests mock the server responses and also do not use a running server.
#### ** Chinese **

Spring MVC测试还提供了客户端支持，用于测试使用`RestTemplate`的代码。客户端测试模拟服务器的响应，也不使用运行中的服务器。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Spring Boot provides an option to write full, end-to-end integration tests that include a running server. If this is your goal, see the [Spring Boot Reference Guide](https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-testing). For more information on the differences between out-of-container and end-to-end integration tests, see [Spring MVC Test vs End-to-End Tests](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#spring-mvc-test-vs-end-to-end-integration-tests).
#### ** Chinese **

Spring Boot 提供了一个选项来编写包含运行中的服务器的完整的端到端集成测试。如果这是您的目标，请参阅 [Spring Boot 参考指南](https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-testing)。有关容器外测试和端到端集成测试的区别，请参阅[Spring MVC测试与端到端测试](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#spring-mvc-test-vs-end-to-end-integration-tests)。
<!-- tabs:end -->


### **3.6.1. Server-Side Tests** 

<!-- tabs:start -->

#### ** English **

You can write a plain unit test for a Spring MVC controller by using JUnit or TestNG. To do so, instantiate the controller, inject it with mocked or stubbed dependencies, and call its methods (passing `MockHttpServletRequest`, `MockHttpServletResponse`, and others, as necessary). However, when writing such a unit test, much remains untested: for example, request mappings, data binding, type conversion, validation, and much more. Furthermore, other controller methods such as `@InitBinder`, `@ModelAttribute`, and `@ExceptionHandler` may also be invoked as part of the request processing lifecycle.
#### ** Chinese **

你可以通过使用JUnit或TestNG为Spring MVC控制器编写一个普通的单元测试。要做到这一点，只需实例化该控制器，将其注入模拟或存根依赖，并调用它的方法（根据需要，传递`MockHttpServletRequest`、`MockHttpServletResponse`和其他方法）。然而，在编写这样的单元测试时，还有很多东西没有被测试到：例如，请求映射、数据绑定、类型转换、验证等等。此外，其他控制器方法，如`@InitBinder`、`@ModelAttribute`和`@ExceptionHandler`也可能作为请求处理生命周期的一部分被调用。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The goal of Spring MVC Test is to provide an effective way to test controllers by performing requests and generating responses through the actual `DispatcherServlet`.
#### ** Chinese **

Spring MVC测试的目标是通过实际的`DispatcherServlet`来执行请求和生成响应，提供一种有效的方法来测试控制器。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Spring MVC Test builds on the familiar [“mock” implementations of the Servlet API](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#mock-objects-servlet) available in the `spring-test` module. This allows performing requests and generating responses without the need for running in a Servlet container. For the most part, everything should work as it does at runtime with a few notable exceptions, as explained in [Spring MVC Test vs End-to-End Tests](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#spring-mvc-test-vs-end-to-end-integration-tests). The following JUnit Jupiter-based example uses Spring MVC Test:
#### ** Chinese **

Spring MVC测试建立在我们熟悉的[Servlet API的 "模拟 "实现](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#mock-objects-servlet)`spring-test`模块中提供的["模拟 "实现](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#mock-objects-servlet)。这允许执行请求和生成响应，而不需要在Servlet容器中运行。在大多数情况下，除了少数几个明显的例外情况，一切都应该在运行时正常工作，这在[Spring MVC 测试与端到端测试](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#spring-mvc-test-vs-end-to-end-integration-tests)中解释过。下面这个基于JUnit Jupiter的例子使用了Spring MVC测试。
<!-- tabs:end -->


```java
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.;

@SpringJUnitWebConfig(locations = "test-servlet-context.xml")
class ExampleTests {

    MockMvc mockMvc;

    @BeforeEach
    void setup(WebApplicationContext wac) {
        this.mockMvc = MockMvcBuilders.webAppContextSetup(wac).build();
    }

    @Test
    void getAccount() throws Exception {
        this.mockMvc.perform(get("/accounts/1")
                .accept(MediaType.APPLICATION_JSON))
            .andExpect(status().isOk())
            .andExpect(content().contentType("application/json"))
            .andExpect(jsonPath("$.name").value("Lee"));
    }
}
```

<!-- tabs:start -->

#### ** English **

A dedicated [MockMvc DSL](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/languages.html#mockmvc-dsl) is available in Kotlin
#### ** Chinese **

Kotlin中有专门的【MockMvc DSL】(https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/languages.html#mockmvc-dsl)。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The preceding test relies on the `WebApplicationContext` support of the TestContext framework to load Spring configuration from an XML configuration file located in the same package as the test class, but Java-based and Groovy-based configuration are also supported. See these [sample tests](https://github.com/spring-projects/spring-framework/tree/master/spring-test/src/test/java/org/springframework/test/web/servlet/samples/context).
#### ** Chinese **

前面的测试依靠TestContext框架的`WebApplicationContext`支持从与测试类相同的XML配置文件中加载Spring配置，但也支持基于Java和Groovy的配置。参见这些[测试样本](https://github.com/spring-projects/spring-framework/tree/master/spring-test/src/test/java/org/springframework/test/web/servlet/samples/context)。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The `MockMvc` instance is used to perform a `GET` request to `/accounts/1` and verify that the resulting response has status 200, the content type is `application/json`, and the response body has a JSON property called `name` with the value `Lee`. The `jsonPath` syntax is supported through the Jayway [JsonPath project](https://github.com/jayway/JsonPath). Many other options for verifying the result of the performed request are discussed later in this document.
#### ** Chinese **

`MockMvc`实例用于向`/accounts/1`执行`GET`请求，并验证所产生的响应具有状态200，内容类型为`application/json`，并且响应体具有一个名为`name`的JSON属性，其值为`Lee`。`jsonPath`语法通过Jayway [JsonPath项目](https://github.com/jayway/JsonPath)支持。本文档后面会讨论许多其他验证执行请求结果的选项。
<!-- tabs:end -->


### **Static Imports** 

<!-- tabs:start -->

#### ** English **

The fluent API in the example from the [preceding section](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#spring-mvc-test-server) requires a few static imports, such as `MockMvcRequestBuilders.*`, `MockMvcResultMatchers.*`, and `MockMvcBuilders.*`. An easy way to find these classes is to search for types that match `MockMvc*`. If you use Eclipse or the [Spring Tools for Eclipse](https://spring.io/tools), be sure to add them as “favorite static members” in the Eclipse preferences under Java → Editor → Content Assist → Favorites. Doing so lets you use content assist after typing the first character of the static method name. Other IDEs (such as IntelliJ) may not require any additional configuration. Check the support for code completion on static members.
#### ** Chinese **

在[上一节](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#spring-mvc-test-server)的例子中的流畅API需要一些静态导入，比如`MockMvcRequestBuilders.*`、`MockMvcResultMatchers.*`和`MockMvcBuilders.*`。找到这些类的一个简单方法是搜索符合 `MockMvc*`的类型。如果您使用 Eclipse 或 [Spring Tools for Eclipse](https://spring.io/tools)，请务必在 Eclipse 首选项中的 Java → Editor → Content Assist → Favorites 下添加它们作为 "最喜欢的静态成员"。这样做可以让你在输入静态方法名称的第一个字符后使用内容辅助。其他 IDE（如 IntelliJ）可能不需要任何额外的配置。请检查对静态成员的代码完成支持。
<!-- tabs:end -->


### **Setup Choices** 

<!-- tabs:start -->

#### ** English **

You have two main options for creating an instance of `MockMvc`. The first is to load Spring MVC configuration through the TestContext framework, which loads the Spring configuration and injects a `WebApplicationContext` into the test to use to build a `MockMvc` instance. The following example shows how to do so:
#### ** Chinese **

你有两个主要的选择来创建一个`MockMvc`的实例。第一种是通过TestContext框架加载Spring MVC配置，它会加载Spring配置，并将`WebApplicationContext`注入到测试中，用于构建一个`MockMvc`实例。下面的例子显示了如何做到这一点。
<!-- tabs:end -->


```java
@SpringJUnitWebConfig(locations = "my-servlet-context.xml")
class MyWebTests {

    MockMvc mockMvc;

    @BeforeEach
    void setup(WebApplicationContext wac) {
        this.mockMvc = MockMvcBuilders.webAppContextSetup(this.wac).build();
    }

    // ...

}
```

<!-- tabs:start -->

#### ** English **

Your second option is to manually create a controller instance without loading Spring configuration. Instead, basic default configuration, roughly comparable to that of the MVC JavaConfig or the MVC namespace, is automatically created. You can customize it to a degree. The following example shows how to do so:
#### ** Chinese **

你的第二个选择是手动创建一个控制器实例，而不加载Spring配置。而是自动创建基本的默认配置，大致相当于MVC JavaConfig或MVC命名空间的默认配置。您可以在一定程度上对其进行自定义。下面的例子显示了如何做到这一点。
<!-- tabs:end -->


```java
class MyWebTests {

    MockMvc mockMvc;

    @BeforeEach
    void setup() {
        this.mockMvc = MockMvcBuilders.standaloneSetup(new AccountController()).build();
    }

    // ...

}
```

<!-- tabs:start -->

#### ** English **

Which setup option should you use?
#### ** Chinese **

你应该使用哪个设置选项？
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The `webAppContextSetup` loads your actual Spring MVC configuration, resulting in a more complete integration test. Since the TestContext framework caches the loaded Spring configuration, it helps keep tests running fast, even as you introduce more tests in your test suite. Furthermore, you can inject mock services into controllers through Spring configuration to remain focused on testing the web layer. The following example declares a mock service with Mockito:
#### ** Chinese **

`webAppContextSetup`加载了你实际的Spring MVC配置，从而实现了更完整的集成测试。由于TestContext框架缓存了加载的Spring配置，因此它有助于保持测试的快速运行，即使你在测试套件中引入更多的测试，也能保持测试的快速运行。此外，你可以通过Spring配置将模拟服务注入到控制器中，以保持专注于测试Web层。下面的例子是用Mockito声明一个mock服务。
<!-- tabs:end -->


```xml
<bean id="accountService" class="org.mockito.Mockito" factory-method="mock">
    <constructor-arg value="org.example.AccountService"/>
</bean>
```

<!-- tabs:start -->

#### ** English **

You can then inject the mock service into the test to set up and verify your expectations, as the following example shows:
#### ** Chinese **

然后，你可以将模拟服务注入到测试中去设置和验证你的期望值，如下例所示。
<!-- tabs:end -->


```java
@SpringJUnitWebConfig(locations = "test-servlet-context.xml")
class AccountTests {

    @Autowired
    AccountService accountService;

    MockMvc mockMvc;

    @BeforeEach
    void setup(WebApplicationContext wac) {
        this.mockMvc = MockMvcBuilders.webAppContextSetup(wac).build();
    }

    // ...

}
```

<!-- tabs:start -->

#### ** English **

The `standaloneSetup`, on the other hand, is a little closer to a unit test. It tests one controller at a time. You can manually inject the controller with mock dependencies, and it does not involve loading Spring configuration. Such tests are more focused on style and make it easier to see which controller is being tested, whether any specific Spring MVC configuration is required to work, and so on. The `standaloneSetup` is also a very convenient way to write ad-hoc tests to verify specific behavior or to debug an issue.
#### ** Chinese **

另一方面，`standaloneSetup`则更接近于单元测试。它一次只测试一个控制器。你可以用mock依赖关系手动注入控制器，而且它不涉及加载Spring配置。这样的测试更侧重于风格，更容易看到哪个控制器被测试，是否需要任何特定的Spring MVC配置才能工作等等。`standaloneSetup`也是一个非常方便的方法，可以编写临时测试来验证特定行为或调试问题。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

As with most “integration versus unit testing” debates, there is no right or wrong answer. However, using the `standaloneSetup` does imply the need for additional `webAppContextSetup` tests in order to verify your Spring MVC configuration. Alternatively, you can write all your tests with `webAppContextSetup`, in order to always test against your actual Spring MVC configuration.
#### ** Chinese **

就像大多数 "集成与单元测试 "的争论一样，没有正确或错误的答案。然而，使用`standaloneSetup`确实意味着需要额外的`webAppContextSetup`测试来验证Spring MVC配置。另外，您也可以使用 `webAppContextSetup`来编写所有的测试，以便始终根据实际的Spring MVC配置进行测试。
<!-- tabs:end -->


### **Setup Features** 

<!-- tabs:start -->

#### ** English **

No matter which MockMvc builder you use, all `MockMvcBuilder` implementations provide some common and very useful features. For example, you can declare an `Accept` header for all requests and expect a status of 200 as well as a `Content-Type` header in all responses, as follows:
#### ** Chinese **

无论你使用的是哪个MockMvc构建器，所有的`MockMvcBuilder`实现都提供了一些常见且非常有用的特性。例如，你可以为所有的请求声明一个`Accept`头，并期望在所有的响应中都有一个状态为200的`Content-Type`头，如下所示。
<!-- tabs:end -->


```java
// static import of MockMvcBuilders.standaloneSetup

MockMvc mockMvc = standaloneSetup(new MusicController())
    .defaultRequest(get("/").accept(MediaType.APPLICATION_JSON))
    .alwaysExpect(status().isOk())
    .alwaysExpect(content().contentType("application/json;charset=UTF-8"))
    .build();
```

<!-- tabs:start -->

#### ** English **

In addition, third-party frameworks (and applications) can pre-package setup instructions, such as those in a `MockMvcConfigurer`. The Spring Framework has one such built-in implementation that helps to save and re-use the HTTP session across requests. You can use it as follows:
#### ** Chinese **

此外，第三方框架（和应用程序）可以预先打包设置指令，例如`MockMvcConfigurer`中的设置指令。Spring框架有一个这样的内置实现，它可以帮助保存和重复使用跨请求的HTTP会话。你可以使用它，如下所示。
<!-- tabs:end -->


```java
// static import of SharedHttpSessionConfigurer.sharedHttpSession

MockMvc mockMvc = MockMvcBuilders.standaloneSetup(new TestController())
        .apply(sharedHttpSession())
        .build();

// Use mockMvc to perform requests...
```

<!-- tabs:start -->

#### ** English **

See the javadoc for [`ConfigurableMockMvcBuilder`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/test/web/servlet/setup/ConfigurableMockMvcBuilder.html) for a list of all MockMvc builder features or use the IDE to explore the available options.
#### ** Chinese **

请参阅 [`ConfigurableMockMvcBuilder`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/test/web/servlet/setup/ConfigurableMockMvcBuilder.html)的javadoc，以了解所有MockMvc构建器的功能列表，或者使用IDE探索可用的选项。
<!-- tabs:end -->


### **Performing Requests** 

<!-- tabs:start -->

#### ** English **

You can perform requests that use any HTTP method, as the following example shows:
#### ** Chinese **

你可以执行使用任何HTTP方法的请求，如下面的例子所示。
<!-- tabs:end -->


```java
mockMvc.perform(post("/hotels/{id}", 42).accept(MediaType.APPLICATION_JSON));
```

<!-- tabs:start -->

#### ** English **

You can also perform file upload requests that internally use `MockMultipartHttpServletRequest` so that there is no actual parsing of a multipart request. Rather, you have to set it up to be similar to the following example:
#### ** Chinese **

你也可以执行内部使用`MockMultipartHttpServletRequest`的文件上传请求，这样就不需要实际解析多部分请求。相反，你必须将其设置为类似于下面的例子。
<!-- tabs:end -->


```java
mockMvc.perform(multipart("/doc").file("a1", "ABC".getBytes("UTF-8")));
```

<!-- tabs:start -->

#### ** English **

You can specify query parameters in URI template style, as the following example shows:
#### ** Chinese **

可以用URI模板样式指定查询参数，如下例所示。
<!-- tabs:end -->


```java
mockMvc.perform(get("/hotels?thing={thing}", "somewhere"));
```

<!-- tabs:start -->

#### ** English **

You can also add Servlet request parameters that represent either query or form parameters, as the following example shows:
#### ** Chinese **

你也可以添加Servlet请求参数，这些参数代表查询或表单参数，如下图所示。
<!-- tabs:end -->


```java
mockMvc.perform(get("/hotels").param("thing", "somewhere"));
```

<!-- tabs:start -->

#### ** English **

If application code relies on Servlet request parameters and does not check the query string explicitly (as is most often the case), it does not matter which option you use. Keep in mind, however, that query parameters provided with the URI template are decoded while request parameters provided through the `param(…​)` method are expected to already be decoded.
#### ** Chinese **

如果应用程序代码依赖Servlet请求参数，并且没有明确检查查询字符串（通常情况下是这样），那么使用哪个选项并不重要。但是，请记住，用URI模板提供的查询参数会被解码，而通过`param(…​)`方法提供的请求参数应该已经被解码。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

In most cases, it is preferable to leave the context path and the Servlet path out of the request URI. If you must test with the full request URI, be sure to set the `contextPath` and `servletPath` accordingly so that request mappings work, as the following example shows:
#### ** Chinese **

在大多数情况下，最好不要把上下文路径和Servlet路径放在请求URI之外。如果您必须使用完整的请求URI进行测试，请确保相应地设置`contextPath`和`servletPath`，这样请求映射就能正常工作，如下例所示。
<!-- tabs:end -->


```java
mockMvc.perform(get("/app/main/hotels/{id}").contextPath("/app").servletPath("/main"))
```

<!-- tabs:start -->

#### ** English **

In the preceding example, it would be cumbersome to set the `contextPath` and `servletPath` with every performed request. Instead, you can set up default request properties, as the following example shows:
#### ** Chinese **

在前面的例子中，在每次执行的请求中设置`contextPath`和`servletPath`是很麻烦的。相反，你可以设置默认的请求属性，如下例所示。
<!-- tabs:end -->


```java
class MyWebTests {

    MockMvc mockMvc;

    @BeforeEach
    void setup() {
        mockMvc = standaloneSetup(new AccountController())
            .defaultRequest(get("/")
            .contextPath("/app").servletPath("/main")
            .accept(MediaType.APPLICATION_JSON)).build();
    }
}
```

<!-- tabs:start -->

#### ** English **

The preceding properties affect every request performed through the `MockMvc` instance. If the same property is also specified on a given request, it overrides the default value. That is why the HTTP method and URI in the default request do not matter, since they must be specified on every request.
#### ** Chinese **

前面的属性会影响通过 `MockMvc`实例执行的每个请求。如果在给定的请求中也指定了相同的属性，那么它将覆盖默认值。这就是为什么默认请求中的HTTP方法和URI并不重要，因为它们必须在每个请求中指定。
<!-- tabs:end -->


### **Defining Expectations** 

<!-- tabs:start -->

#### ** English **

You can define expectations by appending one or more `.andExpect(..)` calls after performing a request, as the following example shows:
#### ** Chinese **

你可以通过在执行请求后附加一个或多个 `.andExpect(..)`调用来定义期望值，如下例所示。
<!-- tabs:end -->


```java
mockMvc.perform(get("/accounts/1")).andExpect(status().isOk());
```

<!-- tabs:start -->

#### ** English **

`MockMvcResultMatchers.*` provides a number of expectations, some of which are further nested with more detailed expectations.
#### ** Chinese **

`MockMvcResultMatchers.*`提供了一些期望值，其中一些期望值进一步嵌套了更详细的期望值。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Expectations fall in two general categories. The first category of assertions verifies properties of the response (for example, the response status, headers, and content). These are the most important results to assert.
#### ** Chinese **

期望可以分为两类。第一类断言是验证响应的属性（例如，响应状态、标题和内容）。这些是最重要的断言结果。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The second category of assertions goes beyond the response. These assertions let you inspect Spring MVC specific aspects, such as which controller method processed the request, whether an exception was raised and handled, what the content of the model is, what view was selected, what flash attributes were added, and so on. They also let you inspect Servlet specific aspects, such as request and session attributes.
#### ** Chinese **

第二类断言超出了响应的范围。这些断言可以让你检查Spring MVC的具体方面，例如哪个控制器方法处理了请求，是否提出并处理了异常，模型的内容是什么，选择了什么视图，添加了什么flash属性等等。它们还可以让你检查Servlet的特定方面，如请求和会话属性等。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following test asserts that binding or validation failed:
#### ** Chinese **

下面的测试断言绑定或验证失败。
<!-- tabs:end -->


```java
mockMvc.perform(post("/persons"))
    .andExpect(status().isOk())
    .andExpect(model().attributeHasErrors("person"));
```

<!-- tabs:start -->

#### ** English **

Many times, when writing tests, it is useful to dump the results of the performed request. You can do so as follows, where `print()` is a static import from `MockMvcResultHandlers`:
#### ** Chinese **

很多时候，在编写测试时，转储执行请求的结果是很有用的。你可以按照以下方法来做，其中`print()`是从`MockMvcResultHandlers`中静态导入的。
<!-- tabs:end -->


```java
mockMvc.perform(post("/persons"))
    .andDo(print())
    .andExpect(status().isOk())
    .andExpect(model().attributeHasErrors("person"));
```

<!-- tabs:start -->

#### ** English **

As long as request processing does not cause an unhandled exception, the `print()` method prints all the available result data to `System.out`. There is also a `log()` method and two additional variants of the `print()` method, one that accepts an `OutputStream` and one that accepts a `Writer`. For example, invoking `print(System.err)` prints the result data to `System.err`, while invoking `print(myWriter)` prints the result data to a custom writer. If you want to have the result data logged instead of printed, you can invoke the `log()` method, which logs the result data as a single `DEBUG` message under the `org.springframework.test.web.servlet.result` logging category.
#### ** Chinese **

只要请求处理不会导致一个未处理的异常，`print()`方法就会将所有可用的结果数据打印到`System.out`中。还有一个`log()`方法和两个额外的`print()`方法的变体，一个是接受一个`OutputStream`，一个是接受一个`Writer`。例如，调用`print(System.err)`将结果数据打印到`System.err`，而调用`print(myWriter)`将结果数据打印到自定义的写入器。如果你想记录结果数据而不是打印，你可以调用 `log()`方法，该方法将结果数据作为一个单独的 `DEBUG`消息记录在 `org.springframework.test.web.servlet.result`记录类别下。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

In some cases, you may want to get direct access to the result and verify something that cannot be verified otherwise. This can be achieved by appending `.andReturn()` after all other expectations, as the following example shows:
#### ** Chinese **

在某些情况下，你可能想直接访问结果并验证一些无法验证的东西。这可以通过在所有其他的期望值后面加上`.andReturn()`来实现，如下例所示。
<!-- tabs:end -->


```java
MvcResult mvcResult = mockMvc.perform(post("/persons")).andExpect(status().isOk()).andReturn();
// ...
```

<!-- tabs:start -->

#### ** English **

If all tests repeat the same expectations, you can set up common expectations once when building the `MockMvc` instance, as the following example shows:
#### ** Chinese **

如果所有测试都重复了相同的期望值，那么在构建`MockMvc`实例时，可以设置一次共同的期望值，如下例所示。
<!-- tabs:end -->


```java
standaloneSetup(new SimpleController())
    .alwaysExpect(status().isOk())
    .alwaysExpect(content().contentType("application/json;charset=UTF-8"))
    .build()
```

<!-- tabs:start -->

#### ** English **

Note that common expectations are always applied and cannot be overridden without creating a separate `MockMvc` instance.
#### ** Chinese **

请注意，通用期望值总是被应用，如果不创建单独的 `MockMvc`实例，就不能重写。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

When a JSON response content contains hypermedia links created with [Spring HATEOAS](https://github.com/spring-projects/spring-hateoas), you can verify the resulting links by using JsonPath expressions, as the following example shows:
#### ** Chinese **

当一个JSON响应内容包含使用[Spring HATEOAS](https://github.com/spring-projects/spring-hateoas)创建的超媒体链接时，可以通过使用JsonPath表达式来验证所产生的链接，如下例所示。
<!-- tabs:end -->


```java
mockMvc.perform(get("/people").accept(MediaType.APPLICATION_JSON))
    .andExpect(jsonPath("$.links[?(@.rel == 'self')].href").value("http://localhost:8080/people"));
```

<!-- tabs:start -->

#### ** English **

When XML response content contains hypermedia links created with [Spring HATEOAS](https://github.com/spring-projects/spring-hateoas), you can verify the resulting links by using XPath expressions:
#### ** Chinese **

当XML响应内容包含使用[Spring HATEOAS](https://github.com/spring-projects/spring-hateoas)创建的超媒体链接时，可以使用XPath表达式来验证生成的链接。
<!-- tabs:end -->


```java
Map<String, String> ns = Collections.singletonMap("ns", "http://www.w3.org/2005/Atom");
mockMvc.perform(get("/handle").accept(MediaType.APPLICATION_XML))
    .andExpect(xpath("/person/ns:link[@rel='self']/@href", ns).string("http://localhost:8080/people"));
```

### **Async Requests** 

<!-- tabs:start -->

#### ** English **

Servlet 3.0 asynchronous requests, [supported in Spring MVC](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-async), work by exiting the Servlet container thread and allowing the application to compute the response asynchronously, after which an async dispatch is made to complete processing on a Servlet container thread.
#### ** Chinese **

Servlet 3.0异步请求，[在Spring MVC中支持](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-async)，通过退出Servlet容器线程，允许应用程序异步计算响应，然后进行异步调度，完成对Servlet容器线程的处理。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

In Spring MVC Test, async requests can be tested by asserting the produced async value first, then manually performing the async dispatch, and finally verifying the response. Below is an example test for controller methods that return `DeferredResult`, `Callable`, or reactive type such as Reactor `Mono`:
#### ** Chinese **

在Spring MVC测试中，可以通过先断言产生的异步请求，然后手动执行异步调度，最后验证响应，来测试异步请求。下面是一个示例测试控制器方法的测试，这些方法返回`DeferredResult`，`Callable`，或者Reactor `Mono`等反应式类型。
<!-- tabs:end -->


```java
@Test
void test() throws Exception {
    MvcResult mvcResult = this.mockMvc.perform(get("/path"))
            .andExpect(status().isOk()) (1)
            .andExpect(request().asyncStarted()) (2)
            .andExpect(request().asyncResult("body")) (3)
            .andReturn();

    this.mockMvc.perform(asyncDispatch(mvcResult)) (4)
            .andExpect(status().isOk()) (5)
            .andExpect(content().string("body"));
}
```

### **Streaming Responses** 

<!-- tabs:start -->

#### ** English **

There are no options built into Spring MVC Test for container-less testing of streaming responses. Applications that make use of [Spring MVC streaming](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-async-http-streaming) options can use the [WebTestClient](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#webtestclient-stream) to perform end-to-end, integration tests against a running server. This is also supported in Spring Boot where you can [test a running server](https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-testing-spring-boot-applications-testing-with-running-server) with `WebTestClient`. One extra advantage is the ability to use the `StepVerifier` from project Reactor that allows declaring expectations on a stream of data.
#### ** Chinese **

Spring MVC Test 中没有内置的选项，用于无容器测试流式响应的测试。使用[Spring MVC streaming](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/web.html#mvc-ann-async-http-streaming) 选项的应用程序可以使用[WebTestClient](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#webtestclient-stream)来针对运行中的服务器执行端到端的集成测试。在Spring Boot中也支持这一点，您可以使用`WebTestClient`对运行中的服务器进行[测试](https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-testing-spring-boot-applications-testing-with-running-server)。一个额外的优势是可以使用项目 Reactor 中的 `StepVerifier`，它允许在数据流上声明期望值。
<!-- tabs:end -->


### **Filter Registrations** 

<!-- tabs:start -->

#### ** English **

When setting up a `MockMvc` instance, you can register one or more Servlet `Filter` instances, as the following example shows:
#### ** Chinese **

在设置 `MockMvc`实例时，可以注册一个或多个Servlet `Filter`实例，如下例所示。
<!-- tabs:end -->


```java
mockMvc = standaloneSetup(new PersonController()).addFilters(new CharacterEncodingFilter()).build();
```

<!-- tabs:start -->

#### ** English **

Registered filters are invoked through the `MockFilterChain` from `spring-test`, and the last filter delegates to the `DispatcherServlet`.
#### ** Chinese **

注册的过滤器通过`MockFilterChain`从`spring-test`中调用，最后一个过滤器委托给`DispatcherServlet`。
<!-- tabs:end -->


### **Spring MVC Test vs End-to-End Tests** 

<!-- tabs:start -->

#### ** English **

Spring MVC Test is built on Servlet API mock implementations from the `spring-test` module and does not rely on a running container. Therefore, there are some differences when compared to full end-to-end integration tests with an actual client and a live server running.
#### ** Chinese **

Spring MVC测试是建立在Servlet API模拟实现的`spring-test`模块中的Servlet API模拟实现上，并且不依赖于运行中的容器。因此，与实际运行的客户端和实时服务器的完整端到端集成测试相比，有一些区别。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The easiest way to think about this is by starting with a blank `MockHttpServletRequest`. Whatever you add to it is what the request becomes. Things that may catch you by surprise are that there is no context path by default; no `jsessionid` cookie; no forwarding, error, or async dispatches; and, therefore, no actual JSP rendering. Instead, “forwarded” and “redirected” URLs are saved in the `MockHttpServletResponse` and can be asserted with expectations.
#### ** Chinese **

最简单的思考方法是从一个空白的`MockHttpServletRequest`开始。无论你在其中添加什么，都会成为请求。可能会让你感到惊讶的是，默认情况下没有上下文路径；没有`jsessionid` cookie；没有转发、错误或异步派遣；因此，没有实际的JSP渲染。相反，"转发 "和 "重定向 "的URL被保存在`MockHttpServletResponse`中，并且可以用期望值来断言。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

This means that, if you use JSPs, you can verify the JSP page to which the request was forwarded, but no HTML is rendered. In other words, the JSP is not invoked. Note, however, that all other rendering technologies that do not rely on forwarding, such as Thymeleaf and Freemarker, render HTML to the response body as expected. The same is true for rendering JSON, XML, and other formats through `@ResponseBody` methods.
#### ** Chinese **

这意味着，如果使用JSP，可以验证请求转发到的JSP页面，但没有渲染HTML。换句话说，JSP没有被调用。但是请注意，所有其他不依赖转发的渲染技术，比如Thymeleaf和Freemarker，都会像预期的那样向响应体渲染HTML。通过`@ResponseBody`方法渲染JSON、XML和其他格式也是如此。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Alternatively, you may consider the full end-to-end integration testing support from Spring Boot with `@SpringBootTest`. See the [Spring Boot Reference Guide](https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-testing).
#### ** Chinese **

或者，您可以考虑使用 `@SpringBootTest`从Spring Boot提供完整的端到端集成测试支持。请参阅[Spring Boot参考指南](https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-testing)。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

There are pros and cons for each approach. The options provided in Spring MVC Test are different stops on the scale from classic unit testing to full integration testing. To be certain, none of the options in Spring MVC Test fall under the category of classic unit testing, but they are a little closer to it. For example, you can isolate the web layer by injecting mocked services into controllers, in which case you are testing the web layer only through the `DispatcherServlet` but with actual Spring configuration, as you might test the data access layer in isolation from the layers above it. Also, you can use the stand-alone setup, focusing on one controller at a time and manually providing the configuration required to make it work.
#### ** Chinese **

每种方法都有其优点和缺点。在Spring MVC测试中提供的选项是从经典的单元测试到完全集成测试的不同阶段。可以肯定的是，Spring MVC Test中的所有选项都不属于经典单元测试的范畴，但它们更接近于经典单元测试。例如，你可以通过将模拟服务注入到控制器中来隔离Web层，在这种情况下，你只通过`DispatcherServlet`来测试Web层，但用实际的Spring配置来测试，因为你可能会测试数据访问层与上面的层隔离。另外，你也可以使用独立的设置，每次只关注一个控制器，并手动提供所需的配置来使其工作。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Another important distinction when using Spring MVC Test is that, conceptually, such tests are the server-side, so you can check what handler was used, if an exception was handled with a HandlerExceptionResolver, what the content of the model is, what binding errors there were, and other details. That means that it is easier to write expectations, since the server is not a black box, as it is when testing it through an actual HTTP client. This is generally an advantage of classic unit testing: It is easier to write, reason about, and debug but does not replace the need for full integration tests. At the same time, it is important not to lose sight of the fact that the response is the most important thing to check. In short, there is room here for multiple styles and strategies of testing even within the same project.
#### ** Chinese **

在使用Spring MVC测试时，还有一个重要的区别，那就是在概念上，这样的测试是服务器端的，所以你可以检查使用了什么处理程序，是否用HandlerExceptionResolver处理了异常，模型的内容是什么，有什么绑定错误等等细节。这意味着写期望值比较容易，因为服务器不是一个黑箱，通过实际的HTTP客户端测试时，服务器不是黑箱。一般来说，这是经典的单元测试的一个优势。它更容易编写、推理和调试，但并不能取代完整的集成测试。同时，也不能忽略了响应是最重要的检查内容。总而言之，在这里，即使是在同一个项目中，也有多种测试风格和策略的空间。
<!-- tabs:end -->


### **Further Examples** 

<!-- tabs:start -->

#### ** English **

The framework’s own tests include [many sample tests](https://github.com/spring-projects/spring-framework/tree/master/spring-test/src/test/java/org/springframework/test/web/servlet/samples) intended to show how to use Spring MVC Test. You can browse these examples for further ideas. Also, the [`spring-mvc-showcase`](https://github.com/spring-projects/spring-mvc-showcase) project has full test coverage based on Spring MVC Test.
#### ** Chinese **

该框架自己的测试包括[许多测试示例](https://github.com/spring-projects/spring-framework/tree/master/spring-test/src/test/java/org/springframework/test/web/servlet/samples)，旨在展示如何使用Spring MVC测试。你可以浏览这些例子以获得进一步的想法。此外，[`spring-mvc-showcase`](https://github.com/spring-projects/spring-mvc-showcase)项目也有基于Spring MVC测试的完整测试覆盖。
<!-- tabs:end -->


### **3.6.2. HtmlUnit Integration** 

<!-- tabs:start -->

#### ** English **

Spring provides integration between [MockMvc](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#spring-mvc-test-server) and [HtmlUnit](http://htmlunit.sourceforge.net/). This simplifies performing end-to-end testing when using HTML-based views. This integration lets you:
#### ** Chinese **

Spring提供了[MockMvc](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#spring-mvc-test-server)和[HtmlUnit](http://htmlunit.sourceforge.net/)之间的集成。这简化了使用基于 HTML 的视图时执行端到端的测试。这种集成可以让你。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

- Easily test HTML pages by using tools such as [HtmlUnit](http://htmlunit.sourceforge.net/), [WebDriver](https://www.seleniumhq.org/), and [Geb](http://www.gebish.org/manual/current/#spock-junit-testng) without the need to deploy to a Servlet container.

- Test JavaScript within pages.

- Optionally, test using mock services to speed up testing.

- Share logic between in-container end-to-end tests and out-of-container integration tests.

#### ** Chinese **

- 通过使用[HtmlUnit](http://htmlunit.sourceforge.net/)、[WebDriver](https://www.seleniumhq.org/)和[Geb](http://www.gebish.org/manual/current/#spock-junit-testng]等工具，轻松地测试HTML页面，而不需要部署到Servlet容器中。

- 在页面内测试JavaScript。

- 可以选择使用模拟服务进行测试，以加快测试速度。

- 在容器内的端到端测试和容器外的集成测试之间共享逻辑。

<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

MockMvc works with templating technologies that do not rely on a Servlet Container (for example, Thymeleaf, FreeMarker, and others), but it does not work with JSPs, since they rely on the Servlet container.
#### ** Chinese **

MockMvc可以与不依赖Servlet容器的模板化技术一起工作（例如Thymeleaf、FreeMarker等），但它不能与JSP一起工作，因为它们依赖Servlet容器。
<!-- tabs:end -->


### **Why HtmlUnit Integration?** 

<!-- tabs:start -->

#### ** English **

The most obvious question that comes to mind is “Why do I need this?” The answer is best found by exploring a very basic sample application. Assume you have a Spring MVC web application that supports CRUD operations on a `Message` object. The application also supports paging through all messages. How would you go about testing it?
#### ** Chinese **

最容易想到的问题是 "我为什么需要这个？" 最好通过探索一个非常基本的示例应用程序来找到答案。假设你有一个支持对`Message`对象进行CRUD操作的Spring MVC Web应用程序。该应用程序还支持对所有消息进行分页操作。你将如何去测试它？
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

With Spring MVC Test, we can easily test if we are able to create a `Message`, as follows:
#### ** Chinese **

通过Spring MVC测试，我们可以轻松地测试是否能够创建一个`Message`，如下所示。
<!-- tabs:end -->


```java
MockHttpServletRequestBuilder createMessage = post("/messages/")
        .param("summary", "Spring Rocks")
        .param("text", "In case you didn't know, Spring Rocks!");

mockMvc.perform(createMessage)
        .andExpect(status().is3xxRedirection())
        .andExpect(redirectedUrl("/messages/123"));
```

<!-- tabs:start -->

#### ** English **

What if we want to test the form view that lets us create the message? For example, assume our form looks like the following snippet:
#### ** Chinese **

如果我们想测试一下让我们创建消息的表单视图呢？例如，假设我们的表单看起来像下面这个片段。
<!-- tabs:end -->


```xml
<form id="messageForm" action="/messages/" method="post">
    <div class="pull-right"><a href="/messages/">Messages</a></div>

    <label for="summary">Summary</label>
    <input type="text" class="required" id="summary" name="summary" value="" />

    <label for="text">Message</label>
    <textarea id="text" name="text"></textarea>

    <div class="form-actions">
        <input type="submit" value="Create" />
    </div>
</form>
```

<!-- tabs:start -->

#### ** English **

How do we ensure that our form produce the correct request to create a new message? A naive attempt might resemble the following:
#### ** Chinese **

我们如何确保我们的表单产生正确的请求来创建一个新消息？一个天真的尝试可能类似于下面的例子。
<!-- tabs:end -->


```java
mockMvc.perform(get("/messages/form"))
        .andExpect(xpath("//input[@name='summary']").exists())
        .andExpect(xpath("//textarea[@name='text']").exists());
```

<!-- tabs:start -->

#### ** English **

This test has some obvious drawbacks. If we update our controller to use the parameter `message` instead of `text`, our form test continues to pass, even though the HTML form is out of synch with the controller. To resolve this we can combine our two tests, as follows:
#### ** Chinese **

这个测试有一些明显的缺点。如果我们将控制器更新为使用参数`message`而不是`text`，那么我们的表单测试就会继续通过，即使HTML表单与控制器不同步。为了解决这个问题，我们可以将两个测试结合起来，如下所示。
<!-- tabs:end -->


```java
String summaryParamName = "summary";
String textParamName = "text";
mockMvc.perform(get("/messages/form"))
        .andExpect(xpath("//input[@name='" + summaryParamName + "']").exists())
        .andExpect(xpath("//textarea[@name='" + textParamName + "']").exists());

MockHttpServletRequestBuilder createMessage = post("/messages/")
        .param(summaryParamName, "Spring Rocks")
        .param(textParamName, "In case you didn't know, Spring Rocks!");

mockMvc.perform(createMessage)
        .andExpect(status().is3xxRedirection())
        .andExpect(redirectedUrl("/messages/123"));
```

<!-- tabs:start -->

#### ** English **

This would reduce the risk of our test incorrectly passing, but there are still some problems:
#### ** Chinese **

这样一来，我们的测试就会减少错误通过的风险，但还是有一些问题。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

- What if we have multiple forms on our page? Admittedly, we could update our XPath expressions, but they get more complicated as we take more factors into account: Are the fields the correct type? Are the fields enabled? And so on.

- Another issue is that we are doing double the work we would expect. We must first verify the view, and then we submit the view with the same parameters we just verified. Ideally, this could be done all at once.

- Finally, we still cannot account for some things. For example, what if the form has JavaScript validation that we wish to test as well?

#### ** Chinese **

- 如果我们的页面上有多个表单怎么办？诚然，我们可以更新我们的XPath表达式，但当我们考虑到更多的因素时，它们会变得更加复杂。字段的类型是否正确？字段是否启用了？诸如此类的问题。

- 另一个问题是，我们要做的工作比我们预期的要多一倍。我们必须首先验证视图，然后用我们刚才验证的参数提交视图。理想情况下，这可以一次完成。

- 最后，我们仍然无法对一些事情进行核算。例如，如果表单有我们希望测试的JavaScript验证，那该怎么办？

<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

The overall problem is that testing a web page does not involve a single interaction. Instead, it is a combination of how the user interacts with a web page and how that web page interacts with other resources. For example, the result of a form view is used as the input to a user for creating a message. In addition, our form view can potentially use additional resources that impact the behavior of the page, such as JavaScript validation.
#### ** Chinese **

整体的问题是，测试一个网页并不涉及单一的交互。相反，它是用户如何与网页进行交互，以及该网页如何与其他资源进行交互的组合。例如，表单视图的结果被用作用户创建消息的输入。此外，我们的表单视图还可能使用影响页面行为的其他资源，例如JavaScript验证等。
<!-- tabs:end -->


### **Integration Testing to the Rescue?** 

<!-- tabs:start -->

#### ** English **

To resolve the issues mentioned earlier, we could perform end-to-end integration testing, but this has some drawbacks. Consider testing the view that lets us page through the messages. We might need the following tests:
#### ** Chinese **

为了解决前面提到的问题，我们可以进行端到端的集成测试，但这有一些缺点。考虑测试一下让我们翻阅消息的视图。我们可能需要进行以下测试。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

- Does our page display a notification to the user to indicate that no results are available when the messages are empty?

- Does our page properly display a single message?

- Does our page properly support paging?

#### ** Chinese **

- 我们的页面是否会在消息为空时，向用户显示通知，提示无结果？

- 我们的页面是否正常显示单条信息？

- 我们的页面是否正确支持分页？

<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

To set up these tests, we need to ensure our database contains the proper messages. This leads to a number of additional challenges:
#### ** Chinese **

为了设置这些测试，我们需要确保我们的数据库包含适当的消息。这导致了一些额外的挑战。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

- Ensuring the proper messages are in the database can be tedious. (Consider foreign key constraints.)

- Testing can become slow, since each test would need to ensure that the database is in the correct state.

- Since our database needs to be in a specific state, we cannot run tests in parallel.

- Performing assertions on such items as auto-generated ids, timestamps, and others can be difficult.

#### ** Chinese **

- 确保适当的消息在数据库中是很繁琐的。考虑外键约束）。

- 测试会变得很慢，因为每个测试都需要确保数据库处于正确的状态。

- 由于我们的数据库需要处于一个特定的状态，所以我们不能并行运行测试。

- 在自动生成的id、时间戳等项上执行断言会很困难。

<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

These challenges do not mean that we should abandon end-to-end integration testing altogether. Instead, we can reduce the number of end-to-end integration tests by refactoring our detailed tests to use mock services that run much faster, more reliably, and without side effects. We can then implement a small number of true end-to-end integration tests that validate simple workflows to ensure that everything works together properly.
#### ** Chinese **

这些挑战并不意味着我们应该完全放弃端到端集成测试。相反，我们可以通过重构我们的详细测试来减少端到端集成测试的数量，使用模拟服务来运行更快、更可靠、没有副作用的模拟服务。然后，我们可以实现少量真正的端到端集成测试，验证简单的工作流程，以确保一切正常运行。
<!-- tabs:end -->


### **Enter HtmlUnit Integration** 

<!-- tabs:start -->

#### ** English **

So how can we achieve a balance between testing the interactions of our pages and still retain good performance within our test suite? The answer is: “By integrating MockMvc with HtmlUnit.”
#### ** Chinese **

那么，我们如何才能在测试页面的交互性和测试套件内保持良好的性能之间取得平衡呢？答案是："通过将MockMvc与HtmlUnit整合在一起。"
<!-- tabs:end -->


### **HtmlUnit Integration Options** 

<!-- tabs:start -->

#### ** English **

You have a number of options when you want to integrate MockMvc with HtmlUnit:
#### ** Chinese **

当你想将MockMvc与HtmlUnit集成时，你有很多选择。
<!-- tabs:end -->


### **MockMvc and HtmlUnit** 

<!-- tabs:start -->

#### ** English **

This section describes how to integrate MockMvc and HtmlUnit. Use this option if you want to use the raw HtmlUnit libraries.
#### ** Chinese **

本节介绍了如何整合MockMvc和HtmlUnit。如果你想使用原始HtmlUnit库，请使用这个选项。
<!-- tabs:end -->


### **MockMvc and HtmlUnit Setup** 

<!-- tabs:start -->

#### ** English **

First, make sure that you have included a test dependency on `net.sourceforge.htmlunit:htmlunit`. In order to use HtmlUnit with Apache HttpComponents 4.5+, you need to use HtmlUnit 2.18 or higher.
#### ** Chinese **

首先，确保你已经在`net.sourceforge.htmlunit:htmlunit`上包含了一个测试依赖关系。为了使用HtmlUnit与Apache HttpComponents 4.5 ，你需要使用HtmlUnit 2.18或更高的版本。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

We can easily create an HtmlUnit `WebClient` that integrates with MockMvc by using the `MockMvcWebClientBuilder`, as follows:
#### ** Chinese **

我们可以通过使用`MockMvcWebClientBuilder`创建一个与MockMvc集成的HtmlUnit`WebClient`，如下所示，我们可以很容易地创建一个与MockMvc集成的HtmlUnit`WebClient`。
<!-- tabs:end -->


```java
WebClient webClient;

@BeforeEach
void setup(WebApplicationContext context) {
    webClient = MockMvcWebClientBuilder
            .webAppContextSetup(context)
            .build();
}
```

<!-- tabs:start -->

#### ** English **

This is a simple example of using `MockMvcWebClientBuilder`. For advanced usage, see [Advanced ](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#spring-mvc-test-server-htmlunit-mah-advanced-builder)[`MockMvcWebClientBuilder`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#spring-mvc-test-server-htmlunit-mah-advanced-builder).
#### ** Chinese **

这是一个使用`MockMvcWebClientBuilder`的简单例子。有关高级用法，请参阅[Advanced](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#spring-mvc-test-server-htmlunit-mah-advanced-builder)[`MockMvcWebClientBuilder`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#spring-mvc-test-server-htmlunit-mah-advanced-builder)。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

This ensures that any URL that references `localhost` as the server is directed to our `MockMvc` instance without the need for a real HTTP connection. Any other URL is requested by using a network connection, as normal. This lets us easily test the use of CDNs.
#### ** Chinese **

这确保了任何引用`localhost`作为服务器的URL都会被指向我们的`MockMvc`实例，而不需要真正的HTTP连接。任何其他的URL都是通过使用网络连接请求的，就像正常情况下一样。这让我们可以轻松地测试CDN的使用情况。
<!-- tabs:end -->


### **MockMvc and HtmlUnit Usage** 

<!-- tabs:start -->

#### ** English **

Now we can use HtmlUnit as we normally would but without the need to deploy our application to a Servlet container. For example, we can request the view to create a message with the following:
#### ** Chinese **

现在我们可以像平常一样使用HtmlUnit，但不需要将我们的应用程序部署到Servlet容器中。例如，我们可以请求视图创建一个消息，内容如下。
<!-- tabs:end -->


```java
HtmlPage createMsgFormPage = webClient.getPage("http://localhost/messages/form");
```

<!-- tabs:start -->

#### ** English **

The default context path is `""`. Alternatively, we can specify the context path, as described in [Advanced ](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#spring-mvc-test-server-htmlunit-mah-advanced-builder)[`MockMvcWebClientBuilder`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#spring-mvc-test-server-htmlunit-mah-advanced-builder).
#### ** Chinese **

默认的上下文路径是`""`。另外，我们也可以指定上下文路径，如[Advanced](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#spring-mvc-test-server-htmlunit-mah-advanced-builder)[`MockMvcWebClientBuilder`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#spring-mvc-test-server-htmlunit-mah-advanced-builder)中所述。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Once we have a reference to the `HtmlPage`, we can then fill out the form and submit it to create a message, as the following example shows:
#### ** Chinese **

当我们有了`HtmlPage`的引用后，我们就可以像下面的例子一样，填写表单，然后提交到表单中去创建一个消息。
<!-- tabs:end -->


```java
HtmlForm form = createMsgFormPage.getHtmlElementById("messageForm");
HtmlTextInput summaryInput = createMsgFormPage.getHtmlElementById("summary");
summaryInput.setValueAttribute("Spring Rocks");
HtmlTextArea textInput = createMsgFormPage.getHtmlElementById("text");
textInput.setText("In case you didn't know, Spring Rocks!");
HtmlSubmitInput submit = form.getOneHtmlElementByAttribute("input", "type", "submit");
HtmlPage newMessagePage = submit.click();
```

<!-- tabs:start -->

#### ** English **

Finally, we can verify that a new message was created successfully. The following assertions use the [AssertJ](https://joel-costigliola.github.io/assertj/) library:
#### ** Chinese **

最后，我们可以验证一个新消息的创建是否成功。下面的断言使用了[AssertJ](https://joel-costigliola.github.io/assertj/)库。
<!-- tabs:end -->


```java
assertThat(newMessagePage.getUrl().toString()).endsWith("/messages/123");
String id = newMessagePage.getHtmlElementById("id").getTextContent();
assertThat(id).isEqualTo("123");
String summary = newMessagePage.getHtmlElementById("summary").getTextContent();
assertThat(summary).isEqualTo("Spring Rocks");
String text = newMessagePage.getHtmlElementById("text").getTextContent();
assertThat(text).isEqualTo("In case you didn't know, Spring Rocks!");
```

<!-- tabs:start -->

#### ** English **

The preceding code improves on our [MockMvc test](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#spring-mvc-test-server-htmlunit-mock-mvc-test) in a number of ways. First, we no longer have to explicitly verify our form and then create a request that looks like the form. Instead, we request the form, fill it out, and submit it, thereby significantly reducing the overhead.
#### ** Chinese **

上面的代码在很多方面改进了我们的[MockMvc测试](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#spring-mvc-test-server-htmlunit-mock-mvc-test)。首先，我们不再需要显式验证我们的表单，然后创建一个看起来像表单的请求。相反，我们只需要请求表单，填写表单，然后提交，从而大大减少了开销。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Another important factor is that [HtmlUnit uses the Mozilla Rhino engine](http://htmlunit.sourceforge.net/javascript.html) to evaluate JavaScript. This means that we can also test the behavior of JavaScript within our pages.
#### ** Chinese **

另一个重要因素是，[HtmlUnit使用Mozilla Rhino引擎](http://htmlunit.sourceforge.net/javascript.html)来评估JavaScript。这意味着我们也可以在页面中测试JavaScript的行为。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

See the [HtmlUnit documentation](http://htmlunit.sourceforge.net/gettingStarted.html) for additional information about using HtmlUnit.
#### ** Chinese **

有关使用HtmlUnit的更多信息，请参阅[HtmlUnit文档](http://htmlunit.sourceforge.net/gettingStarted.html)。
<!-- tabs:end -->


### **Advanced** **`MockMvcWebClientBuilder`** 

<!-- tabs:start -->

#### ** English **

In the examples so far, we have used `MockMvcWebClientBuilder` in the simplest way possible, by building a `WebClient` based on the `WebApplicationContext` loaded for us by the Spring TestContext Framework. This approach is repeated in the following example:
#### ** Chinese **

在迄今为止的例子中，我们以最简单的方式使用了`MockMvcWebClientBuilder`，即在Spring TestContext框架为我们加载的`WebApplicationContext`的基础上建立一个`WebClient`。这个方法在下面的例子中重复。
<!-- tabs:end -->


```java
WebClient webClient;

@BeforeEach
void setup(WebApplicationContext context) {
    webClient = MockMvcWebClientBuilder
            .webAppContextSetup(context)
            .build();
}
```

<!-- tabs:start -->

#### ** English **

We can also specify additional configuration options, as the following example shows:
#### ** Chinese **

我们还可以指定额外的配置选项，如下面的例子所示。
<!-- tabs:end -->


```java
WebClient webClient;

@BeforeEach
void setup() {
    webClient = MockMvcWebClientBuilder
        // demonstrates applying a MockMvcConfigurer (Spring Security)
        .webAppContextSetup(context, springSecurity())
        // for illustration only - defaults to ""
        .contextPath("")
        // By default MockMvc is used for localhost only;
        // the following will use MockMvc for example.com and example.org as well
        .useMockMvcForHosts("example.com","example.org")
        .build();
}
```

<!-- tabs:start -->

#### ** English **

As an alternative, we can perform the exact same setup by configuring the `MockMvc` instance separately and supplying it to the `MockMvcWebClientBuilder`, as follows:
#### ** Chinese **

作为替代方案，我们可以通过单独配置`MockMvc`实例并将其提供给`MockMvcWebClientBuilder`来执行完全相同的设置，如下所示。
<!-- tabs:end -->


```java
MockMvc mockMvc = MockMvcBuilders
        .webAppContextSetup(context)
        .apply(springSecurity())
        .build();

webClient = MockMvcWebClientBuilder
        .mockMvcSetup(mockMvc)
        // for illustration only - defaults to ""
        .contextPath("")
        // By default MockMvc is used for localhost only;
        // the following will use MockMvc for example.com and example.org as well
        .useMockMvcForHosts("example.com","example.org")
        .build();
```

<!-- tabs:start -->

#### ** English **

This is more verbose, but, by building the `WebClient` with a `MockMvc` instance, we have the full power of MockMvc at our fingertips.
#### ** Chinese **

这样做比较啰嗦，但是，通过用`WebClient`和`MockMvc`实例来构建`WebClient`，我们就可以拥有MockMvc的全部功能。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

For additional information on creating a `MockMvc` instance, see [Setup Choices](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#spring-mvc-test-server-setup-options).
#### ** Chinese **

有关创建`MockMvc`实例的其他信息，请参阅[设置选择](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#spring-mvc-test-server-setup-options)。
<!-- tabs:end -->


### **MockMvc and WebDriver** 

<!-- tabs:start -->

#### ** English **

In the previous sections, we have seen how to use MockMvc in conjunction with the raw HtmlUnit APIs. In this section, we use additional abstractions within the Selenium [WebDriver](https://docs.seleniumhq.org/projects/webdriver/) to make things even easier.
#### ** Chinese **

在前面的章节中，我们已经看到了如何将MockMvc与原始HtmlUnit API结合使用。在本节中，我们在Selenium[WebDriver](https://docs.seleniumhq.org/projects/webdriver/)中使用了额外的抽象，使事情变得更加简单。
<!-- tabs:end -->


### **Why WebDriver and MockMvc?** 

<!-- tabs:start -->

#### ** English **

We can already use HtmlUnit and MockMvc, so why would we want to use WebDriver? The Selenium WebDriver provides a very elegant API that lets us easily organize our code. To better show how it works, we explore an example in this section.
#### ** Chinese **

我们已经可以使用HtmlUnit和MockMvc，为什么还要使用WebDriver呢？Selenium WebDriver提供了一个非常优雅的API，可以让我们轻松地组织我们的代码。为了更好地展示它的工作原理，我们在本节中探讨了一个例子。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Despite being a part of [Selenium](https://docs.seleniumhq.org/), WebDriver does not require a Selenium Server to run your tests.
#### ** Chinese **

尽管是[Selenium](https://docs.seleniumhq.org/)的一部分，但WebDriver不需要Selenium服务器来运行测试。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Suppose we need to ensure that a message is created properly. The tests involve finding the HTML form input elements, filling them out, and making various assertions.
#### ** Chinese **

假设我们需要确保一个消息被正确创建。测试的内容包括找到HTML表单的输入元素，填写这些元素，并进行各种断言。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

This approach results in numerous separate tests because we want to test error conditions as well. For example, we want to ensure that we get an error if we fill out only part of the form. If we fill out the entire form, the newly created message should be displayed afterwards.
#### ** Chinese **

这种方法会产生无数个单独的测试，因为我们也想测试错误条件。例如，我们想确保如果我们只填写表单的一部分，就会得到一个错误。如果我们填写了整个表单，那么新创建的消息应该在之后显示。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

If one of the fields were named “summary”, we might have something that resembles the following repeated in multiple places within our tests:
#### ** Chinese **

如果将其中一个字段命名为 "summary"，我们可能会在测试中的多个地方出现类似于下面的内容。
<!-- tabs:end -->


```java
HtmlTextInput summaryInput = currentPage.getHtmlElementById("summary");
summaryInput.setValueAttribute(summary);
```

<!-- tabs:start -->

#### ** English **

So what happens if we change the `id` to `smmry`? Doing so would force us to update all of our tests to incorporate this change. This violates the DRY principle, so we should ideally extract this code into its own method, as follows:
#### ** Chinese **

那么，如果我们将`id`改为`smmry`会发生什么？这样做会迫使我们更新所有的测试以纳入这个变化。这违反了DRY原则，所以我们最好将这段代码提取到自己的方法中，如下所示。
<!-- tabs:end -->


```java
public HtmlPage createMessage(HtmlPage currentPage, String summary, String text) {
    setSummary(currentPage, summary);
    // ...
}

public void setSummary(HtmlPage currentPage, String summary) {
    HtmlTextInput summaryInput = currentPage.getHtmlElementById("summary");
    summaryInput.setValueAttribute(summary);
}
```

<!-- tabs:start -->

#### ** English **

Doing so ensures that we do not have to update all of our tests if we change the UI.
#### ** Chinese **

这样做可以确保我们在改变UI的时候不需要更新所有的测试。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

We might even take this a step further and place this logic within an `Object` that represents the `HtmlPage` we are currently on, as the following example shows:
#### ** Chinese **

我们甚至可以更进一步，将这个逻辑放在一个`Object`中，它代表了我们当前所处的`HtmlPage`，如下图所示。
<!-- tabs:end -->


```java
public class CreateMessagePage {

    final HtmlPage currentPage;

    final HtmlTextInput summaryInput;

    final HtmlSubmitInput submit;

    public CreateMessagePage(HtmlPage currentPage) {
        this.currentPage = currentPage;
        this.summaryInput = currentPage.getHtmlElementById("summary");
        this.submit = currentPage.getHtmlElementById("submit");
    }

    public <T> T createMessage(String summary, String text) throws Exception {
        setSummary(summary);

        HtmlPage result = submit.click();
        boolean error = CreateMessagePage.at(result);

        return (T) (error ? new CreateMessagePage(result) : new ViewMessagePage(result));
    }

    public void setSummary(String summary) throws Exception {
        summaryInput.setValueAttribute(summary);
    }

    public static boolean at(HtmlPage page) {
        return "Create Message".equals(page.getTitleText());
    }
}
```

<!-- tabs:start -->

#### ** English **

Formerly, this pattern was known as the [Page Object Pattern](https://github.com/SeleniumHQ/selenium/wiki/PageObjects). While we can certainly do this with HtmlUnit, WebDriver provides some tools that we explore in the following sections to make this pattern much easier to implement.
#### ** Chinese **

以前，这种模式被称为[页面对象模式](https://github.com/SeleniumHQ/selenium/wiki/PageObjects)。虽然我们当然可以用HtmlUnit来实现，但WebDriver提供了一些工具，我们将在下面的章节中探讨，使这个模式更容易实现。
<!-- tabs:end -->


### **MockMvc and WebDriver Setup** 

<!-- tabs:start -->

#### ** English **

To use Selenium WebDriver with the Spring MVC Test framework, make sure that your project includes a test dependency on `org.seleniumhq.selenium:selenium-htmlunit-driver`.
#### ** Chinese **

要在Spring MVC测试框架中使用Selenium WebDriver，请确保你的项目中包含一个测试依赖`org.seleniumhq.selenium:selenium-htmlunit-driver`。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

We can easily create a Selenium WebDriver that integrates with MockMvc by using the `MockMvcHtmlUnitDriverBuilder` as the following example shows:
#### ** Chinese **

我们可以通过使用`MockMvcHtmlUnitDriverBuilder`创建一个与MockMvc集成的Selenium WebDriver，如下图所示。
<!-- tabs:end -->


```java
WebDriver driver;

@BeforeEach
void setup(WebApplicationContext context) {
    driver = MockMvcHtmlUnitDriverBuilder
            .webAppContextSetup(context)
            .build();
}
```

<!-- tabs:start -->

#### ** English **

This is a simple example of using `MockMvcHtmlUnitDriverBuilder`. For more advanced usage, see [Advanced ](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#spring-mvc-test-server-htmlunit-webdriver-advanced-builder)[`MockMvcHtmlUnitDriverBuilder`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#spring-mvc-test-server-htmlunit-webdriver-advanced-builder).
#### ** Chinese **

这是一个使用`MockMvcHtmlUnitDriverBuilder`的简单例子。更高级的使用方法，请参阅 [Advanced ](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#spring-mvc-test-server-htmlunit-webdriver-advanced-builder)[`MockMvcHtmlUnitDriverBuilder`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#spring-mvc-test-server-htmlunit-webdriver-advanced-builder)。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The preceding example ensures that any URL that references `localhost` as the server is directed to our `MockMvc` instance without the need for a real HTTP connection. Any other URL is requested by using a network connection, as normal. This lets us easily test the use of CDNs.
#### ** Chinese **

上面的例子确保任何引用`localhost`作为服务器的URL都会被引导到我们的`MockMvc`实例，而不需要真正的HTTP连接。任何其他的URL都是通过使用网络连接请求的，就像正常情况下一样。这让我们可以轻松地测试CDN的使用情况。
<!-- tabs:end -->


### **MockMvc and WebDriver Usage** 

<!-- tabs:start -->

#### ** English **

Now we can use WebDriver as we normally would but without the need to deploy our application to a Servlet container. For example, we can request the view to create a message with the following:
#### ** Chinese **

现在我们可以像平常一样使用 WebDriver，但不需要将我们的应用程序部署到 Servlet 容器中。例如，我们可以请求视图创建一个消息，其内容如下。
<!-- tabs:end -->


```java
CreateMessagePage page = CreateMessagePage.to(driver);
```

<!-- tabs:start -->

#### ** English **

We can then fill out the form and submit it to create a message, as follows:
#### ** Chinese **

然后，我们可以将表格填写好后，提交到表单中，建立一个信息，如下图所示。
<!-- tabs:end -->


```java
ViewMessagePage viewMessagePage =
        page.createMessage(ViewMessagePage.class, expectedSummary, expectedText);
```

<!-- tabs:start -->

#### ** English **

This improves on the design of our [HtmlUnit test](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#spring-mvc-test-server-htmlunit-mah-usage) by leveraging the Page Object Pattern. As we mentioned in [Why WebDriver and MockMvc?](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#spring-mvc-test-server-htmlunit-webdriver-why), we can use the Page Object Pattern with HtmlUnit, but it is much easier with WebDriver. Consider the following `CreateMessagePage` implementation:
#### ** Chinese **

这是对我们的[HtmlUnit测试](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#spring-mvc-test-server-htmlunit-mah-usage)的设计进行了改进，利用了页面对象模式。正如我们在[Why WebDriver和MockMvc?](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#spring-mvc-test-server-htmlunit-webdriver-why)中提到的那样，我们可以使用HtmlUnit的Page Object Pattern，但使用WebDriver就容易多了。考虑下面的`CreateMessagePage`实现。
<!-- tabs:end -->


```java
public class CreateMessagePage
        extends AbstractPage { (1)

    (2)
    private WebElement summary;
    private WebElement text;

    (3)
    @FindBy(css = "input[type=submit]")
    private WebElement submit;

    public CreateMessagePage(WebDriver driver) {
        super(driver);
    }

    public <T> T createMessage(Class<T> resultPage, String summary, String details) {
        this.summary.sendKeys(summary);
        this.text.sendKeys(details);
        this.submit.click();
        return PageFactory.initElements(driver, resultPage);
    }

    public static CreateMessagePage to(WebDriver driver) {
        driver.get("http://localhost:9990/mail/messages/form");
        return PageFactory.initElements(driver, CreateMessagePage.class);
    }
}
```

<!-- tabs:start -->

#### ** English **

Finally, we can verify that a new message was created successfully. The following assertions use the [AssertJ](https://joel-costigliola.github.io/assertj/) assertion library:
#### ** Chinese **

最后，我们可以验证一个新消息的创建是否成功。下面的断言使用了[AssertJ](https://joel-costigliola.github.io/assertj/)断言库。
<!-- tabs:end -->


```java
assertThat(viewMessagePage.getMessage()).isEqualTo(expectedMessage);
assertThat(viewMessagePage.getSuccess()).isEqualTo("Successfully created a new message");
```

<!-- tabs:start -->

#### ** English **

We can see that our `ViewMessagePage` lets us interact with our custom domain model. For example, it exposes a method that returns a `Message` object:
#### ** Chinese **

我们可以看到，我们的`ViewMessagePage`可以让我们与自定义域模型进行交互。例如，它公开了一个返回`Message`对象的方法。
<!-- tabs:end -->


```java
public Message getMessage() throws ParseException {
    Message message = new Message();
    message.setId(getId());
    message.setCreated(getCreated());
    message.setSummary(getSummary());
    message.setText(getText());
    return message;
}
```

<!-- tabs:start -->

#### ** English **

We can then use the rich domain objects in our assertions.
#### ** Chinese **

然后，我们可以在断言中使用丰富的领域对象。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Lastly, we must not forget to close the `WebDriver` instance when the test is complete, as follows:
#### ** Chinese **

最后，当测试完成后，我们不要忘记关闭`WebDriver`实例，如下所示。
<!-- tabs:end -->


```java
@AfterEach
void destroy() {
    if (driver != null) {
        driver.close();
    }
}
```

<!-- tabs:start -->

#### ** English **

For additional information on using WebDriver, see the Selenium [WebDriver documentation](https://github.com/SeleniumHQ/selenium/wiki/Getting-Started).
#### ** Chinese **

有关使用WebDriver的更多信息，请参阅Selenium [WebDriver文档](https://github.com/SeleniumHQ/selenium/wiki/Getting-Started)。
<!-- tabs:end -->


### **Advanced** **`MockMvcHtmlUnitDriverBuilder`** 

<!-- tabs:start -->

#### ** English **

In the examples so far, we have used `MockMvcHtmlUnitDriverBuilder` in the simplest way possible, by building a `WebDriver` based on the `WebApplicationContext` loaded for us by the Spring TestContext Framework. This approach is repeated here, as follows:
#### ** Chinese **

在迄今为止的例子中，我们用最简单的方法使用了`MockMvcHtmlUnitDriverBuilder`，即在Spring TestContext框架为我们加载的`WebApplicationContext`的基础上建立一个`WebDriver`。这里重复一下这个方法，如下所示。
<!-- tabs:end -->


```java
WebDriver driver;

@BeforeEach
void setup(WebApplicationContext context) {
    driver = MockMvcHtmlUnitDriverBuilder
            .webAppContextSetup(context)
            .build();
}
```

<!-- tabs:start -->

#### ** English **

We can also specify additional configuration options, as follows:
#### ** Chinese **

我们还可以指定额外的配置选项，具体如下。
<!-- tabs:end -->


```java
WebDriver driver;

@BeforeEach
void setup() {
    driver = MockMvcHtmlUnitDriverBuilder
            // demonstrates applying a MockMvcConfigurer (Spring Security)
            .webAppContextSetup(context, springSecurity())
            // for illustration only - defaults to ""
            .contextPath("")
            // By default MockMvc is used for localhost only;
            // the following will use MockMvc for example.com and example.org as well
            .useMockMvcForHosts("example.com","example.org")
            .build();
}
```

<!-- tabs:start -->

#### ** English **

As an alternative, we can perform the exact same setup by configuring the `MockMvc` instance separately and supplying it to the `MockMvcHtmlUnitDriverBuilder`, as follows:
#### ** Chinese **

作为替代方案，我们可以通过单独配置`MockMvc`实例，并将其提供给`MockMvcHtmlUnitDriverBuilder`，如下所示，执行完全相同的设置。
<!-- tabs:end -->


```java
MockMvc mockMvc = MockMvcBuilders
        .webAppContextSetup(context)
        .apply(springSecurity())
        .build();

driver = MockMvcHtmlUnitDriverBuilder
        .mockMvcSetup(mockMvc)
        // for illustration only - defaults to ""
        .contextPath("")
        // By default MockMvc is used for localhost only;
        // the following will use MockMvc for example.com and example.org as well
        .useMockMvcForHosts("example.com","example.org")
        .build();
```

<!-- tabs:start -->

#### ** English **

This is more verbose, but, by building the `WebDriver` with a `MockMvc` instance, we have the full power of MockMvc at our fingertips.
#### ** Chinese **

这样做比较啰嗦，但是，通过用`WebDriver`和`MockMvc`实例来构建`WebDriver`，我们就可以拥有MockMvc的全部功能。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

For additional information on creating a `MockMvc` instance, see [Setup Choices](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#spring-mvc-test-server-setup-options).
#### ** Chinese **

有关创建`MockMvc`实例的其他信息，请参阅[设置选择](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#spring-mvc-test-server-setup-options)。
<!-- tabs:end -->


### **MockMvc and Geb** 

<!-- tabs:start -->

#### ** English **

In the previous section, we saw how to use MockMvc with WebDriver. In this section, we use [Geb](http://www.gebish.org/) to make our tests even Groovy-er.
#### ** Chinese **

在上一节中，我们看到了如何使用MockMvc与WebDriver。在本节中，我们使用[Geb](http://www.gebish.org/)让我们的测试更加Groovy-er。
<!-- tabs:end -->


### **Why Geb and MockMvc?** 

<!-- tabs:start -->

#### ** English **

Geb is backed by WebDriver, so it offers many of the [same benefits](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#spring-mvc-test-server-htmlunit-webdriver-why) that we get from WebDriver. However, Geb makes things even easier by taking care of some of the boilerplate code for us.
#### ** Chinese **

Geb得到了WebDriver的支持，所以它提供了许多我们从WebDriver获得的[同样的好处](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#spring-mvc-test-server-htmlunit-webdriver-why)。但是，Geb为我们提供了一些模板代码，让我们的工作更加轻松。
<!-- tabs:end -->


### **MockMvc and Geb Setup** 

<!-- tabs:start -->

#### ** English **

We can easily initialize a Geb `Browser` with a Selenium WebDriver that uses MockMvc, as follows:
#### ** Chinese **

我们可以用一个使用MockMvc的Selenium WebDriver来初始化一个Geb`浏览器`，方法如下。
<!-- tabs:end -->


```java
def setup() {
    browser.driver = MockMvcHtmlUnitDriverBuilder
        .webAppContextSetup(context)
        .build()
}
```

<!-- tabs:start -->

#### ** English **

This is a simple example of using `MockMvcHtmlUnitDriverBuilder`. For more advanced usage, see [Advanced ](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#spring-mvc-test-server-htmlunit-webdriver-advanced-builder)[`MockMvcHtmlUnitDriverBuilder`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#spring-mvc-test-server-htmlunit-webdriver-advanced-builder).
#### ** Chinese **

这是一个使用`MockMvcHtmlUnitDriverBuilder`的简单例子。更高级的使用方法，请参阅 [Advanced ](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#spring-mvc-test-server-htmlunit-webdriver-advanced-builder)[`MockMvcHtmlUnitDriverBuilder`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#spring-mvc-test-server-htmlunit-webdriver-advanced-builder)。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

This ensures that any URL referencing `localhost` as the server is directed to our `MockMvc` instance without the need for a real HTTP connection. Any other URL is requested by using a network connection as normal. This lets us easily test the use of CDNs.
#### ** Chinese **

这确保了任何引用`localhost`作为服务器的URL都会被指向我们的`MockMvc`实例，而不需要真正的HTTP连接。任何其他的URL都是通过使用网络连接来请求的。这让我们可以轻松地测试CDN的使用情况。
<!-- tabs:end -->


### **MockMvc and Geb Usage** 

<!-- tabs:start -->

#### ** English **

Now we can use Geb as we normally would but without the need to deploy our application to a Servlet container. For example, we can request the view to create a message with the following:
#### ** Chinese **

现在我们可以像平常一样使用Geb，但不需要将我们的应用程序部署到Servlet容器中。例如，我们可以请求视图创建一个消息，内容如下。
<!-- tabs:end -->


```java
to CreateMessagePage
```

<!-- tabs:start -->

#### ** English **

We can then fill out the form and submit it to create a message, as follows:
#### ** Chinese **

然后，我们可以将表格填写好后，提交到表单中，建立一个信息，如下图所示。
<!-- tabs:end -->


```java
when:
form.summary = expectedSummary
form.text = expectedMessage
submit.click(ViewMessagePage)
```

<!-- tabs:start -->

#### ** English **

Any unrecognized method calls or property accesses or references that are not found are forwarded to the current page object. This removes a lot of the boilerplate code we needed when using WebDriver directly.
#### ** Chinese **

任何未被识别的方法调用或属性访问或引用都会被转发到当前页面对象。这就省去了我们直接使用WebDriver时所需要的大量模板代码。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

As with direct WebDriver usage, this improves on the design of our [HtmlUnit test](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#spring-mvc-test-server-htmlunit-mah-usage) by using the Page Object Pattern. As mentioned previously, we can use the Page Object Pattern with HtmlUnit and WebDriver, but it is even easier with Geb. Consider our new Groovy-based `CreateMessagePage` implementation:
#### ** Chinese **

与直接使用WebDriver一样，这也是在我们的[HtmlUnit测试](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#spring-mvc-test-server-htmlunit-mah-usage)的基础上，通过使用Page Object Pattern来改进我们的设计。如前所述，我们可以用HtmlUnit和WebDriver来使用Page Object Pattern，但用Geb就更容易了。考虑一下我们新的基于Groovy的`CreateMessagePage`实现。
<!-- tabs:end -->


```java
class CreateMessagePage extends Page {
    static url = 'messages/form'
    static at = { assert title == 'Messages : Create'; true }
    static content =  {
        submit { $('input[type=submit]') }
        form { $('form') }
        errors(required:false) { $('label.error, .alert-error')?.text() }
    }
}
```

<!-- tabs:start -->

#### ** English **

Our `CreateMessagePage` extends `Page`. We do not go over the details of `Page`, but, in summary, it contains common functionality for all of our pages. We define a URL in which this page can be found. This lets us navigate to the page, as follows:
#### ** Chinese **

我们的`CreateMessagePage`扩展了`Page`。我们不再赘述`Page`的细节，但总的来说，它包含了我们所有页面的通用功能。我们定义一个URL，在其中可以找到这个页面。这样我们就可以导航到这个页面，如下所示。
<!-- tabs:end -->


```java
to CreateMessagePage
```

<!-- tabs:start -->

#### ** English **

We also have an `at` closure that determines if we are at the specified page. It should return `true` if we are on the correct page. This is why we can assert that we are on the correct page, as follows:
#### ** Chinese **

我们还有一个`at`闭包，用于确定我们是否在指定的页面上。如果我们在正确的页面上，它应该返回`true`。这就是为什么我们可以断言我们在正确的页面上，如下所示。
<!-- tabs:end -->


```java
then:
at CreateMessagePage
errors.contains('This field is required.')
```

<!-- tabs:start -->

#### ** English **

We use an assertion in the closure so that we can determine where things went wrong if we were at the wrong page.
#### ** Chinese **

我们在闭卷中使用了一个断言，这样我们就可以判断出如果我们在错误的页面上，事情到底出了什么问题。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Next, we create a `content` closure that specifies all the areas of interest within the page. We can use a [jQuery-ish Navigator API](http://www.gebish.org/manual/current/#the-jquery-ish-navigator-api) to select the content in which we are interested.
#### ** Chinese **

接下来，我们创建一个`content`闭包，指定页面内所有感兴趣的区域。我们可以使用一个[jQuery-ish Navigator API](http://www.gebish.org/manual/current/#the-jquery-ish-navigator-api)来选择我们感兴趣的内容。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Finally, we can verify that a new message was created successfully, as follows:
#### ** Chinese **

最后，我们可以验证一个新消息的创建是否成功，具体如下。
<!-- tabs:end -->


```
then:
at ViewMessagePage
success == 'Successfully created a new message'
id
date
summary == expectedSummary
message == expectedMessage
```

<!-- tabs:start -->

#### ** English **

For further details on how to get the most out of Geb, see [The Book of Geb](http://www.gebish.org/manual/current/) user’s manual.
#### ** Chinese **

有关如何充分利用Geb的详细信息，请参阅[The Book of Geb](http://www.gebish.org/manual/current/)用户手册。
<!-- tabs:end -->


### **3.6.3. Client-Side REST Tests** 

<!-- tabs:start -->

#### ** English **

You can use client-side tests to test code that internally uses the `RestTemplate`. The idea is to declare expected requests and to provide “stub” responses so that you can focus on testing the code in isolation (that is, without running a server). The following example shows how to do so:
#### ** Chinese **

你可以使用客户端测试来测试内部使用`RestTemplate`的代码。这样做的目的是声明预期的请求，并提供 "存根 "响应，这样你就可以专注于独立测试代码（即不运行服务器）。下面的例子显示了如何做到这一点。
<!-- tabs:end -->


```java
RestTemplate restTemplate = new RestTemplate();

MockRestServiceServer mockServer = MockRestServiceServer.bindTo(restTemplate).build();
mockServer.expect(requestTo("/greeting")).andRespond(withSuccess());

// Test code that uses the above RestTemplate ...

mockServer.verify();
```

<!-- tabs:start -->

#### ** English **

In the preceding example, `MockRestServiceServer` (the central class for client-side REST tests) configures the `RestTemplate` with a custom `ClientHttpRequestFactory` that asserts actual requests against expectations and returns “stub” responses. In this case, we expect a request to `/greeting` and want to return a 200 response with `text/plain` content. We can define additional expected requests and stub responses as needed. When we define expected requests and stub responses, the `RestTemplate` can be used in client-side code as usual. At the end of testing, `mockServer.verify()` can be used to verify that all expectations have been satisfied.
#### ** Chinese **

在前面的例子中，`MockRestServiceServerServer`（客户端REST测试的中心类）配置了`RestTemplate`，并使用自定义的`ClientHttpRequestFactory`来配置`ClientHttpRequestFactory`，它根据期望值来断言实际请求，并返回 "存根 "响应。在本例中，我们期望一个向`/greeting`的请求，并希望返回一个带有`text/plain`内容的200响应。我们可以根据需要定义额外的预期请求和存根响应。当我们定义预期请求和存根响应时，`RestTemplate`可以像往常一样在客户端代码中使用。在测试结束时，可以使用 `mockServer.verify()`来验证所有的期望值是否被满足。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

By default, requests are expected in the order in which expectations were declared. You can set the `ignoreExpectOrder` option when building the server, in which case all expectations are checked (in order) to find a match for a given request. That means requests are allowed to come in any order. The following example uses `ignoreExpectOrder`:
#### ** Chinese **

默认情况下，请求是按照期望值声明的顺序被期望。您可以在构建服务器时设置`ignoreExpectOrder`选项，在这种情况下，所有的期望值都会被检查（按顺序），以便为给定的请求找到匹配的请求。这意味着允许请求以任何顺序出现。下面的例子使用了`ignoreExpectOrder`选项。
<!-- tabs:end -->


```java
server = MockRestServiceServer.bindTo(restTemplate).ignoreExpectOrder(true).build();
```

<!-- tabs:start -->

#### ** English **

Even with unordered requests by default, each request is allowed to execute once only. The `expect` method provides an overloaded variant that accepts an `ExpectedCount` argument that specifies a count range (for example, `once`, `manyTimes`, `max`, `min`, `between`, and so on). The following example uses `times`:
#### ** Chinese **

即使在默认情况下使用无序请求，每个请求也只允许执行一次。`expect`方法提供了一个重载变体，它接受一个`ExpectedCount`参数，该参数指定了一个计数范围（例如，`once`、`manyTimes`、`max`、`min`、`between`等）。下面的例子使用了`times`。
<!-- tabs:end -->


```java
RestTemplate restTemplate = new RestTemplate();

MockRestServiceServer mockServer = MockRestServiceServer.bindTo(restTemplate).build();
mockServer.expect(times(2), requestTo("/something")).andRespond(withSuccess());
mockServer.expect(times(3), requestTo("/somewhere")).andRespond(withSuccess());

// ...

mockServer.verify();
```

<!-- tabs:start -->

#### ** English **

Note that, when `ignoreExpectOrder` is not set (the default), and, therefore, requests are expected in order of declaration, then that order applies only to the first of any expected request. For example if "/something" is expected two times followed by "/somewhere" three times, then there should be a request to "/something" before there is a request to "/somewhere", but, aside from that subsequent "/something" and "/somewhere", requests can come at any time.
#### ** Chinese **

注意，当`ignoreExpectOrder`没有被设置（默认情况），因此，请求是按照声明的顺序来预期的，那么这个顺序只适用于任何预期请求中的第一个。例如，如果"/something "被预期了两次，然后是三次的"/somewhere"，那么在"/somewhere "之前应该有一个对"/something "的请求，但是，除了之后的"/something "和"/somewhere "之外，请求可以在任何时候出现。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

As an alternative to all of the above, the client-side test support also provides a `ClientHttpRequestFactory` implementation that you can configure into a `RestTemplate` to bind it to a `MockMvc` instance. That allows processing requests using actual server-side logic but without running a server. The following example shows how to do so:
#### ** Chinese **

作为上述所有的替代方案，客户端测试支持还提供了一个`ClientHttpRequestFactory`实现，您可以将其配置到一个`RestTemplate`中，将其绑定到一个`MockMvc`实例。这样就可以使用实际的服务器端逻辑来处理请求，但不需要运行服务器。下面的例子显示了如何做到这一点。
<!-- tabs:end -->


```java
MockMvc mockMvc = MockMvcBuilders.webAppContextSetup(this.wac).build();
this.restTemplate = new RestTemplate(new MockMvcClientHttpRequestFactory(mockMvc));

// Test code that uses the above RestTemplate ...
```

### **Static Imports** 

<!-- tabs:start -->

#### ** English **

As with server-side tests, the fluent API for client-side tests requires a few static imports. Those are easy to find by searching for `MockRest*`. Eclipse users should add `MockRestRequestMatchers.*` and `MockRestResponseCreators.*` as “favorite static members” in the Eclipse preferences under Java → Editor → Content Assist → Favorites. That allows using content assist after typing the first character of the static method name. Other IDEs (such IntelliJ) may not require any additional configuration. Check for the support for code completion on static members.
#### ** Chinese **

与服务器端测试一样，客户端测试的流畅API需要一些静态导入。通过搜索`MockRest*`很容易找到这些。Eclipse 用户应该在 Eclipse 首选项中的 Java → 编辑器 → 内容辅助 → 收藏夹下的 Eclipse 首选项中添加 `MockRestRequestMatchers.*` 和 `MockRestResponseCreators.*` 作为 "最喜欢的静态成员"。这样可以在输入静态方法名称的第一个字符后使用内容辅助。其他IDE（如IntelliJ）可能不需要任何额外的配置。请检查是否支持静态成员上的代码完成。
<!-- tabs:end -->


### **Further Examples of Client-side REST Tests** 

<!-- tabs:start -->

#### ** English **

Spring MVC Test’s own tests include [example tests](https://github.com/spring-projects/spring-framework/tree/master/spring-test/src/test/java/org/springframework/test/web/client/samples) of client-side REST tests.
#### ** Chinese **

Spring MVC测试自己的测试包括客户端REST测试的[示例测试](https://github.com/spring-projects/spring-framework/tree/master/spring-test/src/test/java/org/springframework/test/web/client/samples)。
<!-- tabs:end -->



[下一章](Spring-Framework-5.2.6.RELEASE/Testing/3.7.%20WebTestClient.md)


[回目录](Spring-Framework-5.2.6.RELEASE/summary.md)

[回首页](/README)
