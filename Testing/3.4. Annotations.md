# 3.4. Annotations

<!-- tabs:start -->

#### ** English **

This section covers annotations that you can use when you test Spring applications. It includes the following topics:
#### ** Chinese **

本节涵盖了您在测试Spring应用程序时可以使用的注释。它包括以下主题。
<!-- tabs:end -->


### **3.4.1. Spring Testing Annotations** 

<!-- tabs:start -->

#### ** English **

The Spring Framework provides the following set of Spring-specific annotations that you can use in your unit and integration tests in conjunction with the TestContext framework. See the corresponding javadoc for further information, including default attribute values, attribute aliases, and other details.
#### ** Chinese **

Spring框架提供了以下一组特定于Spring的注释，你可以在单元测试和集成测试中与TestContext框架结合使用。有关更多信息，包括默认属性值、属性别名和其他细节，请参阅相应的javadoc。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Spring’s testing annotations include the following:
#### ** Chinese **

Spring的测试注解包括以下内容。
<!-- tabs:end -->


### **`@BootstrapWith`** 

<!-- tabs:start -->

#### ** English **

`@BootstrapWith` is a class-level annotation that you can use to configure how the Spring TestContext Framework is bootstrapped. Specifically, you can use `@BootstrapWith` to specify a custom `TestContextBootstrapper`. See the section on [bootstrapping the TestContext framework](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-bootstrapping) for further details.
#### ** Chinese **

`@BootstrapWith`是一个类级注释，你可以用来配置Spring TestContext框架的引导方式。具体来说，你可以使用 `@BootstrapWith`来指定一个自定义的`TestContextBootstrapper`。更多详情，请参阅[引导TestContext框架](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-bootstrapping)。
<!-- tabs:end -->


### **`@ContextConfiguration`** 

<!-- tabs:start -->

#### ** English **

`@ContextConfiguration` defines class-level metadata that is used to determine how to load and configure an `ApplicationContext` for integration tests. Specifically, `@ContextConfiguration` declares the application context resource `locations` or the component `classes` used to load the context.
#### ** Chinese **

`@ContextConfiguration`定义了类级元数据，用于确定如何加载和配置`ApplicationContext`用于集成测试。具体来说，`@ContextConfiguration`声明了应用上下文资源`locations`或用于加载上下文的组件`classes`。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Resource locations are typically XML configuration files or Groovy scripts located in the classpath, while component classes are typically `@Configuration` classes. However, resource locations can also refer to files and scripts in the file system, and component classes can be `@Component` classes, `@Service` classes, and so on. See [Component Classes](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-ctx-management-javaconfig-component-classes) for further details.
#### ** Chinese **

资源位置通常是位于classpath中的XML配置文件或Groovy脚本，而组件类通常是`@Configuration`类。但是，资源位置也可以指文件系统中的文件和脚本，而组件类可以是`@Component`类、`@Service`类等。详情请参见[组件类](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-ctx-management-javaconfig-component-classes)。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following example shows a `@ContextConfiguration` annotation that refers to an XML file:
#### ** Chinese **

下面的例子显示了一个`@ContextConfiguration`注释，它引用了一个XML文件。
<!-- tabs:end -->


```java
@ContextConfiguration("/test-config.xml") (1)
class XmlApplicationContextTests {
    // class body...
}

//(1) Referring to an XML file.
```

<!-- tabs:start -->

#### ** English **

The following example shows a `@ContextConfiguration` annotation that refers to a class:
#### ** Chinese **

下面的例子显示了一个`@ContextConfiguration`注释，该注释引用了一个类。
<!-- tabs:end -->


```java
@ContextConfiguration(classes = TestConfig.class) (1)
class ConfigClassApplicationContextTests {
    // class body...
}

//(1) Referring to a class.
```

<!-- tabs:start -->

#### ** English **

As an alternative or in addition to declaring resource locations or component classes, you can use `@ContextConfiguration` to declare `ApplicationContextInitializer` classes. The following example shows such a case:
#### ** Chinese **

作为声明资源位置或组件类的另一种选择或补充，你可以使用`@ContextConfiguration`来声明`ApplicationContextInitializer`类。下面的例子显示了这样的情况。
<!-- tabs:end -->


```java
@ContextConfiguration(initializers = CustomContextIntializer.class) (1)
class ContextInitializerTests {
    // class body...
}
```

<!-- tabs:start -->

#### ** English **

You can optionally use `@ContextConfiguration` to declare the `ContextLoader` strategy as well. Note, however, that you typically do not need to explicitly configure the loader, since the default loader supports `initializers` and either resource `locations` or component `classes`.
#### ** Chinese **

您可以选择使用 `@ContextConfiguration`来声明`ContextLoader`策略。但请注意，您通常不需要显式配置加载器，因为默认的加载器支持`initializers`和资源`locations`或组件`classes`。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following example uses both a location and a loader:
#### ** Chinese **

下面的例子同时使用了位置和加载器。
<!-- tabs:end -->


```java
@ContextConfiguration(locations = "/test-context.xml", loader = CustomContextLoader.class) (1)
class CustomLoaderXmlApplicationContextTests {
    // class body...
}

//(1) Configuring both a location and a custom loader.
```

<!-- tabs:start -->

#### ** English **

`@ContextConfiguration` provides support for inheriting resource locations or configuration classes as well as context initializers that are declared by superclasses.
#### ** Chinese **

`@ContextConfiguration`提供了对继承资源位置或配置类以及超类声明的上下文初始化器的支持。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

See [Context Management](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-ctx-management) and the `@ContextConfiguration` javadocs for further details.
#### ** Chinese **

详情请参见[上下文管理](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-ctx-management)和`@ContextConfiguration` javadocs。
<!-- tabs:end -->


### **`@WebAppConfiguration`** 

<!-- tabs:start -->

#### ** English **

`@WebAppConfiguration` is a class-level annotation that you can use to declare that the `ApplicationContext` loaded for an integration test should be a `WebApplicationContext`. The mere presence of `@WebAppConfiguration` on a test class ensures that a `WebApplicationContext` is loaded for the test, using the default value of `"file:src/main/webapp"` for the path to the root of the web application (that is, the resource base path). The resource base path is used behind the scenes to create a `MockServletContext`, which serves as the `ServletContext` for the test’s `WebApplicationContext`.
#### ** Chinese **

`@WebAppConfiguration`是一个类级注释，可以用来声明集成测试中加载的`ApplicationContext`应该是一个`WebApplicationContext`。仅仅在测试类中出现`@WebAppConfiguration`就能确保为测试加载一个`WebApplicationContext`，使用默认值`"file:src/main/webapp"`作为Web应用程序根目录（即资源基础路径）。该资源基础路径在后台用于创建一个`MockServletContext`，作为测试的`WebApplicationContext`的`ServletContext`。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following example shows how to use the `@WebAppConfiguration` annotation:
#### ** Chinese **

下面的示例显示了如何使用`@WebAppConfiguration`注释。
<!-- tabs:end -->


```java
@ContextConfiguration
@WebAppConfiguration (1)
class WebAppTests {
    // class body...
}
```

<!-- tabs:start -->

#### ** English **

To override the default, you can specify a different base resource path by using the implicit `value` attribute. Both `classpath:` and `file:` resource prefixes are supported. If no resource prefix is supplied, the path is assumed to be a file system resource. The following example shows how to specify a classpath resource:
#### ** Chinese **

要覆盖默认值，可以通过使用隐式 `value` 属性指定不同的基本资源路径。`classpath:` 和 `file:` 资源前缀都支持。如果没有提供资源前缀，则认为该路径是一个文件系统资源。下面的例子显示了如何指定一个classpath资源。
<!-- tabs:end -->


```java
@ContextConfiguration
@WebAppConfiguration("classpath:test-web-resources") (1)
class WebAppTests {
    // class body...
}

//(1) Specifying a classpath resource.
```

<!-- tabs:start -->

#### ** English **

Note that `@WebAppConfiguration` must be used in conjunction with `@ContextConfiguration`, either within a single test class or within a test class hierarchy. See the [`@WebAppConfiguration`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/test/context/web/WebAppConfiguration.html) javadoc for further details.
#### ** Chinese **

请注意，`@WebAppConfiguration`必须与`@ContextConfiguration`一起使用，可以在单个测试类中使用，也可以在测试类层次结构中使用。更多详情，请参阅 [`@WebAppConfiguration`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/test/context/web/WebAppConfiguration.html) javadoc。
<!-- tabs:end -->


### **`@ContextHierarchy`** 

<!-- tabs:start -->

#### ** English **

`@ContextHierarchy` is a class-level annotation that is used to define a hierarchy of `ApplicationContext` instances for integration tests. `@ContextHierarchy` should be declared with a list of one or more `@ContextConfiguration` instances, each of which defines a level in the context hierarchy. The following examples demonstrate the use of `@ContextHierarchy` within a single test class (`@ContextHierarchy` can also be used within a test class hierarchy):
#### ** Chinese **

`@ContextHierarchy`是一个类级注释，用于定义`ApplicationContext`实例的层次结构，用于集成测试。 `@ContextHierarchy`应该用一个或多个`@ContextConfiguration`实例的列表来声明，每个实例都定义了上下文层次结构中的一个级别。下面的示例演示了在单个测试类中使用 `@ContextHierarchy`的情况（`@ContextHierarchy`也可以在测试类的层次结构中使用）。
<!-- tabs:end -->


```java
@ContextHierarchy({
    @ContextConfiguration("/parent-config.xml"),
    @ContextConfiguration("/child-config.xml")
})
class ContextHierarchyTests {
    // class body...
}
```

```java
@WebAppConfiguration
@ContextHierarchy({
    @ContextConfiguration(classes = AppConfig.class),
    @ContextConfiguration(classes = WebConfig.class)
})
class WebIntegrationTests {
    // class body...
}
```

<!-- tabs:start -->

#### ** English **

If you need to merge or override the configuration for a given level of the context hierarchy within a test class hierarchy, you must explicitly name that level by supplying the same value to the `name` attribute in `@ContextConfiguration` at each corresponding level in the class hierarchy. See [Context Hierarchies](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-ctx-management-ctx-hierarchies) and the [`@ContextHierarchy`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/test/context/ContextHierarchy.html) javadoc for further examples.
#### ** Chinese **

如果你需要合并或覆盖测试类层次结构中给定的上下文层次结构中的某个级别的配置，你必须在类层次结构中的每个对应级别的`@ContextConfiguration` 的`name`属性中提供相同的值来显式命名该级别。有关进一步的示例，请参阅 [Context Hierarchies](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-ctx-management-ctx-hierarchies) 和 [`@ContextHierarchy`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/test/context/ContextHierarchy.html) javadoc。
<!-- tabs:end -->


### **`@ActiveProfiles`** 

<!-- tabs:start -->

#### ** English **

`@ActiveProfiles` is a class-level annotation that is used to declare which bean definition profiles should be active when loading an `ApplicationContext` for an integration test.
#### ** Chinese **

`@ActiveProfiles`是一个类级注释，用于声明在加载`ApplicationContext`集成测试中的Bean定义配置文件时，哪些Bean定义的配置文件应该是活动的。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following example indicates that the `dev` profile should be active:
#### ** Chinese **

下面的示例表明，`dev`配置文件应该是活动的。
<!-- tabs:end -->


```java
@ContextConfiguration
@ActiveProfiles("dev") (1)
class DeveloperTests {
    // class body...
}

//(1) Indicate that the dev profile should be active.
```

<!-- tabs:start -->

#### ** English **

The following example indicates that both the `dev` and the `integration` profiles should be active:
#### ** Chinese **

下面的示例表明，`dev`和`integration`配置文件都应该激活。
<!-- tabs:end -->


```java
@ContextConfiguration
@ActiveProfiles({"dev", "integration"}) (1)
class DeveloperIntegrationTests {
    // class body...
}

//(1) Indicate that the dev and integration profiles should be active.
```

<!-- tabs:start -->

#### ** English **

`@ActiveProfiles` provides support for inheriting active bean definition profiles declared by superclasses by default. You can also resolve active bean definition profiles programmatically by implementing a custom [`ActiveProfilesResolver`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-ctx-management-env-profiles-ActiveProfilesResolver) and registering it by using the `resolver` attribute of `@ActiveProfiles`.
#### ** Chinese **

`@ActiveProfiles`默认支持继承由超类声明的活动Bean定义配置文件。您也可以通过实现一个自定义的 [`ActiveProfilesResolver`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-ctx-management-env-profiles-ActiveProfilesResolver)，并通过使用`@ActiveProfiles`的`resolver`属性来注册它，从而以编程方式解决活动Bean定义配置文件。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

See [Context Configuration with Environment Profiles](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-ctx-management-env-profiles) and the [`@ActiveProfiles`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/test/context/ActiveProfiles.html) javadoc for examples and further details.
#### ** Chinese **

有关示例和更多细节，请参见 [Context Configuration with Environment Profiles](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-ctx-management-env-profiles)和 [`@ActiveProfiles`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/test/context/ActiveProfiles.html) javadoc。
<!-- tabs:end -->


### **`@TestPropertySource`** 

<!-- tabs:start -->

#### ** English **

`@TestPropertySource` is a class-level annotation that you can use to configure the locations of properties files and inlined properties to be added to the set of `PropertySources` in the `Environment` for an `ApplicationContext` loaded for an integration test.
#### ** Chinese **

`@TestPropertySource`是一个类级注释，您可以用来配置属性文件和内嵌属性的位置，以便为集成测试加载的`Environment`中的`PropertySources`集添加到`ApplicationContext`中的`PropertySources`。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following example demonstrates how to declare a properties file from the classpath:
#### ** Chinese **

下面的例子演示了如何从classpath声明一个属性文件。
<!-- tabs:end -->


```java
@ContextConfiguration
@TestPropertySource("/test.properties") (1)
class MyIntegrationTests {
    // class body...
}

//(1) Specifying a properties file with an absolute path.
```

<!-- tabs:start -->

#### ** English **

The following example demonstrates how to declare inlined properties:
#### ** Chinese **

下面的例子演示了如何声明内联属性。
<!-- tabs:end -->


```java
@ContextConfiguration
@TestPropertySource(properties = { "timezone = GMT", "port: 4242" }) (1)
class MyIntegrationTests {
    // class body...
}

//(1) Declare timezone and port properties.
```

<!-- tabs:start -->

#### ** English **

See [Context Configuration with Test Property Sources](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-ctx-management-property-sources) for examples and further details.
#### ** Chinese **

有关示例和更多细节，请参阅[Context Configuration with Test Property Sources](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-ctx-management-property-sources)。
<!-- tabs:end -->


### **`@DynamicPropertySource`** 

<!-- tabs:start -->

#### ** English **

`@DynamicPropertySource` is a method-level annotation that you can use to register *dynamic* properties to be added to the set of `PropertySources` in the `Environment` for an `ApplicationContext` loaded for an integration test. Dynamic properties are useful when you do not know the value of the properties upfront – for example, if the properties are managed by an external resource such as for a container managed by the [Testcontainers](https://www.testcontainers.org/) project.
#### ** Chinese **

`@DynamicPropertySource`是一个方法级的注释，您可以用来注册*动态*属性，并将其添加到`Environment`中的`PropertySources`集合中，用于为集成测试加载的`ApplicationContext`。当你不知道属性的值时，动态属性是非常有用的--例如，如果属性是由外部资源管理的，例如由[Testcontainers](https://www.testcontainers.org/)项目管理的容器。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following example demonstrates how to register a dynamic property:
#### ** Chinese **

下面的例子演示了如何注册一个动态属性。
<!-- tabs:end -->


```java
@ContextConfiguration
class MyIntegrationTests {

    static MyExternalServer server = // ...

    @DynamicPropertySource (1)
    static void dynamicProperties(DynamicPropertyRegistry registry) { (2)
        registry.add("server.port", server::getPort); (3)
    }

    // tests ...
}

//(1) Annotate a static method with @DynamicPropertySource.
(2) Accept a DynamicPropertyRegistry as an argument.
(3) Register a dynamic server.port property to be retrieved lazily from the server.
```

<!-- tabs:start -->

#### ** English **

See [Context Configuration with Dynamic Property Sources](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-ctx-management-dynamic-property-sources) for further details.
#### ** Chinese **

详见[Context Configuration with Dynamic Property Sources](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-ctx-management-dynamic-property-sources)。
<!-- tabs:end -->


### **`@DirtiesContext`** 

<!-- tabs:start -->

#### ** English **

`@DirtiesContext` indicates that the underlying Spring `ApplicationContext` has been dirtied during the execution of a test (that is, the test modified or corrupted it in some manner — for example, by changing the state of a singleton bean) and should be closed. When an application context is marked as dirty, it is removed from the testing framework’s cache and closed. As a consequence, the underlying Spring container is rebuilt for any subsequent test that requires a context with the same configuration metadata.
#### ** Chinese **

`@DirtiesContext`表示底层的Spring `ApplicationContext`在执行测试过程中被弄脏了（也就是说，测试以某种方式修改或破坏了它--例如，通过改变单子bean的状态），因此应该被关闭。当一个应用上下文被标记为脏的时候，它将从测试框架的缓存中删除并关闭。因此，对于任何后续需要使用相同配置元数据的上下文的测试，底层的Spring容器会被重建。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can use `@DirtiesContext` as both a class-level and a method-level annotation within the same class or class hierarchy. In such scenarios, the `ApplicationContext` is marked as dirty before or after any such annotated method as well as before or after the current test class, depending on the configured `methodMode` and `classMode`.
#### ** Chinese **

您可以在同一个类或类层次结构中使用`@DirtiesContext`作为类级和方法级注释。在这种情况下，根据配置的 `methodMode`和`classMode`，`ApplicationContext`会在任何此类注释的方法之前或之后以及在当前测试类之前或之后被标记为脏，这取决于配置的`methodMode`和`classMode`。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following examples explain when the context would be dirtied for various configuration scenarios:
#### ** Chinese **

下面的例子说明了各种配置场景下的上下文会在什么时候被污点。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

- [Spring Testing Annotations](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#integration-testing-annotations-spring)

- [Standard Annotation Support](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#integration-testing-annotations-standard)

- [Spring JUnit 4 Testing Annotations](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#integration-testing-annotations-junit4)

- [Spring JUnit Jupiter Testing Annotations](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#integration-testing-annotations-junit-jupiter)

- [Meta-Annotation Support for Testing](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#integration-testing-annotations-meta)

- [`@BootstrapWith`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#spring-testing-annotation-bootstrapwith)

- [`@ContextConfiguration`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#spring-testing-annotation-contextconfiguration)

- [`@WebAppConfiguration`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#spring-testing-annotation-webappconfiguration)

- [`@ContextHierarchy`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#spring-testing-annotation-contexthierarchy)

- [`@ActiveProfiles`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#spring-testing-annotation-activeprofiles)

- [`@TestPropertySource`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#spring-testing-annotation-testpropertysource)

- [`@DynamicPropertySource`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#spring-testing-annotation-dynamicpropertysource)

- [`@DirtiesContext`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#spring-testing-annotation-dirtiescontext)

- [`@TestExecutionListeners`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#spring-testing-annotation-testexecutionlisteners)

- [`@Commit`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#spring-testing-annotation-commit)

- [`@Rollback`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#spring-testing-annotation-rollback)

- [`@BeforeTransaction`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#spring-testing-annotation-beforetransaction)

- [`@AfterTransaction`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#spring-testing-annotation-aftertransaction)

- [`@Sql`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#spring-testing-annotation-sql)

- [`@SqlConfig`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#spring-testing-annotation-sqlconfig)

- [`@SqlMergeMode`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#spring-testing-annotation-sqlmergemode)

- [`@SqlGroup`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#spring-testing-annotation-sqlgroup)

#### ** Chinese **

- [Spring Testing Annotations](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#integration-testing-annotations-spring)

- [标准注释支持](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#integration-testing-annotations-standard)

- [Spring JUnit 4测试注释](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#integration-testing-annotations-junit4)

- [Spring JUnit Jupiter测试注释](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#integration-testing-annotations-junit-jupiter)

- [Meta-Annotation Support for Testing](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#integration-testing-annotations-meta)

- [`@BootstrapWith`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#spring-testing-annotation-bootstrapwith)

- [`@ContextConfiguration`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#spring-testing-annotation-contextconfiguration)

- [`@WebAppConfiguration`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#spring-testing-annotation-webappconfiguration)

- [`@ContextHierarchy`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#spring-testing-annotation-contexthierarchy)

- [`@ActiveProfiles`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#spring-testing-annotation-activeprofiles)

- [`@TestPropertySource`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#spring-testing-annotation-testpropertysource)

- [`@DynamicPropertySource`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#spring-testing-annotation-dynamicpropertysource)

- [`@DirtiesContext`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#spring-testing-annotation-dirtiescontext)

- [`@TestExecutionListeners`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#spring-testing-annotation-testexecutionlisteners)

- [`@Commit`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#spring-testing-annotation-commit)

- [`@Rollback`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#spring-testing-annotation-rollback)

- [`@BeforeTransaction`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#spring-testing-annotation-beforetransaction)

- [`@AfterTransaction`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#spring-testing-annotation-aftertransaction)

- [`@Sql`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#spring-testing-annotation-sql)

- [`@SqlConfig`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#spring-testing-annotation-sqlconfig)

- [`@SqlMergeMode`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#spring-testing-annotation-sqlmergemode)

- [`@SqlGroup`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#spring-testing-annotation-sqlgroup)


<!-- tabs:end -->


- Before the current test class, when declared on a class with class mode set to `BEFORE_CLASS`.

- 在当前测试类之前，当声明在类模式设置为`BEFORE_CLASS`的类上时。


```java 
@DirtiesContext(classMode = BEFORE_CLASS) (1)
class FreshContextTests {
    // some tests that require a new Spring container
}

//(1) Dirty the context before the current test class.
```
(1)	Dirty the context before the current test class.


- After the current test class, when declared on a class with class mode set to `AFTER_CLASS` (i.e., the default class mode).

```java
@DirtiesContext (1)
class ContextDirtyingTests {
    // some tests that result in the Spring container being dirtied
}

//(1) Dirty the context after the current test class.
```
(1) Dirty the context after the current test class.


- Before each test method in the current test class, when declared on a class with class mode set to `BEFORE_EACH_TEST_METHOD.`

``` java
@DirtiesContext(classMode = BEFORE_EACH_TEST_METHOD) (1)
class FreshContextTests {
    // some tests that require a new Spring container
}

//(1) Dirty the context before each test method.
```
(1) Dirty the context before each test method.


- After each test method in the current test class, when declared on a class with class mode set to `AFTER_EACH_TEST_METHOD.`

```java
@DirtiesContext(classMode = AFTER_EACH_TEST_METHOD) (1)
class ContextDirtyingTests {
    // some tests that result in the Spring container being dirtied
}

//(1) Dirty the context after each test method.
```
(1) Dirty the context after each test method.


- Before the current test, when declared on a method with the method mode set to `BEFORE_METHOD`.

```java
@DirtiesContext(methodMode = BEFORE_METHOD) (1)
@Test
void testProcessWhichRequiresFreshAppCtx() {
    // some logic that requires a new Spring container
}

//(1) Dirty the context before the current test method.
```
(1) Dirty the context before the current test method.


- After the current test, when declared on a method with the method mode set to `AFTER_METHOD` (i.e., the default method mode).

```java
@DirtiesContext (1)
@Test
void testProcessWhichDirtiesAppCtx() {
    // some logic that results in the Spring container being dirtied
}

//(1) Dirty the context after the current test method.
```
(1) Dirty the context after the current test method.

<!-- tabs:start -->

#### ** English **

If you use `@DirtiesContext` in a test whose context is configured as part of a context hierarchy with `@ContextHierarchy`, you can use the `hierarchyMode` flag to control how the context cache is cleared. By default, an exhaustive algorithm is used to clear the context cache, including not only the current level but also all other context hierarchies that share an ancestor context common to the current test. All `ApplicationContext` instances that reside in a sub-hierarchy of the common ancestor context are removed from the context cache and closed. If the exhaustive algorithm is overkill for a particular use case, you can specify the simpler current level algorithm, as the following example shows.
#### ** Chinese **

如果你在一个测试中使用了`@DirtiesContext`，而这个测试的上下文被配置为`@ContextHierarchy`的上下文层次结构的一部分，你可以使用`hierarchyMode`标志来控制如何清除上下文缓存。默认情况下，会使用一种详尽的算法来清除上下文缓存，不仅包括当前级别，还包括所有与当前测试共享祖先上下文的所有其他上下文层次。所有居住在共同祖先上下文的子层次结构中的 `ApplicationContext`实例都会从上下文缓存中删除并关闭。如果对特定用例来说，详尽的算法是多余的，你可以指定更简单的当前级算法，如下例所示。
<!-- tabs:end -->


```java
@ContextHierarchy({
    @ContextConfiguration("/parent-config.xml"),
    @ContextConfiguration("/child-config.xml")
})
class BaseTests {
    // class body...
}

class ExtendedTests extends BaseTests {

    @Test
    @DirtiesContext(hierarchyMode = CURRENT_LEVEL) (1)
    void test() {
        // some logic that results in the child context being dirtied
    }
}

//(1) Use the current-level algorithm.
```

<!-- tabs:start -->

#### ** English **

For further details regarding the `EXHAUSTIVE` and `CURRENT_LEVEL` algorithms, see the [`DirtiesContext.HierarchyMode`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/test/annotation/DirtiesContext.HierarchyMode.html) javadoc.
#### ** Chinese **

有关 `EXHAUSTIVE`和`CURRENT_LEVEL`算法的更多细节，请参阅 [`DirtiesContext.HierarchyMode`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/test/annotation/DirtiesContext.HierarchyMode.html) javadoc.
<!-- tabs:end -->


### **`@TestExecutionListeners`** 

<!-- tabs:start -->

#### ** English **

`@TestExecutionListeners` defines class-level metadata for configuring the `TestExecutionListener` implementations that should be registered with the `TestContextManager`. Typically, `@TestExecutionListeners` is used in conjunction with `@ContextConfiguration`.
#### ** Chinese **

`@TestExecutionListeners`定义了类级元数据，用于配置应在`TestContextManager`中注册的`TestExecutionListener`实现。通常情况下，`@TestExecutionListeners`与`@ContextConfiguration`一起使用。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following example shows how to register two `TestExecutionListener` implementations:
#### ** Chinese **

下面的示例显示了如何注册两个`TestExecutionListener`实现。
<!-- tabs:end -->


```java
@ContextConfiguration
@TestExecutionListeners({CustomTestExecutionListener.class, AnotherTestExecutionListener.class}) (1)
class CustomTestExecutionListenerTests {
    // class body...
}

//(1) Register two TestExecutionListener implementations.
```

<!-- tabs:start -->

#### ** English **

By default, `@TestExecutionListeners` supports inherited listeners. See the [javadoc](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/test/context/TestExecutionListeners.html) for an example and further details.
#### ** Chinese **

默认情况下，`@TestExecutionListeners`支持继承监听器。请参见 [javadoc](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/test/context/TestExecutionListeners.html)中的示例和更多细节。
<!-- tabs:end -->


### **`@Commit`** 

<!-- tabs:start -->

#### ** English **

`@Commit` indicates that the transaction for a transactional test method should be committed after the test method has completed. You can use `@Commit` as a direct replacement for `@Rollback(false)` to more explicitly convey the intent of the code. Analogous to `@Rollback`, `@Commit` can also be declared as a class-level or method-level annotation.
#### ** Chinese **

`@Commit`表示事务型测试方法的事务应该在测试方法完成后提交。你可以用 `@Commit`直接替代 `@Rollback(false)`来更明确地传达代码的意图。与`@Rollback`类似，`@Commit`也可以作为类级或方法级注释声明。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following example shows how to use the `@Commit` annotation:
#### ** Chinese **

下面的例子说明了如何使用`@Commit`注释。
<!-- tabs:end -->


```java
@Commit (1)
@Test
void testProcessWithoutRollback() {
    // ...
}

//(1) Commit the result of the test to the database.
```

### **`@Rollback`** 

<!-- tabs:start -->

#### ** English **

`@Rollback` indicates whether the transaction for a transactional test method should be rolled back after the test method has completed. If `true`, the transaction is rolled back. Otherwise, the transaction is committed (see also [`@Commit`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#spring-testing-annotation-commit)). Rollback for integration tests in the Spring TestContext Framework defaults to `true` even if `@Rollback` is not explicitly declared.
#### ** Chinese **

`@Rollback`表示在测试方法完成后，是否应该回滚交易测试方法的事务。如果`true`，事务被回滚。否则，事务被提交（另请参阅 [`@Commit`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#spring-testing-annotation-commit)）。在Spring TestContext框架中的集成测试的回滚，即使没有明确声明`@Rollback`，也会默认为`true`。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

When declared as a class-level annotation, `@Rollback` defines the default rollback semantics for all test methods within the test class hierarchy. When declared as a method-level annotation, `@Rollback` defines rollback semantics for the specific test method, potentially overriding class-level `@Rollback` or `@Commit` semantics.
#### ** Chinese **

当声明为类级注释时，`@Rollback`定义了测试类层次结构中所有测试方法的默认回滚语义。当声明为方法级注释时，`@Rollback`定义了特定测试方法的回滚语义，可能会覆盖类级`@Rollback`或`@Commit`语义。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following example causes a test method’s result to not be rolled back (that is, the result is committed to the database):
#### ** Chinese **

下面的例子导致测试方法的结果不回滚（即结果被提交到数据库中）。
<!-- tabs:end -->


```java
@Rollback(false) (1)
@Test
void testProcessWithoutRollback() {
    // ...
}

//(1) Do not roll back the result.
```

### **`@BeforeTransaction`** 

<!-- tabs:start -->

#### ** English **

`@BeforeTransaction` indicates that the annotated `void` method should be run before a transaction is started, for test methods that have been configured to run within a transaction by using Spring’s `@Transactional` annotation. `@BeforeTransaction` methods are not required to be `public` and may be declared on Java 8-based interface default methods.
#### ** Chinese **

`@BeforeTransaction`表示，对于通过使用Spring的`@Transactional`注解配置为在事务内运行的测试方法，应该在事务启动之前运行注解的`void`方法。 `@BeforeTransaction`方法不需要是`public`，可以在基于Java 8的接口默认方法上声明。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following example shows how to use the `@BeforeTransaction` annotation:
#### ** Chinese **

下面的例子显示了如何使用`@BeforeTransaction`注释。
<!-- tabs:end -->


```java
@BeforeTransaction (1)
void beforeTransaction() {
    // logic to be executed before a transaction is started
}

//(1) Run this method before a transaction.
```

### **`@AfterTransaction`** 

<!-- tabs:start -->

#### ** English **

`@AfterTransaction` indicates that the annotated `void` method should be run after a transaction is ended, for test methods that have been configured to run within a transaction by using Spring’s `@Transactional` annotation. `@AfterTransaction` methods are not required to be `public` and may be declared on Java 8-based interface default methods.
#### ** Chinese **

`@AfterTransaction`表示，对于通过使用Spring的`@Transactional`注解配置为在事务内运行的测试方法，在事务结束后应该运行注解的`void`方法。 `@AfterTransaction`方法不需要是`public`，可以在基于Java 8的接口默认方法上声明。
<!-- tabs:end -->


```java
@AfterTransaction (1)
void afterTransaction() {
    // logic to be executed after a transaction has ended
}

//(1) Run this method after a transaction.
```

### **`@Sql`** 

<!-- tabs:start -->

#### ** English **

`@Sql` is used to annotate a test class or test method to configure SQL scripts to be run against a given database during integration tests. The following example shows how to use it:
#### ** Chinese **

`@Sql`用于注释一个测试类或测试方法，以配置SQL脚本，在集成测试期间针对给定数据库运行。下面的例子显示了如何使用它。
<!-- tabs:end -->


```java
@Test
@Sql({"/test-schema.sql", "/test-user-data.sql"}) (1)
void userTest() {
    // execute code that relies on the test schema and test data
}

//(1) Run two scripts for this test.
```

<!-- tabs:start -->

#### ** English **

See [Executing SQL scripts declaratively with @Sql](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-executing-sql-declaratively) for further details.
#### ** Chinese **

详见【用@Sql声明性地执行SQL脚本】(https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-executing-sql-declaratively)。
<!-- tabs:end -->


### **`@SqlConfig`** 

<!-- tabs:start -->

#### ** English **

`@SqlConfig` defines metadata that is used to determine how to parse and run SQL scripts configured with the `@Sql` annotation. The following example shows how to use it:
#### ** Chinese **

`@SqlConfig`定义了元数据，用于确定如何解析和运行用`@Sql`注释配置的SQL脚本。下面的示例显示了如何使用它。
<!-- tabs:end -->


```java
@Test
@Sql(
    scripts = "/test-user-data.sql",
    config = @SqlConfig(commentPrefix = "`", separator = "@@") (1)
)
void userTest() {
    // execute code that relies on the test data
}

//(1) Set the comment prefix and the separator in SQL scripts.
```

### **`@SqlMergeMode`** 

<!-- tabs:start -->

#### ** English **

`@SqlMergeMode` is used to annotate a test class or test method to configure whether method-level `@Sql` declarations are merged with class-level `@Sql` declarations. If `@SqlMergeMode` is not declared on a test class or test method, the `OVERRIDE` merge mode will be used by default. With the `OVERRIDE` mode, method-level `@Sql` declarations will effectively override class-level `@Sql` declarations.
#### ** Chinese **

`@SqlMergeMode`用于注释测试类或测试方法，以配置方法级的`@Sql`声明是否与类级的`@Sql`声明合并。如果`@SqlMergeMode`没有在测试类或测试方法上声明`@SqlMergeMode`，则默认使用`OVERRIDE`合并模式。使用`OVERRIDE`模式，方法级的`@Sql`声明将有效地覆盖类级的`@Sql`声明。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Note that a method-level `@SqlMergeMode` declaration overrides a class-level declaration.
#### ** Chinese **

注意，方法级的`@SqlMergeMode`声明覆盖了类级声明。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following example shows how to use `@SqlMergeMode` at the class level.
#### ** Chinese **

下面的例子显示了如何在类级使用`@SqlMergeMode`。
<!-- tabs:end -->


```java
@SpringJUnitConfig(TestConfig.class)
@Sql("/test-schema.sql")
@SqlMergeMode(MERGE) (1)
class UserTests {

    @Test
    @Sql("/user-test-data-001.sql")
    void standardUserProfile() {
        // execute code that relies on test data set 001
    }
}

//(1) Set the @Sql merge mode to MERGE for all test methods in the class.
```

<!-- tabs:start -->

#### ** English **

The following example shows how to use `@SqlMergeMode` at the method level.
#### ** Chinese **

下面的例子显示了如何在方法级使用`@SqlMergeMode`。
<!-- tabs:end -->


```java
@SpringJUnitConfig(TestConfig.class)
@Sql("/test-schema.sql")
class UserTests {

    @Test
    @Sql("/user-test-data-001.sql")
    @SqlMergeMode(MERGE) (1)
    void standardUserProfile() {
        // execute code that relies on test data set 001
    }
}

//(1) Set the @Sql merge mode to MERGE for a specific test method.
```

### **`@SqlGroup`** 

<!-- tabs:start -->

#### ** English **

`@SqlGroup` is a container annotation that aggregates several `@Sql` annotations. You can use `@SqlGroup` natively to declare several nested `@Sql` annotations, or you can use it in conjunction with Java 8’s support for repeatable annotations, where `@Sql` can be declared several times on the same class or method, implicitly generating this container annotation. The following example shows how to declare an SQL group:
#### ** Chinese **

`@SqlGroup`是一个容器注释，它聚合了多个`@Sql`注释。你可以使用 `@SqlGroup`来声明多个嵌套的 `@Sql` 注解，也可以结合 Java 8 对可重复注解的支持一起使用，其中 `@Sql` 可以在同一个类或方法上多次声明，隐式地生成这个容器注解。下面的例子显示了如何声明一个SQL组。
<!-- tabs:end -->


```java
@Test
@SqlGroup({ (1)
    @Sql(scripts = "/test-schema.sql", config = @SqlConfig(commentPrefix = "`")),
    @Sql("/test-user-data.sql")
)}
void userTest() {
    // execute code that uses the test schema and test data
}

//(1) Declare a group of SQL scripts.
```

### **3.4.2. Standard Annotation Support** 

<!-- tabs:start -->

#### ** English **

The following annotations are supported with standard semantics for all configurations of the Spring TestContext Framework. Note that these annotations are not specific to tests and can be used anywhere in the Spring Framework.
#### ** Chinese **

以下注释支持Spring TestContext框架的所有配置的标准语义。请注意，这些注释并不是特定于测试，可以在Spring框架的任何地方使用。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

- `@Autowired`

- `@Qualifier`

- `@Value`

- `@Resource` (javax.annotation) if JSR-250 is present

- `@ManagedBean` (javax.annotation) if JSR-250 is present

- `@Inject` (javax.inject) if JSR-330 is present

- `@Named` (javax.inject) if JSR-330 is present

- `@PersistenceContext` (javax.persistence) if JPA is present

- `@PersistenceUnit` (javax.persistence) if JPA is present

- `@Required`

- `@Transactional` (org.springframework.transaction.annotation) *with* [*limited attribute support*](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-tx-attribute-support)

#### ** Chinese **

- `@Autowired`

- `@Qualifier`

- `@Value`

- `@Resource` (javax.annotation)，如果JSR-250存在，则为@Resource</x> (javax.annotation)

- `@ManagedBean` (javax.annotation)，如果JSR-250存在，则`@ManagedBean` (javax.annotation)

- `@Inject` (javax.inject)，如果JSR-330存在，则为`@Inject` (javax.inject)

- `@Named` (javax.inject)，如果JSR-330存在，则为`@Named` (javax.inject)

- `@PersistenceContext` (javax.persistence)，如果JPA存在，则@PersistenceContext</x> (javax.persistence)

- `@PersistenceUnit` (javax.persistence)，如果JPA存在，则@PersistenceUnit</x> (javax.persistence)

- `@Required`</x>

- `@Transactional` (org.springframework.transaction.annotation) *with* [*limited attribute support*](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-tx-attribute-support)

<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

JSR-250 Lifecycle Annotations
#### ** Chinese **

JSR-250 生命周期注释
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

In the Spring TestContext Framework, you can use `@PostConstruct` and `@PreDestroy` with standard semantics on any application components configured in the `ApplicationContext`. However, these lifecycle annotations have limited usage within an actual test class.
#### ** Chinese **

在Spring TestContext框架中，您可以在`ApplicationContext`中配置的任何应用程序组件上使用`@PostConstruct`和`@PreDestroy`，并使用标准语义。但是，这些生命周期注释在实际测试类中的使用范围有限。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

If a method within a test class is annotated with `@PostConstruct`, that method runs before any before methods of the underlying test framework (for example, methods annotated with JUnit Jupiter’s `@BeforeEach`), and that applies for every test method in the test class. On the other hand, if a method within a test class is annotated with `@PreDestroy`, that method never runs. Therefore, within a test class, we recommend that you use test lifecycle callbacks from the underlying test framework instead of `@PostConstruct` and `@PreDestroy`.
#### ** Chinese **

如果一个测试类中的方法被注释为`@PostConstruct`，那么该方法将在底层测试框架的任何之前的方法之前运行（例如，被注释为JUnit Jupiter的`@BeforeEach`的方法），这适用于测试类中的每个测试方法。另一方面，如果一个测试类中的方法被注释为`@PreDestroy`，那么这个方法永远不会运行。因此，在测试类中，我们建议您使用来自底层测试框架的测试生命周期回调，而不是`@PostConstruct`和`@PreDestroy`。
<!-- tabs:end -->


### **3.4.3. Spring JUnit 4 Testing Annotations** 

<!-- tabs:start -->

#### ** English **

The following annotations are supported only when used in conjunction with the [SpringRunner](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-junit4-runner), [Spring’s JUnit 4 rules](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-junit4-rules), or [Spring’s JUnit 4 support classes](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-support-classes-junit4):
#### ** Chinese **

以下注释仅在与[SpringRunner](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-junit4-runner)、[Spring的JUnit 4规则](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-junit4-rules)或[Spring的JUnit 4支持类](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-support-classes-junit4)一起使用时才支持。
<!-- tabs:end -->


### **`@IfProfileValue`** 

<!-- tabs:start -->

#### ** English **

`@IfProfileValue` indicates that the annotated test is enabled for a specific testing environment. If the configured `ProfileValueSource` returns a matching `value` for the provided `name`, the test is enabled. Otherwise, the test is disabled and, effectively, ignored.
#### ** Chinese **

`@IfProfileValue`表示注释测试在特定测试环境中被启用。如果配置的`ProfileValueSource`返回一个与所提供的`name`匹配的`value`，则测试被启用。否则，该测试将被禁用，并且实际上被忽略。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can apply `@IfProfileValue` at the class level, the method level, or both. Class-level usage of `@IfProfileValue` takes precedence over method-level usage for any methods within that class or its subclasses. Specifically, a test is enabled if it is enabled both at the class level and at the method level. The absence of `@IfProfileValue` means the test is implicitly enabled. This is analogous to the semantics of JUnit 4’s `@Ignore` annotation, except that the presence of `@Ignore` always disables a test.
#### ** Chinese **

您可以在类级、方法级或方法级应用`@IfProfileValue`，也可以同时应用`@IfProfileValue`。类级的 `@IfProfileValue`的使用优先于该类或其子类中的任何方法的方法级使用。具体来说，如果一个测试在类级和方法级都被启用，那么它就被启用了。没有`@IfProfileValue`意味着测试被隐式地启用了。这与 JUnit 4 的 `@Ignore` 注释的语义类似，只是 `@Ignore` 的存在总是禁用一个测试。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following example shows a test that has an `@IfProfileValue` annotation:
#### ** Chinese **

下面的示例显示了一个具有`@IfProfileValue`注释的测试。
<!-- tabs:end -->


```java
@IfProfileValue(name="java.vendor", value="Oracle Corporation") (1)
@Test
public void testProcessWhichRunsOnlyOnOracleJvm() {
    // some logic that should run only on Java VMs from Oracle Corporation
}

//(1) Run this test only when the Java vendor is "Oracle Corporation".
```

<!-- tabs:start -->

#### ** English **

Alternatively, you can configure `@IfProfileValue` with a list of `values` (with `OR` semantics) to achieve TestNG-like support for test groups in a JUnit 4 environment. Consider the following example:
#### ** Chinese **

或者，你可以配置`@IfProfileValue`，用一个`values`列表（具有`OR`语义）来实现在JUnit 4环境中对测试组的类似于TestNG的支持。考虑一下下面的例子。
<!-- tabs:end -->


```java
@IfProfileValue(name="test-groups", values={"unit-tests", "integration-tests"}) (1)
@Test
public void testProcessWhichRunsForUnitOrIntegrationTestGroups() {
    // some logic that should run only for unit and integration test groups
}

//(1) Run this test for unit tests and integration tests.
```

### **`@ProfileValueSourceConfiguration`** 

<!-- tabs:start -->

#### ** English **

`@ProfileValueSourceConfiguration` is a class-level annotation that specifies what type of `ProfileValueSource` to use when retrieving profile values configured through the `@IfProfileValue` annotation. If `@ProfileValueSourceConfiguration` is not declared for a test, `SystemProfileValueSource` is used by default. The following example shows how to use `@ProfileValueSourceConfiguration`:
#### ** Chinese **

`@ProfileValueSourceConfiguration`是一个类级注释，它指定了通过`@IfProfileValueSource`注释来检索通过`@IfProfileValue`配置的配置文件值时要使用什么类型的`ProfileValueSource`。如果`@ProfileValueSourceConfiguration`没有为测试声明，则默认使用`SystemProfileValueSource`。下面的例子显示了如何使用`@ProfileValueSourceConfiguration`。
<!-- tabs:end -->


```java
@ProfileValueSourceConfiguration(CustomProfileValueSource.class) (1)
public class CustomProfileValueSourceTests {
    // class body...
}

//(1) Use a custom profile value source.
```

### **`@Timed`** 

<!-- tabs:start -->

#### ** English **

`@Timed` indicates that the annotated test method must finish execution in a specified time period (in milliseconds). If the text execution time exceeds the specified time period, the test fails.
#### ** Chinese **

`@Timed`表示注释的测试方法必须在指定的时间段内完成执行（以毫秒为单位）。如果文本执行时间超过了指定的时间段，则测试失败。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The time period includes running the test method itself, any repetitions of the test (see `@Repeat`), as well as any setting up or tearing down of the test fixture. The following example shows how to use it:
#### ** Chinese **

该时间段包括运行测试方法本身、测试的任何重复（见`@Repeat`），以及测试夹具的任何设置或拆卸。下面的例子显示了如何使用它。
<!-- tabs:end -->


```java
@Timed(millis = 1000) (1)
public void testProcessWithOneSecondTimeout() {
    // some logic that should not take longer than 1 second to execute
}

//(1) Set the time period for the test to one second.
```

<!-- tabs:start -->

#### ** English **

Spring’s `@Timed` annotation has different semantics than JUnit 4’s `@Test(timeout=…​)` support. Specifically, due to the manner in which JUnit 4 handles test execution timeouts (that is, by executing the test method in a separate `Thread`), `@Test(timeout=…​)` preemptively fails the test if the test takes too long. Spring’s `@Timed`, on the other hand, does not preemptively fail the test but rather waits for the test to complete before failing.
#### ** Chinese **

Spring的`@Timed`注释与JUnit 4的`@Test(timeout=…​)`支持的语义不同。具体来说，由于JUnit 4处理测试执行超时的方式（即通过在单独的`Thread`中执行测试方法），如果测试时间过长，`@Test(timeout=…​)`会先发制人地失败。另一方面，Spring的`@Timed`并不会先发制人地失败测试，而是等待测试完成后再失败。
<!-- tabs:end -->


### **`@Repeat`** 

<!-- tabs:start -->

#### ** English **

`@Repeat` indicates that the annotated test method must be run repeatedly. The number of times that the test method is to be executed is specified in the annotation.
#### ** Chinese **

`@Repeat`表示必须重复执行注释的测试方法。注释中指定了测试方法的执行次数。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The scope of execution to be repeated includes execution of the test method itself as well as any setting up or tearing down of the test fixture. The following example shows how to use the `@Repeat` annotation:
#### ** Chinese **

要重复执行的范围包括测试方法本身的执行以及测试夹具的设置和拆卸。下面的例子显示了如何使用`@Repeat`注释。
<!-- tabs:end -->


```java
@Repeat(10) (1)
@Test
public void testProcessRepeatedly() {
    // ...
}

//(1) Repeat this test ten times.
```

### **3.4.4. Spring JUnit Jupiter Testing Annotations** 

<!-- tabs:start -->

#### ** English **

The following annotations are supported only when used in conjunction with the [`SpringExtension`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-junit-jupiter-extension) and JUnit Jupiter (that is, the programming model in JUnit 5):
#### ** Chinese **

以下注释只有在与[`SpringExtension`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-junit-jupiter-extension)和JUnit Jupiter(也就是JUnit 5中的编程模型)一起使用时才支持。
<!-- tabs:end -->


### **`@SpringJUnitConfig`** 

<!-- tabs:start -->

#### ** English **

`@SpringJUnitConfig` is a composed annotation that combines `@ExtendWith(SpringExtension.class)` from JUnit Jupiter with `@ContextConfiguration` from the Spring TestContext Framework. It can be used at the class level as a drop-in replacement for `@ContextConfiguration`. With regard to configuration options, the only difference between `@ContextConfiguration` and `@SpringJUnitConfig` is that component classes may be declared with the `value` attribute in `@SpringJUnitConfig`.
#### ** Chinese **

`@SpringJUnitConfig`是一个组成式注释，它将JUnit Jupiter中的`@ExtendWith(SpringExtension.class)`与Spring TestContextConfiguration</x>结合在一起。它可以在类级别上作为`@ContextConfiguration`的替换品使用。在配置选项方面，`@ContextConfiguration`和`@SpringJUnitConfig`之间的唯一区别是，组件类可以用`@SpringJUnitConfig`中的`value`属性来声明。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following example shows how to use the `@SpringJUnitConfig` annotation to specify a configuration class:
#### ** Chinese **

下面的示例显示了如何使用`@SpringJUnitConfig`注释来指定一个配置类。
<!-- tabs:end -->


```java
@SpringJUnitConfig(TestConfig.class) (1)
class ConfigurationClassJUnitJupiterSpringTests {
    // class body...
}

//(1) Specify the configuration class.
```

<!-- tabs:start -->

#### ** English **

The following example shows how to use the `@SpringJUnitConfig` annotation to specify the location of a configuration file:
#### ** Chinese **

下面的示例显示了如何使用`@SpringJUnitConfig`注释来指定配置文件的位置。
<!-- tabs:end -->


```java
@SpringJUnitConfig(locations = "/test-config.xml") (1)
class XmlJUnitJupiterSpringTests {
    // class body...
}

//(1) Specify the location of a configuration file.
```

<!-- tabs:start -->

#### ** English **

See [Context Management](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-ctx-management) as well as the javadoc for [`@SpringJUnitConfig`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/test/context/junit/jupiter/SpringJUnitConfig.html) and `@ContextConfiguration` for further details.
#### ** Chinese **

有关详细信息，请参阅 [Context Management](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-ctx-management)以及 [`@SpringJUnitConfig`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/test/context/junit/jupiter/SpringJUnitConfig.html)和`@ContextConfiguration`的 javadoc。
<!-- tabs:end -->


### **`@SpringJUnitWebConfig`** 

<!-- tabs:start -->

#### ** English **

`@SpringJUnitWebConfig` is a composed annotation that combines `@ExtendWith(SpringExtension.class)` from JUnit Jupiter with `@ContextConfiguration` and `@WebAppConfiguration` from the Spring TestContext Framework. You can use it at the class level as a drop-in replacement for `@ContextConfiguration` and `@WebAppConfiguration`. With regard to configuration options, the only difference between `@ContextConfiguration` and `@SpringJUnitWebConfig` is that you can declare component classes by using the `value` attribute in `@SpringJUnitWebConfig`. In addition, you can override the `value` attribute from `@WebAppConfiguration` only by using the `resourcePath` attribute in `@SpringJUnitWebConfig`.
#### ** Chinese **

`@SpringJUnitWebConfig`是一个组成式注释，它将JUnit Jupiter中的`@ExtendWith(SpringExtension.class)`与Spring TestContext框架中的`@ContextConfiguration`和`@WebAppConfiguration`结合在一起。你可以在类级使用它，作为`@ContextConfiguration`和`@WebAppConfiguration`的替换品。关于配置选项，`@ContextConfiguration`和`@SpringJUnitWebConfig`之间的唯一区别是，您可以通过使用`@SpringJUnitWebConfig`中的`value`属性来声明组件类。此外，只有通过使用`@SpringJUnitWebConfig`中的`resourcePath`属性，才能覆盖`@WebAppConfiguration`中的`value`属性。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following example shows how to use the `@SpringJUnitWebConfig` annotation to specify a configuration class:
#### ** Chinese **

下面的示例显示了如何使用`@SpringJUnitWebConfig`注释来指定配置类。
<!-- tabs:end -->


```java
@SpringJUnitWebConfig(TestConfig.class) (1)
class ConfigurationClassJUnitJupiterSpringWebTests {
    // class body...
}

//(1) Specify the configuration class.
```

<!-- tabs:start -->

#### ** English **

The following example shows how to use the `@SpringJUnitWebConfig` annotation to specify the location of a configuration file:
#### ** Chinese **

下面的示例显示了如何使用`@SpringJUnitWebConfig`注释来指定配置文件的位置。
<!-- tabs:end -->


```java
@SpringJUnitWebConfig(locations = "/test-config.xml") (1)
class XmlJUnitJupiterSpringWebTests {
    // class body...
}

//(1) Specify the location of a configuration file.
```

<!-- tabs:start -->

#### ** English **

See [Context Management](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-ctx-management) as well as the javadoc for [`@SpringJUnitWebConfig`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/test/context/junit/jupiter/web/SpringJUnitWebConfig.html), [`@ContextConfiguration`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/test/context/ContextConfiguration.html), and [`@WebAppConfiguration`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/test/context/web/WebAppConfiguration.html) for further details.
#### ** Chinese **

有关详细信息，请参阅 [Context Management](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-ctx-management)，以及 [`@SpringJUnitWebConfig`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/test/context/junit/jupiter/web/SpringJUnitWebConfig.html)、[`@ContextConfiguration`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/test/context/ContextConfiguration.html)和[`@WebAppConfiguration`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/test/context/web/WebAppConfiguration.html)的 javadoc。
<!-- tabs:end -->


### **`@TestConstructor`** 

<!-- tabs:start -->

#### ** English **

`@TestConstructor` is a type-level annotation that is used to configure how the parameters of a test class constructor are autowired from components in the test’s `ApplicationContext`.
#### ** Chinese **

`@TestConstructor`是一个类型级注释，用于配置测试类构造函数的参数如何从测试的`ApplicationContext`中的组件中自动连接。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

If `@TestConstructor` is not present or meta-present on a test class, the default *test constructor autowire mode* will be used. See the tip below for details on how to change the default mode. Note, however, that a local declaration of `@Autowired` on a constructor takes precedence over both `@TestConstructor` and the default mode.
#### ** Chinese **

如果`@TestConstructor`没有在测试类中存在或元存在，将使用默认的*test构造函数autowire模式*。关于如何改变默认模式的详细信息，请看下面的提示。但请注意，构造函数上的本地声明`@Autowired`优先于`@TestConstructor`和默认模式。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Changing the default test constructor autowire mode
#### ** Chinese **

改变默认的测试构造函数autowire模式
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The default *test constructor autowire mode* can be changed by setting the `spring.test.constructor.autowire.mode` JVM system property to `all`. Alternatively, the default mode may be changed via the `SpringProperties` mechanism.
#### ** Chinese **

可以通过设置`spring.test.constructor.autowire.mode` JVM系统属性为`all`来改变默认的*test构造函数的自动运行模式*。另外，也可以通过`SpringProperties`机制来改变默认模式。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

If the `spring.test.constructor.autowire.mode` property is not set, test class constructors will not be automatically autowired.
#### ** Chinese **

如果没有设置`spring.test.constructor.autowire.mode`属性，测试类构造函数将不会自动被自动触发。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

As of Spring Framework 5.2, `@TestConstructor` is only supported in conjunction with the `SpringExtension` for use with JUnit Jupiter. Note that the `SpringExtension` is often automatically registered for you – for example, when using annotations such as `@SpringJUnitConfig` and `@SpringJUnitWebConfig` or various test-related annotations from Spring Boot Test.
#### ** Chinese **

从Spring Framework 5.2开始，`@TestConstructor`只支持与`SpringExtension`配合使用JUnit Jupiter。请注意，`SpringExtension`通常会自动为您注册 - 例如，当使用诸如`@SpringJUnitConfig`和`@SpringJUnitWebConfig`等注释，或来自Spring Boot Test的各种测试相关注释时，`@SpringExtension`会自动为您注册。
<!-- tabs:end -->


### **`@EnabledIf`** 

<!-- tabs:start -->

#### ** English **

`@EnabledIf` is used to signal that the annotated JUnit Jupiter test class or test method is enabled and should be run if the supplied `expression` evaluates to `true`. Specifically, if the expression evaluates to `Boolean.TRUE` or a `String` equal to `true` (ignoring case), the test is enabled. When applied at the class level, all test methods within that class are automatically enabled by default as well.
#### ** Chinese **

`@EnabledIf`被用来表示，如果提供的`expression`求值为`true`，则表示JUnit Jupiter测试类或测试方法被启用，并且应该运行。具体来说，如果表达式`Boolean.TRUE`或`String`等于`true`（忽略情况），则测试被启用。当应用于类级时，该类中的所有测试方法也会默认自动启用。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Expressions can be any of the following:
#### ** Chinese **

表达式可以是以下任何一种：
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

- [`@IfProfileValue`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#integration-testing-annotations-junit4-ifprofilevalue)

- [`@ProfileValueSourceConfiguration`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#integration-testing-annotations-junit4-profilevaluesourceconfiguration)

- [`@Timed`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#integration-testing-annotations-junit4-timed)

- [`@Repeat`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#integration-testing-annotations-junit4-repeat)

- [`@SpringJUnitConfig`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#integration-testing-annotations-junit-jupiter-springjunitconfig)

- [`@SpringJUnitWebConfig`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#integration-testing-annotations-junit-jupiter-springjunitwebconfig)

- [`@TestConstructor`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#integration-testing-annotations-testconstructor)

- [`@EnabledIf`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#integration-testing-annotations-junit-jupiter-enabledif)

- [`@DisabledIf`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#integration-testing-annotations-junit-jupiter-disabledif)

- [Spring Expression Language](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#expressions) (SpEL) expression. For example: `@EnabledIf("#{systemProperties['os.name'].toLowerCase().contains('mac')}")`

- Placeholder for a property available in the Spring [`Environment`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-environment). For example: `@EnabledIf("${smoke.tests.enabled}")`

- Text literal. For example: `@EnabledIf("true")`

#### ** Chinese **

- [`@IfProfileValue`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#integration-testing-annotations-junit4-ifprofilevalue)

- [`@ProfileValueSourceConfiguration`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#integration-testing-annotations-junit4-profilevaluesourceconfiguration)

- [`@Timed`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#integration-testing-annotations-junit4-timed)

- [`@Repeat`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#integration-testing-annotations-junit4-repeat)

- [`@SpringJUnitConfig`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#integration-testing-annotations-junit-jupiter-springjunitconfig)

- [`@SpringJUnitWebConfig`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#integration-testing-annotations-junit-jupiter-springjunitwebconfig)

- [`@TestConstructor`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#integration-testing-annotations-testconstructor)

- [`@EnabledIf`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#integration-testing-annotations-junit-jupiter-enabledif)

- [`@DisabledIf`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#integration-testing-annotations-junit-jupiter-disabledif)

- [Spring Expression Language](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#expressions)(SpEL)表达式。例如： `@EnabledIf("#{systemProperties['os.name'].toLowerCase().contains('mac')}")`

- 在Spring [`Environment`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-environment)中可用的属性的占位符。 例如： `@EnabledIf("${smoke.tests.enabled}")`

- 文本字面意义。 例如： `@EnabledIf("true")`。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Note, however, that a text literal that is not the result of dynamic resolution of a property placeholder is of zero practical value, since `@EnabledIf("false")` is equivalent to `@Disabled` and `@EnabledIf("true")` is logically meaningless.
#### ** Chinese **

但是，请注意，不是属性占位符动态解析的结果的文本字面意义为零，因为`@EnabledIf("false")`相当于`@Disabled`，而`@EnabledIf("true")`在逻辑上是没有意义的。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can use `@EnabledIf` as a meta-annotation to create custom composed annotations. For example, you can create a custom `@EnabledOnMac` annotation as follows:
#### ** Chinese **

您可以使用 `@EnabledIf` 作为元注释来创建自定义的组成注释。例如，您可以创建一个自定义的 `@EnabledOnMac` 注解如下。
<!-- tabs:end -->


```java
@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@EnabledIf(
    expression = "#{systemProperties['os.name'].toLowerCase().contains('mac')}",
    reason = "Enabled on Mac OS"
)
public @interface EnabledOnMac {}
```

### **`@DisabledIf`** 

<!-- tabs:start -->

#### ** English **

`@DisabledIf` is used to signal that the annotated JUnit Jupiter test class or test method is disabled and should not be executed if the supplied `expression` evaluates to `true`. Specifically, if the expression evaluates to `Boolean.TRUE` or a `String` equal to `true` (ignoring case), the test is disabled. When applied at the class level, all test methods within that class are automatically disabled as well.
#### ** Chinese **

`@DisabledIf`用来表示如果所提供的`expression`值为`true`，则不应该被执行。具体来说，如果表达式`Boolean.TRUE`或`String`等于`true`（忽略情况），则测试被禁用。当应用于类级时，该类中的所有测试方法也会被自动禁用。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Expressions can be any of the following:
#### ** Chinese **

表达式可以是以下任何一种：
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

- [Spring Expression Language](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#expressions) (SpEL) expression. For example: `@DisabledIf("#{systemProperties['os.name'].toLowerCase().contains('mac')}")`

- Placeholder for a property available in the Spring [`Environment`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-environment). For example: `@DisabledIf("${smoke.tests.disabled}")`

- Text literal. For example: `@DisabledIf("true")`

#### ** Chinese **

- Spring Expression Language](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#expressions)(SpEL)表达式。例如：`@DisabledIf("#{systemProperties['os.name'].toLowerCase().contains('mac')}")`

- 在Spring[`Environment`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-environment)中可用的属性的占位符。例如： `@DisabledIf("${smoke.tests.disabled}")`

- 文本字面意义。例如： `@DisabledIf("true")`。
<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

Note, however, that a text literal that is not the result of dynamic resolution of a property placeholder is of zero practical value, since `@DisabledIf("true")` is equivalent to `@Disabled` and `@DisabledIf("false")` is logically meaningless.
#### ** Chinese **

但是，请注意，不是属性占位符动态解析的结果的文本字面意义为零，因为`@DisabledIf("true")`相当于`@Disabled`，而`@DisabledIf("false")`在逻辑上是没有意义的。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can use `@DisabledIf` as a meta-annotation to create custom composed annotations. For example, you can create a custom `@DisabledOnMac` annotation as follows:
#### ** Chinese **

您可以使用`@DisabledIf`作为元注释来创建自定义的组成注释。例如，您可以创建一个自定义的 `@DisabledOnMac` 注解如下。
<!-- tabs:end -->


```java
@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@DisabledIf(
    expression = "#{systemProperties['os.name'].toLowerCase().contains('mac')}",
    reason = "Disabled on Mac OS"
)
public @interface DisabledOnMac {}
```

### **3.4.5. Meta-Annotation Support for Testing** 

<!-- tabs:start -->

#### ** English **

You can use most test-related annotations as [meta-annotations](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-meta-annotations) to create custom composed annotations and reduce configuration duplication across a test suite.
#### ** Chinese **

你可以使用大多数与测试相关的注释作为[meta-annotations](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-meta-annotations)来创建自定义组成的注释，并减少整个测试套件的配置重复。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can use each of the following as a meta-annotation in conjunction with the [TestContext framework](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-framework).
#### ** Chinese **

你可以将以下每一个作为元注释与[TestContext框架](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-framework)结合使用。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

- `@BootstrapWith`

- `@ContextConfiguration`

- `@ContextHierarchy`

- `@ActiveProfiles`

- `@TestPropertySource`

- `@DirtiesContext`

- `@WebAppConfiguration`

- `@TestExecutionListeners`

- `@Transactional`

- `@BeforeTransaction`

- `@AfterTransaction`

- `@Commit`

- `@Rollback`

- `@Sql`

- `@SqlConfig`

- `@SqlMergeMode`

- `@SqlGroup`

- `@Repeat` *(only supported on JUnit 4)*

- `@Timed` *(only supported on JUnit 4)*

- `@IfProfileValue` *(only supported on JUnit 4)*

- `@ProfileValueSourceConfiguration` *(only supported on JUnit 4)*

- `@SpringJUnitConfig` *(only supported on JUnit Jupiter)*

- `@SpringJUnitWebConfig` *(only supported on JUnit Jupiter)*

- `@TestConstructor` *(only supported on JUnit Jupiter)*

- `@EnabledIf` *(only supported on JUnit Jupiter)*

- `@DisabledIf` *(only supported on JUnit Jupiter)*

#### ** Chinese **

- `@BootstrapWith`

- `@ContextConfiguration`

- `@ContextHierarchy`@ContextHierarchy</x>

- `@ActiveProfiles`

- `@TestPropertySource`

- `@DirtiesContext`@DirtiesContext</x>

- `@WebAppConfiguration`</x>

- `@TestExecutionListeners`@TestExecutionListeners</x>

- `@Transactional`</x>

- `@BeforeTransaction`

- `@AfterTransaction`</x>

- `@Commit`

- `@Rollback`

- `@Sql`

- `@SqlConfig`

- `@SqlMergeMode`

- `@SqlGroup`

- `@Repeat` *(仅支持JUnit 4)*。

- `@Timed` *(仅支持JUnit 4)*。

- `@IfProfileValue` *(仅支持JUnit 4)*。

- `@ProfileValueSourceConfiguration` *(仅在JUnit 4上支持)*。

- `@SpringJUnitConfig` *(仅在JUnit Jupiter上支持)*。

- `@SpringJUnitWebConfig` *(仅在JUnit Jupiter上支持)*。

- `@TestConstructor` *(仅在JUnit Jupiter上支持)*。

- `@EnabledIf` *(仅在JUnit Jupiter上支持)*。

- `@DisabledIf` *(仅在JUnit Jupiter上支持)*。

<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

Consider the following example:
#### ** Chinese **

请看下面的例子：
<!-- tabs:end -->


```java
@RunWith(SpringRunner.class)
@ContextConfiguration({"/app-config.xml", "/test-data-access-config.xml"})
@ActiveProfiles("dev")
@Transactional
public class OrderRepositoryTests { }

@RunWith(SpringRunner.class)
@ContextConfiguration({"/app-config.xml", "/test-data-access-config.xml"})
@ActiveProfiles("dev")
@Transactional
public class UserRepositoryTests { }
```

<!-- tabs:start -->

#### ** English **

If we discover that we are repeating the preceding configuration across our JUnit 4-based test suite, we can reduce the duplication by introducing a custom composed annotation that centralizes the common test configuration for Spring, as follows:
#### ** Chinese **

如果我们发现在整个基于JUnit 4的测试套件中，我们发现前面的配置都在重复，那么我们可以通过引入一个自定义的组成注释，将Spring的常用测试配置集中起来，减少重复，具体如下。
<!-- tabs:end -->


```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@ContextConfiguration({"/app-config.xml", "/test-data-access-config.xml"})
@ActiveProfiles("dev")
@Transactional
public @interface TransactionalDevTestConfig { }
```

<!-- tabs:start -->

#### ** English **

Then we can use our custom `@TransactionalDevTestConfig` annotation to simplify the configuration of individual JUnit 4 based test classes, as follows:
#### ** Chinese **

那么我们可以使用我们自定义的`@TransactionalDevTestConfig`注释来简化基于JUnit 4的单个测试类的配置，如下图所示。
<!-- tabs:end -->


```java
@RunWith(SpringRunner.class)
@TransactionalDevTestConfig
public class OrderRepositoryTests { }

@RunWith(SpringRunner.class)
@TransactionalDevTestConfig
public class UserRepositoryTests { }
```

<!-- tabs:start -->

#### ** English **

If we write tests that use JUnit Jupiter, we can reduce code duplication even further, since annotations in JUnit 5 can also be used as meta-annotations. Consider the following example:
#### ** Chinese **
如果我们编写的测试使用JUnit Jupiter，我们可以进一步减少代码重复，因为JUnit 5中的注释也可以作为元注释使用。考虑一下下面的例子。
<!-- tabs:end -->


```java
@ExtendWith(SpringExtension.class)
@ContextConfiguration({"/app-config.xml", "/test-data-access-config.xml"})
@ActiveProfiles("dev")
@Transactional
class OrderRepositoryTests { }

@ExtendWith(SpringExtension.class)
@ContextConfiguration({"/app-config.xml", "/test-data-access-config.xml"})
@ActiveProfiles("dev")
@Transactional
class UserRepositoryTests { }
```

<!-- tabs:start -->

#### ** English **

If we discover that we are repeating the preceding configuration across our JUnit Jupiter-based test suite, we can reduce the duplication by introducing a custom composed annotation that centralizes the common test configuration for Spring and JUnit Jupiter, as follows:
#### ** Chinese **

如果我们发现在整个基于JUnit Jupiter的测试套件中，我们发现前面的配置都在重复，那么我们可以通过引入一个自定义的组成注释，将Spring和JUnit Jupiter的通用测试配置集中在一起，减少重复，具体如下。
<!-- tabs:end -->


```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@ExtendWith(SpringExtension.class)
@ContextConfiguration({"/app-config.xml", "/test-data-access-config.xml"})
@ActiveProfiles("dev")
@Transactional
public @interface TransactionalDevTestConfig { }
```

<!-- tabs:start -->

#### ** English **

Then we can use our custom `@TransactionalDevTestConfig` annotation to simplify the configuration of individual JUnit Jupiter based test classes, as follows:
#### ** Chinese **

那么我们可以使用我们自定义的`@TransactionalDevTestConfig`注解来简化基于JUnit Jupiter的单个测试类的配置，如下图所示。
<!-- tabs:end -->


```java
@TransactionalDevTestConfig
class OrderRepositoryTests { }

@TransactionalDevTestConfig
class UserRepositoryTests { }
```

<!-- tabs:start -->

#### ** English **

Since JUnit Jupiter supports the use of `@Test`, `@RepeatedTest`, `ParameterizedTest`, and others as meta-annotations, you can also create custom composed annotations at the test method level. For example, if we wish to create a composed annotation that combines the `@Test` and `@Tag` annotations from JUnit Jupiter with the `@Transactional` annotation from Spring, we could create an `@TransactionalIntegrationTest` annotation, as follows:
#### ** Chinese **

由于JUnit Jupiter支持使用`@Test`、`@RepeatedTest`、`ParameterizedTest`等作为元注释，所以你也可以在测试方法级创建自定义的组成注释。例如，如果我们希望创建一个组合式注释，将 JUnit Jupiter 中的 `@Test` 和 `@Tag` 注解与 Spring 中的 `@Transactional` 注解结合起来，我们可以创建一个 `@TransactionalIntegrationTest` 注解，如下所示。
<!-- tabs:end -->


```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
@Transactional
@Tag("integration-test") // org.junit.jupiter.api.Tag
@Test // org.junit.jupiter.api.Test
public @interface TransactionalIntegrationTest { }
```

<!-- tabs:start -->

#### ** English **

Then we can use our custom `@TransactionalIntegrationTest` annotation to simplify the configuration of individual JUnit Jupiter based test methods, as follows:
#### ** Chinese **

那么我们可以使用我们自定义的`@TransactionalIntegrationTest`注释来简化基于JUnit Jupiter的单个测试方法的配置，具体如下。
<!-- tabs:end -->


```java
@TransactionalIntegrationTest
void saveOrder() { }

@TransactionalIntegrationTest
void deleteOrder() { }
```

<!-- tabs:start -->

#### ** English **

For further details, see the [Spring Annotation Programming Model](https://github.com/spring-projects/spring-framework/wiki/Spring-Annotation-Programming-Model) wiki page.
#### ** Chinese **

更多详情，请参阅[Spring Annotation Programming Model](https://github.com/spring-projects/spring-framework/wiki/Spring-Annotation-Programming-Model) wiki页面。
<!-- tabs:end -->



[下一章](Spring-Framework-5.2.6.RELEASE/Testing/3.5.%20Spring%20TestContext%20Framework.md)


[回目录](Spring-Framework-5.2.6.RELEASE/summary.md)

[回首页](/README)
