# 3.5. Spring TestContext Framework

<!-- tabs:start -->

#### ** English **

The Spring TestContext Framework (located in the `org.springframework.test.context` package) provides generic, annotation-driven unit and integration testing support that is agnostic of the testing framework in use. The TestContext framework also places a great deal of importance on convention over configuration, with reasonable defaults that you can override through annotation-based configuration.
#### ** Chinese **

Spring TestContext框架（位于`org.springframework.test.context`包中）提供了通用的、注解驱动的单元和集成测试支持，与正在使用的测试框架无关。TestContext框架也非常重视约定俗成而非配置，它提供了合理的默认值，你可以通过基于注释的配置来覆盖。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

In addition to generic testing infrastructure, the TestContext framework provides explicit support for JUnit 4, JUnit Jupiter (AKA JUnit 5), and TestNG. For JUnit 4 and TestNG, Spring provides `abstract` support classes. Furthermore, Spring provides a custom JUnit `Runner` and custom JUnit `Rules` for JUnit 4 and a custom `Extension` for JUnit Jupiter that let you write so-called POJO test classes. POJO test classes are not required to extend a particular class hierarchy, such as the `abstract` support classes.
#### ** Chinese **

除了通用测试基础架构之外，TestContext框架还提供了对JUnit 4、JUnit Jupiter（又名JUnit 5）和TestNG的显式支持。对于JUnit 4和TestNG，Spring提供了`abstract`支持类。此外，Spring还为JUnit 4提供了自定义的JUnit `Runner`和自定义的JUnit `Rules`，并为JUnit Jupiter提供了自定义的`Extension`，让你可以编写所谓的POJO测试类。POJO测试类不需要扩展特定的类层次结构，比如`abstract`支持类。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following section provides an overview of the internals of the TestContext framework. If you are interested only in using the framework and are not interested in extending it with your own custom listeners or custom loaders, feel free to go directly to the configuration ([context management](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-ctx-management), [dependency injection](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-fixture-di), [transaction management](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-tx)), [support classes](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-support-classes), and [annotation support](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#integration-testing-annotations) sections.
#### ** Chinese **

下面的章节提供了TestContext框架的内部概述。如果你只对使用该框架感兴趣，而对用自己的自定义监听器或自定义加载器来扩展该框架不感兴趣，可以直接到配置([[上下文管理](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-ctx-management), [依赖注入](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-fixture-di), [事务管理](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-tx)), [支持类](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-support-classes), 和[注释支持](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#integration-testing-annotations)部分。
<!-- tabs:end -->


### **3.5.1. Key Abstractions** 

<!-- tabs:start -->

#### ** English **

The core of the framework consists of the `TestContextManager` class and the `TestContext`, `TestExecutionListener`, and `SmartContextLoader` interfaces. A `TestContextManager` is created for each test class (for example, for the execution of all test methods within a single test class in JUnit Jupiter). The `TestContextManager`, in turn, manages a `TestContext` that holds the context of the current test. The `TestContextManager` also updates the state of the `TestContext` as the test progresses and delegates to `TestExecutionListener` implementations, which instrument the actual test execution by providing dependency injection, managing transactions, and so on. A `SmartContextLoader` is responsible for loading an `ApplicationContext` for a given test class. See the [javadoc](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/test/context/package-summary.html) and the Spring test suite for further information and examples of various implementations.
#### ** Chinese **

该框架的核心由`TestContextManager`类和`TestContext`、`TestExecutionListener`和`SmartContextLoader`接口组成。为每个测试类创建了一个`TestContextManager`（例如，在JUnit Jupiter中，为单个测试类中的所有测试方法的执行而创建的`TestContextManager`）。`TestContextManager`反过来，管理一个`TestContext`，它持有当前测试的上下文。`TestContextManager`也会随着测试的进行更新`TestContext`的状态，并委托给`TestExecutionListener`实现，后者通过提供依赖注入、管理事务等方式来辅助实际的测试执行。`SmartContextLoader`负责为给定的测试类加载一个`ApplicationContext`。请参阅[javadoc](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/test/context/package-summary.html)和Spring测试套件，了解更多信息和各种实现的例子。
<!-- tabs:end -->


### **`TestContext`** 

<!-- tabs:start -->

#### ** English **

`TestContext` encapsulates the context in which a test is executed (agnostic of the actual testing framework in use) and provides context management and caching support for the test instance for which it is responsible. The `TestContext` also delegates to a `SmartContextLoader` to load an `ApplicationContext` if requested.
#### ** Chinese **

`TestContext`封装了执行测试的上下文（与实际使用的测试框架无关），并为其负责的测试实例提供上下文管理和缓存支持。`TestContext`还委托给一个`SmartContextLoader`来加载`ApplicationContext`（如果请求的话）。
<!-- tabs:end -->


### **`TestContextManager`** 

<!-- tabs:start -->

#### ** English **

`TestContextManager` is the main entry point into the Spring TestContext Framework and is responsible for managing a single `TestContext` and signaling events to each registered `TestExecutionListener` at well-defined test execution points:
#### ** Chinese **

`TestContextManager`是Spring TestContext框架的主要入口，负责管理单一的`TestContext`，并在定义好的测试执行点向每个注册的`TestExecutionListener`发出事件信号。
<!-- tabs:end -->


### **`TestExecutionListener`** 

<!-- tabs:start -->

#### ** English **

`TestExecutionListener` defines the API for reacting to test-execution events published by the `TestContextManager` with which the listener is registered. See [`TestExecutionListener`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-tel-config)[ Configuration](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-tel-config).
#### ** Chinese **

`TestExecutionListener`定义了用于响应由`TestContextManager`发布的测试执行事件的API，该监听器注册了该监听器。参见 [`TestExecutionListener`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-tel-config)[ Configuration](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-tel-config)。
<!-- tabs:end -->


### **Context Loaders** 

<!-- tabs:start -->

#### ** English **

`ContextLoader` is a strategy interface for loading an `ApplicationContext` for an integration test managed by the Spring TestContext Framework. You should implement `SmartContextLoader` instead of this interface to provide support for component classes, active bean definition profiles, test property sources, context hierarchies, and `WebApplicationContext` support.
#### ** Chinese **

`ContextLoader`是一个策略接口，用于加载由Spring TestContext框架管理的集成测试的`ApplicationContext`。您应该实现`SmartContextLoader`而不是这个接口，以提供对组件类、活动Bean定义配置文件、测试属性源、上下文层次结构和`WebApplicationContext`的支持。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

`SmartContextLoader` is an extension of the `ContextLoader` interface that supersedes the original minimal `ContextLoader` SPI. Specifically, a `SmartContextLoader` can choose to process resource locations, component classes, or context initializers. Furthermore, a `SmartContextLoader` can set active bean definition profiles and test property sources in the context that it loads.
#### ** Chinese **

`SmartContextLoader`是`ContextLoader`接口的扩展，它取代了原来的最小化`ContextLoader` SPI。具体来说，`SmartContextLoader`可以选择处理资源位置、组件类或上下文初始化器。此外，`SmartContextLoader`可以在其加载的上下文中设置活动的Bean定义配置文件和测试属性源。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Spring provides the following implementations:
#### ** Chinese **

Spring提供了以下实现。
<!-- tabs:end -->


### **3.5.2. Bootstrapping the TestContext Framework** 

<!-- tabs:start -->

#### ** English **

The default configuration for the internals of the Spring TestContext Framework is sufficient for all common use cases. However, there are times when a development team or third party framework would like to change the default `ContextLoader`, implement a custom `TestContext` or `ContextCache`, augment the default sets of `ContextCustomizerFactory` and `TestExecutionListener` implementations, and so on. For such low-level control over how the TestContext framework operates, Spring provides a bootstrapping strategy.
#### ** Chinese **

Spring TestContext框架内部的默认配置对于所有常见的用例来说已经足够了。然而，有时开发团队或第三方框架希望改变默认的`ContextLoader`，实现一个自定义的`TestContext`或`ContextCache`，增强默认的`ContextCustomizerFactory`和`TestExecutionListener`实现，等等。对于这种对TestContext框架如何运行的低级控制，Spring提供了一个引导策略。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

`TestContextBootstrapper` defines the SPI for bootstrapping the TestContext framework. A `TestContextBootstrapper` is used by the `TestContextManager` to load the `TestExecutionListener` implementations for the current test and to build the `TestContext` that it manages. You can configure a custom bootstrapping strategy for a test class (or test class hierarchy) by using `@BootstrapWith`, either directly or as a meta-annotation. If a bootstrapper is not explicitly configured by using `@BootstrapWith`, either the `DefaultTestContextBootstrapper` or the `WebTestContextBootstrapper` is used, depending on the presence of `@WebAppConfiguration`.
#### ** Chinese **

`TestContextBootstrapper`定义了用于引导TestContext框架的SPI。`TestContextBootstrapper`被`TestContextManager`用于加载当前测试的`TestExecutionListener`实现，并构建它管理的`TestContext`。你可以通过使用`@BootstrapWith`为测试类（或测试类层次结构）配置一个自定义的bootstrapping策略，可以直接使用`@BootstrapWith`，也可以作为元注释。如果没有通过使用 `@BootstrapWith`显式配置 Bootstrapper，则会使用 `DefaultTestContextBootstrapper`或 `WebTestContextBootstrapper`，这取决于 `@WebAppConfiguration`的存在。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Since the `TestContextBootstrapper` SPI is likely to change in the future (to accommodate new requirements), we strongly encourage implementers not to implement this interface directly but rather to extend `AbstractTestContextBootstrapper` or one of its concrete subclasses instead.
#### ** Chinese **

由于`TestContextBootstrapper` SPI在未来可能会发生变化（为了适应新的需求），我们强烈鼓励实现者不要直接实现这个接口，而应该扩展`AbstractTestContextBootstrapper`或其具体的子类之一。
<!-- tabs:end -->


### **3.5.3.** **`TestExecutionListener`** ** Configuration** 

<!-- tabs:start -->

#### ** English **

Spring provides the following `TestExecutionListener` implementations that are registered by default, exactly in the following order:
#### ** Chinese **

Spring提供了以下`TestExecutionListener`实现，这些实现都是默认注册的，具体顺序如下。
<!-- tabs:end -->


### **Registering** **`TestExecutionListener`** ** Implementations** 

<!-- tabs:start -->

#### ** English **

You can register `TestExecutionListener` implementations for a test class and its subclasses by using the `@TestExecutionListeners` annotation. See [annotation support](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#integration-testing-annotations) and the javadoc for [`@TestExecutionListeners`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/test/context/TestExecutionListeners.html) for details and examples.
#### ** Chinese **

你可以通过使用 `@TestExecutionListeners` 注解为测试类及其子类注册 `TestExecutionListener`实现。有关详细信息和示例，请参阅 [注解支持](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#integration-testing-annotations)和 [`@TestExecutionListeners`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/test/context/TestExecutionListeners.html)的 javadoc。
<!-- tabs:end -->


### **Automatic Discovery of Default** **`TestExecutionListener`** ** Implementations** 

<!-- tabs:start -->

#### ** English **

Registering `TestExecutionListener` implementations by using `@TestExecutionListeners` is suitable for custom listeners that are used in limited testing scenarios. However, it can become cumbersome if a custom listener needs to be used across an entire test suite. This issue is addressed through support for automatic discovery of default `TestExecutionListener` implementations through the `SpringFactoriesLoader` mechanism.
#### ** Chinese **

通过使用`@TestExecutionListeners`来注册`TestExecutionListenener`实现，适用于在有限的测试场景中使用的自定义监听器。然而，如果需要在整个测试套件中使用自定义监听器，则会变得很麻烦。这个问题通过支持通过`SpringFactoriesLoader`机制自动发现默认的`TestExecutionListener`实现来解决。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Specifically, the `spring-test` module declares all core default `TestExecutionListener` implementations under the `org.springframework.test.context.TestExecutionListener` key in its `META-INF/spring.factories` properties file. Third-party frameworks and developers can contribute their own `TestExecutionListener` implementations to the list of default listeners in the same manner through their own `META-INF/spring.factories` properties file.
#### ** Chinese **

具体来说，`spring-test` "模块在其 `META-INF/spring.factories`属性文件中的 `org.springframework.test.context.TestExecutionListener` 键下声明了所有核心默认的 `TestExecutionListener` "实现。第三方框架和开发者可以通过自己的 `META-INF/spring.factories` 属性文件，以同样的方式将自己的 `TestExecutionListener` 实现贡献到默认监听器列表中。

<!-- tabs:end -->


### **Ordering** **`TestExecutionListener`** ** Implementations** 

<!-- tabs:start -->

#### ** English **

When the TestContext framework discovers default `TestExecutionListener` implementations through the [aforementioned](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-tel-config-automatic-discovery) `SpringFactoriesLoader` mechanism, the instantiated listeners are sorted by using Spring’s `AnnotationAwareOrderComparator`, which honors Spring’s `Ordered` interface and `@Order` annotation for ordering. `AbstractTestExecutionListener` and all default `TestExecutionListener` implementations provided by Spring implement `Ordered` with appropriate values. Third-party frameworks and developers should therefore make sure that their default `TestExecutionListener` implementations are registered in the proper order by implementing `Ordered` or declaring `@Order`. See the javadoc for the `getOrder()` methods of the core default `TestExecutionListener` implementations for details on what values are assigned to each core listener.
#### ** Chinese **

当TestContext框架通过[前述](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-tel-config-automatic-discovery)`SpringFactoriesLoader`机制发现默认的`TestExecutionListener`实现时，通过使用Spring的`AnnotationAwareOrderComparator`对实例化的监听器进行排序，该机制尊重Spring的`Ordered`接口和`@Order`注释进行排序。 `AbstractTestExecutionListener`和Spring提供的所有默认的`TestExecutionListener`实现都用适当的值实现了`Ordered`。因此，第三方框架和开发人员应该确保其默认的 `TestExecutionListener`实现通过实现`Ordered`或声明`@Order`，以适当的顺序注册。有关分配给每个核心默认的 `TestExecutionListener`实现的 `getOrder()` 方法的 javadoc，请参见关于分配给每个核心监听器的值的详细信息。
<!-- tabs:end -->


### **Merging** **`TestExecutionListener`** ** Implementations** 

<!-- tabs:start -->

#### ** English **

If a custom `TestExecutionListener` is registered via `@TestExecutionListeners`, the default listeners are not registered. In most common testing scenarios, this effectively forces the developer to manually declare all default listeners in addition to any custom listeners. The following listing demonstrates this style of configuration:
#### ** Chinese **

如果通过`@TestExecutionListeners`注册了一个自定义的`TestExecutionListener`，那么默认的监听器就不会被注册。在大多数常见的测试场景中，这有效地迫使开发人员除了任何自定义监听器外，还必须手动声明所有的默认监听器。下面的列表演示了这种配置风格。
<!-- tabs:end -->


```java
@ContextConfiguration
@TestExecutionListeners({
    MyCustomTestExecutionListener.class,
    ServletTestExecutionListener.class,
    DirtiesContextBeforeModesTestExecutionListener.class,
    DependencyInjectionTestExecutionListener.class,
    DirtiesContextTestExecutionListener.class,
    TransactionalTestExecutionListener.class,
    SqlScriptsTestExecutionListener.class
})
class MyTest {
    // class body...
}
```

<!-- tabs:start -->

#### ** English **

The challenge with this approach is that it requires that the developer know exactly which listeners are registered by default. Moreover, the set of default listeners can change from release to release — for example, `SqlScriptsTestExecutionListener` was introduced in Spring Framework 4.1, and `DirtiesContextBeforeModesTestExecutionListener` was introduced in Spring Framework 4.2. Furthermore, third-party frameworks like Spring Boot and Spring Security register their own default `TestExecutionListener` implementations by using the aforementioned [automatic discovery mechanism](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-tel-config-automatic-discovery).
#### ** Chinese **

这种方法的挑战在于，它要求开发者必须准确地知道哪些监听器是默认注册的。此外，默认监听器的集合会随着版本的变化而变化--例如，`SqlScriptsTestExecutionListener`是在Spring Framework 4.1中引入的，而`DirtiesContextBeforeModesTestExecutionListener`是在Spring Framework 4.2中引入的。此外，像Spring Boot和Spring Security这样的第三方框架通过使用上述的[自动发现机制](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-tel-config-automatic-discovery)注册自己的默认`TestExecutionListener`实现。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

To avoid having to be aware of and re-declare all default listeners, you can set the `mergeMode` attribute of `@TestExecutionListeners` to `MergeMode.MERGE_WITH_DEFAULTS`. `MERGE_WITH_DEFAULTS` indicates that locally declared listeners should be merged with the default listeners. The merging algorithm ensures that duplicates are removed from the list and that the resulting set of merged listeners is sorted according to the semantics of `AnnotationAwareOrderComparator`, as described in [Ordering ](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-tel-config-ordering)[`TestExecutionListener`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-tel-config-ordering)[ Implementations](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-tel-config-ordering). If a listener implements `Ordered` or is annotated with `@Order`, it can influence the position in which it is merged with the defaults. Otherwise, locally declared listeners are appended to the list of default listeners when merged.
#### ** Chinese **

为了避免意识到并重新声明所有默认监听器，可以将 `@TestExecutionListeners`的`mergeMode`属性设置为`MergeMode.MERGE_WITH_DEFAULTS`。 `MERGE_WITH_DEFAULTS`表示应将本地声明的监听器与默认监听器合并。合并算法确保从列表中删除重复的监听器，并根据`AnnotationAwareOrderComparator`的语义对合并后的监听器集进行排序，如[Ording](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-tel-config-ordering)[`TestExecutionListener`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-tel-config-ordering)[ Implementations](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-tel-config-ordering)中描述的那样。如果一个监听器实现了`Ordered`，或者被注释为`@Order`，它可以影响它与默认合并的位置。否则，当合并时，本地声明的监听器会被附加到默认监听器列表中。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

For example, if the `MyCustomTestExecutionListener` class in the previous example configures its `order` value (for example, `500`) to be less than the order of the `ServletTestExecutionListener` (which happens to be `1000`), the `MyCustomTestExecutionListener` can then be automatically merged with the list of defaults in front of the `ServletTestExecutionListener`, and the previous example could be replaced with the following:
#### ** Chinese **

例如，如果前面例子中的 `MyCustomTestExecutionListener`类配置的`order`值（例如，`500`）小于`ServletTestExecutionListener`的顺序（恰好是`1000`），那么，我们就可以将其`MyCustomTestExecutionListener`类配置为`order`值（例如，`500`）。`MyCustomTestExecutionListener`可以自动合并到`ServletTestExecutionListener`前面的默认列表中，然后可以用下面的例子来代替前面的例子。
<!-- tabs:end -->


```java
@ContextConfiguration
@TestExecutionListeners(
    listeners = MyCustomTestExecutionListener.class,
    mergeMode = MERGE_WITH_DEFAULTS
)
class MyTest {
    // class body...
}
```

### **3.5.4. Test Execution Events** 

<!-- tabs:start -->

#### ** English **

The `EventPublishingTestExecutionListener` introduced in Spring Framework 5.2 offers an alternative approach to implementing a custom `TestExecutionListener`. Components in the test’s `ApplicationContext` can listen to the following events published by the `EventPublishingTestExecutionListener`, each of which corresponds to a method in the `TestExecutionListener` API.
#### ** Chinese **

Spring Framework 5.2中引入的`EventPublishingTestExecutionListener`提供了一种实现自定义`TestExecutionListener`的替代方法。测试的`ApplicationContext`中的组件可以监听由`EventPublishingTestExecutionListener`发布的以下事件，每个事件都对应于`TestExecutionListener` API中的一个方法。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

- Prior to any “before class” or “before all” methods of a particular testing framework.

- Test instance post-processing.

- Prior to any “before” or “before each” methods of a particular testing framework.

- Immediately before execution of the test method but after test setup.

- Immediately after execution of the test method but before test tear down.

- After any “after” or “after each” methods of a particular testing framework.

- After any “after class” or “after all” methods of a particular testing framework.

- `DelegatingSmartContextLoader`: One of two default loaders, it delegates internally to an `AnnotationConfigContextLoader`, a `GenericXmlContextLoader`, or a `GenericGroovyXmlContextLoader`, depending either on the configuration declared for the test class or on the presence of default locations or default configuration classes. Groovy support is enabled only if Groovy is on the classpath.

- `WebDelegatingSmartContextLoader`: One of two default loaders, it delegates internally to an `AnnotationConfigWebContextLoader`, a `GenericXmlWebContextLoader`, or a `GenericGroovyXmlWebContextLoader`, depending either on the configuration declared for the test class or on the presence of default locations or default configuration classes. A web `ContextLoader` is used only if `@WebAppConfiguration` is present on the test class. Groovy support is enabled only if Groovy is on the classpath.

- `AnnotationConfigContextLoader`: Loads a standard `ApplicationContext` from component classes.

- `AnnotationConfigWebContextLoader`: Loads a `WebApplicationContext` from component classes.

- `GenericGroovyXmlContextLoader`: Loads a standard `ApplicationContext` from resource locations that are either Groovy scripts or XML configuration files.

- `GenericGroovyXmlWebContextLoader`: Loads a `WebApplicationContext` from resource locations that are either Groovy scripts or XML configuration files.

- `GenericXmlContextLoader`: Loads a standard `ApplicationContext` from XML resource locations.

- `GenericXmlWebContextLoader`: Loads a `WebApplicationContext` from XML resource locations.

- `GenericPropertiesContextLoader`: Loads a standard `ApplicationContext` from Java properties files.

- `ServletTestExecutionListener`: Configures Servlet API mocks for a `WebApplicationContext`.

- `DirtiesContextBeforeModesTestExecutionListener`: Handles the `@DirtiesContext` annotation for “before” modes.

- `DependencyInjectionTestExecutionListener`: Provides dependency injection for the test instance.

- `DirtiesContextTestExecutionListener`: Handles the `@DirtiesContext` annotation for “after” modes.

- `TransactionalTestExecutionListener`: Provides transactional test execution with default rollback semantics.

- `SqlScriptsTestExecutionListener`: Runs SQL scripts configured by using the `@Sql` annotation.

- `EventPublishingTestExecutionListener`: Publishes test execution events to the test’s `ApplicationContext` (see [Test Execution Events](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-test-execution-events)).

- `BeforeTestClassEvent`

- `PrepareTestInstanceEvent`

- `BeforeTestMethodEvent`

- `BeforeTestExecutionEvent`

- `AfterTestExecutionEvent`

- `AfterTestMethodEvent`

- `AfterTestClassEvent`

#### ** Chinese **

- 在特定测试框架的任何 "类前 "或 "所有 "方法之前。

- 测试实例的后处理。

- 在特定测试框架的任何 "类前 "或 "每个 "方法之前。

- 紧接在测试方法执行之前，但在测试设置之后。

- 在测试方法执行之后，但在测试拆解之前。

- 在特定测试框架的任何 "后 "或 "每个 "方法之后。

- 在特定测试框架的任何 "类后 "或 "所有 "方法之后。

- `DelegatingSmartContextLoader`。两种默认加载器之一，它在内部委托给`AnnotationConfigContextLoader`、`GenericXmlContextLoader`或`GenericGroovyXmlContextLoader`，这取决于测试类声明的配置或默认位置或默认配置类的存在。只有当Groovy在classpath上时，才会启用Groovy支持。

- `WebDelegatingSmartContextLoader`。两种默认加载器之一，它在内部委托给`AnnotationConfigWebContextLoader`、`GenericXmlWebContextLoader`或`GenericGroovyXmlWebContextLoader`，这取决于测试类声明的配置或默认位置或默认配置类的存在。只有在测试类上存在`@WebAppConfiguration`时，才会使用Web `ContextLoader`。只有当Groovy在classpath上时，才会启用Groovy支持。

- `AnnotationConfigContextLoader`。从组件类中加载一个标准的`ApplicationContext`。

- `AnnotationConfigWebContextLoader`：从组件类中加载一个标准的`ApplicationContext`。从组件类中加载`WebApplicationContext`：从组件类中加载一个`WebApplicationContext`。

- `GenericGroovyXmlContextLoader`：从组件类中加载一个`WebApplicationContext`。从Groovy脚本或XML配置文件的资源位置加载一个标准的`ApplicationContext`。

- `GenericGroovyXmlWebContextLoader`：加载一个标准的`ApplicationContext`。从Groovy脚本或XML配置文件的资源位置加载一个`WebApplicationContext`。

- `GenericXmlContextLoader`：加载一个标准的`WebApplicationContext`。从 XML 资源位置加载标准的 `ApplicationContext`ApplicationContext</x>。

- `GenericXmlWebContextLoader`：加载一个标准的`ApplicationContext`。从 XML 资源位置加载一个 `WebApplicationContext`，从 XML 资源位置加载一个 `WebApplicationContext`。

- `GenericPropertiesContextLoader`：加载一个标准的`WebApplicationContext`。从Java属性文件中加载一个标准的`ApplicationContext`。

- `ServletTestExecutionListener`：从Java属性文件中加载标准的`ApplicationContext`。为`WebApplicationContext`配置Servlet API mocks。

- `DirtiesContextBeforeModesTestExecutionListener`：处理`@DirtiesContext`注解的 "前 "模式。

- `DependencyInjectionTestExecutionListener`: 为测试实例提供依赖注入。

- `DirtiesContextTestExecutionListener`：处理 "后 "模式的`@DirtiesContext`注释。

- `TransactionalTestExecutionListener`: 提供具有默认回滚语义的事务性测试执行。

- `SqlScriptsTestExecutionListener`：提供了默认的回滚语义。运行通过使用`@Sql`注释配置的SQL脚本。

- `EventPublishingTestExecutionListener`：将测试执行事件发布到测试执行服务器上。将测试执行事件发布到测试的`ApplicationContext`（参见[测试执行事件](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-test-execution-events)）。

- `BeforeTestClassEvent`：将测试执行事件发布到测试的`ApplicationContext`（见[测试执行事件]()）。

- `PrepareTestInstanceEvent`

- `BeforeTestMethodEvent`

- `BeforeTestExecutionEvent`。

- `AfterTestExecutionEvent`

- `AfterTestMethodEvent`

- `AfterTestClassEvent`

<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

These events are only published if the `ApplicationContext` has already been loaded.
#### ** Chinese **
这些事件只有在`ApplicationContext`已经加载了的情况下才会发布。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

These events may be consumed for various reasons, such as resetting mock beans or tracing test execution. One advantage of consuming test execution events rather than implementing a custom `TestExecutionListener` is that test execution events may be consumed by any Spring bean registered in the test `ApplicationContext`, and such beans may benefit directly from dependency injection and other features of the `ApplicationContext`. In contrast, a `TestExecutionListener` is not a bean in the `ApplicationContext`.
#### ** Chinese **
这些事件可能会因为各种原因被消耗，比如重置mock bean或跟踪测试执行。消耗测试执行事件而不是实现自定义的 `TestExecutionListener` 的一个优点是，测试执行事件可以被任何在测试 `ApplicationContext` 中注册的Spring Bean所消耗，而且这些bean可以直接从依赖注入和 `ApplicationContext` 的其他特性中受益。相反，`TestExecutionListener` 不是 `ApplicationContext` 中的Bean。

<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

In order to listen to test execution events, a Spring bean may choose to implement the `org.springframework.context.ApplicationListener` interface. Alternatively, listener methods can be annotated with `@EventListener` and configured to listen to one of the particular event types listed above (see [Annotation-based Event Listeners](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#context-functionality-events-annotation)). Due to the popularity of this approach, Spring provides the following dedicated `@EventListener` annotations to simplify registration of test execution event listeners. These annotations reside in the `org.springframework.test.context.event.annotation` package.
#### ** Chinese **

为了监听测试执行事件，Spring Bean可以选择实现`org.springframework.context.ApplicationListener`接口。或者，可以用`@EventListener`注释监听器方法，并配置为监听上面列出的特定事件类型之一（参见[基于注释的事件监听器](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#context-functionality-events-annotation)）。由于这种方法的普及，Spring提供了以下专用的 `@EventListener`注释，以简化测试执行事件监听器的注册。这些注释存在于`org.springframework.test.context.event.annotation`包中。
<!-- tabs:end -->


### **Exception Handling** 

<!-- tabs:start -->

#### ** English **

By default, if a test execution event listener throws an exception while consuming an event, that exception will propagate to the underlying testing framework in use (such as JUnit or TestNG). For example, if the consumption of a `BeforeTestMethodEvent` results in an exception, the corresponding test method will fail as a result of the exception. In contrast, if an asynchronous test execution event listener throws an exception, the exception will not propagate to the underlying testing framework. For further details on asynchronous exception handling, consult the class-level javadoc for `@EventListener`.
#### ** Chinese **

默认情况下，如果一个测试执行事件监听器在消耗一个事件时抛出一个异常，该异常将传播到正在使用的底层测试框架（如JUnit或TestNG）。例如，如果消耗一个`BeforeTestMethodEvent`导致一个异常，那么相应的测试方法将由于该异常而失败。相反，如果异步测试执行事件监听器抛出一个异常，则该异常不会传播到底层测试框架。有关异步异常处理的更多细节，请参考类级 javadoc `@EventListener`。
<!-- tabs:end -->


### **Asynchronous Listeners** 

<!-- tabs:start -->

#### ** English **

If you want a particular test execution event listener to process events asynchronously, you can use Spring’s [regular ](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#scheduling-annotation-support-async)[`@Async`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#scheduling-annotation-support-async)[ support](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#scheduling-annotation-support-async). For further details, consult the class-level javadoc for `@EventListener`.
#### ** Chinese **

如果你想让特定的测试执行事件监听器异步处理事件，可以使用Spring的[regular](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#scheduling-annotation-support-async)[`@Async`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#scheduling-annotation-support-async)[ support](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/integration.html#scheduling-annotation-support-async)。更多详情，请参考类级 javadoc `@EventListener`。
<!-- tabs:end -->


### **3.5.5. Context Management** 

<!-- tabs:start -->

#### ** English **

Each `TestContext` provides context management and caching support for the test instance for which it is responsible. Test instances do not automatically receive access to the configured `ApplicationContext`. However, if a test class implements the `ApplicationContextAware` interface, a reference to the `ApplicationContext` is supplied to the test instance. Note that `AbstractJUnit4SpringContextTests` and `AbstractTestNGSpringContextTests` implement `ApplicationContextAware` and, therefore, provide access to the `ApplicationContext` automatically.
#### ** Chinese **

每个`TestContext`都为其负责的测试实例提供了上下文管理和缓存支持。测试实例不会自动接收到配置的`ApplicationContext`的访问权限。但是，如果测试类实现了`ApplicationContextAware`接口，则会向测试实例提供一个对`ApplicationContext`的引用。请注意，`AbstractJUnit4SpringContextTests`和`AbstractTestNGSpringContextTests`实现了`ApplicationContextAware`，因此，自动提供了对`ApplicationContext`的访问。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

@Autowired ApplicationContext
#### ** Chinese **@Autowired ApplicationContext
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

As an alternative to implementing the `ApplicationContextAware` interface, you can inject the application context for your test class through the `@Autowired` annotation on either a field or setter method, as the following example shows:
#### ** Chinese **

作为实现`ApplicationContextAware`接口的替代方案，你可以通过在字段或setter方法上的`@Autowired`注释为你的测试类注入应用上下文，如下例所示。
<!-- tabs:end -->


```java
@SpringJUnitConfig
class MyTest {

    @Autowired (1)
    ApplicationContext applicationContext;

    // class body...
}

//(1) Injecting the ApplicationContext.
(1) Injecting the ApplicationContext.
(1) Configuring the WebApplicationContext.
(2) Injecting the WebApplicationContext.
(1) Configuring the WebApplicationContext.
(2) Injecting the WebApplicationContext.
```

<!-- tabs:start -->

#### ** English **

Similarly, if your test is configured to load a `WebApplicationContext`, you can inject the web application context into your test, as follows:
#### ** Chinese **

同样，如果你的测试被配置为加载一个`WebApplicationContext`，你可以将Web应用程序上下文注入到你的测试中，如下所示。
<!-- tabs:end -->


```java
@SpringJUnitWebConfig (1)
class MyWebAppTest {

    @Autowired (2)
    WebApplicationContext wac;

    // class body...
}

//(1) Injecting the ApplicationContext.
(1) Injecting the ApplicationContext.
(1) Configuring the WebApplicationContext.
(2) Injecting the WebApplicationContext.
(1) Configuring the WebApplicationContext.
(2) Injecting the WebApplicationContext.
```

<!-- tabs:start -->

#### ** English **

Dependency injection by using `@Autowired` is provided by the `DependencyInjectionTestExecutionListener`, which is configured by default (see [Dependency Injection of Test Fixtures](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-fixture-di)).
#### ** Chinese **

使用`@Autowired`的依赖注入是由`DependencyInjectionTestExecutionListener`提供的，该Listener是默认配置的（参见[测试夹具的依赖注入](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-fixture-di)）。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Test classes that use the TestContext framework do not need to extend any particular class or implement a specific interface to configure their application context. Instead, configuration is achieved by declaring the `@ContextConfiguration` annotation at the class level. If your test class does not explicitly declare application context resource locations or component classes, the configured `ContextLoader` determines how to load a context from a default location or default configuration classes. In addition to context resource locations and component classes, an application context can also be configured through application context initializers.
#### ** Chinese **

使用TestContext框架的测试类不需要扩展任何特定的类，也不需要实现特定的接口来配置应用上下文。相反，配置是通过在类级声明`@ContextConfiguration`注释来实现的。如果你的测试类没有明确声明应用上下文资源位置或组件类，那么配置的`ContextLoader`决定了如何从默认位置或默认配置类中加载上下文。除了上下文资源位置和组件类之外，还可以通过应用上下文初始化器来配置应用上下文。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following sections explain how to use Spring’s `@ContextConfiguration` annotation to configure a test `ApplicationContext` by using XML configuration files, Groovy scripts, component classes (typically `@Configuration` classes), or context initializers. Alternatively, you can implement and configure your own custom `SmartContextLoader` for advanced use cases.
#### ** Chinese **

下面的章节将介绍如何使用Spring的`@ContextConfiguration`注释，通过使用XML配置文件、Groovy脚本、组件类（通常是`@Configuration`类）或上下文初始化器来配置测试`ApplicationContext`。另外，您还可以实现和配置您自己的自定义 `SmartContextLoader`SmartContextLoader</x>，用于高级用例。
<!-- tabs:end -->


### **Context Configuration with XML resources** 

<!-- tabs:start -->

#### ** English **

To load an `ApplicationContext` for your tests by using XML configuration files, annotate your test class with `@ContextConfiguration` and configure the `locations` attribute with an array that contains the resource locations of XML configuration metadata. A plain or relative path (for example, `context.xml`) is treated as a classpath resource that is relative to the package in which the test class is defined. A path starting with a slash is treated as an absolute classpath location (for example, `/org/example/config.xml`). A path that represents a resource URL (i.e., a path prefixed with `classpath:`, `file:`, `http:`, etc.) is used *as is*.
#### ** Chinese **

要通过使用 XML 配置文件为测试加载 `ApplicationContext`，请用 `@ContextConfiguration`注释你的测试类，并配置 `locations` 属性，其中包含 XML 配置元数据的资源位置的数组。普通或相对路径（例如，`context.xml`）被视为相对于定义测试类的包的classpath资源。以斜线开头的路径被视为绝对的classpath位置（例如，`/org/example/config.xml`）。表示资源 URL 的路径（即，以 `classpath:`、`file:`、`http:`等为前缀的路径）被*原样使用。
<!-- tabs:end -->


```java
@ExtendWith(SpringExtension.class)
// ApplicationContext will be loaded from "/app-config.xml" and
// "/test-config.xml" in the root of the classpath
@ContextConfiguration(locations={"/app-config.xml", "/test-config.xml"}) (1)
class MyTest {
    // class body...
}

//(1) Setting the locations attribute to a list of XML files.
```

<!-- tabs:start -->

#### ** English **

`@ContextConfiguration` supports an alias for the `locations` attribute through the standard Java `value` attribute. Thus, if you do not need to declare additional attributes in `@ContextConfiguration`, you can omit the declaration of the `locations` attribute name and declare the resource locations by using the shorthand format demonstrated in the following example:
#### ** Chinese **

`@ContextConfiguration`支持通过标准的Java `value`属性为`locations`属性提供别名。因此，如果不需要在`@ContextConfiguration`中声明额外的属性，可以省略声明`locations`属性名，使用下面的例子中的速记格式来声明资源位置。
<!-- tabs:end -->


```java
@ExtendWith(SpringExtension.class)
@ContextConfiguration({"/app-config.xml", "/test-config.xml"}) (1)
class MyTest {
    // class body...
}

//(1) Specifying XML files without using the location attribute.
```

<!-- tabs:start -->

#### ** English **

If you omit both the `locations` and the `value` attributes from the `@ContextConfiguration` annotation, the TestContext framework tries to detect a default XML resource location. Specifically, `GenericXmlContextLoader` and `GenericXmlWebContextLoader` detect a default location based on the name of the test class. If your class is named `com.example.MyTest`, `GenericXmlContextLoader` loads your application context from `"classpath:com/example/MyTest-context.xml"`. The following example shows how to do so:
#### ** Chinese **

如果从`@ContextConfiguration`注解中省略了`locations`和`value`属性，TestContext框架会尝试检测一个默认的XML资源位置。具体来说，`GenericXmlContextLoader`和`GenericXmlWebContextLoader`根据测试类的名称检测默认位置。如果您的类被命名为 `com.example.MyTest`，`GenericXmlContextLoader`将从`"classpath:com/example/MyTest-context.xml"`中加载您的应用程序上下文。下面的示例显示了如何做到这一点。
<!-- tabs:end -->


```java
@ExtendWith(SpringExtension.class)
// ApplicationContext will be loaded from
// "classpath:com/example/MyTest-context.xml"
@ContextConfiguration (1)
class MyTest {
    // class body...
}

//(1) Loading configuration from the default location.
```

### **Context Configuration with Groovy Scripts** 

<!-- tabs:start -->

#### ** English **

To load an `ApplicationContext` for your tests by using Groovy scripts that use the [Groovy Bean Definition DSL](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#groovy-bean-definition-dsl), you can annotate your test class with `@ContextConfiguration` and configure the `locations` or `value` attribute with an array that contains the resource locations of Groovy scripts. Resource lookup semantics for Groovy scripts are the same as those described for [XML configuration files](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-ctx-management-xml).
#### ** Chinese **

要通过使用使用[Groovy Bean Definition DSL](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#groovy-bean-definition-dsl)的Groovy脚本为测试加载`ApplicationContext`，可以用`@ContextConfiguration`来注释测试类，并用包含Groovy脚本的资源位置的数组来配置`locations`或`value`属性。Groovy脚本的资源查找语义与[XML配置文件](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-ctx-management-xml)中描述的相同。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Enabling Groovy script support
#### ** Chinese **

启用Groovy脚本支持
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Support for using Groovy scripts to load an `ApplicationContext` in the Spring TestContext Framework is enabled automatically if Groovy is on the classpath.
#### ** Chinese **

如果Groovy位于classpath上，则支持使用Groovy脚本加载Spring TestContext框架中的`ApplicationContext`。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following example shows how to specify Groovy configuration files:
#### ** Chinese **

下面的例子显示了如何指定Groovy配置文件。
<!-- tabs:end -->


```java
@ExtendWith(SpringExtension.class)
// ApplicationContext will be loaded from "/AppConfig.groovy" and
// "/TestConfig.groovy" in the root of the classpath
@ContextConfiguration({"/AppConfig.groovy", "/TestConfig.Groovy"}) (1)
class MyTest {
    // class body...
}
```

<!-- tabs:start -->

#### ** English **

If you omit both the `locations` and `value` attributes from the `@ContextConfiguration` annotation, the TestContext framework tries to detect a default Groovy script. Specifically, `GenericGroovyXmlContextLoader` and `GenericGroovyXmlWebContextLoader` detect a default location based on the name of the test class. If your class is named `com.example.MyTest`, the Groovy context loader loads your application context from `"classpath:com/example/MyTestContext.groovy"`. The following example shows how to use the default:
#### ** Chinese **

如果你从`@ContextConfiguration`注释中省略了`locations`和`value`属性，TestContext框架会尝试检测一个默认的Groovy脚本。具体来说，`GenericGroovyXmlContextLoader`和`GenericGroovyXmlWebContextLoader`会根据测试类的名称来检测默认位置。如果您的类被命名为 `com.example.MyTest`，Groovy 上下文加载器将从 `"classpath:com/example/MyTestContext.groovy"`中加载您的应用程序上下文。下面的例子显示了如何使用默认的。
<!-- tabs:end -->


```java
@ExtendWith(SpringExtension.class)
// ApplicationContext will be loaded from
// "classpath:com/example/MyTestContext.groovy"
@ContextConfiguration (1)
class MyTest {
    // class body...
}

//(1) Loading configuration from the default location.
```

<!-- tabs:start -->

#### ** English **

Declaring XML configuration and Groovy scripts simultaneously
#### ** Chinese **

同时声明XML配置和Groovy脚本。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can declare both XML configuration files and Groovy scripts simultaneously by using the `locations` or `value` attribute of `@ContextConfiguration`. If the path to a configured resource location ends with `.xml`, it is loaded by using an `XmlBeanDefinitionReader`. Otherwise, it is loaded by using a `GroovyBeanDefinitionReader`.
#### ** Chinese **

您可以通过使用`@ContextConfiguration`的`locations`或`value`属性同时声明XML配置文件和Groovy脚本。如果配置的资源位置的路径以`.xml`结尾，则通过使用`XmlBeanDefinitionReader`加载。否则，将通过使用 `GroovyBeanDefinitionReader`加载。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following listing shows how to combine both in an integration test:
#### ** Chinese **

下面列举的是如何将两者结合在一个集成测试中。
<!-- tabs:end -->


```java
@ExtendWith(SpringExtension.class)
// ApplicationContext will be loaded from
// "/app-config.xml" and "/TestConfig.groovy"
@ContextConfiguration({ "/app-config.xml", "/TestConfig.groovy" })
class MyTest {
    // class body...
}
```

### **Context Configuration with Component Classes** 

<!-- tabs:start -->

#### ** English **

To load an `ApplicationContext` for your tests by using component classes (see [Java-based container configuration](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-java)), you can annotate your test class with `@ContextConfiguration` and configure the `classes` attribute with an array that contains references to component classes. The following example shows how to do so:
#### ** Chinese **

要使用组件类为测试加载一个`ApplicationContext`（参见[基于Java的容器配置](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-java)），你可以用`@ContextConfiguration`来注释你的测试类，并用包含组件类引用的数组来配置`classes`属性。下面的例子显示了如何做到这一点。
<!-- tabs:end -->


```java
@ExtendWith(SpringExtension.class)
// ApplicationContext will be loaded from AppConfig and TestConfig
@ContextConfiguration(classes = {AppConfig.class, TestConfig.class}) (1)
class MyTest {
    // class body...
}

//(1) Specifying component classes.
```

<!-- tabs:start -->

#### ** English **

Component Classes
#### ** Chinese **

组件类
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The term “component class” can refer to any of the following:
#### ** Chinese **

"组件类 "一词可指下列任何一种：
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

- `@BeforeTestClass`

- `@PrepareTestInstance`

- `@BeforeTestMethod`

- `@BeforeTestExecution`

- `@AfterTestExecution`

- `@AfterTestMethod`

- `@AfterTestClass`

- [Context Configuration with XML resources](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-ctx-management-xml)

- [Context Configuration with Groovy Scripts](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-ctx-management-groovy)

- [Context Configuration with Component Classes](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-ctx-management-javaconfig)

- [Mixing XML, Groovy Scripts, and Component Classes](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-ctx-management-mixed-config)

- [Context Configuration with Context Initializers](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-ctx-management-initializers)

- [Context Configuration Inheritance](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-ctx-management-inheritance)

- [Context Configuration with Environment Profiles](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-ctx-management-env-profiles)

- [Context Configuration with Test Property Sources](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-ctx-management-property-sources)

- [Context Configuration with Dynamic Property Sources](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-ctx-management-dynamic-property-sources)

- [Loading a ](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-ctx-management-web)[`WebApplicationContext`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-ctx-management-web)

- [Context Caching](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-ctx-management-caching)

- [Context Hierarchies](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-ctx-management-ctx-hierarchies)

- A class annotated with `@Configuration`.

- A component (that is, a class annotated with `@Component`, `@Service`, `@Repository`, or other stereotype annotations).

- A JSR-330 compliant class that is annotated with `javax.inject` annotations.

- Any class that contains `@Bean`-methods.

- Any other class that is intended to be registered as a Spring component (i.e., a Spring bean in the `ApplicationContext`), potentially taking advantage of automatic autowiring of a single constructor without the use of Spring annotations.

#### ** Chinese **

- `@BeforeTestClass`

- `@PrepareTestInstance`@PrepareTestInstance</x>

- `@BeforeTestMethod`

- `@BeforeTestExecution`@BeforeTestExecution</x>

- `@AfterTestExecution`@AfterTestExecution</x>

- `@AfterTestMethod`

- `@AfterTestClass`

- [Context Configuration with XML资源](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-ctx-management-xml)

- [Context Configuration with Groovy Scripts](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-ctx-management-groovy)

- [Context Configuration with Component Classes](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-ctx-management-javaconfig)

- 混合XML、Groovy Scripts和组件类](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-ctx-management-mixed-config)

- [Context Configuration with Context Initializers](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-ctx-management-initializers)

- [上下文配置继承](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-ctx-management-inheritance)

- 环境预案的上下文配置](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-ctx-management-env-profiles)

- 上下文配置与测试属性源](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-ctx-management-property-sources)

- 动态属性源的上下文配置](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-ctx-management-dynamic-property-sources)

- [Loading a ](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-ctx-management-web)[`WebApplicationContext`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-ctx-management-web)

- [上下文缓存](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-ctx-management-caching)

- [上下文层次结构](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-ctx-management-ctx-hierarchies)

- 用 `@Configuration`注释的类。

- 一个组件（即用`@Component`、`@Service`、`@Repository`或其他定型注释的类）。

- 一个符合 JSR-330 的类，该类被注释了 `javax.inject` 注解。

- 任何包含`@Bean`方法的类。

- 任何其他打算作为Spring组件注册的类（即`ApplicationContext`中的Spring Bean），可能会利用单个构造函数的自动布线而不使用Spring注释。

<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

See the javadoc of [`@Configuration`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/context/annotation/Configuration.html) and [`@Bean`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/context/annotation/Bean.html) for further information regarding the configuration and semantics of component classes, paying special attention to the discussion of `@Bean` Lite Mode.
#### ** Chinese **

请参阅 [`@Configuration`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/context/annotation/Configuration.html)和[`@Bean`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/context/annotation/Bean.html)的javadoc，了解更多关于组件类的配置和语义的信息，特别注意`@Bean` Lite Mode的讨论。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

If you omit the `classes` attribute from the `@ContextConfiguration` annotation, the TestContext framework tries to detect the presence of default configuration classes. Specifically, `AnnotationConfigContextLoader` and `AnnotationConfigWebContextLoader` detect all `static` nested classes of the test class that meet the requirements for configuration class implementations, as specified in the [`@Configuration`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/context/annotation/Configuration.html) javadoc. Note that the name of the configuration class is arbitrary. In addition, a test class can contain more than one `static` nested configuration class if desired. In the following example, the `OrderServiceTest` class declares a `static` nested configuration class named `Config` that is automatically used to load the `ApplicationContext` for the test class:
#### ** Chinese **

如果从`@ContextConfiguration`注释中省略了`classes`属性，TestContext框架会尝试检测默认配置类的存在。具体来说，`AnnotationConfigContextLoader`和`AnnotationConfigWebContextLoader`检测到测试类的所有`static`嵌套类，这些类满足配置类实现的要求，如[`@Configuration`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/context/annotation/Configuration.html)javadoc中指定的那样。注意，配置类的名称是任意的。此外，如果需要的话，一个测试类可以包含一个以上的`static`嵌套配置类。在下面的示例中，`OrderServiceTest`类声明了一个`static`的名为`Config`的嵌套配置类，该配置类被自动用于加载测试类的`ApplicationContext`。
<!-- tabs:end -->


```java
@SpringJUnitConfig (1)
// ApplicationContext will be loaded from the
// static nested Config class
class OrderServiceTest {

    @Configuration
    static class Config {

        // this bean will be injected into the OrderServiceTest class
        @Bean
        OrderService orderService() {
            OrderService orderService = new OrderServiceImpl();
            // set properties, etc.
            return orderService;
        }
    }

    @Autowired
    OrderService orderService;

    @Test
    void testOrderService() {
        // test the orderService
    }

}

//(1) Loading configuration information from the nested Config class.
```

### **Mixing XML, Groovy Scripts, and Component Classes** 

<!-- tabs:start -->

#### ** English **

It may sometimes be desirable to mix XML configuration files, Groovy scripts, and component classes (typically `@Configuration` classes) to configure an `ApplicationContext` for your tests. For example, if you use XML configuration in production, you may decide that you want to use `@Configuration` classes to configure specific Spring-managed components for your tests, or vice versa.
#### ** Chinese **

有时可能需要混合使用 XML 配置文件、Groovy 脚本和组件类（通常是 `@Configuration`类）来为测试配置 `ApplicationContext`。例如，如果您在生产中使用 XML 配置，您可能决定使用 `@Configuration` 类来为您的测试配置特定的 Spring 管理的组件，反之亦然。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Furthermore, some third-party frameworks (such as Spring Boot) provide first-class support for loading an `ApplicationContext` from different types of resources simultaneously (for example, XML configuration files, Groovy scripts, and `@Configuration` classes). The Spring Framework, historically, has not supported this for standard deployments. Consequently, most of the `SmartContextLoader` implementations that the Spring Framework delivers in the `spring-test` module support only one resource type for each test context. However, this does not mean that you cannot use both. One exception to the general rule is that the `GenericGroovyXmlContextLoader` and `GenericGroovyXmlWebContextLoader` support both XML configuration files and Groovy scripts simultaneously. Furthermore, third-party frameworks may choose to support the declaration of both `locations` and `classes` through `@ContextConfiguration`, and, with the standard testing support in the TestContext framework, you have the following options.
#### ** Chinese **

此外，一些第三方框架（如Spring Boot）提供了一流的支持，可以同时从不同类型的资源中加载`ApplicationContext`（例如，XML配置文件、Groovy脚本和`@Configuration`类）。从历史上看，Spring框架并不支持标准部署。因此，Spring框架在`spring-test`模块中提供的大多数`SmartContextLoader`实现，对每个测试上下文只支持一种资源类型。但是，这并不意味着不能同时使用两种资源类型。一般规则的一个例外是，`GenericGroovyXmlContextLoader`和`GenericGroovyXmlWebContextLoader`同时支持XML配置文件和Groovy脚本。此外，第三方框架可以选择通过`@ContextConfiguration`同时支持`locations`和`classes`的声明，而且，在TestContext框架中的标准测试支持下，你可以选择以下选项。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

If you want to use resource locations (for example, XML or Groovy) and `@Configuration` classes to configure your tests, you must pick one as the entry point, and that one must include or import the other. For example, in XML or Groovy scripts, you can include `@Configuration` classes by using component scanning or defining them as normal Spring beans, whereas, in a `@Configuration` class, you can use `@ImportResource` to import XML configuration files or Groovy scripts. Note that this behavior is semantically equivalent to how you configure your application in production: In production configuration, you define either a set of XML or Groovy resource locations or a set of `@Configuration` classes from which your production `ApplicationContext` is loaded, but you still have the freedom to include or import the other type of configuration.
#### ** Chinese **

如果你想使用资源位置（例如，XML或Groovy）和`@Configuration`类来配置你的测试，你必须选择其中一个作为切入点，而且其中一个必须包含或导入另一个。例如，在 XML 或 Groovy 脚本中，你可以通过使用组件扫描或将其定义为普通的 Spring beans 来包含 `@Configuration` 类，而在 `@Configuration` 类中，你可以使用 `@ImportResource` 来导入 XML 配置文件或 Groovy 脚本。请注意，这个行为在语义上等同于你在生产中如何配置你的应用程序。在生产配置中，您可以定义一组XML或Groovy资源位置或一组`@Configuration`类，您的生产`ApplicationContext`类将从该类中加载，但您仍然可以自由地包含或导入其他类型的配置。
<!-- tabs:end -->


### **Context Configuration with Context Initializers** 

<!-- tabs:start -->

#### ** English **

To configure an `ApplicationContext` for your tests by using context initializers, annotate your test class with `@ContextConfiguration` and configure the `initializers` attribute with an array that contains references to classes that implement `ApplicationContextInitializer`. The declared context initializers are then used to initialize the `ConfigurableApplicationContext` that is loaded for your tests. Note that the concrete `ConfigurableApplicationContext` type supported by each declared initializer must be compatible with the type of `ApplicationContext` created by the `SmartContextLoader` in use (typically a `GenericApplicationContext`). Furthermore, the order in which the initializers are invoked depends on whether they implement Spring’s `Ordered` interface or are annotated with Spring’s `@Order` annotation or the standard `@Priority` annotation. The following example shows how to use initializers:
#### ** Chinese **

要通过使用上下文初始化器为测试配置`ApplicationContext`，请用`@ContextConfiguration`注释你的测试类，并配置`initializers`属性，该属性包含一个数组，该数组包含对实现`ApplicationContextInitializer`的类的引用。然后使用声明的上下文初始化器来初始化为你的测试加载的`ConfigurableApplicationContext`。注意，每个声明的初始化器支持的具体 `ConfigurableApplicationContext`类型必须与使用中的 `SmartContextLoader`创建的`ApplicationContext`类型兼容（通常是`GenericApplicationContext`）。此外，调用初始化器的顺序取决于它们是实现了Spring的`Ordered`接口，还是被Spring的`@Order`注释或标准的`@Priority`注释所注释。下面的示例显示了如何使用初始化器。
<!-- tabs:end -->


```java
@ExtendWith(SpringExtension.class)
// ApplicationContext will be loaded from TestConfig
// and initialized by TestAppCtxInitializer
@ContextConfiguration(
    classes = TestConfig.class,
    initializers = TestAppCtxInitializer.class) (1)
class MyTest {
    // class body...
}

//(1) Specifying configuration by using a configuration class and an initializer.
```

<!-- tabs:start -->

#### ** English **

You can also omit the declaration of XML configuration files, Groovy scripts, or component classes in `@ContextConfiguration` entirely and instead declare only `ApplicationContextInitializer` classes, which are then responsible for registering beans in the context — for example, by programmatically loading bean definitions from XML files or configuration classes. The following example shows how to do so:
#### ** Chinese **

你也可以完全省略在`@ContextConfiguration`中声明XML配置文件、Groovy脚本或组件类，而只声明`ApplicationContextInitializer`类，然后在上下文中负责注册Bean--例如，通过编程地从XML文件或配置类中加载Bean定义。下面的例子说明了如何做到这一点。
<!-- tabs:end -->


```java
@ExtendWith(SpringExtension.class)
// ApplicationContext will be initialized by EntireAppInitializer
// which presumably registers beans in the context
@ContextConfiguration(initializers = EntireAppInitializer.class) (1)
class MyTest {
    // class body...
}

//(1) Specifying configuration by using only an initializer.
```

### **Context Configuration Inheritance** 

<!-- tabs:start -->

#### ** English **

`@ContextConfiguration` supports boolean `inheritLocations` and `inheritInitializers` attributes that denote whether resource locations or component classes and context initializers declared by superclasses should be inherited. The default value for both flags is `true`. This means that a test class inherits the resource locations or component classes as well as the context initializers declared by any superclasses. Specifically, the resource locations or component classes for a test class are appended to the list of resource locations or annotated classes declared by superclasses. Similarly, the initializers for a given test class are added to the set of initializers defined by test superclasses. Thus, subclasses have the option of extending the resource locations, component classes, or context initializers.
#### ** Chinese **

`@ContextConfiguration`支持布尔`inheritLocations`和`inheritInitializers`属性，这些属性表示资源位置或组件类和超类声明的上下文初始化器是否应该继承。这两个标志的默认值是`true`。这意味着测试类继承资源位置或组件类以及任何超级类所声明的上下文初始化器。具体来说，测试类的资源位置或组件类被附加到超类声明的资源位置或注释类列表中。同样，给定测试类的初始化器也被添加到由测试超类定义的初始化器集中。因此，子类可以选择扩展资源位置、组件类或上下文初始化器。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

If the `inheritLocations` or `inheritInitializers` attribute in `@ContextConfiguration` is set to `false`, the resource locations or component classes and the context initializers, respectively, for the test class shadow and effectively replace the configuration defined by superclasses.
#### ** Chinese **

如果`@ContextConfiguration`中的`inheritLocations`或`inheritInitializers`属性被设置为`false`，则测试类的资源位置或组件类和上下文初始化器分别为测试类的影子，并有效地替换了超类定义的配置。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

In the next example, which uses XML resource locations, the `ApplicationContext` for `ExtendedTest` is loaded from `base-config.xml` and `extended-config.xml`, in that order. Beans defined in `extended-config.xml` can, therefore, override (that is, replace) those defined in `base-config.xml`. The following example shows how one class can extend another and use both its own configuration file and the superclass’s configuration file:
#### ** Chinese **

在下一个使用 XML 资源位置的例子中，`ExtendedTest`的 `ApplicationContext`从 `base-config.xml`和 `extended-config.xml`中依次加载。因此，在`extended-config.xml`中定义的Bean可以覆盖（即替换）在`base-config.xml`中定义的Bean。下面的例子显示了一个类如何扩展另一个类并使用它自己的配置文件和超级类的配置文件。
<!-- tabs:end -->


```java
@ExtendWith(SpringExtension.class)
// ApplicationContext will be loaded from "/base-config.xml"
// in the root of the classpath
@ContextConfiguration("/base-config.xml") (1)
class BaseTest {
    // class body...
}

// ApplicationContext will be loaded from "/base-config.xml" and
// "/extended-config.xml" in the root of the classpath
@ContextConfiguration("/extended-config.xml") (2)
class ExtendedTest extends BaseTest {
    // class body...
}

//(1) Configuration file defined in the superclass.
(2) Configuration file defined in the subclass.
```

<!-- tabs:start -->

#### ** English **

Similarly, in the next example, which uses component classes, the `ApplicationContext` for `ExtendedTest` is loaded from the `BaseConfig` and `ExtendedConfig` classes, in that order. Beans defined in `ExtendedConfig` can, therefore, override (that is, replace) those defined in `BaseConfig`. The following example shows how one class can extend another and use both its own configuration class and the superclass’s configuration class:
#### ** Chinese **

同样的，在下一个使用组件类的例子中，`ExtendedTest`的`ApplicationContext`从`BaseConfig`和`ExtendedConfig`类中依次加载。因此，在`ExtendedConfig`中定义的Bean可以覆盖（即替换）在`BaseConfig`中定义的Bean。下面的例子显示了一个类如何扩展另一个类，并使用它自己的配置类和超级类的配置类。
<!-- tabs:end -->


```java
// ApplicationContext will be loaded from BaseConfig
@SpringJUnitConfig(BaseConfig.class) (1)
class BaseTest {
    // class body...
}

// ApplicationContext will be loaded from BaseConfig and ExtendedConfig
@SpringJUnitConfig(ExtendedConfig.class) (2)
class ExtendedTest extends BaseTest {
    // class body...
}

//(1) Configuration class defined in the superclass.
(2) Configuration class defined in the subclass.
```

<!-- tabs:start -->

#### ** English **

In the next example, which uses context initializers, the `ApplicationContext` for `ExtendedTest` is initialized by using `BaseInitializer` and `ExtendedInitializer`. Note, however, that the order in which the initializers are invoked depends on whether they implement Spring’s `Ordered` interface or are annotated with Spring’s `@Order` annotation or the standard `@Priority` annotation. The following example shows how one class can extend another and use both its own initializer and the superclass’s initializer:
#### ** Chinese **

在下一个使用上下文初始化器的例子中，`ExtendedTest`的`ApplicationContext`通过使用`BaseInitializer`和`ExtendedInitializer`进行初始化。但是，请注意，调用初始化器的顺序取决于它们是实现了Spring的`Ordered`接口，还是使用Spring的`@Order`注释或标准的`@Priority`注释。下面的示例显示了一个类如何扩展另一个类并使用它自己的初始化器和超类的初始化器。
<!-- tabs:end -->


```java
// ApplicationContext will be initialized by BaseInitializer
@SpringJUnitConfig(initializers = BaseInitializer.class) (1)
class BaseTest {
    // class body...
}

// ApplicationContext will be initialized by BaseInitializer
// and ExtendedInitializer
@SpringJUnitConfig(initializers = ExtendedInitializer.class) (2)
class ExtendedTest extends BaseTest {
    // class body...
}

//(1) Initializer defined in the superclass.
(2) Initializer defined in the subclass.
```

### **Context Configuration with Environment Profiles** 

<!-- tabs:start -->

#### ** English **

The Spring Framework has first-class support for the notion of environments and profiles (AKA "bean definition profiles"), and integration tests can be configured to activate particular bean definition profiles for various testing scenarios. This is achieved by annotating a test class with the `@ActiveProfiles` annotation and supplying a list of profiles that should be activated when loading the `ApplicationContext` for the test.
#### ** Chinese **

Spring框架对环境和配置文件（又名 "bean定义配置文件"）的概念提供了一流的支持，集成测试可以被配置为激活特定的bean定义配置文件，用于各种测试场景。这可以通过给测试类加上`@ActiveProfiles`注解，并提供一个在加载测试的`ApplicationContext`时应激活的配置文件列表来实现。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can use `@ActiveProfiles` with any implementation of the `SmartContextLoader` SPI, but `@ActiveProfiles` is not supported with implementations of the older `ContextLoader` SPI.
#### ** Chinese **

您可以在 `SmartContextLoader` SPI 的任何实现中使用 `@ActiveProfiles`，但旧版 `ContextLoader` SPI 的实现不支持 `@ActiveProfiles`。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Consider two examples with XML configuration and `@Configuration` classes:
#### ** Chinese **

考虑两个具有XML配置和`@Configuration`类的例子。
<!-- tabs:end -->


```xml
<!-- app-config.xml -->
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:jdbc="http://www.springframework.org/schema/jdbc"
    xmlns:jee="http://www.springframework.org/schema/jee"
    xsi:schemaLocation="...">

    <bean id="transferService"
            class="com.bank.service.internal.DefaultTransferService">
        <constructor-arg ref="accountRepository"/>
        <constructor-arg ref="feePolicy"/>
    </bean>

    <bean id="accountRepository"
            class="com.bank.repository.internal.JdbcAccountRepository">
        <constructor-arg ref="dataSource"/>
    </bean>

    <bean id="feePolicy"
        class="com.bank.service.internal.ZeroFeePolicy"/>

    <beans profile="dev">
        <jdbc:embedded-database id="dataSource">
            <jdbc:script
                location="classpath:com/bank/config/sql/schema.sql"/>
            <jdbc:script
                location="classpath:com/bank/config/sql/test-data.sql"/>
        </jdbc:embedded-database>
    </beans>

    <beans profile="production">
        <jee:jndi-lookup id="dataSource" jndi-name="java:comp/env/jdbc/datasource"/>
    </beans>

    <beans profile="default">
        <jdbc:embedded-database id="dataSource">
            <jdbc:script
                location="classpath:com/bank/config/sql/schema.sql"/>
        </jdbc:embedded-database>
    </beans>

</beans>
```

```java
@ExtendWith(SpringExtension.class)
// ApplicationContext will be loaded from "classpath:/app-config.xml"
@ContextConfiguration("/app-config.xml")
@ActiveProfiles("dev")
class TransferServiceTest {

    @Autowired
    TransferService transferService;

    @Test
    void testTransferService() {
        // test the transferService
    }
}
```

<!-- tabs:start -->

#### ** English **

When `TransferServiceTest` is run, its `ApplicationContext` is loaded from the `app-config.xml` configuration file in the root of the classpath. If you inspect `app-config.xml`, you can see that the `accountRepository` bean has a dependency on a `dataSource` bean. However, `dataSource` is not defined as a top-level bean. Instead, `dataSource` is defined three times: in the `production` profile, in the `dev` profile, and in the `default` profile.
#### ** Chinese **

当`TransferServiceTest`运行时，其`ApplicationContext`会从classpath根目录下的`app-config.xml`配置文件中加载。如果检查`app-config.xml`，可以看到`accountRepository` bean依赖`dataSource` bean。然而，`dataSource`并没有被定义为一个顶层Bean。相反，`dataSource`被定义了三次：在`production`配置文件中，在`dev`配置文件中，以及在`default`配置文件中。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

By annotating `TransferServiceTest` with `@ActiveProfiles("dev")`, we instruct the Spring TestContext Framework to load the `ApplicationContext` with the active profiles set to `{"dev"}`. As a result, an embedded database is created and populated with test data, and the `accountRepository` bean is wired with a reference to the development `DataSource`. That is likely what we want in an integration test.
#### ** Chinese **

通过用 `@ActiveProfiles("dev")`注释`TransferServiceTest`，我们指示Spring TestContext框架加载`ApplicationContext`，并将活动配置文件设置为`{"dev"}`。结果，一个嵌入式数据库被创建并填充了测试数据，而`accountRepository` bean被连接到开发`DataSource`的引用。这很可能是我们在集成测试中想要的。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

It is sometimes useful to assign beans to a `default` profile. Beans within the default profile are included only when no other profile is specifically activated. You can use this to define “fallback” beans to be used in the application’s default state. For example, you may explicitly provide a data source for `dev` and `production` profiles, but define an in-memory data source as a default when neither of these is active.
#### ** Chinese **

有时将豆子分配到一个`default`配置文件中是很有用的。只有在没有特别激活其他配置文件的情况下，默认配置文件中的Bean才会被包含。你可以用它来定义要在应用程序的默认状态下使用的 "后备 "Bean。例如，您可以为`dev`和`production`配置文件显式地提供一个数据源，但在这两个配置文件都没有激活时，定义一个内存中的数据源作为默认状态。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following code listings demonstrate how to implement the same configuration and integration test with `@Configuration` classes instead of XML:
#### ** Chinese **

下面的代码列表演示了如何用`@Configuration`类代替XML实现相同的配置和集成测试。
<!-- tabs:end -->


```java
@Configuration
@Profile("dev")
public class StandaloneDataConfig {

    @Bean
    public DataSource dataSource() {
        return new EmbeddedDatabaseBuilder()
            .setType(EmbeddedDatabaseType.HSQL)
            .addScript("classpath:com/bank/config/sql/schema.sql")
            .addScript("classpath:com/bank/config/sql/test-data.sql")
            .build();
    }
}
```

```java
@Configuration
@Profile("production")
public class JndiDataConfig {

    @Bean(destroyMethod="")
    public DataSource dataSource() throws Exception {
        Context ctx = new InitialContext();
        return (DataSource) ctx.lookup("java:comp/env/jdbc/datasource");
    }
}
```

```java
@Configuration
@Profile("default")
public class DefaultDataConfig {

    @Bean
    public DataSource dataSource() {
        return new EmbeddedDatabaseBuilder()
            .setType(EmbeddedDatabaseType.HSQL)
            .addScript("classpath:com/bank/config/sql/schema.sql")
            .build();
    }
}
```

```java
@Configuration
public class TransferServiceConfig {

    @Autowired DataSource dataSource;

    @Bean
    public TransferService transferService() {
        return new DefaultTransferService(accountRepository(), feePolicy());
    }

    @Bean
    public AccountRepository accountRepository() {
        return new JdbcAccountRepository(dataSource);
    }

    @Bean
    public FeePolicy feePolicy() {
        return new ZeroFeePolicy();
    }
}
```

```java
@SpringJUnitConfig({
        TransferServiceConfig.class,
        StandaloneDataConfig.class,
        JndiDataConfig.class,
        DefaultDataConfig.class})
@ActiveProfiles("dev")
class TransferServiceTest {

    @Autowired
    TransferService transferService;

    @Test
    void testTransferService() {
        // test the transferService
    }
}
```

<!-- tabs:start -->

#### ** English **

In this variation, we have split the XML configuration into four independent `@Configuration` classes:
#### ** Chinese **

在这个变体中，我们将XML配置分成四个独立的`@Configuration`类。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

- `TransferServiceConfig`: Acquires a `dataSource` through dependency injection by using `@Autowired`.

- `StandaloneDataConfig`: Defines a `dataSource` for an embedded database suitable for developer tests.

- `JndiDataConfig`: Defines a `dataSource` that is retrieved from JNDI in a production environment.

- `DefaultDataConfig`: Defines a `dataSource` for a default embedded database, in case no profile is active.

#### ** Chinese **

- `TransferServiceConfig`。通过使用`@Autowired`，通过依赖注入获取一个`数据源`。

- `StandaloneDataConfig`：通过使用`@Autowired`来获取一个`dataSource`。`dataSource`：为嵌入式数据库定义一个适合开发者测试的`dataSource`。

- `JndiDataConfig`。定义了一个在生产环境中从JNDI中检索的`dataSource`。

- `DefaultDataConfig`。`DefaultDataConfig`：定义了一个`dataSource`，用于默认的嵌入式数据库，如果没有活动的配置文件。

<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

As with the XML-based configuration example, we still annotate `TransferServiceTest` with `@ActiveProfiles("dev")`, but this time we specify all four configuration classes by using the `@ContextConfiguration` annotation. The body of the test class itself remains completely unchanged.
#### ** Chinese **

与基于 XML 的配置示例一样，我们仍然用 `@ActiveProfiles("dev")`注释 `TransferServiceTest`，但这次我们使用 `@ContextConfiguration` 注释来指定所有四个配置类。测试类本身的主体保持完全不变。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

It is often the case that a single set of profiles is used across multiple test classes within a given project. Thus, to avoid duplicate declarations of the `@ActiveProfiles` annotation, you can declare `@ActiveProfiles` once on a base class, and subclasses automatically inherit the `@ActiveProfiles` configuration from the base class. In the following example, the declaration of `@ActiveProfiles` (as well as other annotations) has been moved to an abstract superclass, `AbstractIntegrationTest`:
#### ** Chinese **

通常情况下，在给定项目中的多个测试类中使用一组配置文件。因此，为了避免重复声明`@ActiveProfiles`注解，可以在基类上声明一次`@ActiveProfiles`，子类会自动从基类中继承`@ActiveProfiles`配置。在下面的示例中，`@ActiveProfiles`的声明（以及其他注释）被移到了一个抽象的超类`AbstractIntegrationTest`中。
<!-- tabs:end -->


```java
@SpringJUnitConfig({
        TransferServiceConfig.class,
        StandaloneDataConfig.class,
        JndiDataConfig.class,
        DefaultDataConfig.class})
@ActiveProfiles("dev")
abstract class AbstractIntegrationTest {
}
```

```java
// "dev" profile inherited from superclass
class TransferServiceTest extends AbstractIntegrationTest {

    @Autowired
    TransferService transferService;

    @Test
    void testTransferService() {
        // test the transferService
    }
}
```

<!-- tabs:start -->

#### ** English **

`@ActiveProfiles` also supports an `inheritProfiles` attribute that can be used to disable the inheritance of active profiles, as the following example shows:
#### ** Chinese **

`@ActiveProfiles`还支持一个`inheritProfiles`属性，该属性可用于禁用ActiveProfiles的继承，如下例所示。
<!-- tabs:end -->


```java
// "dev" profile overridden with "production"
@ActiveProfiles(profiles = "production", inheritProfiles = false)
class ProductionTransferServiceTest extends AbstractIntegrationTest {
    // test body
}
```

<!-- tabs:start -->

#### ** English **

Furthermore, it is sometimes necessary to resolve active profiles for tests programmatically instead of declaratively — for example, based on:
#### ** Chinese **

此外，有时需要用程序化的方式而不是声明式的方式来解决测试的活动配置文件，例如，基于。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

- The current operating system.

- Whether tests are being executed on a continuous integration build server.

- The presence of certain environment variables.

- The presence of custom class-level annotations.

- Other concerns.

#### ** Chinese **

- 当前的操作系统。

- 是否在连续集成构建服务器上执行测试。

- 是否存在某些环境变量。

- 是否存在自定义类级注释。

- 其他关注的问题。

<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

To resolve active bean definition profiles programmatically, you can implement a custom `ActiveProfilesResolver` and register it by using the `resolver` attribute of `@ActiveProfiles`. For further information, see the corresponding [javadoc](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/test/context/ActiveProfilesResolver.html). The following example demonstrates how to implement and register a custom `OperatingSystemActiveProfilesResolver`:
#### ** Chinese **

要以编程方式解决活动豆定义配置文件，可以实现一个自定义的`ActiveProfilesResolver`，并通过使用`@ActiveProfiles`的`resolver`属性来注册它。更多信息，请参阅相应的 [javadoc](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/test/context/ActiveProfilesResolver.html)。下面的示例演示了如何实现和注册一个自定义的 `OperatingSystemActiveProfilesResolver`。
<!-- tabs:end -->


```java
// "dev" profile overridden programmatically via a custom resolver
@ActiveProfiles(
        resolver = OperatingSystemActiveProfilesResolver.class,
        inheritProfiles = false)
class TransferServiceTest extends AbstractIntegrationTest {
    // test body
}
```

```java
public class OperatingSystemActiveProfilesResolver implements ActiveProfilesResolver {

    @Override
    public String[] resolve(Class<?> testClass) {
        String profile = ...;
        // determine the value of profile based on the operating system
        return new String[] {profile};
    }
}
```

### **Context Configuration with Test Property Sources** 

<!-- tabs:start -->

#### ** English **

The Spring Framework has first-class support for the notion of an environment with a hierarchy of property sources, and you can configure integration tests with test-specific property sources. In contrast to the `@PropertySource` annotation used on `@Configuration` classes, you can declare the `@TestPropertySource` annotation on a test class to declare resource locations for test properties files or inlined properties. These test property sources are added to the set of `PropertySources` in the `Environment` for the `ApplicationContext` loaded for the annotated integration test.
#### ** Chinese **

Spring框架对具有属性源层次结构的环境概念有一流的支持，你可以用测试专用的属性源配置集成测试。与在`@Configuration`类上使用的`@PropertySource`注释不同，您可以在测试类上声明`@TestPropertySource`注释，以声明测试属性文件或内嵌属性的资源位置。这些测试属性源被添加到`Environment`中的`PropertySources`中的`PropertySources`集合中，用于为注释的集成测试加载的`ApplicationContext`。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can use `@TestPropertySource` with any implementation of the `SmartContextLoader` SPI, but `@TestPropertySource` is not supported with implementations of the older `ContextLoader` SPI.
#### ** Chinese **

您可以在 `SmartContextLoader` SPI 的任何实现中使用 `@TestPropertySource`，但旧版 `ContextLoader` SPI 的实现不支持 `@TestPropertySource`。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Implementations of `SmartContextLoader` gain access to merged test property source values through the `getPropertySourceLocations()` and `getPropertySourceProperties()` methods in `MergedContextConfiguration`.
#### ** Chinese **

`SmartContextLoader`的实现通过`MergedContextConfiguration`中的`getPropertySourceLocations()`和`getPropertySourceProperties()`方法获得对合并后的测试属性源值的访问。
<!-- tabs:end -->


### **Declaring Test Property Sources** 

<!-- tabs:start -->

#### ** English **

You can configure test properties files by using the `locations` or `value` attribute of `@TestPropertySource`.
#### ** Chinese **

您可以通过使用`@TestPropertySource`的`locations`或`value`属性来配置测试属性文件。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Both traditional and XML-based properties file formats are supported — for example, `"classpath:/com/example/test.properties"` or `"file:///path/to/file.xml"`.
#### ** Chinese **

支持传统的和基于XML的属性文件格式 - 例如，`"classpath:/com/example/test.properties"`或`"file:///path/to/file.xml"`。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Each path is interpreted as a Spring `Resource`. A plain path (for example, `"test.properties"`) is treated as a classpath resource that is relative to the package in which the test class is defined. A path starting with a slash is treated as an absolute classpath resource (for example: `"/org/example/test.xml"`). A path that references a URL (for example, a path prefixed with `classpath:`, `file:`, or `http:`) is loaded by using the specified resource protocol. Resource location wildcards (such as **`*/`** `.properties`) are not permitted: Each location must evaluate to exactly one `.properties` or `.xml` resource.
#### ** Chinese **

每个路径被解释为 Spring `Resource`。普通路径（例如：`"test.properties"`）被视为相对于定义了测试类的包的classpath资源。以斜线开头的路径被视为绝对的classpath资源（例如：`"/org/example/test.xml"`）。引用 URL 的路径（例如，以 `classpath:`、`file:`或 `http:`为前缀的路径）将通过使用指定的资源协议加载。不允许使用资源位置通配符（如**`*/`** `.properties`）：每个位置必须精确到一个`.properties`或`.xml`资源。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following example uses a test properties file:
#### ** Chinese **

下面的例子使用了一个测试属性文件。
<!-- tabs:end -->


```java
@ContextConfiguration
@TestPropertySource("/test.properties") (1)
class MyIntegrationTests {
    // class body...
}

//(1) Specifying a properties file with an absolute path.
```

<!-- tabs:start -->

#### ** English **

You can configure inlined properties in the form of key-value pairs by using the `properties` attribute of `@TestPropertySource`, as shown in the next example. All key-value pairs are added to the enclosing `Environment` as a single test `PropertySource` with the highest precedence.
#### ** Chinese **

您可以通过使用`@TestPropertySource`的`properties`属性，以键值对的形式配置内联属性，如下图所示。所有的键值对都被添加到包围的 `Environment`中，作为一个单独的测试 `PropertySource`属性</x>，其优先级最高。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The supported syntax for key-value pairs is the same as the syntax defined for entries in a Java properties file:
#### ** Chinese **

支持的键-值对的语法与Java属性文件中的条目定义的语法相同。
<!-- tabs:end -->


- `key=value`

- `key:value`

- `key value`


<!-- tabs:start -->

#### ** English **

The following example sets two inlined properties:
#### ** Chinese **

下面的例子设置了两个内衬属性。
<!-- tabs:end -->


```java
@ContextConfiguration
@TestPropertySource(properties = {"timezone = GMT", "port: 4242"}) (1)
class MyIntegrationTests {
    // class body...
}

//(1) Setting two properties by using two variations of the key-value syntax.
```

<!-- tabs:start -->

#### ** English **

As of Spring Framework 5.2, `@TestPropertySource` can be used as *repeatable annotation*. That means that you can have multiple declarations of `@TestPropertySource` on a single test class, with the `locations` and `properties` from later `@TestPropertySource` annotations overriding those from previous `@TestPropertySource` annotations.
#### ** Chinese **

从Spring Framework 5.2开始，`@TestPropertySource`可以作为*可重复注释*使用。这意味着你可以在一个测试类上有多个`@TestPropertySource`的声明，而后面的`@TestPropertySource`注释中的`locations`和`properties`会覆盖之前的`@TestPropertySource`注释中的`@TestPropertySource`。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

In addition, you may declare multiple composed annotations on a test class that are each meta-annotated with `@TestPropertySource`, and all of those `@TestPropertySource` declarations will contribute to your test property sources.
#### ** Chinese **

此外，你可以在一个测试类上声明多个组成的注释，每个注释都用 `@TestPropertySource`进行元注释，所有这些`@TestPropertySource`声明都将贡献给你的测试属性源。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Directly present `@TestPropertySource` annotations always take precedence over meta-present `@TestPropertySource` annotations. In other words, `locations` and `properties` from a directly present `@TestPropertySource` annotation will override the `locations` and `properties` from a `@TestPropertySource` annotation used as a meta-annotation.
#### ** Chinese **

直接存在的 `@TestPropertySource` 注释总是优先于元存在的 `@TestPropertySource` 注释。换句话说，直接呈现的 `@TestPropertySource` 注解中的 `locations` 和 `properties` 将优先于作为元注释使用的 `@TestPropertySource` 注解中的 `locations` 和 `properties`。
<!-- tabs:end -->


### **Default Properties File Detection** 

<!-- tabs:start -->

#### ** English **

If `@TestPropertySource` is declared as an empty annotation (that is, without explicit values for the `locations` or `properties` attributes), an attempt is made to detect a default properties file relative to the class that declared the annotation. For example, if the annotated test class is `com.example.MyTest`, the corresponding default properties file is `classpath:com/example/MyTest.properties`. If the default cannot be detected, an `IllegalStateException` is thrown.
#### ** Chinese **

如果`@TestPropertySource`被声明为空注释（即没有`locations`或`properties`属性的显式值），则会尝试检测一个相对于声明该注释的类的默认属性文件。例如，如果被注释的测试类是 `com.example.MyTest`，相应的默认属性文件是 `classpath:com/example/MyTest.properties`。如果无法检测到默认属性，则会抛出一个`IllegalStateException`。
<!-- tabs:end -->


### **Precedence** 

<!-- tabs:start -->

#### ** English **

Test properties have higher precedence than those defined in the operating system’s environment, Java system properties, or property sources added by the application declaratively by using `@PropertySource` or programmatically. Thus, test properties can be used to selectively override properties loaded from system and application property sources. Furthermore, inlined properties have higher precedence than properties loaded from resource locations. Note, however, that properties registered via [`@DynamicPropertySource`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-ctx-management-dynamic-property-sources) have higher precedence than those loaded via `@TestPropertySource`.
#### ** Chinese **

测试属性比在操作系统环境中定义的属性、Java系统属性或应用程序通过使用`@PropertySource`声明性地添加的属性源或程序化地添加的属性具有更高的优先级。因此，测试属性可以用来有选择地覆盖从系统和应用程序属性源加载的属性。此外，内联属性比从资源位置加载的属性具有更高的优先级。但是，请注意，通过 [`@DynamicPropertySource`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-ctx-management-dynamic-property-sources)注册的属性比通过`@TestPropertySource`加载的属性具有更高的优先级。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

In the next example, the `timezone` and `port` properties and any properties defined in `"/test.properties"` override any properties of the same name that are defined in system and application property sources. Furthermore, if the `"/test.properties"` file defines entries for the `timezone` and `port` properties those are overridden by the inlined properties declared by using the `properties` attribute. The following example shows how to specify properties both in a file and inline:
#### ** Chinese **

在下一个示例中，`timezone`和`port`属性以及在`"/test.properties"`中定义的任何属性都会覆盖在系统和应用程序属性源中定义的同名属性。此外，如果`"/test.properties"`文件中定义了`timezone`和`port`属性的条目，那么这些属性会被使用`properties`属性声明的内嵌属性覆盖。下面的例子显示了如何在文件中和内联中指定属性。
<!-- tabs:end -->


```java
@ContextConfiguration
@TestPropertySource(
    locations = "/test.properties",
    properties = {"timezone = GMT", "port: 4242"}
)
class MyIntegrationTests {
    // class body...
}
```

### **Inheriting and Overriding Test Property Sources** 

<!-- tabs:start -->

#### ** English **

`@TestPropertySource` supports boolean `inheritLocations` and `inheritProperties` attributes that denote whether resource locations for properties files and inlined properties declared by superclasses should be inherited. The default value for both flags is `true`. This means that a test class inherits the locations and inlined properties declared by any superclasses. Specifically, the locations and inlined properties for a test class are appended to the locations and inlined properties declared by superclasses. Thus, subclasses have the option of extending the locations and inlined properties. Note that properties that appear later shadow (that is, override) properties of the same name that appear earlier. In addition, the aforementioned precedence rules apply for inherited test property sources as well.
#### ** Chinese **

`@TestPropertySource`支持布尔`inheritLocations`和`inheritProperties`属性，该属性表示属性文件的资源位置和超类声明的内嵌属性的资源位置是否应该继承。这两个标志的默认值是`true`。这意味着测试类继承任何超级类所声明的位置和内嵌属性。具体来说，测试类的位置和内衬属性被附加到超类声明的位置和内衬属性上。因此，子类可以选择扩展位置和内衬属性。需要注意的是，后面出现的属性会对前面出现的同名属性产生阴影（即覆盖）。此外，上述的优先级规则也适用于继承的测试属性源。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

If the `inheritLocations` or `inheritProperties` attribute in `@TestPropertySource` is set to `false`, the locations or inlined properties, respectively, for the test class shadow and effectively replace the configuration defined by superclasses.
#### ** Chinese **

如果`@TestPropertySource`中的`inheritLocations`或`inheritProperties`属性被设置为`false`，则测试类的位置或内嵌属性分别为测试类的影子，并有效地替换了超类定义的配置。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

In the next example, the `ApplicationContext` for `BaseTest` is loaded by using only the `base.properties` file as a test property source. In contrast, the `ApplicationContext` for `ExtendedTest` is loaded by using the `base.properties` and `extended.properties` files as test property source locations. The following example shows how to define properties in both a subclass and its superclass by using `properties` files:
#### ** Chinese **

在下一个例子中，`BaseTest`的`ApplicationContext`仅使用`base.properties`文件作为测试属性源来加载。相反，`ExtendedTest`的`ApplicationContext`则通过使用`base.properties`和`extended.properties`文件作为测试属性源位置来加载。下面的例子显示了如何通过使用`properties`文件在子类和超类中定义属性。
<!-- tabs:end -->


```java
@TestPropertySource("base.properties")
@ContextConfiguration
class BaseTest {
    // ...
}

@TestPropertySource("extended.properties")
@ContextConfiguration
class ExtendedTest extends BaseTest {
    // ...
}
```

<!-- tabs:start -->

#### ** English **

In the next example, the `ApplicationContext` for `BaseTest` is loaded by using only the inlined `key1` property. In contrast, the `ApplicationContext` for `ExtendedTest` is loaded by using the inlined `key1` and `key2` properties. The following example shows how to define properties in both a subclass and its superclass by using inline properties:
#### ** Chinese **

在下一个例子中，`BaseTest`的`ApplicationContext`只使用内嵌的`key1`属性来加载。相反，`ExtendedTest`的`ApplicationContext`则通过使用内嵌的`key1`和`key2`属性来加载。下面的例子显示了如何通过使用内联属性在子类和超类中定义属性。
<!-- tabs:end -->


```java
@TestPropertySource(properties = "key1 = value1")
@ContextConfiguration
class BaseTest {
    // ...
}

@TestPropertySource(properties = "key2 = value2")
@ContextConfiguration
class ExtendedTest extends BaseTest {
    // ...
}
```

### **Context Configuration with Dynamic Property Sources** 

<!-- tabs:start -->

#### ** English **

As of Spring Framework 5.2.5, the TestContext framework provides support for *dynamic* properties via the `@DynamicPropertySource` annotation. This annotation can be used in integration tests that need to add properties with dynamic values to the set of `PropertySources` in the `Environment` for the `ApplicationContext` loaded for the integration test.
#### ** Chinese **

从Spring Framework 5.2.5开始，TestContext框架通过`@DynamicPropertySource`注解提供了对 *动态* 属性的支持。这个注解可以用于集成测试中，如果需要将具有动态值的属性添加到为集成测试`ApplicationContext`加载的`Environment`中的`PropertySources`集合中的`PropertySources`，那么这个注解就可以用于集成测试。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The `@DynamicPropertySource` annotation and its supporting infrastructure were originally designed to allow properties from [Testcontainers](https://www.testcontainers.org/) based tests to be exposed easily to Spring integration tests. However, this feature may also be used with any form of external resource whose lifecycle is maintained outside the test’s `ApplicationContext`.
#### ** Chinese **

`@DynamicPropertySource`注释和它的支持基础架构最初是为了让基于[Testcontainers](https://www.testcontainers.org/)的测试中的属性可以很容易地暴露在Spring集成测试中。但是，这个特性也可以用于任何形式的外部资源，其生命周期在测试的`ApplicationContext`之外。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

In contrast to the [`@TestPropertySource`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-ctx-management-property-sources) annotation that is applied at the class level, `@DynamicPropertySource` must be applied to a `static` method that accepts a single `DynamicPropertyRegistry` argument which is used to add *name-value* pairs to the `Environment`. Values are dynamic and provided via a `Supplier` which is only invoked when the property is resolved. Typically, method references are used to supply values, as can be seen in the following example which uses the Testcontainers project to manage a Redis container outside of the Spring `ApplicationContext`. The IP address and port of the managed Redis container are made available to components within the test’s `ApplicationContext` via the `redis.host` and `redis.port` properties. These properties can be accessed via Spring’s `Environment` abstraction or injected directly into Spring-managed components – for example, via `@Value("${redis.host}")` and `@Value("${redis.port}")`, respectively.
#### ** Chinese **

与应用于类级的[`@TestPropertySource`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-ctx-management-property-sources)注释不同，`@DynamicPropertySource`必须应用于一个`static`方法，该方法接受一个单一的`DynamicPropertyRegistry`参数，该参数用于将*名-值*对添加到`Environment`。值是动态的，并通过`Supplier`提供，只有在属性解析时才会被调用。通常情况下，方法引用被用来提供值，从下面的例子中可以看出，该例子使用Testcontainers项目来管理Spring `ApplicationContext`之外的Redis容器。被管理的 Redis 容器的 IP 地址和端口通过 `redis.host` 和 `redis.port` 属性提供给测试的 `ApplicationContext` 中的组件。这些属性可以通过 Spring 的 `Environment` 抽象来访问，或者直接注入到 Spring 管理的组件中，例如，分别通过 `@Value("${redis.host}")` 和 `@Value("${redis.port}")`。
<!-- tabs:end -->


```java
@SpringJUnitConfig(/* ... */)
@Testcontainers
class ExampleIntegrationTests {

    @Container
    static RedisContainer redis = new RedisContainer();

    @DynamicPropertySource
    static void redisProperties(DynamicPropertyRegistry registry) {
        registry.add("redis.host", redis::getContainerIpAddress);
        registry.add("redis.port", redis::getMappedPort);
    }

    // tests ...

}
```

### **Precedence** 

<!-- tabs:start -->

#### ** English **

Dynamic properties have higher precedence than those loaded from `@TestPropertySource`, the operating system’s environment, Java system properties, or property sources added by the application declaratively by using `@PropertySource` or programmatically. Thus, dynamic properties can be used to selectively override properties loaded via `@TestPropertySource`, system property sources, and application property sources.
#### ** Chinese **

动态属性比从 `@TestPropertySource`、操作系统环境、Java系统属性或应用程序通过使用`@PropertySource`声明性地添加的属性源或程序性地添加的属性源具有更高的优先级。因此，动态属性可以用来选择性地覆盖通过`@TestPropertySource`、系统属性源和应用程序属性源加载的属性。
<!-- tabs:end -->


### **Loading a** **`WebApplicationContext`** 

<!-- tabs:start -->

#### ** English **

To instruct the TestContext framework to load a `WebApplicationContext` instead of a standard `ApplicationContext`, you can annotate the respective test class with `@WebAppConfiguration`.
#### ** Chinese **

要指示TestContext框架加载一个`WebApplicationContext`而不是标准的`ApplicationContext`，可以用`@WebAppConfiguration`注释相应的测试类。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The presence of `@WebAppConfiguration` on your test class instructs the TestContext framework (TCF) that a `WebApplicationContext` (WAC) should be loaded for your integration tests. In the background, the TCF makes sure that a `MockServletContext` is created and supplied to your test’s WAC. By default, the base resource path for your `MockServletContext` is set to `src/main/webapp`. This is interpreted as a path relative to the root of your JVM (normally the path to your project). If you are familiar with the directory structure of a web application in a Maven project, you know that `src/main/webapp` is the default location for the root of your WAR. If you need to override this default, you can provide an alternate path to the `@WebAppConfiguration` annotation (for example, `@WebAppConfiguration("src/test/webapp")`). If you wish to reference a base resource path from the classpath instead of the file system, you can use Spring’s `classpath:` prefix.
#### ** Chinese **

在你的测试类上出现`@WebAppConfiguration`会指示TestContext框架(TCF)为你的集成测试加载一个`WebApplicationContext` (WAC)。在后台，TCF会确保创建一个`MockServletContext`并提供给你的测试的WAC。默认情况下，`MockServletContext`的基本资源路径被设置为`src/main/webapp`。这被解释为相对于JVM根目录的路径（通常是你的项目的路径）。如果你熟悉Maven项目中的Web应用程序的目录结构，你会知道`src/main/webapp`是你的WAR根目录的默认位置。如果您需要覆盖这个默认位置，可以提供一个替代路径到 `@WebAppConfiguration`注释（例如，`@WebAppConfiguration("src/test/webapp")`）。如果您希望从classpath而不是文件系统中引用基础资源路径，可以使用Spring的`classpath:`前缀。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Note that Spring’s testing support for `WebApplicationContext` implementations is on par with its support for standard `ApplicationContext` implementations. When testing with a `WebApplicationContext`, you are free to declare XML configuration files, Groovy scripts, or `@Configuration` classes by using `@ContextConfiguration`. You are also free to use any other test annotations, such as `@ActiveProfiles`, `@TestExecutionListeners`, `@Sql`, `@Rollback`, and others.
#### ** Chinese **

请注意，Spring对`WebApplicationContext`实现的测试支持与对标准`ApplicationContext`实现的支持相同。在使用 `WebApplicationContext`进行测试时，您可以通过使用 XML配置文件、Groovy脚本或 使用`@ContextConfiguration`的`@Configuration`类 。你也可以自由地使用任何其他测试注释，如 `@ActiveProfiles`、`@TestExecutionListeners`、`@Sql`、`@Rollback`等。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The remaining examples in this section show some of the various configuration options for loading a `WebApplicationContext`. The following example shows the TestContext framework’s support for convention over configuration:
#### ** Chinese **

本节中剩余的例子展示了一些加载`WebApplicationContext`的各种配置选项。下面的例子显示了TestContext框架对传统配置的支持。
<!-- tabs:end -->


```java
@ExtendWith(SpringExtension.class)

// defaults to "file:src/main/webapp"
@WebAppConfiguration

// detects "WacTests-context.xml" in the same package
// or static nested @Configuration classes
@ContextConfiguration
class WacTests {
    //...
}
```

<!-- tabs:start -->

#### ** English **

If you annotate a test class with `@WebAppConfiguration` without specifying a resource base path, the resource path effectively defaults to `file:src/main/webapp`. Similarly, if you declare `@ContextConfiguration` without specifying resource `locations`, component `classes`, or context `initializers`, Spring tries to detect the presence of your configuration by using conventions (that is, `WacTests-context.xml` in the same package as the `WacTests` class or static nested `@Configuration` classes).
#### ** Chinese **

如果您用 `@WebAppConfiguration`注释一个测试类而不指定资源基础路径，那么资源路径将有效地默认为 `file:src/main/webapp`。同样，如果您声明`@ContextConfiguration`而没有指定资源`locations`、组件`classes`或上下文`initializers`，Spring会通过使用约定（即，与 `WacTests` "类或静态嵌套的`@Configuration` 类中的 `WacTests-context.xml` 类放在同一个包中。)
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following example shows how to explicitly declare a resource base path with `@WebAppConfiguration` and an XML resource location with `@ContextConfiguration`:
#### ** Chinese **

下面的示例显示了如何用`@WebAppConfiguration`显式声明资源基础路径和用`@ContextConfiguration`声明XML资源位置。
<!-- tabs:end -->


```java
@ExtendWith(SpringExtension.class)

// file system resource
@WebAppConfiguration("webapp")

// classpath resource
@ContextConfiguration("/spring/test-servlet-config.xml")
class WacTests {
    //...
}
```

<!-- tabs:start -->

#### ** English **

The important thing to note here is the different semantics for paths with these two annotations. By default, `@WebAppConfiguration` resource paths are file system based, whereas `@ContextConfiguration` resource locations are classpath based.
#### ** Chinese **

这里需要注意的是这两个注释的路径的语义不同。默认情况下，`@WebAppConfiguration`资源路径是基于文件系统，而`@ContextConfiguration`资源位置是基于classpath。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following example shows that we can override the default resource semantics for both annotations by specifying a Spring resource prefix:
#### ** Chinese **

下面的例子显示，我们可以通过指定Spring资源前缀来覆盖这两个注释的默认资源语义。
<!-- tabs:end -->


```java
@ExtendWith(SpringExtension.class)

// classpath resource
@WebAppConfiguration("classpath:test-web-resources")

// file system resource
@ContextConfiguration("file:src/main/webapp/WEB-INF/servlet-config.xml")
class WacTests {
    //...
}
```

<!-- tabs:start -->

#### ** English **

Contrast the comments in this example with the previous example.
#### ** Chinese **

将本例的注释与上例的注释进行对比。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

**Working with Web Mocks** 
#### ** Chinese **

***使用Web Mocks工作**** 
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

To provide comprehensive web testing support, the TestContext framework has a `ServletTestExecutionListener` that is enabled by default. When testing against a `WebApplicationContext`, this [`TestExecutionListener`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-key-abstractions) sets up default thread-local state by using Spring Web’s `RequestContextHolder` before each test method and creates a `MockHttpServletRequest`, a `MockHttpServletResponse`, and a `ServletWebRequest` based on the base resource path configured with `@WebAppConfiguration`. `ServletTestExecutionListener` also ensures that the `MockHttpServletResponse` and `ServletWebRequest` can be injected into the test instance, and, once the test is complete, it cleans up thread-local state.
#### ** Chinese **

为了提供全面的Web测试支持，TestContext框架有一个`ServletTestExecutionListener`，默认情况下是启用的。当对`WebApplicationContext`进行测试时，这个[`TestExecutionListener`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing. html#testcontext-key-abstractions）通过在每个测试方法之前使用Spring Web的`RequestContextHolder`设置默认的线程本地状态，并创建一个`MockHttpServletRequest`。一个 `MockHttpServletResponse`，以及一个基于`@WebAppConfiguration`配置的基础资源路径的`ServletWebRequest`。 `ServletTestExecutionListener`也确保了`MockHttpServletResponse`和`ServletWebRequest`可以被注入到测试实例中，而且，一旦测试完成，它就会清理线程本地状态。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Once you have a `WebApplicationContext` loaded for your test, you might find that you need to interact with the web mocks — for example, to set up your test fixture or to perform assertions after invoking your web component. The following example shows which mocks can be autowired into your test instance. Note that the `WebApplicationContext` and `MockServletContext` are both cached across the test suite, whereas the other mocks are managed per test method by the `ServletTestExecutionListener`.
#### ** Chinese **

一旦你为你的测试加载了`WebApplicationContext`，你可能会发现你需要与web mocks进行交互 - 例如，设置测试夹具或在调用web组件后执行断言。下面的例子显示了哪些mocks可以自动加载到你的测试实例中。请注意，`WebApplicationContext`和`MockServletContext`都是在整个测试套件中缓存的，而其他的mocks是由`ServletTestExecutionListener`来管理每个测试方法。
<!-- tabs:end -->


```java
@SpringJUnitWebConfig
class WacTests {

    @Autowired
    WebApplicationContext wac; // cached

    @Autowired
    MockServletContext servletContext; // cached

    @Autowired
    MockHttpSession session;

    @Autowired
    MockHttpServletRequest request;

    @Autowired
    MockHttpServletResponse response;

    @Autowired
    ServletWebRequest webRequest;

    //...
}
```

### **Context Caching** 

<!-- tabs:start -->

#### ** English **

Once the TestContext framework loads an `ApplicationContext` (or `WebApplicationContext`) for a test, that context is cached and reused for all subsequent tests that declare the same unique context configuration within the same test suite. To understand how caching works, it is important to understand what is meant by “unique” and “test suite.”
#### ** Chinese **

一旦TestContext框架为一个测试加载了`ApplicationContext`（或`WebApplicationContext`），该上下文就会被缓存，并被重用在同一测试套件中声明相同的唯一上下文配置的所有后续测试中。要了解缓存是如何工作的，重要的是了解 "唯一 "和 "测试套件 "的含义。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

An `ApplicationContext` can be uniquely identified by the combination of configuration parameters that is used to load it. Consequently, the unique combination of configuration parameters is used to generate a key under which the context is cached. The TestContext framework uses the following configuration parameters to build the context cache key:
#### ** Chinese **

一个`ApplicationContext`可以通过用于加载它的配置参数组合来唯一标识。因此，配置参数的唯一性组合被用来生成一个键，并在此键下缓存上下文。TestContext框架使用以下配置参数来建立上下文缓存键。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

- `locations` (from `@ContextConfiguration`)

- `classes` (from `@ContextConfiguration`)

- `contextInitializerClasses` (from `@ContextConfiguration`)

- `contextCustomizers` (from `ContextCustomizerFactory`) – this includes `@DynamicPropertySource` methods as well as various features from Spring Boot’s testing support such as `@MockBean` and `@SpyBean`.

- `contextLoader` (from `@ContextConfiguration`)

- `parent` (from `@ContextHierarchy`)

- `activeProfiles` (from `@ActiveProfiles`)

- `propertySourceLocations` (from `@TestPropertySource`)

- `propertySourceProperties` (from `@TestPropertySource`)

- `resourceBasePath` (from `@WebAppConfiguration`)

#### ** Chinese **

- `locations` (来自`@ContextConfiguration`)

- `classes` (来自`@ContextConfiguration`)

- `contextInitializerClasses` (来自`@ContextConfiguration`)

- `contextCustomizers` (来自`ContextCustomizerFactory`) - 这包括`@DynamicPropertySource`方法以及Spring Boot测试支持的各种特性，如`@MockBean`和`@SpyBean`。

- `contextLoader` (来自`@ContextConfiguration`)

- `parent` (来自`@ContextHierarchy`)

- `activeProfiles` (来自`@ActiveProfiles`)

- `propertySourceLocations` (来自`@TestPropertySource`)

- `propertySourceProperties` (来自`@TestPropertySource`)

- `resourceBasePath` (来自`@WebAppConfiguration`)

<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

For example, if `TestClassA` specifies `{"app-config.xml", "test-config.xml"}` for the `locations` (or `value`) attribute of `@ContextConfiguration`, the TestContext framework loads the corresponding `ApplicationContext` and stores it in a `static` context cache under a key that is based solely on those locations. So, if `TestClassB` also defines `{"app-config.xml", "test-config.xml"}` for its locations (either explicitly or implicitly through inheritance) but does not define `@WebAppConfiguration`, a different `ContextLoader`, different active profiles, different context initializers, different test property sources, or a different parent context, then the same `ApplicationContext` is shared by both test classes. This means that the setup cost for loading an application context is incurred only once (per test suite), and subsequent test execution is much faster.
#### ** Chinese **

例如，如果`TestClassA`指定了`{"app-config.xml", "test-config.xml"}`为`@ContextConfiguration`的`locations`（或`value`）属性</x>，TestContext框架就会加载相应的`ApplicationContext`，并将其存储在一个仅基于这些位置的键下的`static`上下文缓存中。因此，如果`TestClassB`也定义了`{"app-config.xml", "test-config.xml"}`的位置（显式或隐式地通过继承），但没有定义`@WebAppConfiguration`、不同的`ContextLoader`、不同的活动配置文件、不同的上下文初始化器、不同的测试属性源或不同的父上下文，那么两个测试类都共享同一个`ApplicationContext`。这意味着加载一个应用上下文的设置成本只需要花费一次（每个测试套件），后续的测试执行速度会更快。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Test suites and forked processes
#### ** Chinese **

测试套件和分叉进程
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The Spring TestContext framework stores application contexts in a static cache. This means that the context is literally stored in a `static` variable. In other words, if tests execute in separate processes, the static cache is cleared between each test execution, which effectively disables the caching mechanism.
#### ** Chinese **

Spring TestContext框架将应用程序上下文存储在静态缓存中。这意味着上下文被存储在一个`static`变量中。换句话说，如果测试在不同的进程中执行，静态缓存在每次测试执行之间都会被清除，这就有效地关闭了缓存机制。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

To benefit from the caching mechanism, all tests must run within the same process or test suite. This can be achieved by executing all tests as a group within an IDE. Similarly, when executing tests with a build framework such as Ant, Maven, or Gradle, it is important to make sure that the build framework does not fork between tests. For example, if the [`forkMode`](https://maven.apache.org/plugins/maven-surefire-plugin/test-mojo.html#forkMode) for the Maven Surefire plug-in is set to `always` or `pertest`, the TestContext framework cannot cache application contexts between test classes, and the build process runs significantly more slowly as a result.
#### ** Chinese **

为了从缓存机制中受益，所有的测试必须在同一个进程或测试套件中运行。这可以通过在IDE中作为一个组来执行所有测试来实现。同样，当使用构建框架（如Ant、Maven或Gradle）执行测试时，确保构建框架不会在测试之间进行分叉是非常重要的。例如，如果Maven Surefire插件的[`forkMode`](https://maven.apache.org/plugins/maven-surefire-plugin/test-mojo.html#forkMode)被设置为`always`或`pertest`，TestContext框架就无法在测试类之间缓存应用程序上下文，结果是构建过程的运行速度会明显变慢。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The size of the context cache is bounded with a default maximum size of 32. Whenever the maximum size is reached, a least recently used (LRU) eviction policy is used to evict and close stale contexts. You can configure the maximum size from the command line or a build script by setting a JVM system property named `spring.test.context.cache.maxSize`. As an alternative, you can set the same property programmatically by using the `SpringProperties` API.
#### ** Chinese **

上下文缓存的大小是有限制的，默认最大大小为32。每当达到最大大小时，就会使用最小最近使用的（LRU）驱逐策略来驱逐和关闭陈旧的上下文。您可以通过设置一个名为`spring.test.context.cache.maxSize`的JVM系统属性，从命令行或构建脚本中配置最大大小。作为替代方案，您可以通过使用`SpringProperties` API来编程设置相同的属性。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Since having a large number of application contexts loaded within a given test suite can cause the suite to take an unnecessarily long time to execute, it is often beneficial to know exactly how many contexts have been loaded and cached. To view the statistics for the underlying context cache, you can set the log level for the `org.springframework.test.context.cache` logging category to `DEBUG`.
#### ** Chinese **

由于在给定的测试套件中加载了大量的应用程序上下文会导致套件执行时间过长，因此，准确地知道有多少个上下文被加载和缓存，通常是很有好处的。要查看底层上下文缓存的统计数据，您可以将 `org.springframework.test.context.cache`的日志级别设置为`DEBUG`。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

In the unlikely case that a test corrupts the application context and requires reloading (for example, by modifying a bean definition or the state of an application object), you can annotate your test class or test method with `@DirtiesContext` (see the discussion of `@DirtiesContext` in [`@DirtiesContext`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#spring-testing-annotation-dirtiescontext)). This instructs Spring to remove the context from the cache and rebuild the application context before running the next test that requires the same application context. Note that support for the `@DirtiesContext` annotation is provided by the `DirtiesContextBeforeModesTestExecutionListener` and the `DirtiesContextTestExecutionListener`, which are enabled by default.
#### ** Chinese **

如果测试破坏了应用程序上下文并需要重新加载（例如，通过修改Bean定义或应用程序对象的状态），你可以用`@DirtiesContext`来注释你的测试类或测试方法（参见[`@DirtiesContext`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#spring-testing-annotation-dirtiescontext)中关于`@DirtiesContext`的讨论）。这指示Spring在运行下一个需要相同的应用程序上下文的测试之前，从缓存中删除上下文，并重建应用程序上下文。注意，对 `@DirtiesContext` 注释的支持由 `DirtiesContextBeforeModesTestExecutionListener`和 `DirtiesContextTestExecutionListener`提供，这两个注解是默认启用的。
<!-- tabs:end -->


### **Context Hierarchies** 

<!-- tabs:start -->

#### ** English **

When writing integration tests that rely on a loaded Spring `ApplicationContext`, it is often sufficient to test against a single context. However, there are times when it is beneficial or even necessary to test against a hierarchy of `ApplicationContext` instances. For example, if you are developing a Spring MVC web application, you typically have a root `WebApplicationContext` loaded by Spring’s `ContextLoaderListener` and a child `WebApplicationContext` loaded by Spring’s `DispatcherServlet`. This results in a parent-child context hierarchy where shared components and infrastructure configuration are declared in the root context and consumed in the child context by web-specific components. Another use case can be found in Spring Batch applications, where you often have a parent context that provides configuration for shared batch infrastructure and a child context for the configuration of a specific batch job.
#### ** Chinese **

当编写依赖于加载的 Spring `ApplicationContext`的集成测试时，通常只需针对单一的上下文进行测试即可。然而，有时甚至有必要针对一个`ApplicationContext`实例的层次结构进行测试。例如，如果您正在开发一个Spring MVC Web应用程序，通常会有一个由Spring的`ContextLoaderListener`加载的根`WebApplicationContext`和一个由Spring的`DispatcherServlet`加载的子`WebApplicationContext`。这就形成了一个父子上下文层次结构，其中共享的组件和基础架构配置在根上下文中声明，并在子上下文中被特定于Web的组件消耗。另一个用例可以在Spring Batch应用程序中找到，在这里，您经常会有一个父上下文为共享的批处理基础架构提供配置，而子上下文为特定的批处理作业提供配置。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

You can write integration tests that use context hierarchies by declaring context configuration with the `@ContextHierarchy` annotation, either on an individual test class or within a test class hierarchy. If a context hierarchy is declared on multiple classes within a test class hierarchy, you can also merge or override the context configuration for a specific, named level in the context hierarchy. When merging configuration for a given level in the hierarchy, the configuration resource type (that is, XML configuration files or component classes) must be consistent. Otherwise, it is perfectly acceptable to have different levels in a context hierarchy configured using different resource types.
#### ** Chinese **

您可以通过使用 `@ContextHierarchy` 注解声明上下文配置来编写使用上下文层次结构的集成测试，可以在单个测试类上或在测试类层次结构中声明上下文配置。如果在一个测试类层次结构中的多个类上声明了上下文层次结构，那么也可以合并或覆盖上下文层次结构中特定的、被命名的级别的上下文配置。在合并层次结构中的特定级别的配置时，配置资源类型（即XML配置文件或组件类）必须一致。否则，上下文层次结构中的不同层级使用不同的资源类型进行配置是完全可以接受的。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The remaining JUnit Jupiter based examples in this section show common configuration scenarios for integration tests that require the use of context hierarchies.
#### ** Chinese **

本节中剩余的基于JUnit Jupiter的示例展示了需要使用上下文层次结构的集成测试的常见配置场景。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

**Single test class with context hierarchy** 
#### ** Chinese **

***单项测试类与上下文层次结构***。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

`ControllerIntegrationTests` represents a typical integration testing scenario for a Spring MVC web application by declaring a context hierarchy that consists of two levels, one for the root `WebApplicationContext` (loaded by using the `TestAppConfig` `@Configuration` class) and one for the dispatcher servlet `WebApplicationContext` (loaded by using the `WebConfig` `@Configuration` class). The `WebApplicationContext` that is autowired into the test instance is the one for the child context (that is, the lowest context in the hierarchy). The following listing shows this configuration scenario:
#### ** Chinese **

`ControllerIntegrationTests`通过声明一个上下文层次结构来表示一个典型的Spring MVC Web应用程序的集成测试场景，该场景包括两个层次。一个用于根`WebApplicationContext`（通过使用`TestAppConfig` `@Configuration`类加载），一个用于dispatcher servlet `WebApplicationContext`（通过使用`WebConfig` `@Configuration`类加载）。自动加载到测试实例中的`WebApplicationContext`就是子上下文（即层次结构中最低的上下文）。下面的列表显示了这种配置场景。
<!-- tabs:end -->


```java
@ExtendWith(SpringExtension.class)
@WebAppConfiguration
@ContextHierarchy({
    @ContextConfiguration(classes = TestAppConfig.class),
    @ContextConfiguration(classes = WebConfig.class)
})
class ControllerIntegrationTests {

    @Autowired
    WebApplicationContext wac;

    // ...
}
```

<!-- tabs:start -->

#### ** English **

**Class hierarchy with implicit parent context** 
#### ** Chinese **

隐含父类上下文的类层次结构**** 
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The test classes in this example define a context hierarchy within a test class hierarchy. `AbstractWebTests` declares the configuration for a root `WebApplicationContext` in a Spring-powered web application. Note, however, that `AbstractWebTests` does not declare `@ContextHierarchy`. Consequently, subclasses of `AbstractWebTests` can optionally participate in a context hierarchy or follow the standard semantics for `@ContextConfiguration`. `SoapWebServiceTests` and `RestWebServiceTests` both extend `AbstractWebTests` and define a context hierarchy by using `@ContextHierarchy`. The result is that three application contexts are loaded (one for each declaration of `@ContextConfiguration`), and the application context loaded based on the configuration in `AbstractWebTests` is set as the parent context for each of the contexts loaded for the concrete subclasses. The following listing shows this configuration scenario:
#### ** Chinese **

这个例子中的测试类定义了测试类层次结构中的上下文层次结构。 `AbstractWebTests`声明了Spring驱动的Web应用程序中的根`WebApplicationContext`的配置。但是，请注意，`AbstractWebTests`没有声明`@ContextHierarchy`。因此，`AbstractWebTests`的子类可以选择参与上下文层次结构，或者遵循`@ContextConfiguration`的标准语义。 `SoapWebServiceTests`和`RestWebServiceTests`都扩展了`AbstractWebTests`，并通过使用`@ContextHierarchy`定义了上下文层次结构。其结果是加载了三个应用上下文（每个声明`@ContextConfiguration`都加载了一个），并且根据`AbstractWebTests`中的配置加载的应用上下文被设置为具体子类加载的每个上下文的父上下文。下面的列表显示了这种配置场景。
<!-- tabs:end -->


```java
@ExtendWith(SpringExtension.class)
@WebAppConfiguration
@ContextConfiguration("file:src/main/webapp/WEB-INF/applicationContext.xml")
public abstract class AbstractWebTests {}

@ContextHierarchy(@ContextConfiguration("/spring/soap-ws-config.xml"))
public class SoapWebServiceTests extends AbstractWebTests {}

@ContextHierarchy(@ContextConfiguration("/spring/rest-ws-config.xml"))
public class RestWebServiceTests extends AbstractWebTests {}
```

<!-- tabs:start -->

#### ** English **

**Class hierarchy with merged context hierarchy configuration** 
#### ** Chinese **

***类层次结构与合并后的上下文层次结构配置***。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The classes in this example show the use of named hierarchy levels in order to merge the configuration for specific levels in a context hierarchy. `BaseTests` defines two levels in the hierarchy, `parent` and `child`. `ExtendedTests` extends `BaseTests` and instructs the Spring TestContext Framework to merge the context configuration for the `child` hierarchy level, by ensuring that the names declared in the `name` attribute in `@ContextConfiguration` are both `child`. The result is that three application contexts are loaded: one for `/app-config.xml`, one for `/user-config.xml`, and one for `{"/user-config.xml", "/order-config.xml"}`. As with the previous example, the application context loaded from `/app-config.xml` is set as the parent context for the contexts loaded from `/user-config.xml` and `{"/user-config.xml", "/order-config.xml"}`. The following listing shows this configuration scenario:
#### ** Chinese **

这个例子中的类展示了使用命名的层次结构层级，以合并上下文层次结构中特定层次的配置。 `BaseTests`定义了层次结构中的两个层次，即`parent`和`child`。 `ExtendedTests`扩展了`BaseTests`，并通过确保`@ContextConfiguration`中的`name`属性中声明的名字都是`child`，来指示Spring TestContext框架合并`child`层次结构层的上下文配置。结果是加载了三个应用程序上下文：一个用于`/app-config.xml`，一个用于`/user-config.xml`，一个用于`{"/user-config.xml"，"/order-config.xml"}`。与前面的例子一样，从 `/app-config.xml`加载的应用程序上下文被设置为从 `/user-config.xml`和 `{"/user-config.xml", "/order-config.xml"}`加载的上下文的父上下文。下面的列表显示了这种配置场景。
<!-- tabs:end -->


```java
@ExtendWith(SpringExtension.class)
@ContextHierarchy({
    @ContextConfiguration(name = "parent", locations = "/app-config.xml"),
    @ContextConfiguration(name = "child", locations = "/user-config.xml")
})
class BaseTests {}

@ContextHierarchy(
    @ContextConfiguration(name = "child", locations = "/order-config.xml")
)
class ExtendedTests extends BaseTests {}
```

<!-- tabs:start -->

#### ** English **

**Class hierarchy with overridden context hierarchy configuration** 
#### ** Chinese **

***类层次结构与重载的上下文层次结构配置**。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

In contrast to the previous example, this example demonstrates how to override the configuration for a given named level in a context hierarchy by setting the `inheritLocations` flag in `@ContextConfiguration` to `false`. Consequently, the application context for `ExtendedTests` is loaded only from `/test-user-config.xml` and has its parent set to the context loaded from `/app-config.xml`. The following listing shows this configuration scenario:
#### ** Chinese **

与前一个示例相反，这个示例演示了如何通过将 `@ContextConfiguration`中的`inheritLocations`标志设置为`false`来重写上下文层次结构中给定的命名级别的配置。因此，`ExtendedTests`的应用程序上下文仅从`/test-user-config.xml`中加载，其父设置为从`/app-config.xml`中加载的上下文。下面的列表显示了这种配置场景。
<!-- tabs:end -->


```java
@ExtendWith(SpringExtension.class)
@ContextHierarchy({
    @ContextConfiguration(name = "parent", locations = "/app-config.xml"),
    @ContextConfiguration(name = "child", locations = "/user-config.xml")
})
class BaseTests {}

@ContextHierarchy(
    @ContextConfiguration(
        name = "child",
        locations = "/test-user-config.xml",
        inheritLocations = false
))
class ExtendedTests extends BaseTests {}
```

<!-- tabs:start -->

#### ** English **

Dirtying a context within a context hierarchy
#### ** Chinese **

在上下文层次结构中弄脏一个上下文
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

If you use `@DirtiesContext` in a test whose context is configured as part of a context hierarchy, you can use the `hierarchyMode` flag to control how the context cache is cleared. For further details, see the discussion of `@DirtiesContext` in [Spring Testing Annotations](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#spring-testing-annotation-dirtiescontext) and the [`@DirtiesContext`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/test/annotation/DirtiesContext.html) javadoc.
#### ** Chinese **

如果在上下文被配置为上下文层次结构的一部分的测试中使用 `@DirtiesContext`，则可以使用 `hierarchyMode` 标志来控制如何清除上下文缓存。更多详情，请参阅 [Spring Testing Annotations](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#spring-testing-annotation-dirtiescontext) 和 [`@DirtiesContext`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/test/annotation/DirtiesContext.html) javadoc 中关于 `@DirtiesContext`的讨论。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

**3.5.6. Dependency Injection of Test Fixtures** 
#### ** Chinese **

**3.5.6. 测试装置的依赖性注入** 
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

When you use the `DependencyInjectionTestExecutionListener` (which is configured by default), the dependencies of your test instances are injected from beans in the application context that you configured with `@ContextConfiguration` or related annotations. You may use setter injection, field injection, or both, depending on which annotations you choose and whether you place them on setter methods or fields. If you are using JUnit Jupiter you may also optionally use constructor injection (see [Dependency Injection with ](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-junit-jupiter-di)[`SpringExtension`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-junit-jupiter-di)). For consistency with Spring’s annotation-based injection support, you may also use Spring’s `@Autowired` annotation or the `@Inject` annotation from JSR-330 for field and setter injection.
#### ** Chinese **

当您使用 `DependencyInjectionTestExecutionListener`（默认情况下配置的）时，您的测试实例的依赖关系会从您使用 `@ContextConfiguration`或相关注释配置的应用程序上下文中的 beans 中注入。你可以使用设置器注入、字段注入，或者两者都可以，这取决于你选择了哪些注释，以及你是将它们放在设置器方法还是字段上。如果你使用的是JUnit Jupiter，你也可以选择使用构造函数注入（参见[Dependency Injection with ](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-junit-jupiter-di)[`SpringExtension`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-junit-jupiter-di)）。为了与Spring的基于注释的注入支持保持一致，你也可以使用Spring的`@Autowired`注释或JSR-330中的`@Inject`注释来进行字段和setter注入。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

For testing frameworks other than JUnit Jupiter, the TestContext framework does not participate in instantiation of the test class. Thus, the use of `@Autowired` or `@Inject` for constructors has no effect for test classes.
#### ** Chinese **

对于JUnit Jupiter以外的测试框架，TestContext框架不参与测试类的实例化。因此，使用`@Autowired`或`@Inject`构造函数对测试类没有影响。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Although field injection is discouraged in production code, field injection is actually quite natural in test code. The rationale for the difference is that you will never instantiate your test class directly. Consequently, there is no need to be able to invoke a `public` constructor or setter method on your test class.
#### ** Chinese **

虽然在生产代码中不鼓励字段注入，但在测试代码中，字段注入实际上是很自然的。这种区别的理由是，你永远不会直接实例化你的测试类。因此，不需要在测试类上调用`public`构造函数或setter方法。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Because `@Autowired` is used to perform [autowiring by type](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-autowire), if you have multiple bean definitions of the same type, you cannot rely on this approach for those particular beans. In that case, you can use `@Autowired` in conjunction with `@Qualifier`. You can also choose to use `@Inject` in conjunction with `@Named`. Alternatively, if your test class has access to its `ApplicationContext`, you can perform an explicit lookup by using (for example) a call to `applicationContext.getBean("titleRepository", TitleRepository.class)`.
#### ** Chinese **

因为`@Autowired`是用来执行[按类型自动布线](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-autowire)的，所以如果你有多个相同类型的Bean定义，你就不能对这些特定的Bean依赖这种方法。在这种情况下，你可以使用`@Autowired`和`@Qualifier`一起使用。您也可以选择使用 `@Inject`与 `@Named`结合使用。另外，如果你的测试类可以访问它的`ApplicationContext`，你可以通过使用（例如）调用`applicationContext.getBean("titleRepository", TitleRepository.class)`来执行显式查找。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

If you do not want dependency injection applied to your test instances, do not annotate fields or setter methods with `@Autowired` or `@Inject`. Alternatively, you can disable dependency injection altogether by explicitly configuring your class with `@TestExecutionListeners` and omitting `DependencyInjectionTestExecutionListener.class` from the list of listeners.
#### ** Chinese **

如果你不希望依赖注入应用到你的测试实例中，请不要用 `@Autowired`或`@Inject`注释字段或设置器方法。另外，您也可以通过显式配置类中的 `@TestExecutionListeners`并从监听器列表中省略 `DependencyInjectionTestExecutionListener.class`来完全禁用依赖注入。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Consider the scenario of testing a `HibernateTitleRepository` class, as outlined in the [Goals](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#integration-testing-goals) section. The next two code listings demonstrate the use of `@Autowired` on fields and setter methods. The application context configuration is presented after all sample code listings.
#### ** Chinese **

考虑测试一个`HibernateTitleRepository`类的场景，如[目标](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#integration-testing-goals)部分所述。接下来的两个代码列表演示了在字段和setter方法上使用`@Autowired`的情况。应用程序上下文配置在所有示例代码列表之后。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The dependency injection behavior in the following code listings is not specific to JUnit Jupiter. The same DI techniques can be used in conjunction with any supported testing framework.
#### ** Chinese **

以下代码列表中的依赖注入行为并不是JUnit Jupiter所特有的。同样的DI技术可以与任何支持的测试框架结合使用。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following examples make calls to static assertion methods, such as `assertNotNull()`, but without prepending the call with `Assertions`. In such cases, assume that the method was properly imported through an `import static` declaration that is not shown in the example.
#### ** Chinese **

下面的示例调用了静态断言方法，如`assertNotNull()`，但没有在调用前加上`Assertions`。在这种情况下，假设该方法是通过`import static`声明正确导入的，而该声明在示例中没有显示。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The first code listing shows a JUnit Jupiter based implementation of the test class that uses `@Autowired` for field injection:
#### ** Chinese **

第一个代码列表显示了一个基于JUnit Jupiter的测试类的实现，该测试类使用`@Autowired`进行字段注入。
<!-- tabs:end -->


```java
@ExtendWith(SpringExtension.class)
// specifies the Spring configuration to load for this test fixture
@ContextConfiguration("repository-config.xml")
class HibernateTitleRepositoryTests {

    // this instance will be dependency injected by type
    @Autowired
    HibernateTitleRepository titleRepository;

    @Test
    void findById() {
        Title title = titleRepository.findById(new Long(10));
        assertNotNull(title);
    }
}
```

<!-- tabs:start -->

#### ** English **

Alternatively, you can configure the class to use `@Autowired` for setter injection, as follows:
#### ** Chinese **

或者，你可以配置类使用`@Autowired`进行设置器注入，如下所示。
<!-- tabs:end -->


```java
@ExtendWith(SpringExtension.class)
// specifies the Spring configuration to load for this test fixture
@ContextConfiguration("repository-config.xml")
class HibernateTitleRepositoryTests {

    // this instance will be dependency injected by type
    HibernateTitleRepository titleRepository;

    @Autowired
    void setTitleRepository(HibernateTitleRepository titleRepository) {
        this.titleRepository = titleRepository;
    }

    @Test
    void findById() {
        Title title = titleRepository.findById(new Long(10));
        assertNotNull(title);
    }
}
```

<!-- tabs:start -->

#### ** English **

The preceding code listings use the same XML context file referenced by the `@ContextConfiguration` annotation (that is, `repository-config.xml`). The following shows this configuration:
#### ** Chinese **

前面的代码列表使用了`@ContextConfiguration`注释引用的相同的XML上下文文件（即`repository-config.xml`）。下面显示的是这个配置。
<!-- tabs:end -->


```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- this bean will be injected into the HibernateTitleRepositoryTests class -->
    <bean id="titleRepository" class="com.foo.repository.hibernate.HibernateTitleRepository">
        <property name="sessionFactory" ref="sessionFactory"/>
    </bean>

    <bean id="sessionFactory" class="org.springframework.orm.hibernate5.LocalSessionFactoryBean">
        <!-- configuration elided for brevity -->
    </bean>

</beans>
```

<!-- tabs:start -->

#### ** English **

If you are extending from a Spring-provided test base class that happens to use `@Autowired` on one of its setter methods, you might have multiple beans of the affected type defined in your application context (for example, multiple `DataSource` beans). In such a case, you can override the setter method and use the `@Qualifier` annotation to indicate a specific target bean, as follows (but make sure to delegate to the overridden method in the superclass as well):
#### ** Chinese **

如果你是从Spring提供的测试基类中扩展出来的，而这个基类恰好在它的一个setter方法上使用了`@Autowired`，那么你可能会在你的应用程序上下文中定义了多个受影响类型的Bean（例如，多个`DataSource` Bean）。在这种情况下，你可以重写setter方法，并使用`@Qualifier`注释来指示一个特定的目标Bean，如下所示（但一定要确保在超类中委托给超类中的重载方法）。
<!-- tabs:end -->


```java
// ...

    @Autowired
    @Override
    public void setDataSource(@Qualifier("myDataSource") DataSource dataSource) {
        super.setDataSource(dataSource);
    }

// ...
```

<!-- tabs:start -->

#### ** English **

The specified qualifier value indicates the specific `DataSource` bean to inject, narrowing the set of type matches to a specific bean. Its value is matched against `<qualifier>` declarations within the corresponding `<bean>` definitions. The bean name is used as a fallback qualifier value, so you can effectively also point to a specific bean by name there (as shown earlier, assuming that `myDataSource` is the bean `id`).
#### ** Chinese **

指定的限定符值表示要注入的特定的 `DataSource` bean，将类型匹配集缩小到特定的 bean。其值与相应的`<qualifier>`定义中的`<bean>`声明进行匹配。bean 的名称被用作一个回避的限定符值，所以你也可以有效地通过名称指向特定的bean（如前文所示，假设`myDataSource`是bean `id`）。
<!-- tabs:end -->


### **3.5.7. Testing Request- and Session-scoped Beans** 

<!-- tabs:start -->

#### ** English **

Spring has supported [Request- and session-scoped beans](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-scopes-other) since the early years, and you can test your request-scoped and session-scoped beans by following these steps:
#### ** Chinese **

Spring早年就支持[request-scoped beans和session-scoped beans](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-factory-scopes-other)，你可以通过以下步骤来测试你的request-scoped和session-scoped beans。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

- Ensure that a `WebApplicationContext` is loaded for your test by annotating your test class with `@WebAppConfiguration`.

- Inject the mock request or session into your test instance and prepare your test fixture as appropriate.

- Invoke your web component that you retrieved from the configured `WebApplicationContext` (with dependency injection).

- Perform assertions against the mocks.

#### ** Chinese **

- 确保为你的测试加载了一个`WebApplicationContext`，并在测试类中标注`@WebAppConfiguration`。

- 将模拟请求或会话注入测试实例中，并准备好测试夹具。

- 从配置的`WebApplicationContext`中调用你从配置的`WebApplicationContext`中检索到的Web组件（有依赖注入）。

- 对mocks执行断言。

<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

The next code snippet shows the XML configuration for a login use case. Note that the `userService` bean has a dependency on a request-scoped `loginAction` bean. Also, the `LoginAction` is instantiated by using [SpEL expressions](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#expressions) that retrieve the username and password from the current HTTP request. In our test, we want to configure these request parameters through the mock managed by the TestContext framework. The following listing shows the configuration for this use case:
#### ** Chinese **

下面的代码片段显示了一个登录用例的XML配置。请注意，`userService` bean有一个依赖性的请求域`loginAction` bean。另外，`LoginAction`是通过使用[SpEL表达式](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/core.html#expressions)来实例化的，该表达式可以从当前的HTTP请求中获取用户名和密码。在我们的测试中，我们希望通过TestContext框架管理的mock来配置这些请求参数。下面的列表显示了这个用例的配置。
<!-- tabs:end -->


```xml
<beans>

    <bean id="userService" class="com.example.SimpleUserService"
            c:loginAction-ref="loginAction"/>

    <bean id="loginAction" class="com.example.LoginAction"
            c:username="#{request.getParameter('user')}"
            c:password="#{request.getParameter('pswd')}"
            scope="request">
        <aop:scoped-proxy/>
    </bean>

</beans>
```

<!-- tabs:start -->

#### ** English **

In `RequestScopedBeanTests`, we inject both the `UserService` (that is, the subject under test) and the `MockHttpServletRequest` into our test instance. Within our `requestScope()` test method, we set up our test fixture by setting request parameters in the provided `MockHttpServletRequest`. When the `loginUser()` method is invoked on our `userService`, we are assured that the user service has access to the request-scoped `loginAction` for the current `MockHttpServletRequest` (that is, the one in which we just set parameters). We can then perform assertions against the results based on the known inputs for the username and password. The following listing shows how to do so:
#### ** Chinese **

在`RequestScopedBeanTests`中，我们将`UserService`（也就是被测对象）和`MockHttpServletRequest`注入到我们的测试实例中。在我们的`requestScope()`测试方法中，我们通过在提供的`MockHttpServletRequest`中设置请求参数来设置我们的测试夹具。当`loginUser()`方法在我们的`userService`上被调用时，我们可以保证用户服务可以访问当前`MockHttpServletRequest`（也就是我们刚才设置参数的那个）的请求范围内的`loginAction`。然后我们可以根据用户名和密码的已知输入，对结果进行断言。下面的列表显示了如何做到这一点。
<!-- tabs:end -->


```java
@SpringJUnitWebConfig
class RequestScopedBeanTests {

    @Autowired UserService userService;
    @Autowired MockHttpServletRequest request;

    @Test
    void requestScope() {
        request.setParameter("user", "enigma");
        request.setParameter("pswd", "$pr!ng");

        LoginResults results = userService.loginUser();
        // assert results
    }
}
```

<!-- tabs:start -->

#### ** English **

The following code snippet is similar to the one we saw earlier for a request-scoped bean. However, this time, the `userService` bean has a dependency on a session-scoped `userPreferences` bean. Note that the `UserPreferences` bean is instantiated by using a SpEL expression that retrieves the theme from the current HTTP session. In our test, we need to configure a theme in the mock session managed by the TestContext framework. The following example shows how to do so:
#### ** Chinese **

下面的代码片段与我们之前看到的请求-scoped bean类似。但是，这一次，`userService` bean依赖于一个会话范围化的`userPreferences` bean。请注意，`UserPreferences` bean是通过使用SpEL表达式实例化的，该表达式从当前HTTP会话中检索主题。在我们的测试中，我们需要在TestContext框架管理的模拟会话中配置一个主题。下面的例子显示了如何做到这一点。
<!-- tabs:end -->


```xml
<beans>

    <bean id="userService" class="com.example.SimpleUserService"
            c:userPreferences-ref="userPreferences" />

    <bean id="userPreferences" class="com.example.UserPreferences"
            c:theme="#{session.getAttribute('theme')}"
            scope="session">
        <aop:scoped-proxy/>
    </bean>

</beans>
```

<!-- tabs:start -->

#### ** English **

In `SessionScopedBeanTests`, we inject the `UserService` and the `MockHttpSession` into our test instance. Within our `sessionScope()` test method, we set up our test fixture by setting the expected `theme` attribute in the provided `MockHttpSession`. When the `processUserPreferences()` method is invoked on our `userService`, we are assured that the user service has access to the session-scoped `userPreferences` for the current `MockHttpSession`, and we can perform assertions against the results based on the configured theme. The following example shows how to do so:
#### ** Chinese **

在`SessionScopedBeanTests`中，我们将`UserService`和`MockHttpSession`注入到我们的测试实例中。在我们的`sessionScope()`测试方法中，我们通过在提供的`MockHttpSession`中设置预期的`theme`属性来设置我们的测试夹具。当 `processUserPreferences()`方法在我们的`userService`上被调用时，我们可以保证用户服务可以访问当前`MockHttpSession`的会话范围内的`userPreferences`，并且我们可以根据配置的主题对结果执行断言。下面的例子显示了如何做到这一点。
<!-- tabs:end -->


```java
@SpringJUnitWebConfig
class SessionScopedBeanTests {

    @Autowired UserService userService;
    @Autowired MockHttpSession session;

    @Test
    void sessionScope() throws Exception {
        session.setAttribute("theme", "blue");

        Results results = userService.processUserPreferences();
        // assert results
    }
}
```

### **3.5.8. Transaction Management** 

<!-- tabs:start -->

#### ** English **

In the TestContext framework, transactions are managed by the `TransactionalTestExecutionListener`, which is configured by default, even if you do not explicitly declare `@TestExecutionListeners` on your test class. To enable support for transactions, however, you must configure a `PlatformTransactionManager` bean in the `ApplicationContext` that is loaded with `@ContextConfiguration` semantics (further details are provided later). In addition, you must declare Spring’s `@Transactional` annotation either at the class or the method level for your tests.
#### ** Chinese **

在TestContext框架中，事务是由`TransactionalTestExecutionListener`管理的，它是默认配置的，即使你没有在测试类上明确声明`@TestExecutionListeners`。但是，要启用对事务的支持，您必须在`ApplicationContext`中配置一个`PlatformTransactionManager` bean，该bean被加载了`@ContextConfiguration`语义（更多细节将在后面提供）。此外，你必须在类或方法级声明Spring的`@Transactional`注解，用于你的测试。
<!-- tabs:end -->


### **Test-managed Transactions** 

<!-- tabs:start -->

#### ** English **

Test-managed transactions are transactions that are managed declaratively by using the `TransactionalTestExecutionListener` or programmatically by using `TestTransaction` (described later). You should not confuse such transactions with Spring-managed transactions (those managed directly by Spring within the `ApplicationContext` loaded for tests) or application-managed transactions (those managed programmatically within application code that is invoked by tests). Spring-managed and application-managed transactions typically participate in test-managed transactions. However, you should use caution if Spring-managed or application-managed transactions are configured with any propagation type other than `REQUIRED` or `SUPPORTS` (see the discussion on [transaction propagation](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/data-access.html#tx-propagation) for details).
#### ** Chinese **

测试管理的事务是通过使用`TransactionalTestExecutionListener`进行声明式管理的事务，或者通过使用`TestTransaction`进行程序化管理的事务（后面会介绍）。您不应该将这些事务与Spring管理的事务（由Spring直接在为测试加载的`ApplicationContext`中管理的事务）或应用程序管理的事务（在被测试调用的应用程序代码中程序化管理的事务）混淆。Spring管理的事务和应用程序管理的事务通常参与到测试管理的事务中。但是，如果Spring管理的事务或应用管理的事务被配置为`REQUIRED`或`SUPPORTS`以外的任何传播类型，则应谨慎使用（详情请参阅[事务传播](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/data-access.html#tx-propagation)的讨论）。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Preemptive timeouts and test-managed transactions
#### ** Chinese **

先发制人的超时和测试管理的交易
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Caution must be taken when using any form of preemptive timeouts from a testing framework in conjunction with Spring’s test-managed transactions.
#### ** Chinese **

在将测试框架中的任何形式的抢先超时与Spring的测试管理事务结合使用时，必须谨慎。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Specifically, Spring’s testing support binds transaction state to the current thread (via a `java.lang.ThreadLocal` variable) *before* the current test method is invoked. If a testing framework invokes the current test method in a new thread in order to support a preemptive timeout, any actions performed within the current test method will *not* be invoked within the test-managed transaction. Consequently, the result of any such actions will not be rolled back with the test-managed transaction. On the contrary, such actions will be committed to the persistent store — for example, a relational database — even though the test-managed transaction is properly rolled back by Spring.
#### ** Chinese **

具体来说，Spring的测试支持将事务状态绑定到当前线程（通过`java.lang.ThreadLocal`变量），在*调用当前测试方法之前。如果测试框架在一个新的线程中调用当前测试方法以支持抢先超时，那么在当前测试方法中执行的任何操作将*不会在测试管理的事务中被调用。因此，任何此类操作的结果不会随着测试管理的事务回滚。相反，这些操作将被提交到持久化存储--例如关系型数据库--即使测试管理的事务被Spring正确回滚。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Situations in which this can occur include but are not limited to the following.
#### ** Chinese **

可能发生这种情况的情况包括但不限于以下情况：
<!-- tabs:end -->


### **Enabling and Disabling Transactions** 

<!-- tabs:start -->

#### ** English **

Annotating a test method with `@Transactional` causes the test to be run within a transaction that is, by default, automatically rolled back after completion of the test. If a test class is annotated with `@Transactional`, each test method within that class hierarchy runs within a transaction. Test methods that are not annotated with `@Transactional` (at the class or method level) are not run within a transaction. Note that `@Transactional` is not supported on test lifecycle methods — for example, methods annotated with JUnit Jupiter’s `@BeforeAll`, `@BeforeEach`, etc. Furthermore, tests that are annotated with `@Transactional` but have the `propagation` attribute set to `NOT_SUPPORTED` are not run within a transaction.
#### ** Chinese **

用 `@Transactional`注释一个测试方法，会导致测试在事务中运行，默认情况下，测试完成后自动回滚。如果一个测试类被注解为`@Transactional`，那么该类层次结构中的每个测试方法都会在事务中运行。没有标注`@Transactional`的测试方法（在类或方法层）不会在事务中运行。请注意，`@Transactional`不支持在测试生命周期方法上使用`@Transactional`--例如，用JUnit Jupiter的`@BeforeAll`、`@BeforeEach`等注释的方法。此外，使用 `@Transactional`注释的测试，但`propagation`属性设置为`NOT_SUPPORTED`的测试不会在事务中运行。
<!-- tabs:end -->


Attribute | Supported for test-managed transactions 
-|-
value and transactionManager | Yes 
propagation | No 
isolation | No 
timeout | No 
readOnly | No 
rollbackFor and rollbackForClassName | No 
noRollbackFor and noRollbackForClassName | No 


<!-- tabs:start -->

#### ** English **

Method-level lifecycle methods — for example, methods annotated with JUnit Jupiter’s `@BeforeEach` or `@AfterEach` — are run within a test-managed transaction. On the other hand, suite-level and class-level lifecycle methods — for example, methods annotated with JUnit Jupiter’s `@BeforeAll` or `@AfterAll` and methods annotated with TestNG’s `@BeforeSuite`, `@AfterSuite`, `@BeforeClass`, or `@AfterClass` — are *not* run within a test-managed transaction.
#### ** Chinese **

方法级的生命周期方法--例如，用JUnit Jupiter的`@BeforeEach`或`@AfterEach`注释的方法--在测试管理的事务中运行。另一方面，套装级和类级的生命周期方法--例如，用JUnit Jupiter的`@BeforeAll`或`@AfterAll`注释的方法和用TestNG的`@BeforeSuite`注释的方法。 `@AfterSuite`、`@BeforeClass`或`@AfterClass` ---在测试管理的事务中*不*运行。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

If you need to execute code in a suite-level or class-level lifecycle method within a transaction, you may wish to inject a corresponding `PlatformTransactionManager` into your test class and then use that with a `TransactionTemplate` for programmatic transaction management.
#### ** Chinese **

如果你需要在事务中执行套装级或类级的生命周期方法中的代码，你可能希望在你的测试类中注入一个相应的`PlatformTransactionManager`，然后用`TransactionTemplate`来进行程序化事务管理。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Note that [`AbstractTransactionalJUnit4SpringContextTests`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-support-classes-junit4) and [`AbstractTransactionalTestNGSpringContextTests`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-support-classes-testng) are preconfigured for transactional support at the class level.
#### ** Chinese **

请注意，[`AbstractTransactionalJUnit4SpringContextTests`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-support-classes-junit4)和[`AbstractTransactionalTestNGSpringContextTests`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-support-classes-testng)是在类级预配置的事务支持。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following example demonstrates a common scenario for writing an integration test for a Hibernate-based `UserRepository`:
#### ** Chinese **

下面的例子演示了为基于Hibernate的`UserRepository`编写集成测试的常见场景。
<!-- tabs:end -->


```java
@SpringJUnitConfig(TestConfig.class)
@Transactional
class HibernateUserRepositoryTests {

    @Autowired
    HibernateUserRepository repository;

    @Autowired
    SessionFactory sessionFactory;

    JdbcTemplate jdbcTemplate;

    @Autowired
    void setDataSource(DataSource dataSource) {
        this.jdbcTemplate = new JdbcTemplate(dataSource);
    }

    @Test
    void createUser() {
        // track initial state in test database:
        final int count = countRowsInTable("user");

        User user = new User(...);
        repository.save(user);

        // Manual flush is required to avoid false positive in test
        sessionFactory.getCurrentSession().flush();
        assertNumUsers(count + 1);
    }

    private int countRowsInTable(String tableName) {
        return JdbcTestUtils.countRowsInTable(this.jdbcTemplate, tableName);
    }

    private void assertNumUsers(int expected) {
        assertEquals("Number of rows in the [user] table.", expected, countRowsInTable("user"));
    }
}
```

<!-- tabs:start -->

#### ** English **

As explained in [Transaction Rollback and Commit Behavior](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-tx-rollback-and-commit-behavior), there is no need to clean up the database after the `createUser()` method runs, since any changes made to the database are automatically rolled back by the `TransactionalTestExecutionListener`.
#### ** Chinese **

正如[事务回滚和提交行为](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-tx-rollback-and-commit-behavior)中所解释的那样，在`createUser()`方法运行后，不需要清理数据库，因为对数据库所做的任何更改都会被`TransactionalTestExecutionListener`自动回滚。
<!-- tabs:end -->


### **Transaction Rollback and Commit Behavior** 

<!-- tabs:start -->

#### ** English **

By default, test transactions will be automatically rolled back after completion of the test; however, transactional commit and rollback behavior can be configured declaratively via the `@Commit` and `@Rollback` annotations. See the corresponding entries in the [annotation support](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#integration-testing-annotations) section for further details.
#### ** Chinese **

默认情况下，测试事务将在测试完成后自动回滚；但是，事务提交和回滚行为可以通过`@Commit`和`@Rollback`注释来声明性地配置。更多详情，请参阅[注解支持](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#integration-testing-annotations)部分中的相应条目。
<!-- tabs:end -->


### **Programmatic Transaction Management** 

<!-- tabs:start -->

#### ** English **

You can interact with test-managed transactions programmatically by using the static methods in `TestTransaction`. For example, you can use `TestTransaction` within test methods, before methods, and after methods to start or end the current test-managed transaction or to configure the current test-managed transaction for rollback or commit. Support for `TestTransaction` is automatically available whenever the `TransactionalTestExecutionListener` is enabled.
#### ** Chinese **

您可以通过使用`TestTransaction`中的静态方法与测试管理事务进行程序化交互。例如，您可以在测试方法中、方法前和方法后使用 `TestTransaction`来启动或结束当前测试管理的事务，或配置当前测试管理的事务进行回滚或提交。只要启用了`TransactionalTestExecutionListener`，就会自动支持`TestTransactionalTestTransaction`。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following example demonstrates some of the features of `TestTransaction`. See the javadoc for [`TestTransaction`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/test/context/transaction/TestTransaction.html) for further details.
#### ** Chinese **

下面的例子演示了`TestTransaction`的一些特性。更多详情，请参阅 [`TestTransaction`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/test/context/transaction/TestTransaction.html)的 javadoc。
<!-- tabs:end -->


```java
@ContextConfiguration(classes = TestConfig.class)
public class ProgrammaticTransactionManagementTests extends
        AbstractTransactionalJUnit4SpringContextTests {

    @Test
    public void transactionalTest() {
        // assert initial state in test database:
        assertNumUsers(2);

        deleteFromTables("user");

        // changes to the database will be committed!
        TestTransaction.flagForCommit();
        TestTransaction.end();
        assertFalse(TestTransaction.isActive());
        assertNumUsers(0);

        TestTransaction.start();
        // perform other actions against the database that will
        // be automatically rolled back after the test completes...
    }

    protected void assertNumUsers(int expected) {
        assertEquals("Number of rows in the [user] table.", expected, countRowsInTable("user"));
    }
}
```

### **Running Code Outside of a Transaction** 

<!-- tabs:start -->

#### ** English **

Occasionally, you may need to execute certain code before or after a transactional test method but outside the transactional context — for example, to verify the initial database state prior to running your test or to verify expected transactional commit behavior after your test runs (if the test was configured to commit the transaction). `TransactionalTestExecutionListener` supports the `@BeforeTransaction` and `@AfterTransaction` annotations for exactly such scenarios. You can annotate any `void` method in a test class or any `void` default method in a test interface with one of these annotations, and the `TransactionalTestExecutionListener` ensures that your before transaction method or after transaction method runs at the appropriate time.
#### ** Chinese **

偶尔，你可能需要在事务性测试方法之前或之后执行某些代码，但在事务性上下文之外--例如，在运行测试前验证初始数据库状态，或者在测试运行后验证预期的事务提交行为（如果测试被配置为提交事务）。 `TransactionalTestExecutionListener`支持`@BeforeTransaction`和`@AfterTransaction`注释，正是针对此类场景的注释。你可以在测试类中的任何`void`方法或测试接口中的任何`void`缺省方法中的任何`void`方法都可以使用这些注释之一进行注释，而`TransactionalTestExecutionListener`可以确保你的事务前方法或事务后方法在适当的时间运行。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Any before methods (such as methods annotated with JUnit Jupiter’s `@BeforeEach`) and any after methods (such as methods annotated with JUnit Jupiter’s `@AfterEach`) are run within a transaction. In addition, methods annotated with `@BeforeTransaction` or `@AfterTransaction` are not run for test methods that are not configured to run within a transaction.
#### ** Chinese **

任何之前的方法（比如用JUnit Jupiter的`@BeforeEach`注释的方法）和之后的方法（比如用JUnit Jupiter的`@AfterEach`注释的方法）都是在事务中运行的。此外，用`@BeforeTransaction`或`@AfterTransaction`注解的方法不会在事务中运行。
<!-- tabs:end -->


### **Configuring a Transaction Manager** 

<!-- tabs:start -->

#### ** English **

`TransactionalTestExecutionListener` expects a `PlatformTransactionManager` bean to be defined in the Spring `ApplicationContext` for the test. If there are multiple instances of `PlatformTransactionManager` within the test’s `ApplicationContext`, you can declare a qualifier by using `@Transactional("myTxMgr")` or `@Transactional(transactionManager = "myTxMgr")`, or `TransactionManagementConfigurer` can be implemented by an `@Configuration` class. Consult the [javadoc for ](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/test/context/transaction/TestContextTransactionUtils.html#retrieveTransactionManager-org.springframework.test.context.TestContext-java.lang.String-)[`TestContextTransactionUtils.retrieveTransactionManager()`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/test/context/transaction/TestContextTransactionUtils.html#retrieveTransactionManager-org.springframework.test.context.TestContext-java.lang.String-) for details on the algorithm used to look up a transaction manager in the test’s `ApplicationContext`.
#### ** Chinese **

`TransactionalTestExecutionListener`期望在测试的 Spring `ApplicationContext`ApplicationContext</x>中定义一个`PlatformTransactionManager` bean。如果在测试的`ApplicationContext`中存在多个`PlatformTransactionManager`实例。你可以通过使用`@Transactional("myTxMgr")`或`@Transactional(transactionManager = "myTxMgr")`来声明一个修饰符，或者`TransactionManagementConfigurer`可以通过`@Configuration`类来实现。有关在测试的`ApplicationContext`中查询事务管理器的算法的详细信息，请参考[javadoc for ](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/test/context/transaction/TestContextTransactionUtils.html#retrieveTransactionManager-org.springframework.test.context.TestContext-java.lang.String-)[`TestContextTransactionUtils.retrieveTransactionManager()`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/test/context/transaction/TestContextTransactionUtils.html#retrieveTransactionManager-org.springframework.test.context.TestContext-java.lang.String-)。
<!-- tabs:end -->


### **Demonstration of All Transaction-related Annotations** 

<!-- tabs:start -->

#### ** English **

The following JUnit Jupiter based example displays a fictitious integration testing scenario that highlights all transaction-related annotations. The example is not intended to demonstrate best practices but rather to demonstrate how these annotations can be used. See the [annotation support](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#integration-testing-annotations) section for further information and configuration examples. [Transaction management for ](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-executing-sql-declaratively-tx)[`@Sql`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-executing-sql-declaratively-tx) contains an additional example that uses `@Sql` for declarative SQL script execution with default transaction rollback semantics. The following example shows the relevant annotations:
#### ** Chinese **

下面这个基于 JUnit Jupiter 的示例显示了一个虚构的集成测试场景，它突出了所有事务相关的注释。这个例子不是为了展示最佳实践，而是为了展示如何使用这些注释。有关更多信息和配置示例，请参阅[注释支持](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#integration-testing-annotations)部分。 事务管理](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-executing-sql-declaratively-tx)[`@Sql`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-executing-sql-declaratively-tx)包含一个额外的示例，该示例使用`@Sql`来执行带有默认事务回滚语义的声明式SQL脚本。下面的例子显示了相关的注释。
<!-- tabs:end -->


```java
@SpringJUnitConfig
@Transactional(transactionManager = "txMgr")
@Commit
class FictitiousTransactionalTest {

    @BeforeTransaction
    void verifyInitialDatabaseState() {
        // logic to verify the initial state before a transaction is started
    }

    @BeforeEach
    void setUpTestDataWithinTransaction() {
        // set up test data within the transaction
    }

    @Test
    // overrides the class-level @Commit setting
    @Rollback
    void modifyDatabaseWithinTransaction() {
        // logic which uses the test data and modifies database state
    }

    @AfterEach
    void tearDownWithinTransaction() {
        // execute "tear down" logic within the transaction
    }

    @AfterTransaction
    void verifyFinalDatabaseState() {
        // logic to verify the final state after transaction has rolled back
    }

}
```

<!-- tabs:start -->

#### ** English **

Avoid false positives when testing ORM code
#### ** Chinese **

避免测试ORM代码时出现假阳性
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

When you test application code that manipulates the state of a Hibernate session or JPA persistence context, make sure to flush the underlying unit of work within test methods that run that code. Failing to flush the underlying unit of work can produce false positives: Your test passes, but the same code throws an exception in a live, production environment. Note that this applies to any ORM framework that maintains an in-memory unit of work. In the following Hibernate-based example test case, one method demonstrates a false positive, and the other method correctly exposes the results of flushing the session:
#### ** Chinese **

当您测试操纵Hibernate会话或JPA持久化上下文状态的应用程序代码时，请确保在运行该代码的测试方法中刷新底层工作单元。如果没有刷新底层工作单元，就会产生假阳性结果。你的测试通过了，但同样的代码却在实时生产环境中抛出了异常。注意，这适用于任何维护内存中工作单元的ORM框架。在下面这个基于Hibernate的示例测试案例中，一个方法演示了一个假阳性，而另一个方法正确地暴露了冲洗会话的结果。
<!-- tabs:end -->


```java
// ...

@Autowired
SessionFactory sessionFactory;

@Transactional
@Test // no expected exception!
public void falsePositive() {
    updateEntityInHibernateSession();
    // False positive: an exception will be thrown once the Hibernate
    // Session is finally flushed (i.e., in production code)
}

@Transactional
@Test(expected = ...)
public void updateWithSessionFlush() {
    updateEntityInHibernateSession();
    // Manual flush is required to avoid false positive in test
    sessionFactory.getCurrentSession().flush();
}

// ...
```

<!-- tabs:start -->

#### ** English **

The following example shows matching methods for JPA:
#### ** Chinese **

下面的例子显示了JPA的匹配方法。
<!-- tabs:end -->


```java
// ...

@PersistenceContext
EntityManager entityManager;

@Transactional
@Test // no expected exception!
public void falsePositive() {
    updateEntityInJpaPersistenceContext();
    // False positive: an exception will be thrown once the JPA
    // EntityManager is finally flushed (i.e., in production code)
}

@Transactional
@Test(expected = ...)
public void updateWithEntityManagerFlush() {
    updateEntityInJpaPersistenceContext();
    // Manual flush is required to avoid false positive in test
    entityManager.flush();
}

// ...
```

### **3.5.9. Executing SQL Scripts** 

<!-- tabs:start -->

#### ** English **

When writing integration tests against a relational database, it is often beneficial to execute SQL scripts to modify the database schema or insert test data into tables. The `spring-jdbc` module provides support for *initializing* an embedded or existing database by executing SQL scripts when the Spring `ApplicationContext` is loaded. See [Embedded database support](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/data-access.html#jdbc-embedded-database-support) and [Testing data access logic with an embedded database](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/data-access.html#jdbc-embedded-database-dao-testing) for details.
#### ** Chinese **

在针对关系型数据库编写集成测试时，执行SQL脚本来修改数据库模式或将测试数据插入到表中通常是很有好处的。`spring-jdbc`模块在加载Spring `ApplicationContext`时，通过执行SQL脚本，支持*初始化嵌入式或现有数据库。详情请参阅[嵌入式数据库支持](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/data-access.html#jdbc-embedded-database-support)和[使用嵌入式数据库测试数据访问逻辑](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/data-access.html#jdbc-embedded-database-dao-testing)。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Although it is very useful to initialize a database for testing *once* when the `ApplicationContext` is loaded, sometimes it is essential to be able to modify the database *during* integration tests. The following sections explain how to execute SQL scripts programmatically and declaratively during integration tests.
#### ** Chinese **

虽然在加载`ApplicationContext`时初始化数据库进行测试是非常有用的，但有时在集成测试期间，必须要能够修改数据库。下面的章节将解释如何在集成测试中以程序化和声明式方式执行SQL脚本。
<!-- tabs:end -->


### **Executing SQL scripts programmatically** 

<!-- tabs:start -->

#### ** English **

Spring provides the following options for executing SQL scripts programmatically within integration test methods.
#### ** Chinese **

Spring提供了以下选项，用于在集成测试方法中以编程方式执行SQL脚本。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

- JUnit 4’s `@Test(timeout = …​)` support and `TimeOut` rule

- JUnit Jupiter’s `assertTimeoutPreemptively(…​)` methods in the `org.junit.jupiter.api.Assertions` class

- TestNG’s `@Test(timeOut = …​)` support

- `org.springframework.jdbc.datasource.init.ScriptUtils`

- `org.springframework.jdbc.datasource.init.ResourceDatabasePopulator`

- `org.springframework.test.context.junit4.AbstractTransactionalJUnit4SpringContextTests`

- `org.springframework.test.context.testng.AbstractTransactionalTestNGSpringContextTests`

#### ** Chinese **

- JUnit 4的`@Test(timeout = …​)`支持和`TimeOut`规则

- JUnit Jupiter的`assertTimeoutPreemptively(…​)`类中的`org.junit.jupiter.api.api.Assertions`方法

- TestNG的`@Test(timeOut = …​)`支持

- `org.springframework.jdbc.datasource.init.ScriptUtils`

- `org.springframework.jdbc.datasource.init.ResourceDatabasePopulator`

- `org.springframework.test.context.junit4.AbstractTransactionalJUnit4SpringContextTests`

- `org.springframework.test.context.testng.AbstractTransactionalTestNGSpringContextTests`

<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

`ScriptUtils` provides a collection of static utility methods for working with SQL scripts and is mainly intended for internal use within the framework. However, if you require full control over how SQL scripts are parsed and executed, `ScriptUtils` may suit your needs better than some of the other alternatives described later. See the [javadoc](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/jdbc/datasource/init/ScriptUtils.html) for individual methods in `ScriptUtils` for further details.
#### ** Chinese **

`ScriptUtils`提供了一个静态实用工具方法的集合，用于处理SQL脚本，主要用于框架内的内部使用。但是，如果您需要完全控制SQL脚本的解析和执行方式，`ScriptUtils`可能比后面描述的其他一些替代方法更适合您的需求。关于 `ScriptUtils`中的个别方法，请参阅 [javadoc](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/jdbc/datasource/init/ScriptUtils.html)，以了解更多详情。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

`ResourceDatabasePopulator` provides an object-based API for programmatically populating, initializing, or cleaning up a database by using SQL scripts defined in external resources. `ResourceDatabasePopulator` provides options for configuring the character encoding, statement separator, comment delimiters, and error handling flags used when parsing and running the scripts. Each of the configuration options has a reasonable default value. See the [javadoc](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/jdbc/datasource/init/ResourceDatabasePopulator.html) for details on default values. To run the scripts configured in a `ResourceDatabasePopulator`, you can invoke either the `populate(Connection)` method to execute the populator against a `java.sql.Connection` or the `execute(DataSource)` method to execute the populator against a `javax.sql.DataSource`. The following example specifies SQL scripts for a test schema and test data, sets the statement separator to `@@`, and executes the scripts against a `DataSource`:
#### ** Chinese **

`ResourceDatabasePopulator`提供了一个基于对象的API，用于使用外部资源中定义的SQL脚本对数据库进行程序化填充、初始化或清理。 `ResourceDatabasePopulator`提供了用于配置字符编码、语句分隔符、注释分隔符、注释分隔符以及解析和运行脚本时使用的错误处理标志的选项。每个配置选项都有一个合理的默认值。有关默认值的详细信息，请参阅[javadoc](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/jdbc/datasource/init/ResourceDatabasePopulator.html)。要运行在`ResourceDatabasePopulator`中配置的脚本，可以调用`populate(Connection)`方法来执行populator，以针对`java.sql.Connection`，或者调用`execute(DataSource)`方法来执行populator，以针对`javax.sql.DataSource`。下面的示例为测试模式和测试数据指定了SQL脚本，将语句分隔符设置为`@@`,，并针对`DataSource`执行脚本。
<!-- tabs:end -->


```java
@Test
void databaseTest() {
    ResourceDatabasePopulator populator = new ResourceDatabasePopulator();
    populator.addScripts(
            new ClassPathResource("test-schema.sql"),
            new ClassPathResource("test-data.sql"));
    populator.setSeparator("@@");
    populator.execute(this.dataSource);
    // execute code that uses the test schema and data
}
```

<!-- tabs:start -->

#### ** English **

Note that `ResourceDatabasePopulator` internally delegates to `ScriptUtils` for parsing and running SQL scripts. Similarly, the `executeSqlScript(..)` methods in [`AbstractTransactionalJUnit4SpringContextTests`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-support-classes-junit4) and [`AbstractTransactionalTestNGSpringContextTests`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-support-classes-testng) internally use a `ResourceDatabasePopulator` to run SQL scripts. See the javadoc for the various `executeSqlScript(..)` methods for further details.
#### ** Chinese **

请注意，`ResourceDatabasePopulator`内部委托给`ScriptUtils`来解析和运行SQL脚本。同样地，[`AbstractactionalJUnit4SpringContextTests`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-support-classes-junit4)和[`AbstractTransactionalTestNGSpringContextTests`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-support-classes-testng)中的`executeSqlScript(..)`方法内部使用`ResourceDatabasePopulator`来运行SQL脚本。更多详情，请参考javadoc中的各种`executeSqlScript(..)`方法。
<!-- tabs:end -->


### **Executing SQL scripts declaratively with @Sql** 

<!-- tabs:start -->

#### ** English **

In addition to the aforementioned mechanisms for running SQL scripts programmatically, you can declaratively configure SQL scripts in the Spring TestContext Framework. Specifically, you can declare the `@Sql` annotation on a test class or test method to configure individual SQL statements or the resource paths to SQL scripts that should be run against a given database before or after an integration test method. Support for `@Sql` is provided by the `SqlScriptsTestExecutionListener`, which is enabled by default.
#### ** Chinese **

除了上述的程序化运行SQL脚本的机制之外，您还可以在Spring TestContext框架中声明性地配置SQL脚本。具体来说，你可以在测试类或测试方法上声明`@Sql`注解，以配置单独的SQL语句或SQL脚本的资源路径，这些资源路径应该在集成测试方法之前或之后针对给定的数据库运行。`@Sql`支持`@Sql`由`SqlScriptsTestExecutionListener`提供，默认情况下，该插件已被启用。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Method-level `@Sql` declarations override class-level declarations by default. As of Spring Framework 5.2, however, this behavior may be configured per test class or per test method via `@SqlMergeMode`. See [Merging and Overriding Configuration with ](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-executing-sql-declaratively-script-merging)[`@SqlMergeMode`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-executing-sql-declaratively-script-merging) for further details.
#### ** Chinese **

方法级的`@Sql`声明默认会覆盖类级声明。但是，从Spring Framework 5.2开始，这个行为可以通过`@SqlMergeMode`来配置每个测试类或每个测试方法。更多详情，请参阅[Merging and Overriding Configuration with ](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-executing-sql-declaratively-script-merging)[`@SqlMergeMode`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-executing-sql-declaratively-script-merging)。
<!-- tabs:end -->


### **Path Resource Semantics** 

<!-- tabs:start -->

#### ** English **

Each path is interpreted as a Spring `Resource`. A plain path (for example, `"schema.sql"`) is treated as a classpath resource that is relative to the package in which the test class is defined. A path starting with a slash is treated as an absolute classpath resource (for example, `"/org/example/schema.sql"`). A path that references a URL (for example, a path prefixed with `classpath:`, `file:`, `http:`) is loaded by using the specified resource protocol.
#### ** Chinese **

每个路径被解释为 Spring `Resource`。一个普通路径（例如，`"schema.sql"`）被视为相对于定义测试类的包的classpath资源。以斜线开头的路径被视为绝对的classpath资源（例如，`"/org/example/schema.sql"`）。引用一个URL的路径（例如，以`classpath:`、`file:`、`http:`为前缀的路径）将通过使用指定的资源协议加载。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following example shows how to use `@Sql` at the class level and at the method level within a JUnit Jupiter based integration test class:
#### ** Chinese **

下面的例子显示了如何在类级和方法级使用`@Sql`，在基于JUnit Jupiter的集成测试类中使用`@Sql`。
<!-- tabs:end -->


```java
@SpringJUnitConfig
@Sql("/test-schema.sql")
class DatabaseTests {

    @Test
    void emptySchemaTest() {
        // execute code that uses the test schema without any test data
    }

    @Test
    @Sql({"/test-schema.sql", "/test-user-data.sql"})
    void userTest() {
        // execute code that uses the test schema and test data
    }
}
```

### **Default Script Detection** 

<!-- tabs:start -->

#### ** English **

If no SQL scripts or statements are specified, an attempt is made to detect a `default` script, depending on where `@Sql` is declared. If a default cannot be detected, an `IllegalStateException` is thrown.
#### ** Chinese **

如果没有指定SQL脚本或语句，将根据`@Sql`声明的位置，尝试检测一个`default`脚本。如果无法检测到默认值，则会抛出一个`IllegalStateException`。
<!-- tabs:end -->


### **Declaring Multiple** **`@Sql`** ** Sets** 

<!-- tabs:start -->

#### ** English **

If you need to configure multiple sets of SQL scripts for a given test class or test method but with different syntax configuration, different error handling rules, or different execution phases per set, you can declare multiple instances of `@Sql`. With Java 8, you can use `@Sql` as a repeatable annotation. Otherwise, you can use the `@SqlGroup` annotation as an explicit container for declaring multiple instances of `@Sql`.
#### ** Chinese **

如果你需要为一个给定的测试类或测试方法配置多套SQL脚本，但每套脚本的语法配置不同，错误处理规则不同，或者每套脚本的执行阶段不同，你可以声明多个`@Sql`的实例。在Java 8中，你可以使用`@Sql`作为可重复的注释。否则，您可以使用 `@SqlGroup` 注解作为一个显式容器，用于声明多个 `@Sql`实例。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following example shows how to use `@Sql` as a repeatable annotation with Java 8:
#### ** Chinese **

下面的例子显示了如何使用`@Sql`作为Java 8的可重复注释。
<!-- tabs:end -->


```java
@Test
@Sql(scripts = "/test-schema.sql", config = @SqlConfig(commentPrefix = "`"))
@Sql("/test-user-data.sql")
void userTest() {
    // execute code that uses the test schema and test data
}
```

<!-- tabs:start -->

#### ** English **

In the scenario presented in the preceding example, the `test-schema.sql` script uses a different syntax for single-line comments.
#### ** Chinese **

在前面的示例中，`test-schema.sql`脚本使用了不同的单行注释语法。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following example is identical to the preceding example, except that the `@Sql` declarations are grouped together within `@SqlGroup`. With Java 8 and above, the use of `@SqlGroup` is optional, but you may need to use `@SqlGroup` for compatibility with other JVM languages such as Kotlin.
#### ** Chinese **

下面的例子与前面的例子相同，只是`@Sql`声明被分组到`@SqlGroup`中。在Java 8及以上版本中，使用`@SqlGroup`是可选的，但为了与其他JVM语言（如Kotlin）的兼容性，您可能需要使用`@SqlGroup`。
<!-- tabs:end -->


```java
@Test
@SqlGroup({
    @Sql(scripts = "/test-schema.sql", config = @SqlConfig(commentPrefix = "`")),
    @Sql("/test-user-data.sql")
)}
void userTest() {
    // execute code that uses the test schema and test data
}
```

### **Script Execution Phases** 

<!-- tabs:start -->

#### ** English **

By default, SQL scripts are executed before the corresponding test method. However, if you need to run a particular set of scripts after the test method (for example, to clean up database state), you can use the `executionPhase` attribute in `@Sql`, as the following example shows:
#### ** Chinese **

默认情况下，SQL脚本会在相应的测试方法之前执行。但是，如果你需要在测试方法之后运行一组特定的脚本（例如，清理数据库状态），你可以使用`@Sql`中的`executionPhase`属性，如下例所示。
<!-- tabs:end -->


```java
@Test
@Sql(
    scripts = "create-test-data.sql",
    config = @SqlConfig(transactionMode = ISOLATED)
)
@Sql(
    scripts = "delete-test-data.sql",
    config = @SqlConfig(transactionMode = ISOLATED),
    executionPhase = AFTER_TEST_METHOD
)
void userTest() {
    // execute code that needs the test data to be committed
    // to the database outside of the test's transaction
}
```

<!-- tabs:start -->

#### ** English **

Note that `ISOLATED` and `AFTER_TEST_METHOD` are statically imported from `Sql.TransactionMode` and `Sql.ExecutionPhase`, respectively.
#### ** Chinese **

请注意，`ISOLATED`和`AFTER_TEST_METHOD`分别从`Sql.TransactionMode`和`Sql.ExecutionPhase`中静态导入。
<!-- tabs:end -->


### **Script Configuration with** **`@SqlConfig`** 

<!-- tabs:start -->

#### ** English **

You can configure script parsing and error handling by using the `@SqlConfig` annotation. When declared as a class-level annotation on an integration test class, `@SqlConfig` serves as global configuration for all SQL scripts within the test class hierarchy. When declared directly by using the `config` attribute of the `@Sql` annotation, `@SqlConfig` serves as local configuration for the SQL scripts declared within the enclosing `@Sql` annotation. Every attribute in `@SqlConfig` has an implicit default value, which is documented in the javadoc of the corresponding attribute. Due to the rules defined for annotation attributes in the Java Language Specification, it is, unfortunately, not possible to assign a value of `null` to an annotation attribute. Thus, in order to support overrides of inherited global configuration, `@SqlConfig` attributes have an explicit default value of either `""` (for Strings), `{}` (for arrays), or `DEFAULT` (for enumerations). This approach lets local declarations of `@SqlConfig` selectively override individual attributes from global declarations of `@SqlConfig` by providing a value other than `""`, `{}`, or `DEFAULT`. Global `@SqlConfig` attributes are inherited whenever local `@SqlConfig` attributes do not supply an explicit value other than `""`, `{}`, or `DEFAULT`. Explicit local configuration, therefore, overrides global configuration.
#### ** Chinese **

您可以通过使用`@SqlConfig`注释来配置脚本解析和错误处理。当作为集成测试类上的类级注释声明时，`@SqlConfig`可以作为测试类层次结构中所有SQL脚本的全局配置。当使用`@Sql`注释的`config`属性直接声明时，`@SqlConfig`将作为包围的`@Sql`注释中声明的SQL脚本的本地配置。`@SqlConfig`中的每一个属性都有一个隐含的默认值，这在相应的属性的javadoc中被记录下来。由于Java语言规范中为注解属性定义的规则，不幸的是，不可能给一个注解属性赋值为`null`。因此，为了支持重写继承的全局配置，`@SqlConfig`属性有一个显式的缺省值`""`（用于字符串），`{}`（用于数组），或者`DEFAULT`（用于枚举）。这种方法可以让 `@SqlConfig`的本地声明通过提供 `@SqlConfig`的全局声明中的 `@SqlConfig`的值以外的值，有选择地覆盖单个属性。当本地的`@SqlConfig`属性没有提供除`""`、`{}`或`DEFAULT`以外的其他显式值时，全局`@SqlConfig`属性就会被继承。因此，明确的本地配置会优先于全局配置。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The configuration options provided by `@Sql` and `@SqlConfig` are equivalent to those supported by `ScriptUtils` and `ResourceDatabasePopulator` but are a superset of those provided by the `<jdbc:initialize-database/>` XML namespace element. See the javadoc of individual attributes in [`@Sql`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/test/context/jdbc/Sql.html) and [`@SqlConfig`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/test/context/jdbc/SqlConfig.html) for details.
#### ** Chinese **

`@Sql`和`@SqlConfig`提供的配置选项与`ScriptUtils`和`ResourceDatabasePopulator`所支持的配置选项相当，但它是`<jdbc:initialize-database/>` XML命名空间元素所提供的配置选项的超集。有关详细信息，请参阅 [`@Sql`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/test/context/jdbc/Sql.html)和 [`@SqlConfig`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/test/context/jdbc/SqlConfig.html)中的单个属性的 javadoc。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

**Transaction management for** **`@Sql`** 
#### ** Chinese **

**交易管理*** **`@Sql`***** 
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

By default, the `SqlScriptsTestExecutionListener` infers the desired transaction semantics for scripts configured by using `@Sql`. Specifically, SQL scripts are run without a transaction, within an existing Spring-managed transaction (for example, a transaction managed by the `TransactionalTestExecutionListener` for a test annotated with `@Transactional`), or within an isolated transaction, depending on the configured value of the `transactionMode` attribute in `@SqlConfig` and the presence of a `PlatformTransactionManager` in the test’s `ApplicationContext`. As a bare minimum, however, a `javax.sql.DataSource` must be present in the test’s `ApplicationContext`.
#### ** Chinese **

缺省情况下，`SqlScriptsTestExecutionListener`为使用`@Sql`配置的脚本推导出所需的事务语义。具体来说，SQL脚本在没有事务的情况下，在现有的Spring管理的事务中运行（例如，由`TransactionalTestExecutionListener`管理的事务，用于注释了`@Transactional`的测试）。或在一个孤立的事务中，取决于`@SqlConfig`中的`transactionMode`属性的配置值，以及测试的`ApplicationContext`中的`PlatformTransactionManager`是否存在。但是，作为最低要求，测试的`javax.sql.DataSource`必须在测试的`ApplicationContext`中存在。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

If the algorithms used by `SqlScriptsTestExecutionListener` to detect a `DataSource` and `PlatformTransactionManager` and infer the transaction semantics do not suit your needs, you can specify explicit names by setting the `dataSource` and `transactionManager` attributes of `@SqlConfig`. Furthermore, you can control the transaction propagation behavior by setting the `transactionMode` attribute of `@SqlConfig` (for example, whether scripts should be run in an isolated transaction). Although a thorough discussion of all supported options for transaction management with `@Sql` is beyond the scope of this reference manual, the javadoc for [`@SqlConfig`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/test/context/jdbc/SqlConfig.html) and [`SqlScriptsTestExecutionListener`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/test/context/jdbc/SqlScriptsTestExecutionListener.html) provide detailed information, and the following example shows a typical testing scenario that uses JUnit Jupiter and transactional tests with `@Sql`:
#### ** Chinese **

如果`SqlScriptsTestExecutionListener`用于检测`DataSource`和`PlatformTransactionManager`并推断事务语义的算法不适合您的需求，您可以通过设置`@SqlConfig`的`dataSource`和`transactionManager`属性来指定显式名称。此外，您可以通过设置`@SqlConfig`的`transactionMode`属性来控制事务传播行为（例如，脚本是否应该在一个孤立的事务中运行）。虽然彻底讨论使用 `@Sql`支持的事务管理的所有选项超出了本参考手册的范围，但 [`@SqlConfig`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/test/context/jdbc/SqlConfig.html)和 [`SqlScriptsTestExecutionListener`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/test/context/jdbc/SqlScriptsTestExecutionListener.html)的 javadoc 提供了详细的信息，下面的例子显示了一个典型的测试场景，该场景使用 JUnit Jupiter 和使用 `@Sql`进行事务测试。
<!-- tabs:end -->


```java
@SpringJUnitConfig(TestDatabaseConfig.class)
@Transactional
class TransactionalSqlScriptsTests {

    final JdbcTemplate jdbcTemplate;

    @Autowired
    TransactionalSqlScriptsTests(DataSource dataSource) {
        this.jdbcTemplate = new JdbcTemplate(dataSource);
    }

    @Test
    @Sql("/test-data.sql")
    void usersTest() {
        // verify state in test database:
        assertNumUsers(2);
        // execute code that uses the test data...
    }

    int countRowsInTable(String tableName) {
        return JdbcTestUtils.countRowsInTable(this.jdbcTemplate, tableName);
    }

    void assertNumUsers(int expected) {
        assertEquals(expected, countRowsInTable("user"),
            "Number of rows in the [user] table.");
    }
}
```

<!-- tabs:start -->

#### ** English **

Note that there is no need to clean up the database after the `usersTest()` method is run, since any changes made to the database (either within the test method or within the `/test-data.sql` script) are automatically rolled back by the `TransactionalTestExecutionListener` (see [transaction management](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-tx) for details).
#### ** Chinese **

请注意，在`usersTest()`方法运行后不需要清理数据库，因为对数据库所做的任何更改（无论是在测试方法内还是在`/test-data.sql`脚本内）都会被`TransactionalTestExecutionListener`自动回滚（详情请参见[事务管理](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-tx)）。
<!-- tabs:end -->


### **Merging and Overriding Configuration with** **`@SqlMergeMode`** 

<!-- tabs:start -->

#### ** English **

As of Spring Framework 5.2, it is possible to merge method-level `@Sql` declarations with class-level declarations. For example, this allows you to provide the configuration for a database schema or some common test data once per test class and then provide additional, use case specific test data per test method. To enable `@Sql` merging, annotate either your test class or test method with `@SqlMergeMode(MERGE)`. To disable merging for a specific test method (or specific test subclass), you can switch back to the default mode via `@SqlMergeMode(OVERRIDE)`. Consult the [`@SqlMergeMode`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#spring-testing-annotation-sqlmergemode)[ annotation documentation section](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#spring-testing-annotation-sqlmergemode) for examples and further details.
#### ** Chinese **

从Spring Framework 5.2开始，可以将方法级`@Sql`声明与类级声明合并。例如，这允许你为每个测试类提供一次数据库模式或一些常用的测试数据的配置，然后为每个测试方法提供额外的、特定于用例的测试数据。要启用`@Sql`合并，请用`@SqlMergeMode(MERGE)`注释测试类或测试方法。要禁用特定测试方法（或特定测试子类）的合并，可以通过`@SqlMergeMode(OVERRIDE)`切换回默认模式。有关示例和进一步的详细信息，请参考[`@SqlMergeMode`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#spring-testing-annotation-sqlmergemode)[注释文档部分](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#spring-testing-annotation-sqlmergemode)。
<!-- tabs:end -->


### **3.5.10. Parallel Test Execution** 

<!-- tabs:start -->

#### ** English **

Spring Framework 5.0 introduced basic support for executing tests in parallel within a single JVM when using the Spring TestContext Framework. In general, this means that most test classes or test methods can be executed in parallel without any changes to test code or configuration.
#### ** Chinese **

Spring Framework 5.0引入了在使用Spring TestContext框架时，在单个JVM内并行执行测试的基本支持。一般来说，这意味着大多数测试类或测试方法都可以并行执行，而无需修改测试代码或配置。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

For details on how to set up parallel test execution, see the documentation for your testing framework, build tool, or IDE.
#### ** Chinese **

有关如何设置并行测试执行的详细信息，请参阅测试框架、构建工具或IDE的文档。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Keep in mind that the introduction of concurrency into your test suite can result in unexpected side effects, strange runtime behavior, and tests that fail intermittently or seemingly randomly. The Spring Team therefore provides the following general guidelines for when not to execute tests in parallel.
#### ** Chinese **

请记住，在测试套件中引入并发可能会导致意外的副作用、奇怪的运行时行为以及间歇性或看似随机的测试失败。因此，Spring团队提供了以下关于何时不并行执行测试的一般指导原则。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Do not execute tests in parallel if the tests:
#### ** Chinese **

不要同时执行测试，如果测试。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

- Class-level declaration: If the annotated test class is `com.example.MyTest`, the corresponding default script is `classpath:com/example/MyTest.sql`.

- Method-level declaration: If the annotated test method is named `testMethod()` and is defined in the class `com.example.MyTest`, the corresponding default script is `classpath:com/example/MyTest.testMethod.sql`.

- Use Spring Framework’s `@DirtiesContext` support.

- Use Spring Boot’s `@MockBean` or `@SpyBean` support.

- Use JUnit 4’s `@FixMethodOrder` support or any testing framework feature that is designed to ensure that test methods run in a particular order. Note, however, that this does not apply if entire test classes are executed in parallel.

- Change the state of shared services or systems such as a database, message broker, filesystem, and others. This applies to both embedded and external systems.

#### ** Chinese **

- 类级声明。如果注释的测试类为`com.example.MyTest`，则相应的默认脚本为`classpath:com/example/MyTest.sql`。

- 方法级声明。如果注释的测试方法被命名为 `testMethod()`，并在类 `com.example.MyTest`中定义，则相应的默认脚本为 `classpath:com/example/MyTest.testMethod.sql`。

- 使用Spring Framework的`@DirtiesContext`支持。

- 使用Spring Boot的`@MockBean`或`@SpyBean`支持。

- 使用JUnit 4的`@FixMethodOrder`支持或任何测试框架功能，该功能旨在确保测试方法按特定顺序运行。但请注意，如果整个测试类并行执行，这并不适用。

- 改变共享服务或系统的状态，如数据库、消息代理、文件系统等共享服务或系统。这既适用于嵌入式系统，也适用于外部系统。

<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

If parallel test execution fails with an exception stating that the `ApplicationContext` for the current test is no longer active, this typically means that the `ApplicationContext` was removed from the `ContextCache` in a different thread.
#### ** Chinese **

如果并行测试执行失败，并且出现异常，说明当前测试的`ApplicationContext`不再活动，这通常意味着`ApplicationContext`在不同的线程中被从`ContextCache`中移除。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

This may be due to the use of `@DirtiesContext` or due to automatic eviction from the `ContextCache`. If `@DirtiesContext` is the culprit, you either need to find a way to avoid using `@DirtiesContext` or exclude such tests from parallel execution. If the maximum size of the `ContextCache` has been exceeded, you can increase the maximum size of the cache. See the discussion on [context caching](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-ctx-management-caching) for details.
#### ** Chinese **

这可能是由于使用了`@DirtiesContext`，或者是由于从`ContextCache`中自动删除。如果`@DirtiesContext`是罪魁祸首，那么您需要找到一种方法来避免使用`@DirtiesContext`，或者将此类测试从并行执行中排除。如果已经超过了`ContextCache`的最大尺寸，可以增加缓存的最大尺寸。详情请参阅[上下文缓存](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-ctx-management-caching)上的讨论。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Parallel test execution in the Spring TestContext Framework is only possible if the underlying `TestContext` implementation provides a copy constructor, as explained in the javadoc for [`TestContext`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/test/context/TestContext.html). The `DefaultTestContext` used in Spring provides such a constructor. However, if you use a third-party library that provides a custom `TestContext` implementation, you need to verify that it is suitable for parallel test execution.
#### ** Chinese **

在Spring TestContext框架中，只有当底层的`TestContext`实现提供了一个副本构造函数时，才有可能在Spring TestContext框架中并行测试执行，这在[`TestContext`](https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/javadoc-api/org/springframework/test/context/TestContext.html)的javadoc中已经解释过了。Spring 中使用的 `DefaultTestContext`提供了这样一个构造函数。但是，如果您使用第三方库提供了自定义的 `TestContext`实现，您需要验证它是否适合于并行测试执行。
<!-- tabs:end -->


### **3.5.11. TestContext Framework Support Classes** 

<!-- tabs:start -->

#### ** English **

This section describes the various classes that support the Spring TestContext Framework.
#### ** Chinese **

本节介绍支持Spring TestContext框架的各种类。
<!-- tabs:end -->


### **Spring JUnit 4 Runner** 

<!-- tabs:start -->

#### ** English **

The Spring TestContext Framework offers full integration with JUnit 4 through a custom runner (supported on JUnit 4.12 or higher). By annotating test classes with `@RunWith(SpringJUnit4ClassRunner.class)` or the shorter `@RunWith(SpringRunner.class)` variant, developers can implement standard JUnit 4-based unit and integration tests and simultaneously reap the benefits of the TestContext framework, such as support for loading application contexts, dependency injection of test instances, transactional test method execution, and so on. If you want to use the Spring TestContext Framework with an alternative runner (such as JUnit 4’s `Parameterized` runner) or third-party runners (such as the `MockitoJUnitRunner`), you can, optionally, use [Spring’s support for JUnit rules](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-junit4-rules) instead.
#### ** Chinese **

Spring TestContext框架通过自定义运行程序（支持JUnit 4.12或更高版本），提供了与JUnit 4的完全集成。通过使用`@RunWith(SpringJUnit4ClassRunner.class)`或更短的`@RunWith(SpringRunner.class)`变体来注释测试类，开发人员可以实现基于JUnit 4的标准单元和集成测试，同时获得TestContext框架的好处，例如支持加载应用程序上下文、测试实例的依赖注入、事务性测试方法执行等。如果你想使用Spring TestContext框架与其他运行器（如JUnit 4的`Parameterized`运行器）或第三方运行器（如`MockitoJUnitRunner`）一起使用Spring TestContext框架，你可以选择使用[Spring对JUnit规则的支持](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-junit4-rules)。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following code listing shows the minimal requirements for configuring a test class to run with the custom Spring `Runner`:
#### ** Chinese **

下面的代码列表显示了配置测试类与自定义Spring `Runner`运行的最低要求。
<!-- tabs:end -->


```java
@RunWith(SpringRunner.class)
@TestExecutionListeners({})
public class SimpleTest {

    @Test
    public void testMethod() {
        // execute test logic...
    }
}
```

<!-- tabs:start -->

#### ** English **

In the preceding example, `@TestExecutionListeners` is configured with an empty list, to disable the default listeners, which otherwise would require an `ApplicationContext` to be configured through `@ContextConfiguration`.
#### ** Chinese **

在前面的例子中，`@TestExecutionListeners`被配置为空列表，以禁用默认监听器，否则需要通过`@ContextConfiguration`来配置`ApplicationContext`。
<!-- tabs:end -->


### **Spring JUnit 4 Rules** 

<!-- tabs:start -->

#### ** English **

The `org.springframework.test.context.junit4.rules` package provides the following JUnit 4 rules (supported on JUnit 4.12 or higher):
#### ** Chinese **

`org.springframework.test.context.junit4.rules`包提供了以下JUnit 4规则（支持JUnit 4.12或更高版本）。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

- `SpringClassRule`

- `SpringMethodRule`

#### ** Chinese **

- `SpringClassRule`

- `SpringMethodRule`

<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

`SpringClassRule` is a JUnit `TestRule` that supports class-level features of the Spring TestContext Framework, whereas `SpringMethodRule` is a JUnit `MethodRule` that supports instance-level and method-level features of the Spring TestContext Framework.
#### ** Chinese **

`SpringClassRule`是一个JUnit `TestRule`，支持Spring TestContext框架的类级特性，而`SpringMethodRule`是一个JUnit `MethodRule`，支持Spring TestContext框架的实例级和方法级特性。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

In contrast to the `SpringRunner`, Spring’s rule-based JUnit support has the advantage of being independent of any `org.junit.runner.Runner` implementation and can, therefore, be combined with existing alternative runners (such as JUnit 4’s `Parameterized`) or third-party runners (such as the `MockitoJUnitRunner`).
#### ** Chinese **

与`SpringRunner`相比，Spring的基于规则的JUnit支持具有独立于任何`org.junit.runner.Runner`实现的优势，因此可以与现有的替代运行器（如JUnit 4的`Parameterized`）或第三方运行器（如`MockitoJUnitRunner`）结合起来。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

To support the full functionality of the TestContext framework, you must combine a `SpringClassRule` with a `SpringMethodRule`. The following example shows the proper way to declare these rules in an integration test:
#### ** Chinese **

为了支持TestContext框架的全部功能，你必须将`SpringClassRule`和`SpringMethodRule`结合起来。下面的例子显示了在集成测试中声明这些规则的正确方法。
<!-- tabs:end -->


```java
// Optionally specify a non-Spring Runner via @RunWith(...)
@ContextConfiguration
public class IntegrationTest {

    @ClassRule
    public static final SpringClassRule springClassRule = new SpringClassRule();

    @Rule
    public final SpringMethodRule springMethodRule = new SpringMethodRule();

    @Test
    public void testMethod() {
        // execute test logic...
    }
}
```

### **JUnit 4 Support Classes** 

<!-- tabs:start -->

#### ** English **

The `org.springframework.test.context.junit4` package provides the following support classes for JUnit 4-based test cases (supported on JUnit 4.12 or higher):
#### ** Chinese **

`org.springframework.test.context.junit4`包为基于JUnit 4的测试用例（支持JUnit 4.12或更高版本）提供了以下支持类。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

- `AbstractJUnit4SpringContextTests`

- `AbstractTransactionalJUnit4SpringContextTests`

#### ** Chinese **

- `AbstractJUnit4SpringContextTests`

- `AbstractTransactionalJUnit4SpringContextTests`</x>

<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

`AbstractJUnit4SpringContextTests` is an abstract base test class that integrates the Spring TestContext Framework with explicit `ApplicationContext` testing support in a JUnit 4 environment. When you extend `AbstractJUnit4SpringContextTests`, you can access a `protected` `applicationContext` instance variable that you can use to perform explicit bean lookups or to test the state of the context as a whole.
#### ** Chinese **

`AbstractJUnit4SpringContextTests`是一个抽象的基础测试类，它在JUnit 4环境中集成了Spring TestContext框架和显式`ApplicationContext`测试支持。当你扩展了`AbstractJUnit4S4SpringContextTests`时，你可以访问一个`protected`的`applicationContext`实例变量，你可以用它来执行显式Bean查找或测试整个上下文的状态。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

`AbstractTransactionalJUnit4SpringContextTests` is an abstract transactional extension of `AbstractJUnit4SpringContextTests` that adds some convenience functionality for JDBC access. This class expects a `javax.sql.DataSource` bean and a `PlatformTransactionManager` bean to be defined in the `ApplicationContext`. When you extend `AbstractTransactionalJUnit4SpringContextTests`, you can access a `protected` `jdbcTemplate` instance variable that you can use to run SQL statements to query the database. You can use such queries to confirm database state both before and after running database-related application code, and Spring ensures that such queries run in the scope of the same transaction as the application code. When used in conjunction with an ORM tool, be sure to avoid [false positives](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-tx-false-positives). As mentioned in [JDBC Testing Support](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#integration-testing-support-jdbc), `AbstractTransactionalJUnit4SpringContextTests` also provides convenience methods that delegate to methods in `JdbcTestUtils` by using the aforementioned `jdbcTemplate`. Furthermore, `AbstractTransactionalJUnit4SpringContextTests` provides an `executeSqlScript(..)` method for running SQL scripts against the configured `DataSource`.
#### ** Chinese **

`AbstractTransactionalJUnit4SpringContextTests`是`AbstractJUnit4SpringContextTests`的一个抽象事务性扩展，它为JDBC访问增加了一些方便的功能。这个类期望在`ApplicationContext`中定义一个`javax.sql.DataSource` bean和一个`PlatformTransactionManager` bean。当你扩展`AbstractTransactionalJUnit4SpringContextTests`时，你可以访问一个受保护的```jdbcTemplate`实例变量，你可以用它来运行SQL语句来查询数据库。您可以在运行数据库相关的应用程序代码之前和之后使用这些查询来确认数据库状态，Spring确保这些查询与应用程序代码在同一事务的范围内运行。当与ORM工具配合使用时，一定要避免[误报](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-tx-false-positives)。正如[JDBC测试支持](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#integration-testing-support-jdbc)中提到的那样，`AbstractTransactionalJUnit4SpringContextTests`还提供了方便的方法，通过使用前面提到的`jdbcTemplate`，将其委托给`JdbcTestUtils`中的方法。此外，`AbstractTransactionalJUnit4SpringContextTests`还提供了一个`executeSqlScript(.)`方法，用于针对配置的`DataSource`运行SQL脚本。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

These classes are a convenience for extension. If you do not want your test classes to be tied to a Spring-specific class hierarchy, you can configure your own custom test classes by using `@RunWith(SpringRunner.class)` or [Spring’s JUnit rules](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-junit4-rules).
#### ** Chinese **

这些类是一种方便的扩展方式。如果你不希望你的测试类被绑定到Spring特有的类层次结构中，你可以通过使用`@RunWith(SpringRunner.class)`或[Spring的JUnit规则](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-junit4-rules)来配置你自己的自定义测试类。
<!-- tabs:end -->


### **SpringExtension for JUnit Jupiter** 

<!-- tabs:start -->

#### ** English **

The Spring TestContext Framework offers full integration with the JUnit Jupiter testing framework, introduced in JUnit 5. By annotating test classes with `@ExtendWith(SpringExtension.class)`, you can implement standard JUnit Jupiter-based unit and integration tests and simultaneously reap the benefits of the TestContext framework, such as support for loading application contexts, dependency injection of test instances, transactional test method execution, and so on.
#### ** Chinese **

Spring TestContext框架提供了与JUnit 5中引入的JUnit Jupiter测试框架的完全集成。通过用`@ExtendWith(SpringExtension.class)`注释测试类，您可以实现基于JUnit Jupiter的标准单元测试和集成测试，并同时获得TestContext框架的好处，如支持加载应用程序上下文、测试实例的依赖注入、事务性测试方法执行等。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Furthermore, thanks to the rich extension API in JUnit Jupiter, Spring provides the following features above and beyond the feature set that Spring supports for JUnit 4 and TestNG:
#### ** Chinese **

此外，得益于JUnit Jupiter中丰富的扩展API，Spring在JUnit 4和TestNG支持的功能集之外，还提供了以下功能。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

- Dependency injection for test constructors, test methods, and test lifecycle callback methods. See [Dependency Injection with ](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-junit-jupiter-di)[`SpringExtension`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-junit-jupiter-di) for further details.

- Powerful support for [conditional test execution](https://junit.org/junit5/docs/current/user-guide/#extensions-conditions) based on SpEL expressions, environment variables, system properties, and so on. See the documentation for `@EnabledIf` and `@DisabledIf` in [Spring JUnit Jupiter Testing Annotations](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#integration-testing-annotations-junit-jupiter) for further details and examples.

- Custom composed annotations that combine annotations from Spring and JUnit Jupiter. See the `@TransactionalDevTestConfig` and `@TransactionalIntegrationTest` examples in [Meta-Annotation Support for Testing](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#integration-testing-annotations-meta) for further details.

#### ** Chinese **

- 测试构造函数、测试方法和测试生命周期回调方法的依赖注入。详情请参见[Dependency Injection with ](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-junit-jupiter-di)[`SpringExtension`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-junit-jupiter-di)。

- 基于SpEL表达式、环境变量、系统属性等的[条件测试执行](https://junit.org/junit5/docs/current/user-guide/#extensions-conditions)的强大支持。更多详情和示例请参见[Spring JUnit Jupiter测试注释](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#integration-testing-annotations-junit-jupiter)中的`@EnabledIf`和`@DisabledIf`的文档。

- 结合Spring和JUnit Jupiter注释的自定义组成注释。更多详情，请参阅[Meta-Annotation Support for Testing](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#integration-testing-annotations-meta)中的 `@TransactionalDevTestConfig` 和 `@TransactionalIntegrationTest` 示例。

<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

The following code listing shows how to configure a test class to use the `SpringExtension` in conjunction with `@ContextConfiguration`:
#### ** Chinese **

下面的代码列表显示了如何配置一个测试类来使用`SpringExtension`和`@ContextConfiguration`。
<!-- tabs:end -->


```java
// Instructs JUnit Jupiter to extend the test with Spring support.
@ExtendWith(SpringExtension.class)
// Instructs Spring to load an ApplicationContext from TestConfig.class
@ContextConfiguration(classes = TestConfig.class)
class SimpleTests {

    @Test
    void testMethod() {
        // execute test logic...
    }
}
```

<!-- tabs:start -->

#### ** English **

Since you can also use annotations in JUnit 5 as meta-annotations, Spring provides the `@SpringJUnitConfig` and `@SpringJUnitWebConfig` composed annotations to simplify the configuration of the test `ApplicationContext` and JUnit Jupiter.
#### ** Chinese **

因为你也可以在JUnit 5中使用注解作为元注解，所以Spring提供了`@SpringJUnitConfig`和`@SpringJUnitWebConfig`组成的注解，以简化测试`ApplicationContext`和JUnit Jupiter的配置。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following example uses `@SpringJUnitConfig` to reduce the amount of configuration used in the previous example:
#### ** Chinese **

下面的例子使用`@SpringJUnitConfig`来减少上一个例子中使用的配置量。
<!-- tabs:end -->


```java
// Instructs Spring to register the SpringExtension with JUnit
// Jupiter and load an ApplicationContext from TestConfig.class
@SpringJUnitConfig(TestConfig.class)
class SimpleTests {

    @Test
    void testMethod() {
        // execute test logic...
    }
}
```

<!-- tabs:start -->

#### ** English **

Similarly, the following example uses `@SpringJUnitWebConfig` to create a `WebApplicationContext` for use with JUnit Jupiter:
#### ** Chinese **

同样，下面的例子使用`@SpringJUnitWebConfig`来创建一个`WebApplicationContext`用于JUnit Jupiter。
<!-- tabs:end -->


```java
// Instructs Spring to register the SpringExtension with JUnit
// Jupiter and load a WebApplicationContext from TestWebConfig.class
@SpringJUnitWebConfig(TestWebConfig.class)
class SimpleWebTests {

    @Test
    void testMethod() {
        // execute test logic...
    }
}
```

<!-- tabs:start -->

#### ** English **

See the documentation for `@SpringJUnitConfig` and `@SpringJUnitWebConfig` in [Spring JUnit Jupiter Testing Annotations](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#integration-testing-annotations-junit-jupiter) for further details.
#### ** Chinese **

更多详情，请参阅[Spring JUnit Jupiter 测试注释](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#integration-testing-annotations-junit-jupiter)中的 `@SpringJUnitConfig`和`@SpringJUnitWebConfig`的文档。
<!-- tabs:end -->


### **Dependency Injection with** **`SpringExtension`** 

<!-- tabs:start -->

#### ** English **

`SpringExtension` implements the [`ParameterResolver`](https://junit.org/junit5/docs/current/user-guide/#extensions-parameter-resolution) extension API from JUnit Jupiter, which lets Spring provide dependency injection for test constructors, test methods, and test lifecycle callback methods.
#### ** Chinese **

`SpringExtension`实现了JUnit Jupiter的[`ParameterResolver`](https://junit.org/junit5/docs/current/user-guide/#extensions-parameter-resolution)扩展API，它可以让Spring为测试构造函数、测试方法和测试生命周期回调方法提供依赖注入。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Specifically, `SpringExtension` can inject dependencies from the test’s `ApplicationContext` into test constructors and methods that are annotated with `@BeforeAll`, `@AfterAll`, `@BeforeEach`, `@AfterEach`, `@Test`, `@RepeatedTest`, `@ParameterizedTest`, and others.
#### ** Chinese **

具体来说，`SpringExtension`可以从测试的`ApplicationContext`中注入依赖关系到测试构造函数和方法中，这些方法被注释为`@BeforeAll`。 `@AfterAll`、`@BeforeEach`、`@AfterEach`、`@Test`、`@RepeatedTest`、`@ParameterizedTest`等。
<!-- tabs:end -->


### **Constructor Injection** 

<!-- tabs:start -->

#### ** English **

If a specific parameter in a constructor for a JUnit Jupiter test class is of type `ApplicationContext` (or a sub-type thereof) or is annotated or meta-annotated with `@Autowired`, `@Qualifier`, or `@Value`, Spring injects the value for that specific parameter with the corresponding bean or value from the test’s `ApplicationContext`.
#### ** Chinese **

如果JUnit Jupiter测试类的构造函数中的特定参数属于`ApplicationContext`类型（或其子类型），或被注释或元注释为`@Autowired`、`@Qualifier`或`@Value`，Spring就会从测试的`ApplicationContext`中注入相应的Bean或值，为该特定参数注入值。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Spring can also be configured to autowire all arguments for a test class constructor if the constructor is considered to be *autowirable*. A constructor is considered to be autowirable if one of the following conditions is met (in order of precedence).
#### ** Chinese **

如果构造函数被认为是*autowirable*，Spring也可以被配置为自动触发测试类构造函数的所有参数。如果满足以下条件之一，则构造函数被认为是自动触发的（按优先级排序）。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

- The constructor is annotated with `@Autowired`.

- `@TestConstructor` is present or meta-present on the test class with the `autowireMode` attribute set to `ALL`.

- The default *test constructor autowire mode* has been changed to `ALL`.

#### ** Chinese **

- 构造函数被注释为`@Autowired`。

- `@TestConstructor`存在或元存在于测试类中，并且`autowireMode`属性设置为`ALL`。

- 默认的*test构造函数autowire模式*已改为`ALL`。

<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

See [`@TestConstructor`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#integration-testing-annotations-testconstructor) for details on the use of `@TestConstructor` and how to change the global *test constructor autowire mode*.
#### ** Chinese **

有关 `@TestConstructor`</x>的详细使用方法以及如何改变全局*test构造函数的自动线模式*，请参见[`@TestConstructor`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#integration-testing-annotations-testconstructor)。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

If the constructor for a test class is considered to be *autowirable*, Spring assumes the responsibility for resolving arguments for all parameters in the constructor. Consequently, no other `ParameterResolver` registered with JUnit Jupiter can resolve parameters for such a constructor.
#### ** Chinese **

如果一个测试类的构造函数被认为是*autowirable*，那么Spring将承担解析构造函数中所有参数的参数的责任。因此，在 JUnit Jupiter 中注册的其他 `ParameterResolver`都不能解析这样的构造函数的参数。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

Constructor injection for test classes must not be used in conjunction with JUnit Jupiter’s `@TestInstance(PER_CLASS)` support if `@DirtiesContext` is used to close the test’s `ApplicationContext` before or after test methods.
#### ** Chinese **

如果`@DirtiesContext`被用来在测试方法之前或之后关闭测试的`ApplicationContext`，则测试类的构造函数注入不得与JUnit Jupiter的`@TestInstance(PER_CLASS)`支持结合使用。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The reason is that `@TestInstance(PER_CLASS)` instructs JUnit Jupiter to cache the test instance between test method invocations. Consequently, the test instance will retain references to beans that were originally injected from an `ApplicationContext` that has been subsequently closed. Since the constructor for the test class will only be invoked once in such scenarios, dependency injection will not occur again, and subsequent tests will interact with beans from the closed `ApplicationContext` which may result in errors.
#### ** Chinese **

原因是`@TestInstance(PER_CLASS)`指示JUnit Jupiter在测试方法调用之间缓存测试实例。因此，测试实例将保留对最初从`ApplicationContext`注入的Bean的引用，该Bean随后被关闭。由于在这种情况下，测试类的构造函数只会被调用一次，因此依赖注入不会再次发生，后续的测试将与来自已关闭的`ApplicationContext`的bean交互，这可能会导致错误。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

To use `@DirtiesContext` with "before test method" or "after test method" modes in conjunction with `@TestInstance(PER_CLASS)`, one must configure dependencies from Spring to be supplied via field or setter injection so that they can be re-injected between test method invocations.
#### ** Chinese **

要将`@DirtiesContext`与`@TestInstance(PER_CLASS)`结合使用`@TestInstance(PER_CLASS)`，必须配置来自Spring的依赖关系，通过字段或setter注入来提供，以便在测试方法调用之间重新注入。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

In the following example, Spring injects the `OrderService` bean from the `ApplicationContext` loaded from `TestConfig.class` into the `OrderServiceIntegrationTests` constructor.
#### ** Chinese **

在下面的例子中，Spring将从`TestConfig.class`加载的`ApplicationContext`中的`OrderService` bean注入到`OrderServiceIntegrationTests`构造函数中。
<!-- tabs:end -->


```java
@SpringJUnitConfig(TestConfig.class)
class OrderServiceIntegrationTests {

    private final OrderService orderService;

    @Autowired
    OrderServiceIntegrationTests(OrderService orderService) {
        this.orderService = orderService;
    }

    // tests that use the injected OrderService
}
```

<!-- tabs:start -->

#### ** English **

Note that this feature lets test dependencies be `final` and therefore immutable.
#### ** Chinese **

请注意，这个特性可以让测试依赖关系成为`final`，因此是不可更改的。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

If the `spring.test.constructor.autowire.mode` property is to `all` (see [`@TestConstructor`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#integration-testing-annotations-testconstructor)), we can omit the declaration of `@Autowired` on the constructor in the previous example, resulting in the following.
#### ** Chinese **

如果`spring.test.constructor.autowire.mode`属性为`all`（参见[`@TestConstructor`](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#integration-testing-annotations-testconstructor)），我们可以省略上一个例子中的构造函数上的`@Autowired`声明，结果是如下所示。
<!-- tabs:end -->


```java
@SpringJUnitConfig(TestConfig.class)
class OrderServiceIntegrationTests {

    private final OrderService orderService;

    OrderServiceIntegrationTests(OrderService orderService) {
        this.orderService = orderService;
    }

    // tests that use the injected OrderService
}
```

### **Method Injection** 

<!-- tabs:start -->

#### ** English **

If a parameter in a JUnit Jupiter test method or test lifecycle callback method is of type `ApplicationContext` (or a sub-type thereof) or is annotated or meta-annotated with `@Autowired`, `@Qualifier`, or `@Value`, Spring injects the value for that specific parameter with the corresponding bean from the test’s `ApplicationContext`.
#### ** Chinese **

如果JUnit Jupiter测试方法或测试生命周期回调方法中的参数是类型为`ApplicationContext`（或其子类型），或被注释或元注释为`@Autowired`。 `@Qualifier`，或`@Value`，Spring将从测试的`ApplicationContext`中注入相应的Bean，为该特定参数注入值。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

In the following example, Spring injects the `OrderService` from the `ApplicationContext` loaded from `TestConfig.class` into the `deleteOrder()` test method:
#### ** Chinese **

在下面的示例中，Spring将从`TestConfig.class`中加载的`ApplicationContext`中的`OrderService`注入到`deleteOrder()`测试方法中。
<!-- tabs:end -->


```java
@SpringJUnitConfig(TestConfig.class)
class OrderServiceIntegrationTests {

    @Test
    void deleteOrder(@Autowired OrderService orderService) {
        // use orderService from the test's ApplicationContext
    }
}
```

<!-- tabs:start -->

#### ** English **

Due to the robustness of the `ParameterResolver` support in JUnit Jupiter, you can also have multiple dependencies injected into a single method, not only from Spring but also from JUnit Jupiter itself or other third-party extensions.
#### ** Chinese **

由于JUnit Jupiter中的`ParameterResolver`支持的鲁棒性，你也可以将多个依赖注入到一个方法中，不仅可以来自Spring，也可以来自JUnit Jupiter本身或其他第三方扩展。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

The following example shows how to have both Spring and JUnit Jupiter inject dependencies into the `placeOrderRepeatedly()` test method simultaneously.
#### ** Chinese **

下面的示例显示了如何让Spring和JUnit Jupiter同时向`placeOrderRepeatedly()`测试方法注入依赖关系。
<!-- tabs:end -->


```java
@SpringJUnitConfig(TestConfig.class)
class OrderServiceIntegrationTests {

    @RepeatedTest(10)
    void placeOrderRepeatedly(RepetitionInfo repetitionInfo,
            @Autowired OrderService orderService) {

        // use orderService from the test's ApplicationContext
        // and repetitionInfo from JUnit Jupiter
    }
}
```

<!-- tabs:start -->

#### ** English **

Note that the use of `@RepeatedTest` from JUnit Jupiter lets the test method gain access to the `RepetitionInfo`.
#### ** Chinese **

注意，使用 JUnit Jupiter 中的 `@RepeatedTest` 可以让测试方法获得对 `RepetitionInfo`的访问。
<!-- tabs:end -->


### **TestNG Support Classes** 

<!-- tabs:start -->

#### ** English **

The `org.springframework.test.context.testng` package provides the following support classes for TestNG based test cases:
#### ** Chinese **

`org.springframework.test.context.testng`包为基于TestNG的测试用例提供了以下支持类。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

- `AbstractTestNGSpringContextTests`

- `AbstractTransactionalTestNGSpringContextTests`

#### ** Chinese **

- `AbstractTestNGSpringContextTests`

- `AbstractTransactionalTestNGSpringContextTests`

<!-- tabs:end -->

<!-- tabs:start -->

#### ** English **

`AbstractTestNGSpringContextTests` is an abstract base test class that integrates the Spring TestContext Framework with explicit `ApplicationContext` testing support in a TestNG environment. When you extend `AbstractTestNGSpringContextTests`, you can access a `protected` `applicationContext` instance variable that you can use to perform explicit bean lookups or to test the state of the context as a whole.
#### ** Chinese **

`AbstractTestNGSpringContextTests`是一个抽象的基础测试类，它将Spring TestContext框架与显式`ApplicationContext`测试支持集成在TestNG环境中。当你扩展`AbstractTestNGSpringContextTests`时，你可以访问一个受保护的`applicationContext`实例变量，你可以用它来执行显式Bean查找或测试整个上下文的状态。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

`AbstractTransactionalTestNGSpringContextTests` is an abstract transactional extension of `AbstractTestNGSpringContextTests` that adds some convenience functionality for JDBC access. This class expects a `javax.sql.DataSource` bean and a `PlatformTransactionManager` bean to be defined in the `ApplicationContext`. When you extend `AbstractTransactionalTestNGSpringContextTests`, you can access a `protected` `jdbcTemplate` instance variable that you can use to execute SQL statements to query the database. You can use such queries to confirm database state both before and after running database-related application code, and Spring ensures that such queries run in the scope of the same transaction as the application code. When used in conjunction with an ORM tool, be sure to avoid [false positives](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-tx-false-positives). As mentioned in [JDBC Testing Support](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#integration-testing-support-jdbc), `AbstractTransactionalTestNGSpringContextTests` also provides convenience methods that delegate to methods in `JdbcTestUtils` by using the aforementioned `jdbcTemplate`. Furthermore, `AbstractTransactionalTestNGSpringContextTests` provides an `executeSqlScript(..)` method for running SQL scripts against the configured `DataSource`.
#### ** Chinese **

`AbstractTransactionalTestNGSpringContextTests`是`AbstractTestNGSpringContextTests`的一个抽象事务性扩展，它为JDBC访问增加了一些方便的功能。这个类期望在`ApplicationContext`中定义一个`javax.sql.DataSource` bean和一个`PlatformTransactionManager` bean。当你扩展`AbstractTransactionalTestNGSpringContextTests`时，你可以访问一个受保护的```jdbcTemplate`实例变量，你可以用它来执行SQL语句来查询数据库。您可以在运行数据库相关的应用程序代码之前和之后使用这些查询来确认数据库状态，Spring确保这些查询与应用程序代码在同一事务的范围内运行。当与ORM工具配合使用时，一定要避免[误报](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#testcontext-tx-false-positives)。正如[JDBC测试支持](https://docs.spring.io/spring/docs/5.2.6.RELEASE/spring-framework-reference/testing.html#integration-testing-support-jdbc)中提到的那样，`AbstractTransactionalTestNGSpringContextTests`还提供了方便的方法，通过使用前面提到的`jdbcTemplate`，将其委托给`JdbcTestUtils`中的方法。此外，`AbstractTransactionalTestNGSpringContextTests`还提供了一个`executeSqlScript(.)`方法，用于针对配置的`DataSource`运行SQL脚本。
<!-- tabs:end -->


<!-- tabs:start -->

#### ** English **

These classes are a convenience for extension. If you do not want your test classes to be tied to a Spring-specific class hierarchy, you can configure your own custom test classes by using `@ContextConfiguration`, `@TestExecutionListeners`, and so on and by manually instrumenting your test class with a `TestContextManager`. See the source code of `AbstractTestNGSpringContextTests` for an example of how to instrument your test class.
#### ** Chinese **

这些类是一种方便的扩展方式。如果你不希望你的测试类被绑定到一个特定于Spring的类层次结构，你可以通过使用`@ContextConfiguration`、`@TestExecutionListeners`等来配置你自己的自定义测试类，也可以通过使用`TestContextManager`手动仪表化你的测试类。请参阅 `AbstractTestNGSpringContextTests`的源代码，了解如何对测试类进行仪表化的例子。
<!-- tabs:end -->



[下一章](Spring-Framework-5.2.6.RELEASE/Testing/3.6.%20Spring%20MVC%20Test%20Framework.md)


[回目录](Spring-Framework-5.2.6.RELEASE/summary.md)

[回首页](/README)
